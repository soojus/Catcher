
teks.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001c8  08000000  08000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00024bb8  08010000  08010000  00010000  2**16
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0004f0f4  08034bc0  08034bc0  00034bc0  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08083cb4  08083cb4  00085198  2**0
                  CONTENTS
  4 .ARM          00000008  08083cb4  08083cb4  00083cb4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  08083cbc  08083cbc  00085198  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08083cbc  08083cbc  00083cbc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .fini_array   00000004  08083cc0  08083cc0  00083cc0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .data         00001058  20000000  08083cc4  00084000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  9 .TxDecripSection 000000a0  20001058  08084d1c  00085058  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .RxDecripSection 000000a0  200010f8  08084dbc  000850f8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 11 .bss          000111f8  200011a0  08084e5c  000851a0  2**5
                  ALLOC
 12 ._user_heap_stack 00001800  20012398  08084e5c  00085398  2**0
                  ALLOC
 13 .ARM.attributes 00000030  00000000  00000000  00085198  2**0
                  CONTENTS, READONLY
 14 .debug_info   0006787a  00000000  00000000  000851c8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_abbrev 0000c069  00000000  00000000  000eca42  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_aranges 000034c0  00000000  00000000  000f8ab0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_rnglists 00005c6f  00000000  00000000  000fbf70  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_macro  0003aa44  00000000  00000000  00101bdf  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_line   00075563  00000000  00000000  0013c623  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_str    0013d604  00000000  00000000  001b1b86  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .comment      00000086  00000000  00000000  002ef18a  2**0
                  CONTENTS, READONLY
 22 .debug_frame  0000b1d0  00000000  00000000  002ef210  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 23 .debug_loclists 00035ceb  00000000  00000000  002fa3e0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 24 .debug_line_str 0000003d  00000000  00000000  003300cb  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08010000 <__do_global_dtors_aux>:
 8010000:	b510      	push	{r4, lr}
 8010002:	4c05      	ldr	r4, [pc, #20]	@ (8010018 <__do_global_dtors_aux+0x18>)
 8010004:	7823      	ldrb	r3, [r4, #0]
 8010006:	b933      	cbnz	r3, 8010016 <__do_global_dtors_aux+0x16>
 8010008:	4b04      	ldr	r3, [pc, #16]	@ (801001c <__do_global_dtors_aux+0x1c>)
 801000a:	b113      	cbz	r3, 8010012 <__do_global_dtors_aux+0x12>
 801000c:	4804      	ldr	r0, [pc, #16]	@ (8010020 <__do_global_dtors_aux+0x20>)
 801000e:	f3af 8000 	nop.w
 8010012:	2301      	movs	r3, #1
 8010014:	7023      	strb	r3, [r4, #0]
 8010016:	bd10      	pop	{r4, pc}
 8010018:	200011a0 	.word	0x200011a0
 801001c:	00000000 	.word	0x00000000
 8010020:	08034ba0 	.word	0x08034ba0

08010024 <frame_dummy>:
 8010024:	b508      	push	{r3, lr}
 8010026:	4b03      	ldr	r3, [pc, #12]	@ (8010034 <frame_dummy+0x10>)
 8010028:	b11b      	cbz	r3, 8010032 <frame_dummy+0xe>
 801002a:	4903      	ldr	r1, [pc, #12]	@ (8010038 <frame_dummy+0x14>)
 801002c:	4803      	ldr	r0, [pc, #12]	@ (801003c <frame_dummy+0x18>)
 801002e:	f3af 8000 	nop.w
 8010032:	bd08      	pop	{r3, pc}
 8010034:	00000000 	.word	0x00000000
 8010038:	200011a4 	.word	0x200011a4
 801003c:	08034ba0 	.word	0x08034ba0

08010040 <memchr>:
 8010040:	f001 01ff 	and.w	r1, r1, #255	@ 0xff
 8010044:	2a10      	cmp	r2, #16
 8010046:	db2b      	blt.n	80100a0 <memchr+0x60>
 8010048:	f010 0f07 	tst.w	r0, #7
 801004c:	d008      	beq.n	8010060 <memchr+0x20>
 801004e:	f810 3b01 	ldrb.w	r3, [r0], #1
 8010052:	3a01      	subs	r2, #1
 8010054:	428b      	cmp	r3, r1
 8010056:	d02d      	beq.n	80100b4 <memchr+0x74>
 8010058:	f010 0f07 	tst.w	r0, #7
 801005c:	b342      	cbz	r2, 80100b0 <memchr+0x70>
 801005e:	d1f6      	bne.n	801004e <memchr+0xe>
 8010060:	b4f0      	push	{r4, r5, r6, r7}
 8010062:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8010066:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 801006a:	f022 0407 	bic.w	r4, r2, #7
 801006e:	f07f 0700 	mvns.w	r7, #0
 8010072:	2300      	movs	r3, #0
 8010074:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8010078:	3c08      	subs	r4, #8
 801007a:	ea85 0501 	eor.w	r5, r5, r1
 801007e:	ea86 0601 	eor.w	r6, r6, r1
 8010082:	fa85 f547 	uadd8	r5, r5, r7
 8010086:	faa3 f587 	sel	r5, r3, r7
 801008a:	fa86 f647 	uadd8	r6, r6, r7
 801008e:	faa5 f687 	sel	r6, r5, r7
 8010092:	b98e      	cbnz	r6, 80100b8 <memchr+0x78>
 8010094:	d1ee      	bne.n	8010074 <memchr+0x34>
 8010096:	bcf0      	pop	{r4, r5, r6, r7}
 8010098:	f001 01ff 	and.w	r1, r1, #255	@ 0xff
 801009c:	f002 0207 	and.w	r2, r2, #7
 80100a0:	b132      	cbz	r2, 80100b0 <memchr+0x70>
 80100a2:	f810 3b01 	ldrb.w	r3, [r0], #1
 80100a6:	3a01      	subs	r2, #1
 80100a8:	ea83 0301 	eor.w	r3, r3, r1
 80100ac:	b113      	cbz	r3, 80100b4 <memchr+0x74>
 80100ae:	d1f8      	bne.n	80100a2 <memchr+0x62>
 80100b0:	2000      	movs	r0, #0
 80100b2:	4770      	bx	lr
 80100b4:	3801      	subs	r0, #1
 80100b6:	4770      	bx	lr
 80100b8:	2d00      	cmp	r5, #0
 80100ba:	bf06      	itte	eq
 80100bc:	4635      	moveq	r5, r6
 80100be:	3803      	subeq	r0, #3
 80100c0:	3807      	subne	r0, #7
 80100c2:	f015 0f01 	tst.w	r5, #1
 80100c6:	d107      	bne.n	80100d8 <memchr+0x98>
 80100c8:	3001      	adds	r0, #1
 80100ca:	f415 7f80 	tst.w	r5, #256	@ 0x100
 80100ce:	bf02      	ittt	eq
 80100d0:	3001      	addeq	r0, #1
 80100d2:	f415 3fc0 	tsteq.w	r5, #98304	@ 0x18000
 80100d6:	3001      	addeq	r0, #1
 80100d8:	bcf0      	pop	{r4, r5, r6, r7}
 80100da:	3801      	subs	r0, #1
 80100dc:	4770      	bx	lr
 80100de:	bf00      	nop

080100e0 <strlen>:
 80100e0:	4603      	mov	r3, r0
 80100e2:	f813 2b01 	ldrb.w	r2, [r3], #1
 80100e6:	2a00      	cmp	r2, #0
 80100e8:	d1fb      	bne.n	80100e2 <strlen+0x2>
 80100ea:	1a18      	subs	r0, r3, r0
 80100ec:	3801      	subs	r0, #1
 80100ee:	4770      	bx	lr

080100f0 <__aeabi_drsub>:
 80100f0:	f081 4100 	eor.w	r1, r1, #2147483648	@ 0x80000000
 80100f4:	e002      	b.n	80100fc <__adddf3>
 80100f6:	bf00      	nop

080100f8 <__aeabi_dsub>:
 80100f8:	f083 4300 	eor.w	r3, r3, #2147483648	@ 0x80000000

080100fc <__adddf3>:
 80100fc:	b530      	push	{r4, r5, lr}
 80100fe:	ea4f 0441 	mov.w	r4, r1, lsl #1
 8010102:	ea4f 0543 	mov.w	r5, r3, lsl #1
 8010106:	ea94 0f05 	teq	r4, r5
 801010a:	bf08      	it	eq
 801010c:	ea90 0f02 	teqeq	r0, r2
 8010110:	bf1f      	itttt	ne
 8010112:	ea54 0c00 	orrsne.w	ip, r4, r0
 8010116:	ea55 0c02 	orrsne.w	ip, r5, r2
 801011a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 801011e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8010122:	f000 80e2 	beq.w	80102ea <__adddf3+0x1ee>
 8010126:	ea4f 5454 	mov.w	r4, r4, lsr #21
 801012a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 801012e:	bfb8      	it	lt
 8010130:	426d      	neglt	r5, r5
 8010132:	dd0c      	ble.n	801014e <__adddf3+0x52>
 8010134:	442c      	add	r4, r5
 8010136:	ea80 0202 	eor.w	r2, r0, r2
 801013a:	ea81 0303 	eor.w	r3, r1, r3
 801013e:	ea82 0000 	eor.w	r0, r2, r0
 8010142:	ea83 0101 	eor.w	r1, r3, r1
 8010146:	ea80 0202 	eor.w	r2, r0, r2
 801014a:	ea81 0303 	eor.w	r3, r1, r3
 801014e:	2d36      	cmp	r5, #54	@ 0x36
 8010150:	bf88      	it	hi
 8010152:	bd30      	pophi	{r4, r5, pc}
 8010154:	f011 4f00 	tst.w	r1, #2147483648	@ 0x80000000
 8010158:	ea4f 3101 	mov.w	r1, r1, lsl #12
 801015c:	f44f 1c80 	mov.w	ip, #1048576	@ 0x100000
 8010160:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8010164:	d002      	beq.n	801016c <__adddf3+0x70>
 8010166:	4240      	negs	r0, r0
 8010168:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 801016c:	f013 4f00 	tst.w	r3, #2147483648	@ 0x80000000
 8010170:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8010174:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8010178:	d002      	beq.n	8010180 <__adddf3+0x84>
 801017a:	4252      	negs	r2, r2
 801017c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8010180:	ea94 0f05 	teq	r4, r5
 8010184:	f000 80a7 	beq.w	80102d6 <__adddf3+0x1da>
 8010188:	f1a4 0401 	sub.w	r4, r4, #1
 801018c:	f1d5 0e20 	rsbs	lr, r5, #32
 8010190:	db0d      	blt.n	80101ae <__adddf3+0xb2>
 8010192:	fa02 fc0e 	lsl.w	ip, r2, lr
 8010196:	fa22 f205 	lsr.w	r2, r2, r5
 801019a:	1880      	adds	r0, r0, r2
 801019c:	f141 0100 	adc.w	r1, r1, #0
 80101a0:	fa03 f20e 	lsl.w	r2, r3, lr
 80101a4:	1880      	adds	r0, r0, r2
 80101a6:	fa43 f305 	asr.w	r3, r3, r5
 80101aa:	4159      	adcs	r1, r3
 80101ac:	e00e      	b.n	80101cc <__adddf3+0xd0>
 80101ae:	f1a5 0520 	sub.w	r5, r5, #32
 80101b2:	f10e 0e20 	add.w	lr, lr, #32
 80101b6:	2a01      	cmp	r2, #1
 80101b8:	fa03 fc0e 	lsl.w	ip, r3, lr
 80101bc:	bf28      	it	cs
 80101be:	f04c 0c02 	orrcs.w	ip, ip, #2
 80101c2:	fa43 f305 	asr.w	r3, r3, r5
 80101c6:	18c0      	adds	r0, r0, r3
 80101c8:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 80101cc:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 80101d0:	d507      	bpl.n	80101e2 <__adddf3+0xe6>
 80101d2:	f04f 0e00 	mov.w	lr, #0
 80101d6:	f1dc 0c00 	rsbs	ip, ip, #0
 80101da:	eb7e 0000 	sbcs.w	r0, lr, r0
 80101de:	eb6e 0101 	sbc.w	r1, lr, r1
 80101e2:	f5b1 1f80 	cmp.w	r1, #1048576	@ 0x100000
 80101e6:	d31b      	bcc.n	8010220 <__adddf3+0x124>
 80101e8:	f5b1 1f00 	cmp.w	r1, #2097152	@ 0x200000
 80101ec:	d30c      	bcc.n	8010208 <__adddf3+0x10c>
 80101ee:	0849      	lsrs	r1, r1, #1
 80101f0:	ea5f 0030 	movs.w	r0, r0, rrx
 80101f4:	ea4f 0c3c 	mov.w	ip, ip, rrx
 80101f8:	f104 0401 	add.w	r4, r4, #1
 80101fc:	ea4f 5244 	mov.w	r2, r4, lsl #21
 8010200:	f512 0f80 	cmn.w	r2, #4194304	@ 0x400000
 8010204:	f080 809a 	bcs.w	801033c <__adddf3+0x240>
 8010208:	f1bc 4f00 	cmp.w	ip, #2147483648	@ 0x80000000
 801020c:	bf08      	it	eq
 801020e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8010212:	f150 0000 	adcs.w	r0, r0, #0
 8010216:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 801021a:	ea41 0105 	orr.w	r1, r1, r5
 801021e:	bd30      	pop	{r4, r5, pc}
 8010220:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 8010224:	4140      	adcs	r0, r0
 8010226:	eb41 0101 	adc.w	r1, r1, r1
 801022a:	3c01      	subs	r4, #1
 801022c:	bf28      	it	cs
 801022e:	f5b1 1f80 	cmpcs.w	r1, #1048576	@ 0x100000
 8010232:	d2e9      	bcs.n	8010208 <__adddf3+0x10c>
 8010234:	f091 0f00 	teq	r1, #0
 8010238:	bf04      	itt	eq
 801023a:	4601      	moveq	r1, r0
 801023c:	2000      	moveq	r0, #0
 801023e:	fab1 f381 	clz	r3, r1
 8010242:	bf08      	it	eq
 8010244:	3320      	addeq	r3, #32
 8010246:	f1a3 030b 	sub.w	r3, r3, #11
 801024a:	f1b3 0220 	subs.w	r2, r3, #32
 801024e:	da0c      	bge.n	801026a <__adddf3+0x16e>
 8010250:	320c      	adds	r2, #12
 8010252:	dd08      	ble.n	8010266 <__adddf3+0x16a>
 8010254:	f102 0c14 	add.w	ip, r2, #20
 8010258:	f1c2 020c 	rsb	r2, r2, #12
 801025c:	fa01 f00c 	lsl.w	r0, r1, ip
 8010260:	fa21 f102 	lsr.w	r1, r1, r2
 8010264:	e00c      	b.n	8010280 <__adddf3+0x184>
 8010266:	f102 0214 	add.w	r2, r2, #20
 801026a:	bfd8      	it	le
 801026c:	f1c2 0c20 	rsble	ip, r2, #32
 8010270:	fa01 f102 	lsl.w	r1, r1, r2
 8010274:	fa20 fc0c 	lsr.w	ip, r0, ip
 8010278:	bfdc      	itt	le
 801027a:	ea41 010c 	orrle.w	r1, r1, ip
 801027e:	4090      	lslle	r0, r2
 8010280:	1ae4      	subs	r4, r4, r3
 8010282:	bfa2      	ittt	ge
 8010284:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8010288:	4329      	orrge	r1, r5
 801028a:	bd30      	popge	{r4, r5, pc}
 801028c:	ea6f 0404 	mvn.w	r4, r4
 8010290:	3c1f      	subs	r4, #31
 8010292:	da1c      	bge.n	80102ce <__adddf3+0x1d2>
 8010294:	340c      	adds	r4, #12
 8010296:	dc0e      	bgt.n	80102b6 <__adddf3+0x1ba>
 8010298:	f104 0414 	add.w	r4, r4, #20
 801029c:	f1c4 0220 	rsb	r2, r4, #32
 80102a0:	fa20 f004 	lsr.w	r0, r0, r4
 80102a4:	fa01 f302 	lsl.w	r3, r1, r2
 80102a8:	ea40 0003 	orr.w	r0, r0, r3
 80102ac:	fa21 f304 	lsr.w	r3, r1, r4
 80102b0:	ea45 0103 	orr.w	r1, r5, r3
 80102b4:	bd30      	pop	{r4, r5, pc}
 80102b6:	f1c4 040c 	rsb	r4, r4, #12
 80102ba:	f1c4 0220 	rsb	r2, r4, #32
 80102be:	fa20 f002 	lsr.w	r0, r0, r2
 80102c2:	fa01 f304 	lsl.w	r3, r1, r4
 80102c6:	ea40 0003 	orr.w	r0, r0, r3
 80102ca:	4629      	mov	r1, r5
 80102cc:	bd30      	pop	{r4, r5, pc}
 80102ce:	fa21 f004 	lsr.w	r0, r1, r4
 80102d2:	4629      	mov	r1, r5
 80102d4:	bd30      	pop	{r4, r5, pc}
 80102d6:	f094 0f00 	teq	r4, #0
 80102da:	f483 1380 	eor.w	r3, r3, #1048576	@ 0x100000
 80102de:	bf06      	itte	eq
 80102e0:	f481 1180 	eoreq.w	r1, r1, #1048576	@ 0x100000
 80102e4:	3401      	addeq	r4, #1
 80102e6:	3d01      	subne	r5, #1
 80102e8:	e74e      	b.n	8010188 <__adddf3+0x8c>
 80102ea:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80102ee:	bf18      	it	ne
 80102f0:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80102f4:	d029      	beq.n	801034a <__adddf3+0x24e>
 80102f6:	ea94 0f05 	teq	r4, r5
 80102fa:	bf08      	it	eq
 80102fc:	ea90 0f02 	teqeq	r0, r2
 8010300:	d005      	beq.n	801030e <__adddf3+0x212>
 8010302:	ea54 0c00 	orrs.w	ip, r4, r0
 8010306:	bf04      	itt	eq
 8010308:	4619      	moveq	r1, r3
 801030a:	4610      	moveq	r0, r2
 801030c:	bd30      	pop	{r4, r5, pc}
 801030e:	ea91 0f03 	teq	r1, r3
 8010312:	bf1e      	ittt	ne
 8010314:	2100      	movne	r1, #0
 8010316:	2000      	movne	r0, #0
 8010318:	bd30      	popne	{r4, r5, pc}
 801031a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 801031e:	d105      	bne.n	801032c <__adddf3+0x230>
 8010320:	0040      	lsls	r0, r0, #1
 8010322:	4149      	adcs	r1, r1
 8010324:	bf28      	it	cs
 8010326:	f041 4100 	orrcs.w	r1, r1, #2147483648	@ 0x80000000
 801032a:	bd30      	pop	{r4, r5, pc}
 801032c:	f514 0480 	adds.w	r4, r4, #4194304	@ 0x400000
 8010330:	bf3c      	itt	cc
 8010332:	f501 1180 	addcc.w	r1, r1, #1048576	@ 0x100000
 8010336:	bd30      	popcc	{r4, r5, pc}
 8010338:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 801033c:	f045 41fe 	orr.w	r1, r5, #2130706432	@ 0x7f000000
 8010340:	f441 0170 	orr.w	r1, r1, #15728640	@ 0xf00000
 8010344:	f04f 0000 	mov.w	r0, #0
 8010348:	bd30      	pop	{r4, r5, pc}
 801034a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 801034e:	bf1a      	itte	ne
 8010350:	4619      	movne	r1, r3
 8010352:	4610      	movne	r0, r2
 8010354:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8010358:	bf1c      	itt	ne
 801035a:	460b      	movne	r3, r1
 801035c:	4602      	movne	r2, r0
 801035e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8010362:	bf06      	itte	eq
 8010364:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8010368:	ea91 0f03 	teqeq	r1, r3
 801036c:	f441 2100 	orrne.w	r1, r1, #524288	@ 0x80000
 8010370:	bd30      	pop	{r4, r5, pc}
 8010372:	bf00      	nop

08010374 <__aeabi_ui2d>:
 8010374:	f090 0f00 	teq	r0, #0
 8010378:	bf04      	itt	eq
 801037a:	2100      	moveq	r1, #0
 801037c:	4770      	bxeq	lr
 801037e:	b530      	push	{r4, r5, lr}
 8010380:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 8010384:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 8010388:	f04f 0500 	mov.w	r5, #0
 801038c:	f04f 0100 	mov.w	r1, #0
 8010390:	e750      	b.n	8010234 <__adddf3+0x138>
 8010392:	bf00      	nop

08010394 <__aeabi_i2d>:
 8010394:	f090 0f00 	teq	r0, #0
 8010398:	bf04      	itt	eq
 801039a:	2100      	moveq	r1, #0
 801039c:	4770      	bxeq	lr
 801039e:	b530      	push	{r4, r5, lr}
 80103a0:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 80103a4:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 80103a8:	f010 4500 	ands.w	r5, r0, #2147483648	@ 0x80000000
 80103ac:	bf48      	it	mi
 80103ae:	4240      	negmi	r0, r0
 80103b0:	f04f 0100 	mov.w	r1, #0
 80103b4:	e73e      	b.n	8010234 <__adddf3+0x138>
 80103b6:	bf00      	nop

080103b8 <__aeabi_f2d>:
 80103b8:	0042      	lsls	r2, r0, #1
 80103ba:	ea4f 01e2 	mov.w	r1, r2, asr #3
 80103be:	ea4f 0131 	mov.w	r1, r1, rrx
 80103c2:	ea4f 7002 	mov.w	r0, r2, lsl #28
 80103c6:	bf1f      	itttt	ne
 80103c8:	f012 437f 	andsne.w	r3, r2, #4278190080	@ 0xff000000
 80103cc:	f093 4f7f 	teqne	r3, #4278190080	@ 0xff000000
 80103d0:	f081 5160 	eorne.w	r1, r1, #939524096	@ 0x38000000
 80103d4:	4770      	bxne	lr
 80103d6:	f032 427f 	bics.w	r2, r2, #4278190080	@ 0xff000000
 80103da:	bf08      	it	eq
 80103dc:	4770      	bxeq	lr
 80103de:	f093 4f7f 	teq	r3, #4278190080	@ 0xff000000
 80103e2:	bf04      	itt	eq
 80103e4:	f441 2100 	orreq.w	r1, r1, #524288	@ 0x80000
 80103e8:	4770      	bxeq	lr
 80103ea:	b530      	push	{r4, r5, lr}
 80103ec:	f44f 7460 	mov.w	r4, #896	@ 0x380
 80103f0:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 80103f4:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
 80103f8:	e71c      	b.n	8010234 <__adddf3+0x138>
 80103fa:	bf00      	nop

080103fc <__aeabi_ul2d>:
 80103fc:	ea50 0201 	orrs.w	r2, r0, r1
 8010400:	bf08      	it	eq
 8010402:	4770      	bxeq	lr
 8010404:	b530      	push	{r4, r5, lr}
 8010406:	f04f 0500 	mov.w	r5, #0
 801040a:	e00a      	b.n	8010422 <__aeabi_l2d+0x16>

0801040c <__aeabi_l2d>:
 801040c:	ea50 0201 	orrs.w	r2, r0, r1
 8010410:	bf08      	it	eq
 8010412:	4770      	bxeq	lr
 8010414:	b530      	push	{r4, r5, lr}
 8010416:	f011 4500 	ands.w	r5, r1, #2147483648	@ 0x80000000
 801041a:	d502      	bpl.n	8010422 <__aeabi_l2d+0x16>
 801041c:	4240      	negs	r0, r0
 801041e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8010422:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 8010426:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 801042a:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 801042e:	f43f aed8 	beq.w	80101e2 <__adddf3+0xe6>
 8010432:	f04f 0203 	mov.w	r2, #3
 8010436:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 801043a:	bf18      	it	ne
 801043c:	3203      	addne	r2, #3
 801043e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8010442:	bf18      	it	ne
 8010444:	3203      	addne	r2, #3
 8010446:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 801044a:	f1c2 0320 	rsb	r3, r2, #32
 801044e:	fa00 fc03 	lsl.w	ip, r0, r3
 8010452:	fa20 f002 	lsr.w	r0, r0, r2
 8010456:	fa01 fe03 	lsl.w	lr, r1, r3
 801045a:	ea40 000e 	orr.w	r0, r0, lr
 801045e:	fa21 f102 	lsr.w	r1, r1, r2
 8010462:	4414      	add	r4, r2
 8010464:	e6bd      	b.n	80101e2 <__adddf3+0xe6>
 8010466:	bf00      	nop

08010468 <__aeabi_dmul>:
 8010468:	b570      	push	{r4, r5, r6, lr}
 801046a:	f04f 0cff 	mov.w	ip, #255	@ 0xff
 801046e:	f44c 6ce0 	orr.w	ip, ip, #1792	@ 0x700
 8010472:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8010476:	bf1d      	ittte	ne
 8010478:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 801047c:	ea94 0f0c 	teqne	r4, ip
 8010480:	ea95 0f0c 	teqne	r5, ip
 8010484:	f000 f8de 	bleq	8010644 <__aeabi_dmul+0x1dc>
 8010488:	442c      	add	r4, r5
 801048a:	ea81 0603 	eor.w	r6, r1, r3
 801048e:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 8010492:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 8010496:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 801049a:	bf18      	it	ne
 801049c:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 80104a0:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 80104a4:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
 80104a8:	d038      	beq.n	801051c <__aeabi_dmul+0xb4>
 80104aa:	fba0 ce02 	umull	ip, lr, r0, r2
 80104ae:	f04f 0500 	mov.w	r5, #0
 80104b2:	fbe1 e502 	umlal	lr, r5, r1, r2
 80104b6:	f006 4200 	and.w	r2, r6, #2147483648	@ 0x80000000
 80104ba:	fbe0 e503 	umlal	lr, r5, r0, r3
 80104be:	f04f 0600 	mov.w	r6, #0
 80104c2:	fbe1 5603 	umlal	r5, r6, r1, r3
 80104c6:	f09c 0f00 	teq	ip, #0
 80104ca:	bf18      	it	ne
 80104cc:	f04e 0e01 	orrne.w	lr, lr, #1
 80104d0:	f1a4 04ff 	sub.w	r4, r4, #255	@ 0xff
 80104d4:	f5b6 7f00 	cmp.w	r6, #512	@ 0x200
 80104d8:	f564 7440 	sbc.w	r4, r4, #768	@ 0x300
 80104dc:	d204      	bcs.n	80104e8 <__aeabi_dmul+0x80>
 80104de:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 80104e2:	416d      	adcs	r5, r5
 80104e4:	eb46 0606 	adc.w	r6, r6, r6
 80104e8:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 80104ec:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 80104f0:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 80104f4:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 80104f8:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 80104fc:	f1b4 0cfd 	subs.w	ip, r4, #253	@ 0xfd
 8010500:	bf88      	it	hi
 8010502:	f5bc 6fe0 	cmphi.w	ip, #1792	@ 0x700
 8010506:	d81e      	bhi.n	8010546 <__aeabi_dmul+0xde>
 8010508:	f1be 4f00 	cmp.w	lr, #2147483648	@ 0x80000000
 801050c:	bf08      	it	eq
 801050e:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 8010512:	f150 0000 	adcs.w	r0, r0, #0
 8010516:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 801051a:	bd70      	pop	{r4, r5, r6, pc}
 801051c:	f006 4600 	and.w	r6, r6, #2147483648	@ 0x80000000
 8010520:	ea46 0101 	orr.w	r1, r6, r1
 8010524:	ea40 0002 	orr.w	r0, r0, r2
 8010528:	ea81 0103 	eor.w	r1, r1, r3
 801052c:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 8010530:	bfc2      	ittt	gt
 8010532:	ebd4 050c 	rsbsgt	r5, r4, ip
 8010536:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 801053a:	bd70      	popgt	{r4, r5, r6, pc}
 801053c:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 8010540:	f04f 0e00 	mov.w	lr, #0
 8010544:	3c01      	subs	r4, #1
 8010546:	f300 80ab 	bgt.w	80106a0 <__aeabi_dmul+0x238>
 801054a:	f114 0f36 	cmn.w	r4, #54	@ 0x36
 801054e:	bfde      	ittt	le
 8010550:	2000      	movle	r0, #0
 8010552:	f001 4100 	andle.w	r1, r1, #2147483648	@ 0x80000000
 8010556:	bd70      	pople	{r4, r5, r6, pc}
 8010558:	f1c4 0400 	rsb	r4, r4, #0
 801055c:	3c20      	subs	r4, #32
 801055e:	da35      	bge.n	80105cc <__aeabi_dmul+0x164>
 8010560:	340c      	adds	r4, #12
 8010562:	dc1b      	bgt.n	801059c <__aeabi_dmul+0x134>
 8010564:	f104 0414 	add.w	r4, r4, #20
 8010568:	f1c4 0520 	rsb	r5, r4, #32
 801056c:	fa00 f305 	lsl.w	r3, r0, r5
 8010570:	fa20 f004 	lsr.w	r0, r0, r4
 8010574:	fa01 f205 	lsl.w	r2, r1, r5
 8010578:	ea40 0002 	orr.w	r0, r0, r2
 801057c:	f001 4200 	and.w	r2, r1, #2147483648	@ 0x80000000
 8010580:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
 8010584:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8010588:	fa21 f604 	lsr.w	r6, r1, r4
 801058c:	eb42 0106 	adc.w	r1, r2, r6
 8010590:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8010594:	bf08      	it	eq
 8010596:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 801059a:	bd70      	pop	{r4, r5, r6, pc}
 801059c:	f1c4 040c 	rsb	r4, r4, #12
 80105a0:	f1c4 0520 	rsb	r5, r4, #32
 80105a4:	fa00 f304 	lsl.w	r3, r0, r4
 80105a8:	fa20 f005 	lsr.w	r0, r0, r5
 80105ac:	fa01 f204 	lsl.w	r2, r1, r4
 80105b0:	ea40 0002 	orr.w	r0, r0, r2
 80105b4:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 80105b8:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 80105bc:	f141 0100 	adc.w	r1, r1, #0
 80105c0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80105c4:	bf08      	it	eq
 80105c6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80105ca:	bd70      	pop	{r4, r5, r6, pc}
 80105cc:	f1c4 0520 	rsb	r5, r4, #32
 80105d0:	fa00 f205 	lsl.w	r2, r0, r5
 80105d4:	ea4e 0e02 	orr.w	lr, lr, r2
 80105d8:	fa20 f304 	lsr.w	r3, r0, r4
 80105dc:	fa01 f205 	lsl.w	r2, r1, r5
 80105e0:	ea43 0302 	orr.w	r3, r3, r2
 80105e4:	fa21 f004 	lsr.w	r0, r1, r4
 80105e8:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 80105ec:	fa21 f204 	lsr.w	r2, r1, r4
 80105f0:	ea20 0002 	bic.w	r0, r0, r2
 80105f4:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 80105f8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80105fc:	bf08      	it	eq
 80105fe:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8010602:	bd70      	pop	{r4, r5, r6, pc}
 8010604:	f094 0f00 	teq	r4, #0
 8010608:	d10f      	bne.n	801062a <__aeabi_dmul+0x1c2>
 801060a:	f001 4600 	and.w	r6, r1, #2147483648	@ 0x80000000
 801060e:	0040      	lsls	r0, r0, #1
 8010610:	eb41 0101 	adc.w	r1, r1, r1
 8010614:	f411 1f80 	tst.w	r1, #1048576	@ 0x100000
 8010618:	bf08      	it	eq
 801061a:	3c01      	subeq	r4, #1
 801061c:	d0f7      	beq.n	801060e <__aeabi_dmul+0x1a6>
 801061e:	ea41 0106 	orr.w	r1, r1, r6
 8010622:	f095 0f00 	teq	r5, #0
 8010626:	bf18      	it	ne
 8010628:	4770      	bxne	lr
 801062a:	f003 4600 	and.w	r6, r3, #2147483648	@ 0x80000000
 801062e:	0052      	lsls	r2, r2, #1
 8010630:	eb43 0303 	adc.w	r3, r3, r3
 8010634:	f413 1f80 	tst.w	r3, #1048576	@ 0x100000
 8010638:	bf08      	it	eq
 801063a:	3d01      	subeq	r5, #1
 801063c:	d0f7      	beq.n	801062e <__aeabi_dmul+0x1c6>
 801063e:	ea43 0306 	orr.w	r3, r3, r6
 8010642:	4770      	bx	lr
 8010644:	ea94 0f0c 	teq	r4, ip
 8010648:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 801064c:	bf18      	it	ne
 801064e:	ea95 0f0c 	teqne	r5, ip
 8010652:	d00c      	beq.n	801066e <__aeabi_dmul+0x206>
 8010654:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8010658:	bf18      	it	ne
 801065a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 801065e:	d1d1      	bne.n	8010604 <__aeabi_dmul+0x19c>
 8010660:	ea81 0103 	eor.w	r1, r1, r3
 8010664:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 8010668:	f04f 0000 	mov.w	r0, #0
 801066c:	bd70      	pop	{r4, r5, r6, pc}
 801066e:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8010672:	bf06      	itte	eq
 8010674:	4610      	moveq	r0, r2
 8010676:	4619      	moveq	r1, r3
 8010678:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 801067c:	d019      	beq.n	80106b2 <__aeabi_dmul+0x24a>
 801067e:	ea94 0f0c 	teq	r4, ip
 8010682:	d102      	bne.n	801068a <__aeabi_dmul+0x222>
 8010684:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 8010688:	d113      	bne.n	80106b2 <__aeabi_dmul+0x24a>
 801068a:	ea95 0f0c 	teq	r5, ip
 801068e:	d105      	bne.n	801069c <__aeabi_dmul+0x234>
 8010690:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 8010694:	bf1c      	itt	ne
 8010696:	4610      	movne	r0, r2
 8010698:	4619      	movne	r1, r3
 801069a:	d10a      	bne.n	80106b2 <__aeabi_dmul+0x24a>
 801069c:	ea81 0103 	eor.w	r1, r1, r3
 80106a0:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 80106a4:	f041 41fe 	orr.w	r1, r1, #2130706432	@ 0x7f000000
 80106a8:	f441 0170 	orr.w	r1, r1, #15728640	@ 0xf00000
 80106ac:	f04f 0000 	mov.w	r0, #0
 80106b0:	bd70      	pop	{r4, r5, r6, pc}
 80106b2:	f041 41fe 	orr.w	r1, r1, #2130706432	@ 0x7f000000
 80106b6:	f441 0178 	orr.w	r1, r1, #16252928	@ 0xf80000
 80106ba:	bd70      	pop	{r4, r5, r6, pc}

080106bc <__aeabi_ddiv>:
 80106bc:	b570      	push	{r4, r5, r6, lr}
 80106be:	f04f 0cff 	mov.w	ip, #255	@ 0xff
 80106c2:	f44c 6ce0 	orr.w	ip, ip, #1792	@ 0x700
 80106c6:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80106ca:	bf1d      	ittte	ne
 80106cc:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80106d0:	ea94 0f0c 	teqne	r4, ip
 80106d4:	ea95 0f0c 	teqne	r5, ip
 80106d8:	f000 f8a7 	bleq	801082a <__aeabi_ddiv+0x16e>
 80106dc:	eba4 0405 	sub.w	r4, r4, r5
 80106e0:	ea81 0e03 	eor.w	lr, r1, r3
 80106e4:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80106e8:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80106ec:	f000 8088 	beq.w	8010800 <__aeabi_ddiv+0x144>
 80106f0:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80106f4:	f04f 5580 	mov.w	r5, #268435456	@ 0x10000000
 80106f8:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 80106fc:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 8010700:	ea4f 2202 	mov.w	r2, r2, lsl #8
 8010704:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 8010708:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 801070c:	ea4f 2600 	mov.w	r6, r0, lsl #8
 8010710:	f00e 4100 	and.w	r1, lr, #2147483648	@ 0x80000000
 8010714:	429d      	cmp	r5, r3
 8010716:	bf08      	it	eq
 8010718:	4296      	cmpeq	r6, r2
 801071a:	f144 04fd 	adc.w	r4, r4, #253	@ 0xfd
 801071e:	f504 7440 	add.w	r4, r4, #768	@ 0x300
 8010722:	d202      	bcs.n	801072a <__aeabi_ddiv+0x6e>
 8010724:	085b      	lsrs	r3, r3, #1
 8010726:	ea4f 0232 	mov.w	r2, r2, rrx
 801072a:	1ab6      	subs	r6, r6, r2
 801072c:	eb65 0503 	sbc.w	r5, r5, r3
 8010730:	085b      	lsrs	r3, r3, #1
 8010732:	ea4f 0232 	mov.w	r2, r2, rrx
 8010736:	f44f 1080 	mov.w	r0, #1048576	@ 0x100000
 801073a:	f44f 2c00 	mov.w	ip, #524288	@ 0x80000
 801073e:	ebb6 0e02 	subs.w	lr, r6, r2
 8010742:	eb75 0e03 	sbcs.w	lr, r5, r3
 8010746:	bf22      	ittt	cs
 8010748:	1ab6      	subcs	r6, r6, r2
 801074a:	4675      	movcs	r5, lr
 801074c:	ea40 000c 	orrcs.w	r0, r0, ip
 8010750:	085b      	lsrs	r3, r3, #1
 8010752:	ea4f 0232 	mov.w	r2, r2, rrx
 8010756:	ebb6 0e02 	subs.w	lr, r6, r2
 801075a:	eb75 0e03 	sbcs.w	lr, r5, r3
 801075e:	bf22      	ittt	cs
 8010760:	1ab6      	subcs	r6, r6, r2
 8010762:	4675      	movcs	r5, lr
 8010764:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8010768:	085b      	lsrs	r3, r3, #1
 801076a:	ea4f 0232 	mov.w	r2, r2, rrx
 801076e:	ebb6 0e02 	subs.w	lr, r6, r2
 8010772:	eb75 0e03 	sbcs.w	lr, r5, r3
 8010776:	bf22      	ittt	cs
 8010778:	1ab6      	subcs	r6, r6, r2
 801077a:	4675      	movcs	r5, lr
 801077c:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8010780:	085b      	lsrs	r3, r3, #1
 8010782:	ea4f 0232 	mov.w	r2, r2, rrx
 8010786:	ebb6 0e02 	subs.w	lr, r6, r2
 801078a:	eb75 0e03 	sbcs.w	lr, r5, r3
 801078e:	bf22      	ittt	cs
 8010790:	1ab6      	subcs	r6, r6, r2
 8010792:	4675      	movcs	r5, lr
 8010794:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8010798:	ea55 0e06 	orrs.w	lr, r5, r6
 801079c:	d018      	beq.n	80107d0 <__aeabi_ddiv+0x114>
 801079e:	ea4f 1505 	mov.w	r5, r5, lsl #4
 80107a2:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 80107a6:	ea4f 1606 	mov.w	r6, r6, lsl #4
 80107aa:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80107ae:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 80107b2:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 80107b6:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 80107ba:	d1c0      	bne.n	801073e <__aeabi_ddiv+0x82>
 80107bc:	f411 1f80 	tst.w	r1, #1048576	@ 0x100000
 80107c0:	d10b      	bne.n	80107da <__aeabi_ddiv+0x11e>
 80107c2:	ea41 0100 	orr.w	r1, r1, r0
 80107c6:	f04f 0000 	mov.w	r0, #0
 80107ca:	f04f 4c00 	mov.w	ip, #2147483648	@ 0x80000000
 80107ce:	e7b6      	b.n	801073e <__aeabi_ddiv+0x82>
 80107d0:	f411 1f80 	tst.w	r1, #1048576	@ 0x100000
 80107d4:	bf04      	itt	eq
 80107d6:	4301      	orreq	r1, r0
 80107d8:	2000      	moveq	r0, #0
 80107da:	f1b4 0cfd 	subs.w	ip, r4, #253	@ 0xfd
 80107de:	bf88      	it	hi
 80107e0:	f5bc 6fe0 	cmphi.w	ip, #1792	@ 0x700
 80107e4:	f63f aeaf 	bhi.w	8010546 <__aeabi_dmul+0xde>
 80107e8:	ebb5 0c03 	subs.w	ip, r5, r3
 80107ec:	bf04      	itt	eq
 80107ee:	ebb6 0c02 	subseq.w	ip, r6, r2
 80107f2:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80107f6:	f150 0000 	adcs.w	r0, r0, #0
 80107fa:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80107fe:	bd70      	pop	{r4, r5, r6, pc}
 8010800:	f00e 4e00 	and.w	lr, lr, #2147483648	@ 0x80000000
 8010804:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 8010808:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 801080c:	bfc2      	ittt	gt
 801080e:	ebd4 050c 	rsbsgt	r5, r4, ip
 8010812:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8010816:	bd70      	popgt	{r4, r5, r6, pc}
 8010818:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 801081c:	f04f 0e00 	mov.w	lr, #0
 8010820:	3c01      	subs	r4, #1
 8010822:	e690      	b.n	8010546 <__aeabi_dmul+0xde>
 8010824:	ea45 0e06 	orr.w	lr, r5, r6
 8010828:	e68d      	b.n	8010546 <__aeabi_dmul+0xde>
 801082a:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 801082e:	ea94 0f0c 	teq	r4, ip
 8010832:	bf08      	it	eq
 8010834:	ea95 0f0c 	teqeq	r5, ip
 8010838:	f43f af3b 	beq.w	80106b2 <__aeabi_dmul+0x24a>
 801083c:	ea94 0f0c 	teq	r4, ip
 8010840:	d10a      	bne.n	8010858 <__aeabi_ddiv+0x19c>
 8010842:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8010846:	f47f af34 	bne.w	80106b2 <__aeabi_dmul+0x24a>
 801084a:	ea95 0f0c 	teq	r5, ip
 801084e:	f47f af25 	bne.w	801069c <__aeabi_dmul+0x234>
 8010852:	4610      	mov	r0, r2
 8010854:	4619      	mov	r1, r3
 8010856:	e72c      	b.n	80106b2 <__aeabi_dmul+0x24a>
 8010858:	ea95 0f0c 	teq	r5, ip
 801085c:	d106      	bne.n	801086c <__aeabi_ddiv+0x1b0>
 801085e:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8010862:	f43f aefd 	beq.w	8010660 <__aeabi_dmul+0x1f8>
 8010866:	4610      	mov	r0, r2
 8010868:	4619      	mov	r1, r3
 801086a:	e722      	b.n	80106b2 <__aeabi_dmul+0x24a>
 801086c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8010870:	bf18      	it	ne
 8010872:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8010876:	f47f aec5 	bne.w	8010604 <__aeabi_dmul+0x19c>
 801087a:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 801087e:	f47f af0d 	bne.w	801069c <__aeabi_dmul+0x234>
 8010882:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 8010886:	f47f aeeb 	bne.w	8010660 <__aeabi_dmul+0x1f8>
 801088a:	e712      	b.n	80106b2 <__aeabi_dmul+0x24a>

0801088c <__gedf2>:
 801088c:	f04f 3cff 	mov.w	ip, #4294967295
 8010890:	e006      	b.n	80108a0 <__cmpdf2+0x4>
 8010892:	bf00      	nop

08010894 <__ledf2>:
 8010894:	f04f 0c01 	mov.w	ip, #1
 8010898:	e002      	b.n	80108a0 <__cmpdf2+0x4>
 801089a:	bf00      	nop

0801089c <__cmpdf2>:
 801089c:	f04f 0c01 	mov.w	ip, #1
 80108a0:	f84d cd04 	str.w	ip, [sp, #-4]!
 80108a4:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 80108a8:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80108ac:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 80108b0:	bf18      	it	ne
 80108b2:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 80108b6:	d01b      	beq.n	80108f0 <__cmpdf2+0x54>
 80108b8:	b001      	add	sp, #4
 80108ba:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 80108be:	bf0c      	ite	eq
 80108c0:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 80108c4:	ea91 0f03 	teqne	r1, r3
 80108c8:	bf02      	ittt	eq
 80108ca:	ea90 0f02 	teqeq	r0, r2
 80108ce:	2000      	moveq	r0, #0
 80108d0:	4770      	bxeq	lr
 80108d2:	f110 0f00 	cmn.w	r0, #0
 80108d6:	ea91 0f03 	teq	r1, r3
 80108da:	bf58      	it	pl
 80108dc:	4299      	cmppl	r1, r3
 80108de:	bf08      	it	eq
 80108e0:	4290      	cmpeq	r0, r2
 80108e2:	bf2c      	ite	cs
 80108e4:	17d8      	asrcs	r0, r3, #31
 80108e6:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 80108ea:	f040 0001 	orr.w	r0, r0, #1
 80108ee:	4770      	bx	lr
 80108f0:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 80108f4:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80108f8:	d102      	bne.n	8010900 <__cmpdf2+0x64>
 80108fa:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 80108fe:	d107      	bne.n	8010910 <__cmpdf2+0x74>
 8010900:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8010904:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8010908:	d1d6      	bne.n	80108b8 <__cmpdf2+0x1c>
 801090a:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 801090e:	d0d3      	beq.n	80108b8 <__cmpdf2+0x1c>
 8010910:	f85d 0b04 	ldr.w	r0, [sp], #4
 8010914:	4770      	bx	lr
 8010916:	bf00      	nop

08010918 <__aeabi_cdrcmple>:
 8010918:	4684      	mov	ip, r0
 801091a:	4610      	mov	r0, r2
 801091c:	4662      	mov	r2, ip
 801091e:	468c      	mov	ip, r1
 8010920:	4619      	mov	r1, r3
 8010922:	4663      	mov	r3, ip
 8010924:	e000      	b.n	8010928 <__aeabi_cdcmpeq>
 8010926:	bf00      	nop

08010928 <__aeabi_cdcmpeq>:
 8010928:	b501      	push	{r0, lr}
 801092a:	f7ff ffb7 	bl	801089c <__cmpdf2>
 801092e:	2800      	cmp	r0, #0
 8010930:	bf48      	it	mi
 8010932:	f110 0f00 	cmnmi.w	r0, #0
 8010936:	bd01      	pop	{r0, pc}

08010938 <__aeabi_dcmpeq>:
 8010938:	f84d ed08 	str.w	lr, [sp, #-8]!
 801093c:	f7ff fff4 	bl	8010928 <__aeabi_cdcmpeq>
 8010940:	bf0c      	ite	eq
 8010942:	2001      	moveq	r0, #1
 8010944:	2000      	movne	r0, #0
 8010946:	f85d fb08 	ldr.w	pc, [sp], #8
 801094a:	bf00      	nop

0801094c <__aeabi_dcmplt>:
 801094c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8010950:	f7ff ffea 	bl	8010928 <__aeabi_cdcmpeq>
 8010954:	bf34      	ite	cc
 8010956:	2001      	movcc	r0, #1
 8010958:	2000      	movcs	r0, #0
 801095a:	f85d fb08 	ldr.w	pc, [sp], #8
 801095e:	bf00      	nop

08010960 <__aeabi_dcmple>:
 8010960:	f84d ed08 	str.w	lr, [sp, #-8]!
 8010964:	f7ff ffe0 	bl	8010928 <__aeabi_cdcmpeq>
 8010968:	bf94      	ite	ls
 801096a:	2001      	movls	r0, #1
 801096c:	2000      	movhi	r0, #0
 801096e:	f85d fb08 	ldr.w	pc, [sp], #8
 8010972:	bf00      	nop

08010974 <__aeabi_dcmpge>:
 8010974:	f84d ed08 	str.w	lr, [sp, #-8]!
 8010978:	f7ff ffce 	bl	8010918 <__aeabi_cdrcmple>
 801097c:	bf94      	ite	ls
 801097e:	2001      	movls	r0, #1
 8010980:	2000      	movhi	r0, #0
 8010982:	f85d fb08 	ldr.w	pc, [sp], #8
 8010986:	bf00      	nop

08010988 <__aeabi_dcmpgt>:
 8010988:	f84d ed08 	str.w	lr, [sp, #-8]!
 801098c:	f7ff ffc4 	bl	8010918 <__aeabi_cdrcmple>
 8010990:	bf34      	ite	cc
 8010992:	2001      	movcc	r0, #1
 8010994:	2000      	movcs	r0, #0
 8010996:	f85d fb08 	ldr.w	pc, [sp], #8
 801099a:	bf00      	nop

0801099c <__aeabi_dcmpun>:
 801099c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 80109a0:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80109a4:	d102      	bne.n	80109ac <__aeabi_dcmpun+0x10>
 80109a6:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 80109aa:	d10a      	bne.n	80109c2 <__aeabi_dcmpun+0x26>
 80109ac:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 80109b0:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80109b4:	d102      	bne.n	80109bc <__aeabi_dcmpun+0x20>
 80109b6:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 80109ba:	d102      	bne.n	80109c2 <__aeabi_dcmpun+0x26>
 80109bc:	f04f 0000 	mov.w	r0, #0
 80109c0:	4770      	bx	lr
 80109c2:	f04f 0001 	mov.w	r0, #1
 80109c6:	4770      	bx	lr

080109c8 <__aeabi_d2iz>:
 80109c8:	ea4f 0241 	mov.w	r2, r1, lsl #1
 80109cc:	f512 1200 	adds.w	r2, r2, #2097152	@ 0x200000
 80109d0:	d215      	bcs.n	80109fe <__aeabi_d2iz+0x36>
 80109d2:	d511      	bpl.n	80109f8 <__aeabi_d2iz+0x30>
 80109d4:	f46f 7378 	mvn.w	r3, #992	@ 0x3e0
 80109d8:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 80109dc:	d912      	bls.n	8010a04 <__aeabi_d2iz+0x3c>
 80109de:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 80109e2:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 80109e6:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 80109ea:	f011 4f00 	tst.w	r1, #2147483648	@ 0x80000000
 80109ee:	fa23 f002 	lsr.w	r0, r3, r2
 80109f2:	bf18      	it	ne
 80109f4:	4240      	negne	r0, r0
 80109f6:	4770      	bx	lr
 80109f8:	f04f 0000 	mov.w	r0, #0
 80109fc:	4770      	bx	lr
 80109fe:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8010a02:	d105      	bne.n	8010a10 <__aeabi_d2iz+0x48>
 8010a04:	f011 4000 	ands.w	r0, r1, #2147483648	@ 0x80000000
 8010a08:	bf08      	it	eq
 8010a0a:	f06f 4000 	mvneq.w	r0, #2147483648	@ 0x80000000
 8010a0e:	4770      	bx	lr
 8010a10:	f04f 0000 	mov.w	r0, #0
 8010a14:	4770      	bx	lr
 8010a16:	bf00      	nop

08010a18 <__aeabi_uldivmod>:
 8010a18:	b953      	cbnz	r3, 8010a30 <__aeabi_uldivmod+0x18>
 8010a1a:	b94a      	cbnz	r2, 8010a30 <__aeabi_uldivmod+0x18>
 8010a1c:	2900      	cmp	r1, #0
 8010a1e:	bf08      	it	eq
 8010a20:	2800      	cmpeq	r0, #0
 8010a22:	bf1c      	itt	ne
 8010a24:	f04f 31ff 	movne.w	r1, #4294967295
 8010a28:	f04f 30ff 	movne.w	r0, #4294967295
 8010a2c:	f000 b96a 	b.w	8010d04 <__aeabi_idiv0>
 8010a30:	f1ad 0c08 	sub.w	ip, sp, #8
 8010a34:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8010a38:	f000 f806 	bl	8010a48 <__udivmoddi4>
 8010a3c:	f8dd e004 	ldr.w	lr, [sp, #4]
 8010a40:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8010a44:	b004      	add	sp, #16
 8010a46:	4770      	bx	lr

08010a48 <__udivmoddi4>:
 8010a48:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8010a4c:	9d08      	ldr	r5, [sp, #32]
 8010a4e:	460c      	mov	r4, r1
 8010a50:	2b00      	cmp	r3, #0
 8010a52:	d14e      	bne.n	8010af2 <__udivmoddi4+0xaa>
 8010a54:	4694      	mov	ip, r2
 8010a56:	458c      	cmp	ip, r1
 8010a58:	4686      	mov	lr, r0
 8010a5a:	fab2 f282 	clz	r2, r2
 8010a5e:	d962      	bls.n	8010b26 <__udivmoddi4+0xde>
 8010a60:	b14a      	cbz	r2, 8010a76 <__udivmoddi4+0x2e>
 8010a62:	f1c2 0320 	rsb	r3, r2, #32
 8010a66:	4091      	lsls	r1, r2
 8010a68:	fa20 f303 	lsr.w	r3, r0, r3
 8010a6c:	fa0c fc02 	lsl.w	ip, ip, r2
 8010a70:	4319      	orrs	r1, r3
 8010a72:	fa00 fe02 	lsl.w	lr, r0, r2
 8010a76:	ea4f 471c 	mov.w	r7, ip, lsr #16
 8010a7a:	fa1f f68c 	uxth.w	r6, ip
 8010a7e:	fbb1 f4f7 	udiv	r4, r1, r7
 8010a82:	ea4f 431e 	mov.w	r3, lr, lsr #16
 8010a86:	fb07 1114 	mls	r1, r7, r4, r1
 8010a8a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8010a8e:	fb04 f106 	mul.w	r1, r4, r6
 8010a92:	4299      	cmp	r1, r3
 8010a94:	d90a      	bls.n	8010aac <__udivmoddi4+0x64>
 8010a96:	eb1c 0303 	adds.w	r3, ip, r3
 8010a9a:	f104 30ff 	add.w	r0, r4, #4294967295
 8010a9e:	f080 8112 	bcs.w	8010cc6 <__udivmoddi4+0x27e>
 8010aa2:	4299      	cmp	r1, r3
 8010aa4:	f240 810f 	bls.w	8010cc6 <__udivmoddi4+0x27e>
 8010aa8:	3c02      	subs	r4, #2
 8010aaa:	4463      	add	r3, ip
 8010aac:	1a59      	subs	r1, r3, r1
 8010aae:	fa1f f38e 	uxth.w	r3, lr
 8010ab2:	fbb1 f0f7 	udiv	r0, r1, r7
 8010ab6:	fb07 1110 	mls	r1, r7, r0, r1
 8010aba:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8010abe:	fb00 f606 	mul.w	r6, r0, r6
 8010ac2:	429e      	cmp	r6, r3
 8010ac4:	d90a      	bls.n	8010adc <__udivmoddi4+0x94>
 8010ac6:	eb1c 0303 	adds.w	r3, ip, r3
 8010aca:	f100 31ff 	add.w	r1, r0, #4294967295
 8010ace:	f080 80fc 	bcs.w	8010cca <__udivmoddi4+0x282>
 8010ad2:	429e      	cmp	r6, r3
 8010ad4:	f240 80f9 	bls.w	8010cca <__udivmoddi4+0x282>
 8010ad8:	4463      	add	r3, ip
 8010ada:	3802      	subs	r0, #2
 8010adc:	1b9b      	subs	r3, r3, r6
 8010ade:	ea40 4004 	orr.w	r0, r0, r4, lsl #16
 8010ae2:	2100      	movs	r1, #0
 8010ae4:	b11d      	cbz	r5, 8010aee <__udivmoddi4+0xa6>
 8010ae6:	40d3      	lsrs	r3, r2
 8010ae8:	2200      	movs	r2, #0
 8010aea:	e9c5 3200 	strd	r3, r2, [r5]
 8010aee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8010af2:	428b      	cmp	r3, r1
 8010af4:	d905      	bls.n	8010b02 <__udivmoddi4+0xba>
 8010af6:	b10d      	cbz	r5, 8010afc <__udivmoddi4+0xb4>
 8010af8:	e9c5 0100 	strd	r0, r1, [r5]
 8010afc:	2100      	movs	r1, #0
 8010afe:	4608      	mov	r0, r1
 8010b00:	e7f5      	b.n	8010aee <__udivmoddi4+0xa6>
 8010b02:	fab3 f183 	clz	r1, r3
 8010b06:	2900      	cmp	r1, #0
 8010b08:	d146      	bne.n	8010b98 <__udivmoddi4+0x150>
 8010b0a:	42a3      	cmp	r3, r4
 8010b0c:	d302      	bcc.n	8010b14 <__udivmoddi4+0xcc>
 8010b0e:	4290      	cmp	r0, r2
 8010b10:	f0c0 80f0 	bcc.w	8010cf4 <__udivmoddi4+0x2ac>
 8010b14:	1a86      	subs	r6, r0, r2
 8010b16:	eb64 0303 	sbc.w	r3, r4, r3
 8010b1a:	2001      	movs	r0, #1
 8010b1c:	2d00      	cmp	r5, #0
 8010b1e:	d0e6      	beq.n	8010aee <__udivmoddi4+0xa6>
 8010b20:	e9c5 6300 	strd	r6, r3, [r5]
 8010b24:	e7e3      	b.n	8010aee <__udivmoddi4+0xa6>
 8010b26:	2a00      	cmp	r2, #0
 8010b28:	f040 8090 	bne.w	8010c4c <__udivmoddi4+0x204>
 8010b2c:	eba1 040c 	sub.w	r4, r1, ip
 8010b30:	ea4f 481c 	mov.w	r8, ip, lsr #16
 8010b34:	fa1f f78c 	uxth.w	r7, ip
 8010b38:	2101      	movs	r1, #1
 8010b3a:	fbb4 f6f8 	udiv	r6, r4, r8
 8010b3e:	ea4f 431e 	mov.w	r3, lr, lsr #16
 8010b42:	fb08 4416 	mls	r4, r8, r6, r4
 8010b46:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
 8010b4a:	fb07 f006 	mul.w	r0, r7, r6
 8010b4e:	4298      	cmp	r0, r3
 8010b50:	d908      	bls.n	8010b64 <__udivmoddi4+0x11c>
 8010b52:	eb1c 0303 	adds.w	r3, ip, r3
 8010b56:	f106 34ff 	add.w	r4, r6, #4294967295
 8010b5a:	d202      	bcs.n	8010b62 <__udivmoddi4+0x11a>
 8010b5c:	4298      	cmp	r0, r3
 8010b5e:	f200 80cd 	bhi.w	8010cfc <__udivmoddi4+0x2b4>
 8010b62:	4626      	mov	r6, r4
 8010b64:	1a1c      	subs	r4, r3, r0
 8010b66:	fa1f f38e 	uxth.w	r3, lr
 8010b6a:	fbb4 f0f8 	udiv	r0, r4, r8
 8010b6e:	fb08 4410 	mls	r4, r8, r0, r4
 8010b72:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
 8010b76:	fb00 f707 	mul.w	r7, r0, r7
 8010b7a:	429f      	cmp	r7, r3
 8010b7c:	d908      	bls.n	8010b90 <__udivmoddi4+0x148>
 8010b7e:	eb1c 0303 	adds.w	r3, ip, r3
 8010b82:	f100 34ff 	add.w	r4, r0, #4294967295
 8010b86:	d202      	bcs.n	8010b8e <__udivmoddi4+0x146>
 8010b88:	429f      	cmp	r7, r3
 8010b8a:	f200 80b0 	bhi.w	8010cee <__udivmoddi4+0x2a6>
 8010b8e:	4620      	mov	r0, r4
 8010b90:	1bdb      	subs	r3, r3, r7
 8010b92:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
 8010b96:	e7a5      	b.n	8010ae4 <__udivmoddi4+0x9c>
 8010b98:	f1c1 0620 	rsb	r6, r1, #32
 8010b9c:	408b      	lsls	r3, r1
 8010b9e:	fa22 f706 	lsr.w	r7, r2, r6
 8010ba2:	431f      	orrs	r7, r3
 8010ba4:	fa20 fc06 	lsr.w	ip, r0, r6
 8010ba8:	fa04 f301 	lsl.w	r3, r4, r1
 8010bac:	ea43 030c 	orr.w	r3, r3, ip
 8010bb0:	40f4      	lsrs	r4, r6
 8010bb2:	fa00 f801 	lsl.w	r8, r0, r1
 8010bb6:	0c38      	lsrs	r0, r7, #16
 8010bb8:	ea4f 4913 	mov.w	r9, r3, lsr #16
 8010bbc:	fbb4 fef0 	udiv	lr, r4, r0
 8010bc0:	fa1f fc87 	uxth.w	ip, r7
 8010bc4:	fb00 441e 	mls	r4, r0, lr, r4
 8010bc8:	ea49 4404 	orr.w	r4, r9, r4, lsl #16
 8010bcc:	fb0e f90c 	mul.w	r9, lr, ip
 8010bd0:	45a1      	cmp	r9, r4
 8010bd2:	fa02 f201 	lsl.w	r2, r2, r1
 8010bd6:	d90a      	bls.n	8010bee <__udivmoddi4+0x1a6>
 8010bd8:	193c      	adds	r4, r7, r4
 8010bda:	f10e 3aff 	add.w	sl, lr, #4294967295
 8010bde:	f080 8084 	bcs.w	8010cea <__udivmoddi4+0x2a2>
 8010be2:	45a1      	cmp	r9, r4
 8010be4:	f240 8081 	bls.w	8010cea <__udivmoddi4+0x2a2>
 8010be8:	f1ae 0e02 	sub.w	lr, lr, #2
 8010bec:	443c      	add	r4, r7
 8010bee:	eba4 0409 	sub.w	r4, r4, r9
 8010bf2:	fa1f f983 	uxth.w	r9, r3
 8010bf6:	fbb4 f3f0 	udiv	r3, r4, r0
 8010bfa:	fb00 4413 	mls	r4, r0, r3, r4
 8010bfe:	ea49 4404 	orr.w	r4, r9, r4, lsl #16
 8010c02:	fb03 fc0c 	mul.w	ip, r3, ip
 8010c06:	45a4      	cmp	ip, r4
 8010c08:	d907      	bls.n	8010c1a <__udivmoddi4+0x1d2>
 8010c0a:	193c      	adds	r4, r7, r4
 8010c0c:	f103 30ff 	add.w	r0, r3, #4294967295
 8010c10:	d267      	bcs.n	8010ce2 <__udivmoddi4+0x29a>
 8010c12:	45a4      	cmp	ip, r4
 8010c14:	d965      	bls.n	8010ce2 <__udivmoddi4+0x29a>
 8010c16:	3b02      	subs	r3, #2
 8010c18:	443c      	add	r4, r7
 8010c1a:	ea43 400e 	orr.w	r0, r3, lr, lsl #16
 8010c1e:	fba0 9302 	umull	r9, r3, r0, r2
 8010c22:	eba4 040c 	sub.w	r4, r4, ip
 8010c26:	429c      	cmp	r4, r3
 8010c28:	46ce      	mov	lr, r9
 8010c2a:	469c      	mov	ip, r3
 8010c2c:	d351      	bcc.n	8010cd2 <__udivmoddi4+0x28a>
 8010c2e:	d04e      	beq.n	8010cce <__udivmoddi4+0x286>
 8010c30:	b155      	cbz	r5, 8010c48 <__udivmoddi4+0x200>
 8010c32:	ebb8 030e 	subs.w	r3, r8, lr
 8010c36:	eb64 040c 	sbc.w	r4, r4, ip
 8010c3a:	fa04 f606 	lsl.w	r6, r4, r6
 8010c3e:	40cb      	lsrs	r3, r1
 8010c40:	431e      	orrs	r6, r3
 8010c42:	40cc      	lsrs	r4, r1
 8010c44:	e9c5 6400 	strd	r6, r4, [r5]
 8010c48:	2100      	movs	r1, #0
 8010c4a:	e750      	b.n	8010aee <__udivmoddi4+0xa6>
 8010c4c:	f1c2 0320 	rsb	r3, r2, #32
 8010c50:	fa20 f103 	lsr.w	r1, r0, r3
 8010c54:	fa0c fc02 	lsl.w	ip, ip, r2
 8010c58:	fa24 f303 	lsr.w	r3, r4, r3
 8010c5c:	4094      	lsls	r4, r2
 8010c5e:	430c      	orrs	r4, r1
 8010c60:	ea4f 481c 	mov.w	r8, ip, lsr #16
 8010c64:	fa00 fe02 	lsl.w	lr, r0, r2
 8010c68:	fa1f f78c 	uxth.w	r7, ip
 8010c6c:	fbb3 f0f8 	udiv	r0, r3, r8
 8010c70:	fb08 3110 	mls	r1, r8, r0, r3
 8010c74:	0c23      	lsrs	r3, r4, #16
 8010c76:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8010c7a:	fb00 f107 	mul.w	r1, r0, r7
 8010c7e:	4299      	cmp	r1, r3
 8010c80:	d908      	bls.n	8010c94 <__udivmoddi4+0x24c>
 8010c82:	eb1c 0303 	adds.w	r3, ip, r3
 8010c86:	f100 36ff 	add.w	r6, r0, #4294967295
 8010c8a:	d22c      	bcs.n	8010ce6 <__udivmoddi4+0x29e>
 8010c8c:	4299      	cmp	r1, r3
 8010c8e:	d92a      	bls.n	8010ce6 <__udivmoddi4+0x29e>
 8010c90:	3802      	subs	r0, #2
 8010c92:	4463      	add	r3, ip
 8010c94:	1a5b      	subs	r3, r3, r1
 8010c96:	b2a4      	uxth	r4, r4
 8010c98:	fbb3 f1f8 	udiv	r1, r3, r8
 8010c9c:	fb08 3311 	mls	r3, r8, r1, r3
 8010ca0:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 8010ca4:	fb01 f307 	mul.w	r3, r1, r7
 8010ca8:	42a3      	cmp	r3, r4
 8010caa:	d908      	bls.n	8010cbe <__udivmoddi4+0x276>
 8010cac:	eb1c 0404 	adds.w	r4, ip, r4
 8010cb0:	f101 36ff 	add.w	r6, r1, #4294967295
 8010cb4:	d213      	bcs.n	8010cde <__udivmoddi4+0x296>
 8010cb6:	42a3      	cmp	r3, r4
 8010cb8:	d911      	bls.n	8010cde <__udivmoddi4+0x296>
 8010cba:	3902      	subs	r1, #2
 8010cbc:	4464      	add	r4, ip
 8010cbe:	1ae4      	subs	r4, r4, r3
 8010cc0:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
 8010cc4:	e739      	b.n	8010b3a <__udivmoddi4+0xf2>
 8010cc6:	4604      	mov	r4, r0
 8010cc8:	e6f0      	b.n	8010aac <__udivmoddi4+0x64>
 8010cca:	4608      	mov	r0, r1
 8010ccc:	e706      	b.n	8010adc <__udivmoddi4+0x94>
 8010cce:	45c8      	cmp	r8, r9
 8010cd0:	d2ae      	bcs.n	8010c30 <__udivmoddi4+0x1e8>
 8010cd2:	ebb9 0e02 	subs.w	lr, r9, r2
 8010cd6:	eb63 0c07 	sbc.w	ip, r3, r7
 8010cda:	3801      	subs	r0, #1
 8010cdc:	e7a8      	b.n	8010c30 <__udivmoddi4+0x1e8>
 8010cde:	4631      	mov	r1, r6
 8010ce0:	e7ed      	b.n	8010cbe <__udivmoddi4+0x276>
 8010ce2:	4603      	mov	r3, r0
 8010ce4:	e799      	b.n	8010c1a <__udivmoddi4+0x1d2>
 8010ce6:	4630      	mov	r0, r6
 8010ce8:	e7d4      	b.n	8010c94 <__udivmoddi4+0x24c>
 8010cea:	46d6      	mov	lr, sl
 8010cec:	e77f      	b.n	8010bee <__udivmoddi4+0x1a6>
 8010cee:	4463      	add	r3, ip
 8010cf0:	3802      	subs	r0, #2
 8010cf2:	e74d      	b.n	8010b90 <__udivmoddi4+0x148>
 8010cf4:	4606      	mov	r6, r0
 8010cf6:	4623      	mov	r3, r4
 8010cf8:	4608      	mov	r0, r1
 8010cfa:	e70f      	b.n	8010b1c <__udivmoddi4+0xd4>
 8010cfc:	3e02      	subs	r6, #2
 8010cfe:	4463      	add	r3, ip
 8010d00:	e730      	b.n	8010b64 <__udivmoddi4+0x11c>
 8010d02:	bf00      	nop

08010d04 <__aeabi_idiv0>:
 8010d04:	4770      	bx	lr
 8010d06:	bf00      	nop

08010d08 <vApplicationIdleHook>:
   specified, or call vTaskDelay()). If the application makes use of the
   vTaskDelete() API function (as this demo application does) then it is also
   important that vApplicationIdleHook() is permitted to return to its calling
   function, because it is the responsibility of the idle task to clean up
   memory allocated by the kernel to any task that has since been deleted. */
}
 8010d08:	4770      	bx	lr
 8010d0a:	bf00      	nop

08010d0c <vApplicationStackOverflowHook>:
__weak void vApplicationStackOverflowHook(xTaskHandle xTask, signed char *pcTaskName)
{
   /* Run time stack overflow checking is performed if
   configCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2. This hook function is
   called if a stack overflow is detected. */
}
 8010d0c:	4770      	bx	lr
 8010d0e:	bf00      	nop

08010d10 <vApplicationMallocFailedHook>:
/* USER CODE END 4 */

/* USER CODE BEGIN 5 */
__weak void vApplicationMallocFailedHook(void)
 8010d10:	4770      	bx	lr
 8010d12:	bf00      	nop

08010d14 <OV5640_I2C_Init>:
    HAL_DMAEx_ChangeMemory(hdma, frameBuffers[(currentBufferIndex + 2)% 4 ], MEMORY1);
}

int32_t OV5640_I2C_Init(void) {
    return 0;
}
 8010d14:	2000      	movs	r0, #0
 8010d16:	4770      	bx	lr

08010d18 <XferCpltCallback>:
{
 8010d18:	b570      	push	{r4, r5, r6, lr}
    currentBufferIndex = (currentBufferIndex + 1) % 4;
 8010d1a:	4e0d      	ldr	r6, [pc, #52]	@ (8010d50 <XferCpltCallback+0x38>)
{
 8010d1c:	4604      	mov	r4, r0
    HAL_LTDC_SetAddress(&hltdc, frameBuffers[currentBufferIndex], 0);
 8010d1e:	4d0d      	ldr	r5, [pc, #52]	@ (8010d54 <XferCpltCallback+0x3c>)
 8010d20:	2200      	movs	r2, #0
    currentBufferIndex = (currentBufferIndex + 1) % 4;
 8010d22:	6833      	ldr	r3, [r6, #0]
    HAL_LTDC_SetAddress(&hltdc, frameBuffers[currentBufferIndex], 0);
 8010d24:	480c      	ldr	r0, [pc, #48]	@ (8010d58 <XferCpltCallback+0x40>)
    currentBufferIndex = (currentBufferIndex + 1) % 4;
 8010d26:	3301      	adds	r3, #1
 8010d28:	f003 0303 	and.w	r3, r3, #3
    HAL_LTDC_SetAddress(&hltdc, frameBuffers[currentBufferIndex], 0);
 8010d2c:	f855 1023 	ldr.w	r1, [r5, r3, lsl #2]
    currentBufferIndex = (currentBufferIndex + 1) % 4;
 8010d30:	6033      	str	r3, [r6, #0]
    HAL_LTDC_SetAddress(&hltdc, frameBuffers[currentBufferIndex], 0);
 8010d32:	f005 fa0f 	bl	8016154 <HAL_LTDC_SetAddress>
    HAL_DMAEx_ChangeMemory(hdma, frameBuffers[(currentBufferIndex + 2) % 4 ], MEMORY0);
 8010d36:	6833      	ldr	r3, [r6, #0]
 8010d38:	4620      	mov	r0, r4
 8010d3a:	2200      	movs	r2, #0
 8010d3c:	3302      	adds	r3, #2
 8010d3e:	f003 0303 	and.w	r3, r3, #3
 8010d42:	f855 1023 	ldr.w	r1, [r5, r3, lsl #2]
}
 8010d46:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    HAL_DMAEx_ChangeMemory(hdma, frameBuffers[(currentBufferIndex + 2) % 4 ], MEMORY0);
 8010d4a:	f004 b84d 	b.w	8014de8 <HAL_DMAEx_ChangeMemory>
 8010d4e:	bf00      	nop
 8010d50:	200021cc 	.word	0x200021cc
 8010d54:	08034bd0 	.word	0x08034bd0
 8010d58:	200027dc 	.word	0x200027dc

08010d5c <XferM1CpltCallback>:
{
 8010d5c:	b570      	push	{r4, r5, r6, lr}
    currentBufferIndex = (currentBufferIndex + 1) % 4;
 8010d5e:	4e0d      	ldr	r6, [pc, #52]	@ (8010d94 <XferM1CpltCallback+0x38>)
{
 8010d60:	4604      	mov	r4, r0
    HAL_LTDC_SetAddress(&hltdc, frameBuffers[currentBufferIndex], 0);
 8010d62:	4d0d      	ldr	r5, [pc, #52]	@ (8010d98 <XferM1CpltCallback+0x3c>)
 8010d64:	2200      	movs	r2, #0
    currentBufferIndex = (currentBufferIndex + 1) % 4;
 8010d66:	6833      	ldr	r3, [r6, #0]
    HAL_LTDC_SetAddress(&hltdc, frameBuffers[currentBufferIndex], 0);
 8010d68:	480c      	ldr	r0, [pc, #48]	@ (8010d9c <XferM1CpltCallback+0x40>)
    currentBufferIndex = (currentBufferIndex + 1) % 4;
 8010d6a:	3301      	adds	r3, #1
 8010d6c:	f003 0303 	and.w	r3, r3, #3
    HAL_LTDC_SetAddress(&hltdc, frameBuffers[currentBufferIndex], 0);
 8010d70:	f855 1023 	ldr.w	r1, [r5, r3, lsl #2]
    currentBufferIndex = (currentBufferIndex + 1) % 4;
 8010d74:	6033      	str	r3, [r6, #0]
    HAL_LTDC_SetAddress(&hltdc, frameBuffers[currentBufferIndex], 0);
 8010d76:	f005 f9ed 	bl	8016154 <HAL_LTDC_SetAddress>
    HAL_DMAEx_ChangeMemory(hdma, frameBuffers[(currentBufferIndex + 2)% 4 ], MEMORY1);
 8010d7a:	6833      	ldr	r3, [r6, #0]
 8010d7c:	4620      	mov	r0, r4
 8010d7e:	2201      	movs	r2, #1
 8010d80:	3302      	adds	r3, #2
 8010d82:	f003 0303 	and.w	r3, r3, #3
 8010d86:	f855 1023 	ldr.w	r1, [r5, r3, lsl #2]
}
 8010d8a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    HAL_DMAEx_ChangeMemory(hdma, frameBuffers[(currentBufferIndex + 2)% 4 ], MEMORY1);
 8010d8e:	f004 b82b 	b.w	8014de8 <HAL_DMAEx_ChangeMemory>
 8010d92:	bf00      	nop
 8010d94:	200021cc 	.word	0x200021cc
 8010d98:	08034bd0 	.word	0x08034bd0
 8010d9c:	200027dc 	.word	0x200027dc

08010da0 <OV5640_I2C_WriteReg>:

#define MAX_DUMP	(1024)
uint32_t backit_len = 0;
uint16_t backit[MAX_DUMP][2];

int32_t OV5640_I2C_WriteReg(uint16_t Address, uint16_t Reg, uint8_t *pData, uint16_t Length) {
 8010da0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}


	if (backit_len < MAX_DUMP) {
 8010da4:	4e15      	ldr	r6, [pc, #84]	@ (8010dfc <OV5640_I2C_WriteReg+0x5c>)
int32_t OV5640_I2C_WriteReg(uint16_t Address, uint16_t Reg, uint8_t *pData, uint16_t Length) {
 8010da6:	4682      	mov	sl, r0
 8010da8:	b084      	sub	sp, #16
 8010daa:	4610      	mov	r0, r2
	if (backit_len < MAX_DUMP) {
 8010dac:	6835      	ldr	r5, [r6, #0]
 8010dae:	f5b5 6f80 	cmp.w	r5, #1024	@ 0x400
 8010db2:	d215      	bcs.n	8010de0 <OV5640_I2C_WriteReg+0x40>
		for (int i=0; i<Length; i++) {
 8010db4:	b1a3      	cbz	r3, 8010de0 <OV5640_I2C_WriteReg+0x40>
 8010db6:	462c      	mov	r4, r5
 8010db8:	4f11      	ldr	r7, [pc, #68]	@ (8010e00 <OV5640_I2C_WriteReg+0x60>)
 8010dba:	441d      	add	r5, r3
 8010dbc:	f102 3cff 	add.w	ip, r2, #4294967295
 8010dc0:	eba1 0904 	sub.w	r9, r1, r4
 8010dc4:	f107 0802 	add.w	r8, r7, #2
			backit[backit_len][0] =  Reg + i;
 8010dc8:	eb09 0e04 	add.w	lr, r9, r4
 8010dcc:	f827 e024 	strh.w	lr, [r7, r4, lsl #2]
			backit[backit_len][1] =  pData[i];
 8010dd0:	f81c ef01 	ldrb.w	lr, [ip, #1]!
 8010dd4:	f828 e024 	strh.w	lr, [r8, r4, lsl #2]
			backit_len++;
 8010dd8:	3401      	adds	r4, #1
		for (int i=0; i<Length; i++) {
 8010dda:	42ac      	cmp	r4, r5
			backit_len++;
 8010ddc:	6034      	str	r4, [r6, #0]
		for (int i=0; i<Length; i++) {
 8010dde:	d1f3      	bne.n	8010dc8 <OV5640_I2C_WriteReg+0x28>
		}
	}

    return HAL_I2C_Mem_Write(&hi2c1, Address, Reg, I2C_MEMADD_SIZE_16BIT, pData, Length, 1000);
 8010de0:	f44f 747a 	mov.w	r4, #1000	@ 0x3e8
 8010de4:	460a      	mov	r2, r1
 8010de6:	9301      	str	r3, [sp, #4]
 8010de8:	4651      	mov	r1, sl
 8010dea:	2302      	movs	r3, #2
 8010dec:	9000      	str	r0, [sp, #0]
 8010dee:	9402      	str	r4, [sp, #8]
 8010df0:	4804      	ldr	r0, [pc, #16]	@ (8010e04 <OV5640_I2C_WriteReg+0x64>)
 8010df2:	f004 fdb1 	bl	8015958 <HAL_I2C_Mem_Write>
}
 8010df6:	b004      	add	sp, #16
 8010df8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8010dfc:	200021c8 	.word	0x200021c8
 8010e00:	200011c8 	.word	0x200011c8
 8010e04:	200028d8 	.word	0x200028d8

08010e08 <OV5640_I2C_ReadReg>:

int32_t OV5640_I2C_ReadReg(uint16_t Address, uint16_t Reg, uint8_t *pData, uint16_t Length) {
 8010e08:	b530      	push	{r4, r5, lr}
 8010e0a:	b085      	sub	sp, #20
 8010e0c:	4614      	mov	r4, r2

    return HAL_I2C_Mem_Read(&hi2c1, Address, Reg, I2C_MEMADD_SIZE_16BIT, pData, Length, 1000);
 8010e0e:	f44f 757a 	mov.w	r5, #1000	@ 0x3e8
 8010e12:	460a      	mov	r2, r1
 8010e14:	9301      	str	r3, [sp, #4]
 8010e16:	4601      	mov	r1, r0
 8010e18:	2302      	movs	r3, #2
 8010e1a:	9502      	str	r5, [sp, #8]
 8010e1c:	9400      	str	r4, [sp, #0]
 8010e1e:	4802      	ldr	r0, [pc, #8]	@ (8010e28 <OV5640_I2C_ReadReg+0x20>)
 8010e20:	f004 fe98 	bl	8015b54 <HAL_I2C_Mem_Read>
}
 8010e24:	b005      	add	sp, #20
 8010e26:	bd30      	pop	{r4, r5, pc}
 8010e28:	200028d8 	.word	0x200028d8

08010e2c <OV5640_GetTick>:

int32_t OV5640_GetTick(void) {

    return HAL_GetTick();
 8010e2c:	f002 b81e 	b.w	8012e6c <HAL_GetTick>

08010e30 <OV5640_I2C_DeInit>:
int32_t OV5640_I2C_DeInit(void) {
 8010e30:	2000      	movs	r0, #0
 8010e32:	4770      	bx	lr

08010e34 <SystemClock_Config>:
{
 8010e34:	b530      	push	{r4, r5, lr}
 8010e36:	b095      	sub	sp, #84	@ 0x54
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8010e38:	2230      	movs	r2, #48	@ 0x30
 8010e3a:	2100      	movs	r1, #0
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8010e3c:	2402      	movs	r4, #2
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8010e3e:	a808      	add	r0, sp, #32
 8010e40:	f022 f8de 	bl	8033000 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8010e44:	2300      	movs	r3, #0
 8010e46:	e9cd 3303 	strd	r3, r3, [sp, #12]
 8010e4a:	e9cd 3305 	strd	r3, r3, [sp, #20]
 8010e4e:	9307      	str	r3, [sp, #28]
  HAL_PWR_EnableBkUpAccess();
 8010e50:	f006 fc20 	bl	8017694 <HAL_PWR_EnableBkUpAccess>
  __HAL_RCC_PWR_CLK_ENABLE();
 8010e54:	4a22      	ldr	r2, [pc, #136]	@ (8010ee0 <SystemClock_Config+0xac>)
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8010e56:	a808      	add	r0, sp, #32
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8010e58:	4b22      	ldr	r3, [pc, #136]	@ (8010ee4 <SystemClock_Config+0xb0>)
  __HAL_RCC_PWR_CLK_ENABLE();
 8010e5a:	6c11      	ldr	r1, [r2, #64]	@ 0x40
 8010e5c:	f041 5180 	orr.w	r1, r1, #268435456	@ 0x10000000
 8010e60:	6411      	str	r1, [r2, #64]	@ 0x40
 8010e62:	6c12      	ldr	r2, [r2, #64]	@ 0x40
 8010e64:	f002 5280 	and.w	r2, r2, #268435456	@ 0x10000000
 8010e68:	9201      	str	r2, [sp, #4]
 8010e6a:	9a01      	ldr	r2, [sp, #4]
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8010e6c:	681a      	ldr	r2, [r3, #0]
 8010e6e:	f442 4240 	orr.w	r2, r2, #49152	@ 0xc000
 8010e72:	601a      	str	r2, [r3, #0]
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI|RCC_OSCILLATORTYPE_HSE;
 8010e74:	2209      	movs	r2, #9
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8010e76:	681b      	ldr	r3, [r3, #0]
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8010e78:	940e      	str	r4, [sp, #56]	@ 0x38
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8010e7a:	f403 4340 	and.w	r3, r3, #49152	@ 0xc000
  RCC_OscInitStruct.PLL.PLLN = 432;
 8010e7e:	9412      	str	r4, [sp, #72]	@ 0x48
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8010e80:	9302      	str	r3, [sp, #8]
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI|RCC_OSCILLATORTYPE_HSE;
 8010e82:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8010e86:	9902      	ldr	r1, [sp, #8]
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI|RCC_OSCILLATORTYPE_HSE;
 8010e88:	e9cd 2308 	strd	r2, r3, [sp, #32]
  RCC_OscInitStruct.LSIState = RCC_LSI_ON;
 8010e8c:	2201      	movs	r2, #1
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8010e8e:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
  RCC_OscInitStruct.LSIState = RCC_LSI_ON;
 8010e92:	920d      	str	r2, [sp, #52]	@ 0x34
  RCC_OscInitStruct.PLL.PLLN = 432;
 8010e94:	2219      	movs	r2, #25
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8010e96:	930f      	str	r3, [sp, #60]	@ 0x3c
  RCC_OscInitStruct.PLL.PLLN = 432;
 8010e98:	f44f 73d8 	mov.w	r3, #432	@ 0x1b0
 8010e9c:	e9cd 2310 	strd	r2, r3, [sp, #64]	@ 0x40
  RCC_OscInitStruct.PLL.PLLQ = 9;
 8010ea0:	2309      	movs	r3, #9
 8010ea2:	9313      	str	r3, [sp, #76]	@ 0x4c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8010ea4:	f006 fc9a 	bl	80177dc <HAL_RCC_OscConfig>
 8010ea8:	b108      	cbz	r0, 8010eae <SystemClock_Config+0x7a>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8010eaa:	b672      	cpsid	i
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 8010eac:	e7fe      	b.n	8010eac <SystemClock_Config+0x78>
  if (HAL_PWREx_EnableOverDrive() != HAL_OK)
 8010eae:	f006 fbf9 	bl	80176a4 <HAL_PWREx_EnableOverDrive>
 8010eb2:	4603      	mov	r3, r0
 8010eb4:	b108      	cbz	r0, 8010eba <SystemClock_Config+0x86>
 8010eb6:	b672      	cpsid	i
  while (1)
 8010eb8:	e7fe      	b.n	8010eb8 <SystemClock_Config+0x84>
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8010eba:	220f      	movs	r2, #15
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 8010ebc:	f44f 55a0 	mov.w	r5, #5120	@ 0x1400
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7) != HAL_OK)
 8010ec0:	a803      	add	r0, sp, #12
 8010ec2:	2107      	movs	r1, #7
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8010ec4:	e9cd 2403 	strd	r2, r4, [sp, #12]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 8010ec8:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 8010ecc:	e9cd 3505 	strd	r3, r5, [sp, #20]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 8010ed0:	9207      	str	r2, [sp, #28]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7) != HAL_OK)
 8010ed2:	f006 fe71 	bl	8017bb8 <HAL_RCC_ClockConfig>
 8010ed6:	b108      	cbz	r0, 8010edc <SystemClock_Config+0xa8>
 8010ed8:	b672      	cpsid	i
  while (1)
 8010eda:	e7fe      	b.n	8010eda <SystemClock_Config+0xa6>
}
 8010edc:	b015      	add	sp, #84	@ 0x54
 8010ede:	bd30      	pop	{r4, r5, pc}
 8010ee0:	40023800 	.word	0x40023800
 8010ee4:	40007000 	.word	0x40007000

08010ee8 <PeriphCommonClock_Config>:
{
 8010ee8:	b510      	push	{r4, lr}
 8010eea:	b0a2      	sub	sp, #136	@ 0x88
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 8010eec:	2280      	movs	r2, #128	@ 0x80
 8010eee:	2100      	movs	r1, #0
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_LTDC|RCC_PERIPHCLK_SAI2
 8010ef0:	4c11      	ldr	r4, [pc, #68]	@ (8010f38 <PeriphCommonClock_Config+0x50>)
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 8010ef2:	a801      	add	r0, sp, #4
 8010ef4:	f022 f884 	bl	8033000 <memset>
  PeriphClkInitStruct.PLLSAI.PLLSAIR = 5;
 8010ef8:	2305      	movs	r3, #5
  PeriphClkInitStruct.PLLSAI.PLLSAIN = 384;
 8010efa:	f44f 70c0 	mov.w	r0, #384	@ 0x180
  PeriphClkInitStruct.PLLSAI.PLLSAIQ = 2;
 8010efe:	2102      	movs	r1, #2
  PeriphClkInitStruct.PLLSAI.PLLSAIP = RCC_PLLSAIP_DIV8;
 8010f00:	2203      	movs	r2, #3
  PeriphClkInitStruct.PLLSAI.PLLSAIR = 5;
 8010f02:	9307      	str	r3, [sp, #28]
  PeriphClkInitStruct.Clk48ClockSelection = RCC_CLK48SOURCE_PLLSAIP;
 8010f04:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
  PeriphClkInitStruct.PLLSAI.PLLSAIN = 384;
 8010f08:	9005      	str	r0, [sp, #20]
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8010f0a:	4668      	mov	r0, sp
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_LTDC|RCC_PERIPHCLK_SAI2
 8010f0c:	9400      	str	r4, [sp, #0]
  PeriphClkInitStruct.PLLSAI.PLLSAIQ = 2;
 8010f0e:	9106      	str	r1, [sp, #24]
  PeriphClkInitStruct.PLLSAI.PLLSAIP = RCC_PLLSAIP_DIV8;
 8010f10:	9208      	str	r2, [sp, #32]
  PeriphClkInitStruct.Clk48ClockSelection = RCC_CLK48SOURCE_PLLSAIP;
 8010f12:	931f      	str	r3, [sp, #124]	@ 0x7c
  PeriphClkInitStruct.PLLSAIDivQ = 1;
 8010f14:	ed9f 7b06 	vldr	d7, [pc, #24]	@ 8010f30 <PeriphCommonClock_Config+0x48>
 8010f18:	ed8d 7b0a 	vstr	d7, [sp, #40]	@ 0x28
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8010f1c:	f006 ff9c 	bl	8017e58 <HAL_RCCEx_PeriphCLKConfig>
 8010f20:	b108      	cbz	r0, 8010f26 <PeriphCommonClock_Config+0x3e>
 8010f22:	b672      	cpsid	i
  while (1)
 8010f24:	e7fe      	b.n	8010f24 <PeriphCommonClock_Config+0x3c>
}
 8010f26:	b022      	add	sp, #136	@ 0x88
 8010f28:	bd10      	pop	{r4, pc}
 8010f2a:	bf00      	nop
 8010f2c:	f3af 8000 	nop.w
 8010f30:	00000001 	.word	0x00000001
 8010f34:	00020000 	.word	0x00020000
 8010f38:	00b00008 	.word	0x00b00008

08010f3c <main>:
{
 8010f3c:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 8010f40:	b0ab      	sub	sp, #172	@ 0xac
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8010f42:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8010f46:	f3bf 8f6f 	isb	sy
__STATIC_INLINE void SCB_EnableICache (void)
{
  #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
 8010f4a:	48ce      	ldr	r0, [pc, #824]	@ (8011284 <main+0x348>)
 8010f4c:	2200      	movs	r2, #0
 8010f4e:	f8c0 2250 	str.w	r2, [r0, #592]	@ 0x250
  __ASM volatile ("dsb 0xF":::"memory");
 8010f52:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8010f56:	f3bf 8f6f 	isb	sy
    __DSB();
    __ISB();
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
 8010f5a:	6943      	ldr	r3, [r0, #20]
 8010f5c:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8010f60:	6143      	str	r3, [r0, #20]
  __ASM volatile ("dsb 0xF":::"memory");
 8010f62:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8010f66:	f3bf 8f6f 	isb	sy
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

    SCB->CSSELR = 0U; /*(0U << 1U) | 0U;*/  /* Level 1 data cache */
 8010f6a:	f8c0 2084 	str.w	r2, [r0, #132]	@ 0x84
  __ASM volatile ("dsb 0xF":::"memory");
 8010f6e:	f3bf 8f4f 	dsb	sy
    __DSB();

    ccsidr = SCB->CCSIDR;
 8010f72:	f8d0 5080 	ldr.w	r5, [r0, #128]	@ 0x80
                                            /* invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
      do {
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8010f76:	f643 76e0 	movw	r6, #16352	@ 0x3fe0
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
 8010f7a:	f3c5 344e 	ubfx	r4, r5, #13, #15
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 8010f7e:	f3c5 05c9 	ubfx	r5, r5, #3, #10
 8010f82:	0164      	lsls	r4, r4, #5
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8010f84:	ea04 0106 	and.w	r1, r4, r6
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 8010f88:	462b      	mov	r3, r5
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8010f8a:	ea41 7283 	orr.w	r2, r1, r3, lsl #30
                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways-- != 0U);
 8010f8e:	3b01      	subs	r3, #1
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8010f90:	f8c0 2260 	str.w	r2, [r0, #608]	@ 0x260
      } while (ways-- != 0U);
 8010f94:	1c5a      	adds	r2, r3, #1
 8010f96:	d1f8      	bne.n	8010f8a <main+0x4e>
    } while(sets-- != 0U);
 8010f98:	3c20      	subs	r4, #32
 8010f9a:	f114 0f20 	cmn.w	r4, #32
 8010f9e:	d1f1      	bne.n	8010f84 <main+0x48>
 8010fa0:	f3bf 8f4f 	dsb	sy
    __DSB();

    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
 8010fa4:	6943      	ldr	r3, [r0, #20]
 8010fa6:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8010faa:	6143      	str	r3, [r0, #20]
 8010fac:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8010fb0:	f3bf 8f6f 	isb	sy
  __HAL_RCC_GPIOE_CLK_ENABLE();
 8010fb4:	f8df b2f8 	ldr.w	fp, [pc, #760]	@ 80112b0 <main+0x374>
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8010fb8:	2400      	movs	r4, #0
  HAL_Init();
 8010fba:	f001 ff3f 	bl	8012e3c <HAL_Init>
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8010fbe:	2602      	movs	r6, #2
  SystemClock_Config();
 8010fc0:	f7ff ff38 	bl	8010e34 <SystemClock_Config>
  GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
 8010fc4:	2703      	movs	r7, #3
  PeriphCommonClock_Config();
 8010fc6:	f7ff ff8f 	bl	8010ee8 <PeriphCommonClock_Config>
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8010fca:	9421      	str	r4, [sp, #132]	@ 0x84
  HAL_GPIO_WritePin(OTG_FS_PowerSwitchOn_GPIO_Port, OTG_FS_PowerSwitchOn_Pin, GPIO_PIN_SET);
 8010fcc:	2201      	movs	r2, #1
 8010fce:	2120      	movs	r1, #32
  GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
 8010fd0:	f04f 080a 	mov.w	r8, #10
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8010fd4:	2501      	movs	r5, #1
  GPIO_InitStruct.Pin = uSD_Detect_Pin;
 8010fd6:	f44f 5900 	mov.w	r9, #8192	@ 0x2000
  GPIO_InitStruct.Pin = OTG_FS_OverCurrent_Pin;
 8010fda:	f04f 0a10 	mov.w	sl, #16
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8010fde:	e9cd 441d 	strd	r4, r4, [sp, #116]	@ 0x74
 8010fe2:	e9cd 441f 	strd	r4, r4, [sp, #124]	@ 0x7c
  __HAL_RCC_GPIOE_CLK_ENABLE();
 8010fe6:	f8db 0030 	ldr.w	r0, [fp, #48]	@ 0x30
 8010fea:	f040 0010 	orr.w	r0, r0, #16
 8010fee:	f8cb 0030 	str.w	r0, [fp, #48]	@ 0x30
 8010ff2:	f8db 0030 	ldr.w	r0, [fp, #48]	@ 0x30
 8010ff6:	f000 0010 	and.w	r0, r0, #16
 8010ffa:	9004      	str	r0, [sp, #16]
 8010ffc:	9804      	ldr	r0, [sp, #16]
  __HAL_RCC_GPIOG_CLK_ENABLE();
 8010ffe:	f8db 0030 	ldr.w	r0, [fp, #48]	@ 0x30
 8011002:	f040 0040 	orr.w	r0, r0, #64	@ 0x40
 8011006:	f8cb 0030 	str.w	r0, [fp, #48]	@ 0x30
 801100a:	f8db 0030 	ldr.w	r0, [fp, #48]	@ 0x30
 801100e:	f000 0040 	and.w	r0, r0, #64	@ 0x40
 8011012:	9005      	str	r0, [sp, #20]
 8011014:	9805      	ldr	r0, [sp, #20]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8011016:	f8db 0030 	ldr.w	r0, [fp, #48]	@ 0x30
 801101a:	f040 0002 	orr.w	r0, r0, #2
 801101e:	f8cb 0030 	str.w	r0, [fp, #48]	@ 0x30
 8011022:	f8db 0030 	ldr.w	r0, [fp, #48]	@ 0x30
 8011026:	f000 0002 	and.w	r0, r0, #2
 801102a:	9006      	str	r0, [sp, #24]
 801102c:	9806      	ldr	r0, [sp, #24]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 801102e:	f8db 0030 	ldr.w	r0, [fp, #48]	@ 0x30
 8011032:	f040 0008 	orr.w	r0, r0, #8
 8011036:	f8cb 0030 	str.w	r0, [fp, #48]	@ 0x30
 801103a:	f8db 0030 	ldr.w	r0, [fp, #48]	@ 0x30
 801103e:	f000 0008 	and.w	r0, r0, #8
 8011042:	9007      	str	r0, [sp, #28]
 8011044:	9807      	ldr	r0, [sp, #28]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8011046:	f8db 0030 	ldr.w	r0, [fp, #48]	@ 0x30
 801104a:	f040 0004 	orr.w	r0, r0, #4
 801104e:	f8cb 0030 	str.w	r0, [fp, #48]	@ 0x30
 8011052:	f8db 0030 	ldr.w	r0, [fp, #48]	@ 0x30
 8011056:	f000 0004 	and.w	r0, r0, #4
 801105a:	9008      	str	r0, [sp, #32]
 801105c:	9808      	ldr	r0, [sp, #32]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 801105e:	f8db 0030 	ldr.w	r0, [fp, #48]	@ 0x30
 8011062:	4310      	orrs	r0, r2
 8011064:	f8cb 0030 	str.w	r0, [fp, #48]	@ 0x30
 8011068:	f8db 0030 	ldr.w	r0, [fp, #48]	@ 0x30
 801106c:	4010      	ands	r0, r2
 801106e:	9009      	str	r0, [sp, #36]	@ 0x24
 8011070:	9809      	ldr	r0, [sp, #36]	@ 0x24
  __HAL_RCC_GPIOJ_CLK_ENABLE();
 8011072:	f8db 0030 	ldr.w	r0, [fp, #48]	@ 0x30
 8011076:	f440 7000 	orr.w	r0, r0, #512	@ 0x200
 801107a:	f8cb 0030 	str.w	r0, [fp, #48]	@ 0x30
 801107e:	f8db 0030 	ldr.w	r0, [fp, #48]	@ 0x30
 8011082:	f400 7000 	and.w	r0, r0, #512	@ 0x200
 8011086:	900a      	str	r0, [sp, #40]	@ 0x28
 8011088:	980a      	ldr	r0, [sp, #40]	@ 0x28
  __HAL_RCC_GPIOI_CLK_ENABLE();
 801108a:	f8db 0030 	ldr.w	r0, [fp, #48]	@ 0x30
 801108e:	f440 7080 	orr.w	r0, r0, #256	@ 0x100
 8011092:	f8cb 0030 	str.w	r0, [fp, #48]	@ 0x30
 8011096:	f8db 0030 	ldr.w	r0, [fp, #48]	@ 0x30
 801109a:	f400 7080 	and.w	r0, r0, #256	@ 0x100
 801109e:	900b      	str	r0, [sp, #44]	@ 0x2c
 80110a0:	980b      	ldr	r0, [sp, #44]	@ 0x2c
  __HAL_RCC_GPIOK_CLK_ENABLE();
 80110a2:	f8db 0030 	ldr.w	r0, [fp, #48]	@ 0x30
 80110a6:	f440 6080 	orr.w	r0, r0, #1024	@ 0x400
 80110aa:	f8cb 0030 	str.w	r0, [fp, #48]	@ 0x30
 80110ae:	f8db 0030 	ldr.w	r0, [fp, #48]	@ 0x30
 80110b2:	f400 6080 	and.w	r0, r0, #1024	@ 0x400
 80110b6:	900c      	str	r0, [sp, #48]	@ 0x30
 80110b8:	980c      	ldr	r0, [sp, #48]	@ 0x30
  __HAL_RCC_GPIOF_CLK_ENABLE();
 80110ba:	f8db 0030 	ldr.w	r0, [fp, #48]	@ 0x30
 80110be:	4308      	orrs	r0, r1
 80110c0:	f8cb 0030 	str.w	r0, [fp, #48]	@ 0x30
 80110c4:	f8db 0030 	ldr.w	r0, [fp, #48]	@ 0x30
 80110c8:	4008      	ands	r0, r1
 80110ca:	900d      	str	r0, [sp, #52]	@ 0x34
 80110cc:	980d      	ldr	r0, [sp, #52]	@ 0x34
  __HAL_RCC_GPIOH_CLK_ENABLE();
 80110ce:	f8db 0030 	ldr.w	r0, [fp, #48]	@ 0x30
 80110d2:	f040 0080 	orr.w	r0, r0, #128	@ 0x80
 80110d6:	f8cb 0030 	str.w	r0, [fp, #48]	@ 0x30
 80110da:	f8db 0030 	ldr.w	r0, [fp, #48]	@ 0x30
 80110de:	f000 0080 	and.w	r0, r0, #128	@ 0x80
 80110e2:	900e      	str	r0, [sp, #56]	@ 0x38
 80110e4:	980e      	ldr	r0, [sp, #56]	@ 0x38
  HAL_GPIO_WritePin(OTG_FS_PowerSwitchOn_GPIO_Port, OTG_FS_PowerSwitchOn_Pin, GPIO_PIN_SET);
 80110e6:	4868      	ldr	r0, [pc, #416]	@ (8011288 <main+0x34c>)
 80110e8:	f004 f908 	bl	80152fc <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOI, ARDUINO_D7_Pin|ARDUINO_D8_Pin, GPIO_PIN_RESET);
 80110ec:	4622      	mov	r2, r4
 80110ee:	210c      	movs	r1, #12
 80110f0:	4866      	ldr	r0, [pc, #408]	@ (801128c <main+0x350>)
 80110f2:	f004 f903 	bl	80152fc <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(LCD_BL_CTRL_GPIO_Port, LCD_BL_CTRL_Pin, GPIO_PIN_SET);
 80110f6:	2201      	movs	r2, #1
 80110f8:	2108      	movs	r1, #8
 80110fa:	4865      	ldr	r0, [pc, #404]	@ (8011290 <main+0x354>)
 80110fc:	f004 f8fe 	bl	80152fc <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(LCD_DISP_GPIO_Port, LCD_DISP_Pin, GPIO_PIN_SET);
 8011100:	f44f 5180 	mov.w	r1, #4096	@ 0x1000
 8011104:	4861      	ldr	r0, [pc, #388]	@ (801128c <main+0x350>)
 8011106:	2201      	movs	r2, #1
 8011108:	f004 f8f8 	bl	80152fc <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(DCMI_PWR_EN_GPIO_Port, DCMI_PWR_EN_Pin, GPIO_PIN_RESET);
 801110c:	4622      	mov	r2, r4
 801110e:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
 8011112:	4860      	ldr	r0, [pc, #384]	@ (8011294 <main+0x358>)
 8011114:	f004 f8f2 	bl	80152fc <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOG, ARDUINO_D4_Pin|ARDUINO_D2_Pin|EXT_RST_Pin, GPIO_PIN_RESET);
 8011118:	4622      	mov	r2, r4
 801111a:	21c8      	movs	r1, #200	@ 0xc8
 801111c:	485e      	ldr	r0, [pc, #376]	@ (8011298 <main+0x35c>)
 801111e:	f004 f8ed 	bl	80152fc <HAL_GPIO_WritePin>
  GPIO_InitStruct.Pin = OTG_HS_OverCurrent_Pin;
 8011122:	2308      	movs	r3, #8
  HAL_GPIO_Init(OTG_HS_OverCurrent_GPIO_Port, &GPIO_InitStruct);
 8011124:	a91d      	add	r1, sp, #116	@ 0x74
 8011126:	485d      	ldr	r0, [pc, #372]	@ (801129c <main+0x360>)
  GPIO_InitStruct.Pin = OTG_HS_OverCurrent_Pin;
 8011128:	931d      	str	r3, [sp, #116]	@ 0x74
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 801112a:	941e      	str	r4, [sp, #120]	@ 0x78
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 801112c:	941f      	str	r4, [sp, #124]	@ 0x7c
  HAL_GPIO_Init(OTG_HS_OverCurrent_GPIO_Port, &GPIO_InitStruct);
 801112e:	f003 ffa5 	bl	801507c <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = ULPI_D7_Pin|ULPI_D6_Pin|ULPI_D5_Pin|ULPI_D3_Pin
 8011132:	f643 4223 	movw	r2, #15395	@ 0x3c23
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8011136:	a91d      	add	r1, sp, #116	@ 0x74
 8011138:	4859      	ldr	r0, [pc, #356]	@ (80112a0 <main+0x364>)
  GPIO_InitStruct.Pin = ULPI_D7_Pin|ULPI_D6_Pin|ULPI_D5_Pin|ULPI_D3_Pin
 801113a:	921d      	str	r2, [sp, #116]	@ 0x74
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 801113c:	941f      	str	r4, [sp, #124]	@ 0x7c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 801113e:	961e      	str	r6, [sp, #120]	@ 0x78
  GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
 8011140:	e9cd 7820 	strd	r7, r8, [sp, #128]	@ 0x80
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8011144:	f003 ff9a 	bl	801507c <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = OTG_FS_VBUS_Pin;
 8011148:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
  HAL_GPIO_Init(OTG_FS_VBUS_GPIO_Port, &GPIO_InitStruct);
 801114c:	a91d      	add	r1, sp, #116	@ 0x74
 801114e:	4855      	ldr	r0, [pc, #340]	@ (80112a4 <main+0x368>)
  GPIO_InitStruct.Pin = OTG_FS_VBUS_Pin;
 8011150:	931d      	str	r3, [sp, #116]	@ 0x74
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8011152:	e9cd 441e 	strd	r4, r4, [sp, #120]	@ 0x78
  HAL_GPIO_Init(OTG_FS_VBUS_GPIO_Port, &GPIO_InitStruct);
 8011156:	f003 ff91 	bl	801507c <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = Audio_INT_Pin;
 801115a:	f44f 1290 	mov.w	r2, #1179648	@ 0x120000
 801115e:	2340      	movs	r3, #64	@ 0x40
  HAL_GPIO_Init(Audio_INT_GPIO_Port, &GPIO_InitStruct);
 8011160:	a91d      	add	r1, sp, #116	@ 0x74
 8011162:	4849      	ldr	r0, [pc, #292]	@ (8011288 <main+0x34c>)
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8011164:	941f      	str	r4, [sp, #124]	@ 0x7c
  GPIO_InitStruct.Pin = Audio_INT_Pin;
 8011166:	e9cd 321d 	strd	r3, r2, [sp, #116]	@ 0x74
  HAL_GPIO_Init(Audio_INT_GPIO_Port, &GPIO_InitStruct);
 801116a:	f003 ff87 	bl	801507c <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = OTG_FS_PowerSwitchOn_Pin;
 801116e:	2320      	movs	r3, #32
  HAL_GPIO_Init(OTG_FS_PowerSwitchOn_GPIO_Port, &GPIO_InitStruct);
 8011170:	a91d      	add	r1, sp, #116	@ 0x74
 8011172:	4845      	ldr	r0, [pc, #276]	@ (8011288 <main+0x34c>)
  GPIO_InitStruct.Pin = OTG_FS_PowerSwitchOn_Pin;
 8011174:	931d      	str	r3, [sp, #116]	@ 0x74
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8011176:	9420      	str	r4, [sp, #128]	@ 0x80
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8011178:	e9cd 541e 	strd	r5, r4, [sp, #120]	@ 0x78
  HAL_GPIO_Init(OTG_FS_PowerSwitchOn_GPIO_Port, &GPIO_InitStruct);
 801117c:	f003 ff7e 	bl	801507c <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = ARDUINO_D7_Pin|ARDUINO_D8_Pin|LCD_DISP_Pin;
 8011180:	f241 010c 	movw	r1, #4108	@ 0x100c
  HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
 8011184:	4841      	ldr	r0, [pc, #260]	@ (801128c <main+0x350>)
  GPIO_InitStruct.Pin = ARDUINO_D7_Pin|ARDUINO_D8_Pin|LCD_DISP_Pin;
 8011186:	911d      	str	r1, [sp, #116]	@ 0x74
  HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
 8011188:	a91d      	add	r1, sp, #116	@ 0x74
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 801118a:	9420      	str	r4, [sp, #128]	@ 0x80
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 801118c:	e9cd 541e 	strd	r5, r4, [sp, #120]	@ 0x78
  HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
 8011190:	f003 ff74 	bl	801507c <HAL_GPIO_Init>
  HAL_GPIO_Init(uSD_Detect_GPIO_Port, &GPIO_InitStruct);
 8011194:	a91d      	add	r1, sp, #116	@ 0x74
 8011196:	4844      	ldr	r0, [pc, #272]	@ (80112a8 <main+0x36c>)
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8011198:	941f      	str	r4, [sp, #124]	@ 0x7c
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 801119a:	e9cd 941d 	strd	r9, r4, [sp, #116]	@ 0x74
  HAL_GPIO_Init(uSD_Detect_GPIO_Port, &GPIO_InitStruct);
 801119e:	f003 ff6d 	bl	801507c <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = LCD_BL_CTRL_Pin;
 80111a2:	2308      	movs	r3, #8
  HAL_GPIO_Init(LCD_BL_CTRL_GPIO_Port, &GPIO_InitStruct);
 80111a4:	a91d      	add	r1, sp, #116	@ 0x74
 80111a6:	483a      	ldr	r0, [pc, #232]	@ (8011290 <main+0x354>)
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80111a8:	e9cd 351d 	strd	r3, r5, [sp, #116]	@ 0x74
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80111ac:	e9cd 441f 	strd	r4, r4, [sp, #124]	@ 0x7c
  HAL_GPIO_Init(LCD_BL_CTRL_GPIO_Port, &GPIO_InitStruct);
 80111b0:	f003 ff64 	bl	801507c <HAL_GPIO_Init>
  HAL_GPIO_Init(OTG_FS_OverCurrent_GPIO_Port, &GPIO_InitStruct);
 80111b4:	a91d      	add	r1, sp, #116	@ 0x74
 80111b6:	4834      	ldr	r0, [pc, #208]	@ (8011288 <main+0x34c>)
  GPIO_InitStruct.Pin = OTG_FS_OverCurrent_Pin;
 80111b8:	f8cd a074 	str.w	sl, [sp, #116]	@ 0x74
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80111bc:	e9cd 441e 	strd	r4, r4, [sp, #120]	@ 0x78
  HAL_GPIO_Init(OTG_FS_OverCurrent_GPIO_Port, &GPIO_InitStruct);
 80111c0:	f003 ff5c 	bl	801507c <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = TP3_Pin|NC2_Pin;
 80111c4:	f248 0104 	movw	r1, #32772	@ 0x8004
  HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
 80111c8:	4832      	ldr	r0, [pc, #200]	@ (8011294 <main+0x358>)
  GPIO_InitStruct.Pin = TP3_Pin|NC2_Pin;
 80111ca:	911d      	str	r1, [sp, #116]	@ 0x74
  HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
 80111cc:	a91d      	add	r1, sp, #116	@ 0x74
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80111ce:	e9cd 441e 	strd	r4, r4, [sp, #120]	@ 0x78
  HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
 80111d2:	f003 ff53 	bl	801507c <HAL_GPIO_Init>
  HAL_GPIO_Init(DCMI_PWR_EN_GPIO_Port, &GPIO_InitStruct);
 80111d6:	a91d      	add	r1, sp, #116	@ 0x74
 80111d8:	482e      	ldr	r0, [pc, #184]	@ (8011294 <main+0x358>)
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80111da:	e9cd 951d 	strd	r9, r5, [sp, #116]	@ 0x74
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80111de:	e9cd 441f 	strd	r4, r4, [sp, #124]	@ 0x7c
  HAL_GPIO_Init(DCMI_PWR_EN_GPIO_Port, &GPIO_InitStruct);
 80111e2:	f003 ff4b 	bl	801507c <HAL_GPIO_Init>
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 80111e6:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 80111ea:	f44f 1188 	mov.w	r1, #1114112	@ 0x110000
  HAL_GPIO_Init(USER_GPIO_Port, &GPIO_InitStruct);
 80111ee:	4827      	ldr	r0, [pc, #156]	@ (801128c <main+0x350>)
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80111f0:	941f      	str	r4, [sp, #124]	@ 0x7c
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 80111f2:	e9cd 311d 	strd	r3, r1, [sp, #116]	@ 0x74
  HAL_GPIO_Init(USER_GPIO_Port, &GPIO_InitStruct);
 80111f6:	a91d      	add	r1, sp, #116	@ 0x74
 80111f8:	f003 ff40 	bl	801507c <HAL_GPIO_Init>
  GPIO_InitStruct.Mode = GPIO_MODE_EVT_RISING;
 80111fc:	f44f 1290 	mov.w	r2, #1179648	@ 0x120000
  HAL_GPIO_Init(LCD_INT_GPIO_Port, &GPIO_InitStruct);
 8011200:	a91d      	add	r1, sp, #116	@ 0x74
 8011202:	4822      	ldr	r0, [pc, #136]	@ (801128c <main+0x350>)
  GPIO_InitStruct.Pin = LCD_INT_Pin;
 8011204:	f8cd 9074 	str.w	r9, [sp, #116]	@ 0x74
  GPIO_InitStruct.Pin = RMII_RXER_Pin;
 8011208:	f04f 0904 	mov.w	r9, #4
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 801120c:	e9cd 241e 	strd	r2, r4, [sp, #120]	@ 0x78
  HAL_GPIO_Init(LCD_INT_GPIO_Port, &GPIO_InitStruct);
 8011210:	f003 ff34 	bl	801507c <HAL_GPIO_Init>
  HAL_GPIO_Init(ULPI_NXT_GPIO_Port, &GPIO_InitStruct);
 8011214:	a91d      	add	r1, sp, #116	@ 0x74
 8011216:	481f      	ldr	r0, [pc, #124]	@ (8011294 <main+0x358>)
  GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
 8011218:	f8cd 8084 	str.w	r8, [sp, #132]	@ 0x84
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 801121c:	e9cd a61d 	strd	sl, r6, [sp, #116]	@ 0x74
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8011220:	e9cd 471f 	strd	r4, r7, [sp, #124]	@ 0x7c
  HAL_GPIO_Init(ULPI_NXT_GPIO_Port, &GPIO_InitStruct);
 8011224:	f003 ff2a 	bl	801507c <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = ARDUINO_D4_Pin|ARDUINO_D2_Pin|EXT_RST_Pin;
 8011228:	22c8      	movs	r2, #200	@ 0xc8
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 801122a:	a91d      	add	r1, sp, #116	@ 0x74
 801122c:	481a      	ldr	r0, [pc, #104]	@ (8011298 <main+0x35c>)
  GPIO_InitStruct.Pin = ARDUINO_D4_Pin|ARDUINO_D2_Pin|EXT_RST_Pin;
 801122e:	921d      	str	r2, [sp, #116]	@ 0x74
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8011230:	9420      	str	r4, [sp, #128]	@ 0x80
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8011232:	e9cd 541e 	strd	r5, r4, [sp, #120]	@ 0x78
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 8011236:	f003 ff21 	bl	801507c <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = ULPI_STP_Pin|ULPI_DIR_Pin;
 801123a:	2205      	movs	r2, #5
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 801123c:	a91d      	add	r1, sp, #116	@ 0x74
 801123e:	481a      	ldr	r0, [pc, #104]	@ (80112a8 <main+0x36c>)
  GPIO_InitStruct.Pin = ULPI_STP_Pin|ULPI_DIR_Pin;
 8011240:	921d      	str	r2, [sp, #116]	@ 0x74
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8011242:	e9cd 641e 	strd	r6, r4, [sp, #120]	@ 0x78
  GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
 8011246:	e9cd 7820 	strd	r7, r8, [sp, #128]	@ 0x80
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 801124a:	f003 ff17 	bl	801507c <HAL_GPIO_Init>
  HAL_GPIO_Init(RMII_RXER_GPIO_Port, &GPIO_InitStruct);
 801124e:	a91d      	add	r1, sp, #116	@ 0x74
 8011250:	4811      	ldr	r0, [pc, #68]	@ (8011298 <main+0x35c>)
  GPIO_InitStruct.Pin = RMII_RXER_Pin;
 8011252:	f8cd 9074 	str.w	r9, [sp, #116]	@ 0x74
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8011256:	e9cd 441e 	strd	r4, r4, [sp, #120]	@ 0x78
  HAL_GPIO_Init(RMII_RXER_GPIO_Port, &GPIO_InitStruct);
 801125a:	f003 ff0f 	bl	801507c <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = ULPI_CLK_Pin|ULPI_D0_Pin;
 801125e:	2128      	movs	r1, #40	@ 0x28
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8011260:	4812      	ldr	r0, [pc, #72]	@ (80112ac <main+0x370>)
  GPIO_InitStruct.Pin = ULPI_CLK_Pin|ULPI_D0_Pin;
 8011262:	911d      	str	r1, [sp, #116]	@ 0x74
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8011264:	a91d      	add	r1, sp, #116	@ 0x74
  GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
 8011266:	f8cd 8084 	str.w	r8, [sp, #132]	@ 0x84
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 801126a:	9720      	str	r7, [sp, #128]	@ 0x80
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 801126c:	e9cd 641e 	strd	r6, r4, [sp, #120]	@ 0x78
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8011270:	f003 ff04 	bl	801507c <HAL_GPIO_Init>
  HAL_NVIC_SetPriority(DMA2_Stream1_IRQn, 5, 0);
 8011274:	2205      	movs	r2, #5
 8011276:	2039      	movs	r0, #57	@ 0x39
 8011278:	4611      	mov	r1, r2
  __HAL_RCC_DMA2_CLK_ENABLE();
 801127a:	f8db 2030 	ldr.w	r2, [fp, #48]	@ 0x30
 801127e:	f442 0280 	orr.w	r2, r2, #4194304	@ 0x400000
 8011282:	e017      	b.n	80112b4 <main+0x378>
 8011284:	e000ed00 	.word	0xe000ed00
 8011288:	40020c00 	.word	0x40020c00
 801128c:	40022000 	.word	0x40022000
 8011290:	40022800 	.word	0x40022800
 8011294:	40021c00 	.word	0x40021c00
 8011298:	40021800 	.word	0x40021800
 801129c:	40021000 	.word	0x40021000
 80112a0:	40020400 	.word	0x40020400
 80112a4:	40022400 	.word	0x40022400
 80112a8:	40020800 	.word	0x40020800
 80112ac:	40020000 	.word	0x40020000
 80112b0:	40023800 	.word	0x40023800
 80112b4:	f8cb 2030 	str.w	r2, [fp, #48]	@ 0x30
  HAL_NVIC_SetPriority(DMA2_Stream1_IRQn, 5, 0);
 80112b8:	4622      	mov	r2, r4
  __HAL_RCC_DMA2_CLK_ENABLE();
 80112ba:	f8db 3030 	ldr.w	r3, [fp, #48]	@ 0x30
 80112be:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 80112c2:	9303      	str	r3, [sp, #12]
 80112c4:	9b03      	ldr	r3, [sp, #12]
  HAL_NVIC_SetPriority(DMA2_Stream1_IRQn, 5, 0);
 80112c6:	f001 ff67 	bl	8013198 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream1_IRQn);
 80112ca:	2039      	movs	r0, #57	@ 0x39
 80112cc:	f001 ffa0 	bl	8013210 <HAL_NVIC_EnableIRQ>
  hcrc.Instance = CRC;
 80112d0:	48b0      	ldr	r0, [pc, #704]	@ (8011594 <main+0x658>)
 80112d2:	4bb1      	ldr	r3, [pc, #708]	@ (8011598 <main+0x65c>)
  hcrc.Init.DefaultPolynomialUse = DEFAULT_POLYNOMIAL_ENABLE;
 80112d4:	8084      	strh	r4, [r0, #4]
  hcrc.Instance = CRC;
 80112d6:	6003      	str	r3, [r0, #0]
  hcrc.InputDataFormat = CRC_INPUTDATA_FORMAT_BYTES;
 80112d8:	6205      	str	r5, [r0, #32]
  hcrc.Init.OutputDataInversionMode = CRC_OUTPUTDATA_INVERSION_DISABLE;
 80112da:	e9c0 4405 	strd	r4, r4, [r0, #20]
  if (HAL_CRC_Init(&hcrc) != HAL_OK)
 80112de:	f001 ffa5 	bl	801322c <HAL_CRC_Init>
 80112e2:	4603      	mov	r3, r0
 80112e4:	b108      	cbz	r0, 80112ea <main+0x3ae>
  __ASM volatile ("cpsid i" : : : "memory");
 80112e6:	b672      	cpsid	i
  while (1)
 80112e8:	e7fe      	b.n	80112e8 <main+0x3ac>
  hdcmi.Instance = DCMI;
 80112ea:	48ac      	ldr	r0, [pc, #688]	@ (801159c <main+0x660>)
  hdcmi.Init.PCKPolarity = DCMI_PCKPOLARITY_RISING;
 80112ec:	2220      	movs	r2, #32
  hdcmi.Init.SynchroMode = DCMI_SYNCHRO_HARDWARE;
 80112ee:	e9c0 3201 	strd	r3, r2, [r0, #4]
  hdcmi.Init.HSPolarity = DCMI_HSPOLARITY_HIGH;
 80112f2:	2240      	movs	r2, #64	@ 0x40
  hdcmi.Init.ExtendedDataMode = DCMI_EXTEND_DATA_8B;
 80112f4:	6183      	str	r3, [r0, #24]
  hdcmi.Init.LineSelectStart = DCMI_OELS_ODD;
 80112f6:	6303      	str	r3, [r0, #48]	@ 0x30
  hdcmi.Init.CaptureRate = DCMI_CR_ALL_FRAME;
 80112f8:	e9c0 2304 	strd	r2, r3, [r0, #16]
  hdcmi.Init.ByteSelectMode = DCMI_BSM_ALL;
 80112fc:	e9c0 3308 	strd	r3, r3, [r0, #32]
  hdcmi.Init.LineSelectMode = DCMI_LSM_ALL;
 8011300:	e9c0 330a 	strd	r3, r3, [r0, #40]	@ 0x28
  hdcmi.Instance = DCMI;
 8011304:	4ba6      	ldr	r3, [pc, #664]	@ (80115a0 <main+0x664>)
 8011306:	6003      	str	r3, [r0, #0]
  hdcmi.Init.VSPolarity = DCMI_VSPOLARITY_HIGH;
 8011308:	2380      	movs	r3, #128	@ 0x80
 801130a:	60c3      	str	r3, [r0, #12]
  if (HAL_DCMI_Init(&hdcmi) != HAL_OK)
 801130c:	f002 f848 	bl	80133a0 <HAL_DCMI_Init>
 8011310:	b108      	cbz	r0, 8011316 <main+0x3da>
 8011312:	b672      	cpsid	i
  while (1)
 8011314:	e7fe      	b.n	8011314 <main+0x3d8>
  hdma2d.Instance = DMA2D;
 8011316:	4ca3      	ldr	r4, [pc, #652]	@ (80115a4 <main+0x668>)
 8011318:	4ba3      	ldr	r3, [pc, #652]	@ (80115a8 <main+0x66c>)
  hdma2d.Init.OutputOffset = 0;
 801131a:	60e0      	str	r0, [r4, #12]
  hdma2d.Instance = DMA2D;
 801131c:	6023      	str	r3, [r4, #0]
  hdma2d.Init.ColorMode = DMA2D_OUTPUT_ARGB8888;
 801131e:	e9c4 0001 	strd	r0, r0, [r4, #4]
  hdma2d.LayerCfg[1].InputColorMode = DMA2D_INPUT_ARGB8888;
 8011322:	e9c4 000a 	strd	r0, r0, [r4, #40]	@ 0x28
  hdma2d.LayerCfg[1].InputAlpha = 0;
 8011326:	e9c4 000c 	strd	r0, r0, [r4, #48]	@ 0x30
  if (HAL_DMA2D_Init(&hdma2d) != HAL_OK)
 801132a:	4620      	mov	r0, r4
 801132c:	f002 fb9a 	bl	8013a64 <HAL_DMA2D_Init>
 8011330:	b108      	cbz	r0, 8011336 <main+0x3fa>
 8011332:	b672      	cpsid	i
  while (1)
 8011334:	e7fe      	b.n	8011334 <main+0x3f8>
  if (HAL_DMA2D_ConfigLayer(&hdma2d, 1) != HAL_OK)
 8011336:	4620      	mov	r0, r4
 8011338:	4629      	mov	r1, r5
 801133a:	f002 fc59 	bl	8013bf0 <HAL_DMA2D_ConfigLayer>
 801133e:	4603      	mov	r3, r0
 8011340:	b9b8      	cbnz	r0, 8011372 <main+0x436>
  MACAddr[0] = 0x00;
 8011342:	4a9a      	ldr	r2, [pc, #616]	@ (80115ac <main+0x670>)
  heth.Instance = ETH;
 8011344:	489a      	ldr	r0, [pc, #616]	@ (80115b0 <main+0x674>)
  MACAddr[4] = 0x00;
 8011346:	8093      	strh	r3, [r2, #4]
  heth.Instance = ETH;
 8011348:	4b9a      	ldr	r3, [pc, #616]	@ (80115b4 <main+0x678>)
  heth.Init.MACAddr = &MACAddr[0];
 801134a:	6042      	str	r2, [r0, #4]
  heth.Instance = ETH;
 801134c:	6003      	str	r3, [r0, #0]
  MACAddr[0] = 0x00;
 801134e:	4b9a      	ldr	r3, [pc, #616]	@ (80115b8 <main+0x67c>)
 8011350:	6013      	str	r3, [r2, #0]
  heth.Init.MediaInterface = HAL_ETH_RMII_MODE;
 8011352:	f44f 0300 	mov.w	r3, #8388608	@ 0x800000
 8011356:	6083      	str	r3, [r0, #8]
  heth.Init.TxDesc = DMATxDscrTab;
 8011358:	4b98      	ldr	r3, [pc, #608]	@ (80115bc <main+0x680>)
 801135a:	60c3      	str	r3, [r0, #12]
  heth.Init.RxDesc = DMARxDscrTab;
 801135c:	4b98      	ldr	r3, [pc, #608]	@ (80115c0 <main+0x684>)
 801135e:	6103      	str	r3, [r0, #16]
  heth.Init.RxBuffLen = 1524;
 8011360:	f240 53f4 	movw	r3, #1524	@ 0x5f4
 8011364:	6143      	str	r3, [r0, #20]
  if (HAL_ETH_Init(&heth) != HAL_OK)
 8011366:	f003 fd47 	bl	8014df8 <HAL_ETH_Init>
 801136a:	4680      	mov	r8, r0
 801136c:	b118      	cbz	r0, 8011376 <main+0x43a>
 801136e:	b672      	cpsid	i
  while (1)
 8011370:	e7fe      	b.n	8011370 <main+0x434>
 8011372:	b672      	cpsid	i
 8011374:	e7fe      	b.n	8011374 <main+0x438>
  memset(&TxConfig, 0 , sizeof(ETH_TxPacketConfig));
 8011376:	4b93      	ldr	r3, [pc, #588]	@ (80115c4 <main+0x688>)
 8011378:	4601      	mov	r1, r0
 801137a:	2234      	movs	r2, #52	@ 0x34
  hsdram1.Instance = FMC_SDRAM_DEVICE;
 801137c:	4c92      	ldr	r4, [pc, #584]	@ (80115c8 <main+0x68c>)
  memset(&TxConfig, 0 , sizeof(ETH_TxPacketConfig));
 801137e:	4618      	mov	r0, r3
 8011380:	f021 fe3e 	bl	8033000 <memset>
  hsdram1.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4;
 8011384:	2240      	movs	r2, #64	@ 0x40
  hsdram1.Init.ReadBurst = FMC_SDRAM_RBURST_ENABLE;
 8011386:	f44f 6100 	mov.w	r1, #2048	@ 0x800
  hsdram1.Instance = FMC_SDRAM_DEVICE;
 801138a:	4b90      	ldr	r3, [pc, #576]	@ (80115cc <main+0x690>)
  hsdram1.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4;
 801138c:	6162      	str	r2, [r4, #20]
  hsdram1.Init.ReadBurst = FMC_SDRAM_RBURST_ENABLE;
 801138e:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
  hsdram1.Instance = FMC_SDRAM_DEVICE;
 8011392:	6023      	str	r3, [r4, #0]
  hsdram1.Init.CASLatency = FMC_SDRAM_CAS_LATENCY_3;
 8011394:	f44f 73c0 	mov.w	r3, #384	@ 0x180
  hsdram1.Init.WriteProtection = FMC_SDRAM_WRITE_PROTECTION_DISABLE;
 8011398:	f8c4 801c 	str.w	r8, [r4, #28]
  hsdram1.Init.ReadPipeDelay = FMC_SDRAM_RPIPE_DELAY_0;
 801139c:	f8c4 8028 	str.w	r8, [r4, #40]	@ 0x28
  SdramTiming.LoadToActiveDelay = 2;
 80113a0:	961d      	str	r6, [sp, #116]	@ 0x74
  SdramTiming.SelfRefreshTime = 4;
 80113a2:	f8cd 907c 	str.w	r9, [sp, #124]	@ 0x7c
  SdramTiming.RCDDelay = 2;
 80113a6:	9623      	str	r6, [sp, #140]	@ 0x8c
  hsdram1.Init.CASLatency = FMC_SDRAM_CAS_LATENCY_3;
 80113a8:	61a3      	str	r3, [r4, #24]
  hsdram1.Init.ReadBurst = FMC_SDRAM_RBURST_ENABLE;
 80113aa:	e9c4 1208 	strd	r1, r2, [r4, #32]
  SdramTiming.ExitSelfRefreshDelay = 7;
 80113ae:	2207      	movs	r2, #7
  if (HAL_SDRAM_Init(&hsdram1, &SdramTiming) != HAL_OK)
 80113b0:	a91d      	add	r1, sp, #116	@ 0x74
  SdramTiming.ExitSelfRefreshDelay = 7;
 80113b2:	921e      	str	r2, [sp, #120]	@ 0x78
  SdramTiming.RowCycleDelay = 7;
 80113b4:	9220      	str	r2, [sp, #128]	@ 0x80
  TxConfig.Attributes = ETH_TX_PACKETS_FEATURES_CSUM | ETH_TX_PACKETS_FEATURES_CRCPAD;
 80113b6:	2221      	movs	r2, #33	@ 0x21
 80113b8:	f840 2c04 	str.w	r2, [r0, #-4]
  TxConfig.ChecksumCtrl = ETH_CHECKSUM_IPHDR_PAYLOAD_INSERT_PHDR_CALC;
 80113bc:	f44f 0240 	mov.w	r2, #12582912	@ 0xc00000
 80113c0:	6102      	str	r2, [r0, #16]
  if (HAL_SDRAM_Init(&hsdram1, &SdramTiming) != HAL_OK)
 80113c2:	4620      	mov	r0, r4
  hsdram1.Init.ColumnBitsNumber = FMC_SDRAM_COLUMN_BITS_NUM_8;
 80113c4:	e9c4 8801 	strd	r8, r8, [r4, #4]
  hsdram1.Init.MemoryDataWidth = FMC_SDRAM_MEM_BUS_WIDTH_16;
 80113c8:	e9c4 9a03 	strd	r9, sl, [r4, #12]
  SdramTiming.RPDelay = 2;
 80113cc:	e9cd 7621 	strd	r7, r6, [sp, #132]	@ 0x84
  if (HAL_SDRAM_Init(&hsdram1, &SdramTiming) != HAL_OK)
 80113d0:	f008 f8f0 	bl	80195b4 <HAL_SDRAM_Init>
 80113d4:	b108      	cbz	r0, 80113da <main+0x49e>
 80113d6:	b672      	cpsid	i
  while (1)
 80113d8:	e7fe      	b.n	80113d8 <main+0x49c>
      Command.CommandMode            = FMC_SDRAM_CMD_CLK_ENABLE;
 80113da:	f8df 8210 	ldr.w	r8, [pc, #528]	@ 80115ec <main+0x6b0>
      HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
 80113de:	f64f 72ff 	movw	r2, #65535	@ 0xffff
  __IO uint32_t tmpmrd = 0;
 80113e2:	9002      	str	r0, [sp, #8]
      HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
 80113e4:	4641      	mov	r1, r8
      Command.ModeRegisterDefinition = 0;
 80113e6:	9001      	str	r0, [sp, #4]
 80113e8:	e9c8 5002 	strd	r5, r0, [r8, #8]
      HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
 80113ec:	4620      	mov	r0, r4
      Command.CommandTarget          =  FMC_SDRAM_CMD_TARGET_BANK1;
 80113ee:	e9c8 5a00 	strd	r5, sl, [r8]
      HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
 80113f2:	f008 f901 	bl	80195f8 <HAL_SDRAM_SendCommand>
      HAL_Delay(1);
 80113f6:	4628      	mov	r0, r5
 80113f8:	f001 fd3e 	bl	8012e78 <HAL_Delay>
      Command.ModeRegisterDefinition = 0;
 80113fc:	9b01      	ldr	r3, [sp, #4]
      HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
 80113fe:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 8011402:	4641      	mov	r1, r8
 8011404:	4620      	mov	r0, r4
      Command.ModeRegisterDefinition = 0;
 8011406:	f8c8 300c 	str.w	r3, [r8, #12]
      Command.AutoRefreshNumber      = 1;
 801140a:	f8c8 5008 	str.w	r5, [r8, #8]
      Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
 801140e:	e9c8 6a00 	strd	r6, sl, [r8]
      HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
 8011412:	f008 f8f1 	bl	80195f8 <HAL_SDRAM_SendCommand>
      Command.AutoRefreshNumber      = 8;
 8011416:	2308      	movs	r3, #8
      HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
 8011418:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 801141c:	4641      	mov	r1, r8
 801141e:	4620      	mov	r0, r4
      Command.CommandMode            = FMC_SDRAM_CMD_AUTOREFRESH_MODE;
 8011420:	f8c8 7000 	str.w	r7, [r8]
      Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
 8011424:	e9c8 a301 	strd	sl, r3, [r8, #4]
      Command.ModeRegisterDefinition = 0;
 8011428:	9b01      	ldr	r3, [sp, #4]
 801142a:	f8c8 300c 	str.w	r3, [r8, #12]
      HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
 801142e:	f008 f8e3 	bl	80195f8 <HAL_SDRAM_SendCommand>
      tmpmrd = (uint32_t)SDRAM_MODEREG_BURST_LENGTH_1 | \
 8011432:	f44f 720c 	mov.w	r2, #560	@ 0x230
      HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
 8011436:	4620      	mov	r0, r4
      Command.AutoRefreshNumber      = 1;
 8011438:	f8c8 5008 	str.w	r5, [r8, #8]
      tmpmrd = (uint32_t)SDRAM_MODEREG_BURST_LENGTH_1 | \
 801143c:	9202      	str	r2, [sp, #8]
      HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
 801143e:	f64f 72ff 	movw	r2, #65535	@ 0xffff
      Command.ModeRegisterDefinition = tmpmrd;
 8011442:	9902      	ldr	r1, [sp, #8]
 8011444:	f8c8 100c 	str.w	r1, [r8, #12]
      HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
 8011448:	4641      	mov	r1, r8
      Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
 801144a:	e9c8 9a00 	strd	r9, sl, [r8]
      HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
 801144e:	f008 f8d3 	bl	80195f8 <HAL_SDRAM_SendCommand>
      HAL_SDRAM_ProgramRefreshRate(&hsdram1, REFRESH_COUNT);
 8011452:	f240 712b 	movw	r1, #1835	@ 0x72b
 8011456:	4620      	mov	r0, r4
  hi2c1.Instance = I2C1;
 8011458:	4c5d      	ldr	r4, [pc, #372]	@ (80115d0 <main+0x694>)
      HAL_SDRAM_ProgramRefreshRate(&hsdram1, REFRESH_COUNT);
 801145a:	f008 f8ed 	bl	8019638 <HAL_SDRAM_ProgramRefreshRate>
      FMC_Bank1->BTCR[0] = 0x000030D2;
 801145e:	f243 01d2 	movw	r1, #12498	@ 0x30d2
 8011462:	f04f 4220 	mov.w	r2, #2684354560	@ 0xa0000000
  hi2c1.Init.OwnAddress1 = 0;
 8011466:	9b01      	ldr	r3, [sp, #4]
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
 8011468:	4620      	mov	r0, r4
      FMC_Bank1->BTCR[0] = 0x000030D2;
 801146a:	6011      	str	r1, [r2, #0]
  hi2c1.Instance = I2C1;
 801146c:	4a59      	ldr	r2, [pc, #356]	@ (80115d4 <main+0x698>)
  hi2c1.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
 801146e:	61a3      	str	r3, [r4, #24]
  hi2c1.Instance = I2C1;
 8011470:	6022      	str	r2, [r4, #0]
  hi2c1.Init.Timing = 0x20404768;
 8011472:	f1a2 52fe 	sub.w	r2, r2, #532676608	@ 0x1fc00000
 8011476:	f6a2 4298 	subw	r2, r2, #3224	@ 0xc98
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 801147a:	e9c4 3502 	strd	r3, r5, [r4, #8]
  hi2c1.Init.OwnAddress2 = 0;
 801147e:	e9c4 3304 	strd	r3, r3, [r4, #16]
  hi2c1.Init.Timing = 0x20404768;
 8011482:	6062      	str	r2, [r4, #4]
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 8011484:	e9c4 3307 	strd	r3, r3, [r4, #28]
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
 8011488:	f004 fa0c 	bl	80158a4 <HAL_I2C_Init>
 801148c:	4601      	mov	r1, r0
 801148e:	b108      	cbz	r0, 8011494 <main+0x558>
 8011490:	b672      	cpsid	i
  while (1)
 8011492:	e7fe      	b.n	8011492 <main+0x556>
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c1, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
 8011494:	4620      	mov	r0, r4
 8011496:	f004 fc5d 	bl	8015d54 <HAL_I2CEx_ConfigAnalogFilter>
 801149a:	b108      	cbz	r0, 80114a0 <main+0x564>
 801149c:	b672      	cpsid	i
  while (1)
 801149e:	e7fe      	b.n	801149e <main+0x562>
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c1, 0) != HAL_OK)
 80114a0:	2100      	movs	r1, #0
 80114a2:	484b      	ldr	r0, [pc, #300]	@ (80115d0 <main+0x694>)
 80114a4:	f004 fc80 	bl	8015da8 <HAL_I2CEx_ConfigDigitalFilter>
 80114a8:	4603      	mov	r3, r0
 80114aa:	b108      	cbz	r0, 80114b0 <main+0x574>
 80114ac:	b672      	cpsid	i
  while (1)
 80114ae:	e7fe      	b.n	80114ae <main+0x572>
  hi2c3.Instance = I2C3;
 80114b0:	4c49      	ldr	r4, [pc, #292]	@ (80115d8 <main+0x69c>)
  hi2c3.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 80114b2:	2601      	movs	r6, #1
  hi2c3.Instance = I2C3;
 80114b4:	4949      	ldr	r1, [pc, #292]	@ (80115dc <main+0x6a0>)
  hi2c3.Init.Timing = 0x20404768;
 80114b6:	4a4a      	ldr	r2, [pc, #296]	@ (80115e0 <main+0x6a4>)
  if (HAL_I2C_Init(&hi2c3) != HAL_OK)
 80114b8:	4620      	mov	r0, r4
  hi2c3.Init.Timing = 0x20404768;
 80114ba:	e884 000e 	stmia.w	r4, {r1, r2, r3}
  hi2c3.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 80114be:	e9c4 6303 	strd	r6, r3, [r4, #12]
  hi2c3.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
 80114c2:	e9c4 3305 	strd	r3, r3, [r4, #20]
  hi2c3.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 80114c6:	e9c4 3307 	strd	r3, r3, [r4, #28]
  if (HAL_I2C_Init(&hi2c3) != HAL_OK)
 80114ca:	f004 f9eb 	bl	80158a4 <HAL_I2C_Init>
 80114ce:	4601      	mov	r1, r0
 80114d0:	b108      	cbz	r0, 80114d6 <main+0x59a>
 80114d2:	b672      	cpsid	i
  while (1)
 80114d4:	e7fe      	b.n	80114d4 <main+0x598>
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c3, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
 80114d6:	4620      	mov	r0, r4
 80114d8:	f004 fc3c 	bl	8015d54 <HAL_I2CEx_ConfigAnalogFilter>
 80114dc:	4601      	mov	r1, r0
 80114de:	b108      	cbz	r0, 80114e4 <main+0x5a8>
 80114e0:	b672      	cpsid	i
  while (1)
 80114e2:	e7fe      	b.n	80114e2 <main+0x5a6>
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c3, 0) != HAL_OK)
 80114e4:	4620      	mov	r0, r4
 80114e6:	f004 fc5f 	bl	8015da8 <HAL_I2CEx_ConfigDigitalFilter>
 80114ea:	4605      	mov	r5, r0
 80114ec:	b108      	cbz	r0, 80114f2 <main+0x5b6>
 80114ee:	b672      	cpsid	i
  while (1)
 80114f0:	e7fe      	b.n	80114f0 <main+0x5b4>
  LTDC_LayerCfgTypeDef pLayerCfg = {0};
 80114f2:	2234      	movs	r2, #52	@ 0x34
 80114f4:	4601      	mov	r1, r0
 80114f6:	a81d      	add	r0, sp, #116	@ 0x74
  hltdc.Instance = LTDC;
 80114f8:	4c3a      	ldr	r4, [pc, #232]	@ (80115e4 <main+0x6a8>)
  LTDC_LayerCfgTypeDef pLayerCfg = {0};
 80114fa:	f021 fd81 	bl	8033000 <memset>
  hltdc.Instance = LTDC;
 80114fe:	4b3a      	ldr	r3, [pc, #232]	@ (80115e8 <main+0x6ac>)
  hltdc.Init.Backcolor.Blue = 0;
 8011500:	86a5      	strh	r5, [r4, #52]	@ 0x34
  hltdc.Init.AccumulatedActiveW = 533;
 8011502:	f04f 0c0b 	mov.w	ip, #11
  hltdc.Instance = LTDC;
 8011506:	6023      	str	r3, [r4, #0]
  hltdc.Init.AccumulatedHBP = 53;
 8011508:	2335      	movs	r3, #53	@ 0x35
  hltdc.Init.Backcolor.Red = 0;
 801150a:	f884 5036 	strb.w	r5, [r4, #54]	@ 0x36
  hltdc.Init.TotalWidth = 565;
 801150e:	f240 1e1b 	movw	lr, #283	@ 0x11b
  hltdc.Init.HorizontalSync = 40;
 8011512:	2728      	movs	r7, #40	@ 0x28
  if (HAL_LTDC_Init(&hltdc) != HAL_OK)
 8011514:	4620      	mov	r0, r4
  hltdc.Init.VSPolarity = LTDC_VSPOLARITY_AL;
 8011516:	e9c4 5501 	strd	r5, r5, [r4, #4]
  hltdc.Init.PCPolarity = LTDC_PCPOLARITY_IPC;
 801151a:	e9c4 5503 	strd	r5, r5, [r4, #12]
  hltdc.Init.AccumulatedHBP = 53;
 801151e:	2509      	movs	r5, #9
  hltdc.Init.HorizontalSync = 40;
 8011520:	6167      	str	r7, [r4, #20]
  hltdc.Init.AccumulatedHBP = 53;
 8011522:	e9c4 5306 	strd	r5, r3, [r4, #24]
  hltdc.Init.AccumulatedActiveW = 533;
 8011526:	f240 2315 	movw	r3, #533	@ 0x215
 801152a:	e9c4 c308 	strd	ip, r3, [r4, #32]
  hltdc.Init.TotalWidth = 565;
 801152e:	f240 2335 	movw	r3, #565	@ 0x235
 8011532:	e9c4 e30a 	strd	lr, r3, [r4, #40]	@ 0x28
  hltdc.Init.TotalHeigh = 285;
 8011536:	f240 131d 	movw	r3, #285	@ 0x11d
 801153a:	6323      	str	r3, [r4, #48]	@ 0x30
  if (HAL_LTDC_Init(&hltdc) != HAL_OK)
 801153c:	f004 fc60 	bl	8015e00 <HAL_LTDC_Init>
 8011540:	4602      	mov	r2, r0
 8011542:	b108      	cbz	r0, 8011548 <main+0x60c>
 8011544:	b672      	cpsid	i
  while (1)
 8011546:	e7fe      	b.n	8011546 <main+0x60a>
  pLayerCfg.WindowX1 = 480;
 8011548:	f44f 73f0 	mov.w	r3, #480	@ 0x1e0
  pLayerCfg.BlendingFactor2 = LTDC_BLENDING_FACTOR2_PAxCA;
 801154c:	f44f 61c0 	mov.w	r1, #1536	@ 0x600
  pLayerCfg.Alpha = 255;
 8011550:	f04f 0902 	mov.w	r9, #2
 8011554:	f04f 08ff 	mov.w	r8, #255	@ 0xff
  pLayerCfg.WindowX1 = 480;
 8011558:	931e      	str	r3, [sp, #120]	@ 0x78
  pLayerCfg.ImageWidth = 480;
 801155a:	9327      	str	r3, [sp, #156]	@ 0x9c
  pLayerCfg.WindowY1 = 272;
 801155c:	f44f 7388 	mov.w	r3, #272	@ 0x110
  pLayerCfg.WindowX0 = 0;
 8011560:	901d      	str	r0, [sp, #116]	@ 0x74
  pLayerCfg.WindowY1 = 272;
 8011562:	9320      	str	r3, [sp, #128]	@ 0x80
  pLayerCfg.ImageHeight = 272;
 8011564:	9328      	str	r3, [sp, #160]	@ 0xa0
  pLayerCfg.BlendingFactor2 = LTDC_BLENDING_FACTOR2_PAxCA;
 8011566:	2307      	movs	r3, #7
  pLayerCfg.WindowY0 = 0;
 8011568:	901f      	str	r0, [sp, #124]	@ 0x7c
  pLayerCfg.Alpha0 = 0;
 801156a:	9023      	str	r0, [sp, #140]	@ 0x8c
  pLayerCfg.Backcolor.Blue = 0;
 801156c:	f8ad 00a4 	strh.w	r0, [sp, #164]	@ 0xa4
  pLayerCfg.Backcolor.Red = 0;
 8011570:	f88d 00a6 	strb.w	r0, [sp, #166]	@ 0xa6
  if (HAL_LTDC_ConfigLayer(&hltdc, &pLayerCfg, 0) != HAL_OK)
 8011574:	4620      	mov	r0, r4
  pLayerCfg.BlendingFactor2 = LTDC_BLENDING_FACTOR2_PAxCA;
 8011576:	e9cd 1324 	strd	r1, r3, [sp, #144]	@ 0x90
  pLayerCfg.FBStartAdress = 0xC0000000;
 801157a:	f04f 4340 	mov.w	r3, #3221225472	@ 0xc0000000
  if (HAL_LTDC_ConfigLayer(&hltdc, &pLayerCfg, 0) != HAL_OK)
 801157e:	a91d      	add	r1, sp, #116	@ 0x74
  pLayerCfg.Alpha = 255;
 8011580:	e9cd 9821 	strd	r9, r8, [sp, #132]	@ 0x84
  pLayerCfg.FBStartAdress = 0xC0000000;
 8011584:	9326      	str	r3, [sp, #152]	@ 0x98
  if (HAL_LTDC_ConfigLayer(&hltdc, &pLayerCfg, 0) != HAL_OK)
 8011586:	f004 fd11 	bl	8015fac <HAL_LTDC_ConfigLayer>
 801158a:	4605      	mov	r5, r0
 801158c:	b380      	cbz	r0, 80115f0 <main+0x6b4>
 801158e:	b672      	cpsid	i
  while (1)
 8011590:	e7fe      	b.n	8011590 <main+0x654>
 8011592:	bf00      	nop
 8011594:	20002acc 	.word	0x20002acc
 8011598:	40023000 	.word	0x40023000
 801159c:	20002a7c 	.word	0x20002a7c
 80115a0:	50050000 	.word	0x50050000
 80115a4:	200029dc 	.word	0x200029dc
 80115a8:	4002b000 	.word	0x4002b000
 80115ac:	200011bc 	.word	0x200011bc
 80115b0:	2000292c 	.word	0x2000292c
 80115b4:	40028000 	.word	0x40028000
 80115b8:	00e18000 	.word	0x00e18000
 80115bc:	20001058 	.word	0x20001058
 80115c0:	200010f8 	.word	0x200010f8
 80115c4:	20002b3c 	.word	0x20002b3c
 80115c8:	20002228 	.word	0x20002228
 80115cc:	a0000140 	.word	0xa0000140
 80115d0:	200028d8 	.word	0x200028d8
 80115d4:	40005400 	.word	0x40005400
 80115d8:	20002884 	.word	0x20002884
 80115dc:	40005c00 	.word	0x40005c00
 80115e0:	20404768 	.word	0x20404768
 80115e4:	200027dc 	.word	0x200027dc
 80115e8:	40016800 	.word	0x40016800
 80115ec:	200021d0 	.word	0x200021d0
  HAL_LTDC_Reload(&hltdc, LTDC_RELOAD_VERTICAL_BLANKING);
 80115f0:	4649      	mov	r1, r9
 80115f2:	4620      	mov	r0, r4
 80115f4:	f004 fe5e 	bl	80162b4 <HAL_LTDC_Reload>
  hqspi.Instance = QUADSPI;
 80115f8:	48a1      	ldr	r0, [pc, #644]	@ (8011880 <main+0x944>)
 80115fa:	4ba2      	ldr	r3, [pc, #648]	@ (8011884 <main+0x948>)
  hqspi.Init.SampleShifting = QSPI_SAMPLE_SHIFTING_HALFCYCLE;
 80115fc:	f04f 0b04 	mov.w	fp, #4
  hqspi.Init.ChipSelectHighTime = QSPI_CS_HIGH_TIME_6_CYCLE;
 8011600:	2218      	movs	r2, #24
  hqspi.Init.ClockPrescaler = 1;
 8011602:	6046      	str	r6, [r0, #4]
  hqspi.Instance = QUADSPI;
 8011604:	6003      	str	r3, [r0, #0]
  hqspi.Init.SampleShifting = QSPI_SAMPLE_SHIFTING_HALFCYCLE;
 8011606:	2310      	movs	r3, #16
  hqspi.Init.DualFlash = QSPI_DUALFLASH_DISABLE;
 8011608:	6205      	str	r5, [r0, #32]
  hqspi.Init.SampleShifting = QSPI_SAMPLE_SHIFTING_HALFCYCLE;
 801160a:	e9c0 b302 	strd	fp, r3, [r0, #8]
  hqspi.Init.ChipSelectHighTime = QSPI_CS_HIGH_TIME_6_CYCLE;
 801160e:	f44f 63a0 	mov.w	r3, #1280	@ 0x500
  hqspi.Init.FlashID = QSPI_FLASH_ID_1;
 8011612:	e9c0 5506 	strd	r5, r5, [r0, #24]
  hqspi.Init.ChipSelectHighTime = QSPI_CS_HIGH_TIME_6_CYCLE;
 8011616:	e9c0 2304 	strd	r2, r3, [r0, #16]
  if (HAL_QSPI_Init(&hqspi) != HAL_OK)
 801161a:	f006 f87d 	bl	8017718 <HAL_QSPI_Init>
 801161e:	4604      	mov	r4, r0
 8011620:	b108      	cbz	r0, 8011626 <main+0x6ea>
 8011622:	b672      	cpsid	i
  while (1)
 8011624:	e7fe      	b.n	8011624 <main+0x6e8>
  RTC_AlarmTypeDef sAlarm = {0};
 8011626:	4601      	mov	r1, r0
  RTC_TimeTypeDef sTime = {0};
 8011628:	9016      	str	r0, [sp, #88]	@ 0x58
  RTC_DateTypeDef sDate = {0};
 801162a:	9012      	str	r0, [sp, #72]	@ 0x48
  RTC_AlarmTypeDef sAlarm = {0};
 801162c:	463a      	mov	r2, r7
  hrtc.Instance = RTC;
 801162e:	4d96      	ldr	r5, [pc, #600]	@ (8011888 <main+0x94c>)
  RTC_TimeTypeDef sTime = {0};
 8011630:	e9cd 0017 	strd	r0, r0, [sp, #92]	@ 0x5c
 8011634:	e9cd 0019 	strd	r0, r0, [sp, #100]	@ 0x64
  RTC_AlarmTypeDef sAlarm = {0};
 8011638:	a81d      	add	r0, sp, #116	@ 0x74
 801163a:	f021 fce1 	bl	8033000 <memset>
  hrtc.Instance = RTC;
 801163e:	4b93      	ldr	r3, [pc, #588]	@ (801188c <main+0x950>)
  if (HAL_RTC_Init(&hrtc) != HAL_OK)
 8011640:	4628      	mov	r0, r5
  hrtc.Init.SynchPrediv = 255;
 8011642:	f8c5 800c 	str.w	r8, [r5, #12]
  hrtc.Instance = RTC;
 8011646:	602b      	str	r3, [r5, #0]
  hrtc.Init.AsynchPrediv = 127;
 8011648:	237f      	movs	r3, #127	@ 0x7f
  hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
 801164a:	606c      	str	r4, [r5, #4]
  hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
 801164c:	61ac      	str	r4, [r5, #24]
  hrtc.Init.AsynchPrediv = 127;
 801164e:	60ab      	str	r3, [r5, #8]
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
 8011650:	e9c5 4404 	strd	r4, r4, [r5, #16]
  if (HAL_RTC_Init(&hrtc) != HAL_OK)
 8011654:	f006 ff00 	bl	8018458 <HAL_RTC_Init>
 8011658:	b108      	cbz	r0, 801165e <main+0x722>
 801165a:	b672      	cpsid	i
  while (1)
 801165c:	e7fe      	b.n	801165c <main+0x720>
  sTime.Hours = 0x0;
 801165e:	f8ad 0058 	strh.w	r0, [sp, #88]	@ 0x58
  if (HAL_RTC_SetTime(&hrtc, &sTime, RTC_FORMAT_BCD) != HAL_OK)
 8011662:	4632      	mov	r2, r6
  sTime.Seconds = 0x0;
 8011664:	f88d 005a 	strb.w	r0, [sp, #90]	@ 0x5a
  if (HAL_RTC_SetTime(&hrtc, &sTime, RTC_FORMAT_BCD) != HAL_OK)
 8011668:	a916      	add	r1, sp, #88	@ 0x58
  sTime.StoreOperation = RTC_STOREOPERATION_RESET;
 801166a:	e9cd 0019 	strd	r0, r0, [sp, #100]	@ 0x64
  if (HAL_RTC_SetTime(&hrtc, &sTime, RTC_FORMAT_BCD) != HAL_OK)
 801166e:	4628      	mov	r0, r5
 8011670:	f006 ff6e 	bl	8018550 <HAL_RTC_SetTime>
 8011674:	b108      	cbz	r0, 801167a <main+0x73e>
 8011676:	b672      	cpsid	i
  while (1)
 8011678:	e7fe      	b.n	8011678 <main+0x73c>
  sDate.WeekDay = RTC_WEEKDAY_MONDAY;
 801167a:	4b85      	ldr	r3, [pc, #532]	@ (8011890 <main+0x954>)
  if (HAL_RTC_SetDate(&hrtc, &sDate, RTC_FORMAT_BCD) != HAL_OK)
 801167c:	4632      	mov	r2, r6
 801167e:	4628      	mov	r0, r5
 8011680:	a912      	add	r1, sp, #72	@ 0x48
  sDate.WeekDay = RTC_WEEKDAY_MONDAY;
 8011682:	9312      	str	r3, [sp, #72]	@ 0x48
  if (HAL_RTC_SetDate(&hrtc, &sDate, RTC_FORMAT_BCD) != HAL_OK)
 8011684:	f007 f816 	bl	80186b4 <HAL_RTC_SetDate>
 8011688:	b108      	cbz	r0, 801168e <main+0x752>
 801168a:	b672      	cpsid	i
  while (1)
 801168c:	e7fe      	b.n	801168c <main+0x750>
  sAlarm.AlarmTime.Hours = 0x0;
 801168e:	2300      	movs	r3, #0
  sAlarm.AlarmDateWeekDay = 0x1;
 8011690:	2601      	movs	r6, #1
  if (HAL_RTC_SetAlarm(&hrtc, &sAlarm, RTC_FORMAT_BCD) != HAL_OK)
 8011692:	a91d      	add	r1, sp, #116	@ 0x74
 8011694:	487c      	ldr	r0, [pc, #496]	@ (8011888 <main+0x94c>)
  sAlarm.AlarmTime.Hours = 0x0;
 8011696:	f8ad 3074 	strh.w	r3, [sp, #116]	@ 0x74
  if (HAL_RTC_SetAlarm(&hrtc, &sAlarm, RTC_FORMAT_BCD) != HAL_OK)
 801169a:	4632      	mov	r2, r6
  sAlarm.AlarmTime.Seconds = 0x0;
 801169c:	f88d 3076 	strb.w	r3, [sp, #118]	@ 0x76
  sAlarm.AlarmTime.SubSeconds = 0x0;
 80116a0:	931e      	str	r3, [sp, #120]	@ 0x78
  sAlarm.AlarmDateWeekDaySel = RTC_ALARMDATEWEEKDAYSEL_DATE;
 80116a2:	9324      	str	r3, [sp, #144]	@ 0x90
  sAlarm.AlarmDateWeekDay = 0x1;
 80116a4:	f88d 6094 	strb.w	r6, [sp, #148]	@ 0x94
  sAlarm.AlarmTime.StoreOperation = RTC_STOREOPERATION_RESET;
 80116a8:	e9cd 3320 	strd	r3, r3, [sp, #128]	@ 0x80
  sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDMASK_ALL;
 80116ac:	e9cd 3322 	strd	r3, r3, [sp, #136]	@ 0x88
  sAlarm.Alarm = RTC_ALARM_A;
 80116b0:	f44f 7380 	mov.w	r3, #256	@ 0x100
 80116b4:	9326      	str	r3, [sp, #152]	@ 0x98
  if (HAL_RTC_SetAlarm(&hrtc, &sAlarm, RTC_FORMAT_BCD) != HAL_OK)
 80116b6:	f007 f8a9 	bl	801880c <HAL_RTC_SetAlarm>
 80116ba:	b108      	cbz	r0, 80116c0 <main+0x784>
 80116bc:	b672      	cpsid	i
  while (1)
 80116be:	e7fe      	b.n	80116be <main+0x782>
  sAlarm.Alarm = RTC_ALARM_B;
 80116c0:	f44f 7400 	mov.w	r4, #512	@ 0x200
  if (HAL_RTC_SetAlarm(&hrtc, &sAlarm, RTC_FORMAT_BCD) != HAL_OK)
 80116c4:	a91d      	add	r1, sp, #116	@ 0x74
 80116c6:	4632      	mov	r2, r6
 80116c8:	486f      	ldr	r0, [pc, #444]	@ (8011888 <main+0x94c>)
  sAlarm.Alarm = RTC_ALARM_B;
 80116ca:	9426      	str	r4, [sp, #152]	@ 0x98
  if (HAL_RTC_SetAlarm(&hrtc, &sAlarm, RTC_FORMAT_BCD) != HAL_OK)
 80116cc:	f007 f89e 	bl	801880c <HAL_RTC_SetAlarm>
 80116d0:	4601      	mov	r1, r0
 80116d2:	b108      	cbz	r0, 80116d8 <main+0x79c>
 80116d4:	b672      	cpsid	i
  while (1)
 80116d6:	e7fe      	b.n	80116d6 <main+0x79a>
  if (HAL_RTCEx_SetTimeStamp(&hrtc, RTC_TIMESTAMPEDGE_RISING, RTC_TIMESTAMPPIN_POS1) != HAL_OK)
 80116d8:	2202      	movs	r2, #2
 80116da:	486b      	ldr	r0, [pc, #428]	@ (8011888 <main+0x94c>)
 80116dc:	f007 f968 	bl	80189b0 <HAL_RTCEx_SetTimeStamp>
 80116e0:	4603      	mov	r3, r0
 80116e2:	b108      	cbz	r0, 80116e8 <main+0x7ac>
 80116e4:	b672      	cpsid	i
  while (1)
 80116e6:	e7fe      	b.n	80116e6 <main+0x7aa>
  hsai_BlockA2.Instance = SAI2_Block_A;
 80116e8:	486a      	ldr	r0, [pc, #424]	@ (8011894 <main+0x958>)
  hsai_BlockA2.Init.DataSize = SAI_DATASIZE_8;
 80116ea:	2740      	movs	r7, #64	@ 0x40
  hsai_BlockA2.FrameInit.FrameLength = 8;
 80116ec:	2508      	movs	r5, #8
  hsai_BlockA2.Init.Protocol = SAI_FREE_PROTOCOL;
 80116ee:	6303      	str	r3, [r0, #48]	@ 0x30
  hsai_BlockA2.Init.AudioMode = SAI_MODEMASTER_TX;
 80116f0:	6043      	str	r3, [r0, #4]
  hsai_BlockA2.Init.Synchro = SAI_ASYNCHRONOUS;
 80116f2:	6083      	str	r3, [r0, #8]
  hsai_BlockA2.Init.FIFOThreshold = SAI_FIFOTHRESHOLD_EMPTY;
 80116f4:	6183      	str	r3, [r0, #24]
  hsai_BlockA2.Init.SynchroExt = SAI_SYNCEXT_DISABLE;
 80116f6:	60c3      	str	r3, [r0, #12]
  hsai_BlockA2.Init.TriState = SAI_OUTPUT_NOTRELEASED;
 80116f8:	62c3      	str	r3, [r0, #44]	@ 0x2c
  hsai_BlockA2.Init.DataSize = SAI_DATASIZE_8;
 80116fa:	6347      	str	r7, [r0, #52]	@ 0x34
  hsai_BlockA2.FrameInit.FrameLength = 8;
 80116fc:	6405      	str	r5, [r0, #64]	@ 0x40
  hsai_BlockA2.Init.ClockStrobing = SAI_CLOCKSTROBING_FALLINGEDGE;
 80116fe:	e9c0 330e 	strd	r3, r3, [r0, #56]	@ 0x38
  hsai_BlockA2.Init.NoDivider = SAI_MASTERDIVIDER_ENABLE;
 8011702:	e9c0 3304 	strd	r3, r3, [r0, #16]
  hsai_BlockA2.Init.CompandingMode = SAI_NOCOMPANDING;
 8011706:	e9c0 3309 	strd	r3, r3, [r0, #36]	@ 0x24
  hsai_BlockA2.FrameInit.FSDefinition = SAI_FS_STARTFRAME;
 801170a:	e9c0 6311 	strd	r6, r3, [r0, #68]	@ 0x44
  hsai_BlockA2.FrameInit.FSOffset = SAI_FS_FIRSTBIT;
 801170e:	e9c0 3313 	strd	r3, r3, [r0, #76]	@ 0x4c
  hsai_BlockA2.SlotInit.SlotSize = SAI_SLOTSIZE_DATASIZE;
 8011712:	e9c0 3315 	strd	r3, r3, [r0, #84]	@ 0x54
  hsai_BlockA2.SlotInit.SlotNumber = 1;
 8011716:	e9c0 6317 	strd	r6, r3, [r0, #92]	@ 0x5c
  hsai_BlockA2.Instance = SAI2_Block_A;
 801171a:	4b5f      	ldr	r3, [pc, #380]	@ (8011898 <main+0x95c>)
 801171c:	6003      	str	r3, [r0, #0]
  hsai_BlockA2.Init.AudioFrequency = SAI_AUDIO_FREQUENCY_192K;
 801171e:	4b5f      	ldr	r3, [pc, #380]	@ (801189c <main+0x960>)
 8011720:	61c3      	str	r3, [r0, #28]
  if (HAL_SAI_Init(&hsai_BlockA2) != HAL_OK)
 8011722:	f007 f97d 	bl	8018a20 <HAL_SAI_Init>
 8011726:	4603      	mov	r3, r0
 8011728:	b108      	cbz	r0, 801172e <main+0x7f2>
 801172a:	b672      	cpsid	i
  while (1)
 801172c:	e7fe      	b.n	801172c <main+0x7f0>
  hsai_BlockB2.Instance = SAI2_Block_B;
 801172e:	485c      	ldr	r0, [pc, #368]	@ (80118a0 <main+0x964>)
  hsai_BlockB2.Init.AudioMode = SAI_MODESLAVE_RX;
 8011730:	f8df 818c 	ldr.w	r8, [pc, #396]	@ 80118c0 <main+0x984>
  hsai_BlockB2.Init.OutputDrive = SAI_OUTPUTDRIVE_DISABLE;
 8011734:	6103      	str	r3, [r0, #16]
  hsai_BlockB2.Init.FIFOThreshold = SAI_FIFOTHRESHOLD_EMPTY;
 8011736:	6183      	str	r3, [r0, #24]
  hsai_BlockB2.Init.SynchroExt = SAI_SYNCEXT_DISABLE;
 8011738:	60c3      	str	r3, [r0, #12]
  hsai_BlockB2.Init.TriState = SAI_OUTPUT_NOTRELEASED;
 801173a:	62c3      	str	r3, [r0, #44]	@ 0x2c
  hsai_BlockB2.SlotInit.SlotSize = SAI_SLOTSIZE_DATASIZE;
 801173c:	6583      	str	r3, [r0, #88]	@ 0x58
  hsai_BlockB2.SlotInit.SlotActive = 0x00000000;
 801173e:	6603      	str	r3, [r0, #96]	@ 0x60
  hsai_BlockB2.Init.Synchro = SAI_SYNCHRONOUS;
 8011740:	6086      	str	r6, [r0, #8]
  hsai_BlockB2.SlotInit.SlotNumber = 1;
 8011742:	65c6      	str	r6, [r0, #92]	@ 0x5c
  hsai_BlockB2.Init.Protocol = SAI_FREE_PROTOCOL;
 8011744:	e9c0 370c 	strd	r3, r7, [r0, #48]	@ 0x30
  hsai_BlockB2.Init.ClockStrobing = SAI_CLOCKSTROBING_FALLINGEDGE;
 8011748:	e9c0 330e 	strd	r3, r3, [r0, #56]	@ 0x38
  hsai_BlockB2.Init.CompandingMode = SAI_NOCOMPANDING;
 801174c:	e9c0 3309 	strd	r3, r3, [r0, #36]	@ 0x24
  hsai_BlockB2.FrameInit.FSPolarity = SAI_FS_ACTIVE_LOW;
 8011750:	e9c0 3312 	strd	r3, r3, [r0, #72]	@ 0x48
  hsai_BlockB2.SlotInit.FirstBitOffset = 0;
 8011754:	e9c0 3314 	strd	r3, r3, [r0, #80]	@ 0x50
  hsai_BlockB2.Init.AudioMode = SAI_MODESLAVE_RX;
 8011758:	2303      	movs	r3, #3
  hsai_BlockB2.FrameInit.ActiveFrameLength = 1;
 801175a:	e9c0 5610 	strd	r5, r6, [r0, #64]	@ 0x40
  hsai_BlockB2.Init.AudioMode = SAI_MODESLAVE_RX;
 801175e:	e9c0 8300 	strd	r8, r3, [r0]
  if (HAL_SAI_Init(&hsai_BlockB2) != HAL_OK)
 8011762:	f007 f95d 	bl	8018a20 <HAL_SAI_Init>
 8011766:	4603      	mov	r3, r0
 8011768:	b108      	cbz	r0, 801176e <main+0x832>
 801176a:	b672      	cpsid	i
  while (1)
 801176c:	e7fe      	b.n	801176c <main+0x830>
  hspdif.Instance = SPDIFRX;
 801176e:	484d      	ldr	r0, [pc, #308]	@ (80118a4 <main+0x968>)
  hsd1.Instance = SDMMC1;
 8011770:	4a4d      	ldr	r2, [pc, #308]	@ (80118a8 <main+0x96c>)
  hspdif.Init.Retries = SPDIFRX_MAXRETRIES_NONE;
 8011772:	e9c0 3301 	strd	r3, r3, [r0, #4]
  hspdif.Init.ChannelSelection = SPDIFRX_CHANNEL_A;
 8011776:	e9c0 3303 	strd	r3, r3, [r0, #12]
  hspdif.Init.StereoMode = SPDIFRX_STEREOMODE_DISABLE;
 801177a:	e9c0 3305 	strd	r3, r3, [r0, #20]
  hspdif.Init.ChannelStatusMask = SPDIFRX_CHANNELSTATUS_OFF;
 801177e:	e9c0 3307 	strd	r3, r3, [r0, #28]
  hspdif.Init.ParityErrorMask = SPDIFRX_PARITYERRORMASK_OFF;
 8011782:	e9c0 3309 	strd	r3, r3, [r0, #36]	@ 0x24
  hsd1.Init.ClockBypass = SDMMC_CLOCK_BYPASS_DISABLE;
 8011786:	e9c2 3301 	strd	r3, r3, [r2, #4]
  hsd1.Init.ClockPowerSave = SDMMC_CLOCK_POWER_SAVE_DISABLE;
 801178a:	60d3      	str	r3, [r2, #12]
  hsd1.Init.ClockDiv = 0;
 801178c:	e9c2 3305 	strd	r3, r3, [r2, #20]
  hsd1.Instance = SDMMC1;
 8011790:	4b46      	ldr	r3, [pc, #280]	@ (80118ac <main+0x970>)
 8011792:	6013      	str	r3, [r2, #0]
  hsd1.Init.BusWide = SDMMC_BUS_WIDE_4B;
 8011794:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8011798:	6113      	str	r3, [r2, #16]
  hspdif.Instance = SPDIFRX;
 801179a:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 801179e:	6003      	str	r3, [r0, #0]
  if (HAL_SPDIFRX_Init(&hspdif) != HAL_OK)
 80117a0:	f007 ff62 	bl	8019668 <HAL_SPDIFRX_Init>
 80117a4:	4603      	mov	r3, r0
 80117a6:	b108      	cbz	r0, 80117ac <main+0x870>
 80117a8:	b672      	cpsid	i
  while (1)
 80117aa:	e7fe      	b.n	80117aa <main+0x86e>
  hspi2.Instance = SPI2;
 80117ac:	4840      	ldr	r0, [pc, #256]	@ (80118b0 <main+0x974>)
  hspi2.Init.Mode = SPI_MODE_MASTER;
 80117ae:	4f41      	ldr	r7, [pc, #260]	@ (80118b4 <main+0x978>)
  hspi2.Init.Direction = SPI_DIRECTION_2LINES;
 80117b0:	6083      	str	r3, [r0, #8]
  hspi2.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
 80117b2:	6303      	str	r3, [r0, #48]	@ 0x30
  hspi2.Init.NSS = SPI_NSS_SOFT;
 80117b4:	6184      	str	r4, [r0, #24]
  hspi2.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
 80117b6:	6345      	str	r5, [r0, #52]	@ 0x34
  hspi2.Init.CLKPhase = SPI_PHASE_1EDGE;
 80117b8:	e9c0 3304 	strd	r3, r3, [r0, #16]
  hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;
 80117bc:	e9c0 3307 	strd	r3, r3, [r0, #28]
  hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 80117c0:	e9c0 3309 	strd	r3, r3, [r0, #36]	@ 0x24
  hspi2.Init.Mode = SPI_MODE_MASTER;
 80117c4:	f44f 7382 	mov.w	r3, #260	@ 0x104
 80117c8:	e9c0 7300 	strd	r7, r3, [r0]
  hspi2.Init.DataSize = SPI_DATASIZE_4BIT;
 80117cc:	f44f 7340 	mov.w	r3, #768	@ 0x300
 80117d0:	60c3      	str	r3, [r0, #12]
  hspi2.Init.CRCPolynomial = 7;
 80117d2:	2307      	movs	r3, #7
 80117d4:	62c3      	str	r3, [r0, #44]	@ 0x2c
  if (HAL_SPI_Init(&hspi2) != HAL_OK)
 80117d6:	f007 ff7f 	bl	80196d8 <HAL_SPI_Init>
 80117da:	4604      	mov	r4, r0
 80117dc:	b108      	cbz	r0, 80117e2 <main+0x8a6>
 80117de:	b672      	cpsid	i
  while (1)
 80117e0:	e7fe      	b.n	80117e0 <main+0x8a4>
  TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = {0};
 80117e2:	4601      	mov	r1, r0
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 80117e4:	900f      	str	r0, [sp, #60]	@ 0x3c
  TIM_OC_InitTypeDef sConfigOC = {0};
 80117e6:	901c      	str	r0, [sp, #112]	@ 0x70
  TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = {0};
 80117e8:	222c      	movs	r2, #44	@ 0x2c
  htim1.Instance = TIM1;
 80117ea:	4d33      	ldr	r5, [pc, #204]	@ (80118b8 <main+0x97c>)
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 80117ec:	e9cd 0012 	strd	r0, r0, [sp, #72]	@ 0x48
 80117f0:	e9cd 0014 	strd	r0, r0, [sp, #80]	@ 0x50
  TIM_OC_InitTypeDef sConfigOC = {0};
 80117f4:	e9cd 0016 	strd	r0, r0, [sp, #88]	@ 0x58
 80117f8:	e9cd 0018 	strd	r0, r0, [sp, #96]	@ 0x60
 80117fc:	e9cd 001a 	strd	r0, r0, [sp, #104]	@ 0x68
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8011800:	e9cd 0010 	strd	r0, r0, [sp, #64]	@ 0x40
  TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = {0};
 8011804:	a81d      	add	r0, sp, #116	@ 0x74
 8011806:	f021 fbfb 	bl	8033000 <memset>
  htim1.Instance = TIM1;
 801180a:	4b2c      	ldr	r3, [pc, #176]	@ (80118bc <main+0x980>)
  if (HAL_TIM_Base_Init(&htim1) != HAL_OK)
 801180c:	4628      	mov	r0, r5
  htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 801180e:	61ac      	str	r4, [r5, #24]
  htim1.Instance = TIM1;
 8011810:	602b      	str	r3, [r5, #0]
  htim1.Init.Period = 65535;
 8011812:	f64f 73ff 	movw	r3, #65535	@ 0xffff
  htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
 8011816:	e9c5 4401 	strd	r4, r4, [r5, #4]
  htim1.Init.RepetitionCounter = 0;
 801181a:	e9c5 4404 	strd	r4, r4, [r5, #16]
  htim1.Init.Period = 65535;
 801181e:	60eb      	str	r3, [r5, #12]
  if (HAL_TIM_Base_Init(&htim1) != HAL_OK)
 8011820:	f007 ffd0 	bl	80197c4 <HAL_TIM_Base_Init>
 8011824:	b108      	cbz	r0, 801182a <main+0x8ee>
 8011826:	b672      	cpsid	i
  while (1)
 8011828:	e7fe      	b.n	8011828 <main+0x8ec>
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 801182a:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
  if (HAL_TIM_ConfigClockSource(&htim1, &sClockSourceConfig) != HAL_OK)
 801182e:	a912      	add	r1, sp, #72	@ 0x48
 8011830:	4628      	mov	r0, r5
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8011832:	9312      	str	r3, [sp, #72]	@ 0x48
  if (HAL_TIM_ConfigClockSource(&htim1, &sClockSourceConfig) != HAL_OK)
 8011834:	f008 fad8 	bl	8019de8 <HAL_TIM_ConfigClockSource>
 8011838:	b108      	cbz	r0, 801183e <main+0x902>
 801183a:	b672      	cpsid	i
  while (1)
 801183c:	e7fe      	b.n	801183c <main+0x900>
  if (HAL_TIM_PWM_Init(&htim1) != HAL_OK)
 801183e:	4628      	mov	r0, r5
 8011840:	f008 f8b2 	bl	80199a8 <HAL_TIM_PWM_Init>
 8011844:	b108      	cbz	r0, 801184a <main+0x90e>
 8011846:	b672      	cpsid	i
  while (1)
 8011848:	e7fe      	b.n	8011848 <main+0x90c>
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 801184a:	2300      	movs	r3, #0
  if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
 801184c:	a90f      	add	r1, sp, #60	@ 0x3c
 801184e:	481a      	ldr	r0, [pc, #104]	@ (80118b8 <main+0x97c>)
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8011850:	9311      	str	r3, [sp, #68]	@ 0x44
  sMasterConfig.MasterOutputTrigger2 = TIM_TRGO2_RESET;
 8011852:	e9cd 330f 	strd	r3, r3, [sp, #60]	@ 0x3c
  if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
 8011856:	f008 fc25 	bl	801a0a4 <HAL_TIMEx_MasterConfigSynchronization>
 801185a:	4602      	mov	r2, r0
 801185c:	b108      	cbz	r0, 8011862 <main+0x926>
 801185e:	b672      	cpsid	i
  while (1)
 8011860:	e7fe      	b.n	8011860 <main+0x924>
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 8011862:	2660      	movs	r6, #96	@ 0x60
  sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
 8011864:	9019      	str	r0, [sp, #100]	@ 0x64
  sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
 8011866:	901c      	str	r0, [sp, #112]	@ 0x70
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 8011868:	a916      	add	r1, sp, #88	@ 0x58
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 801186a:	9616      	str	r6, [sp, #88]	@ 0x58
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 801186c:	e9cd 0017 	strd	r0, r0, [sp, #92]	@ 0x5c
  sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
 8011870:	e9cd 001a 	strd	r0, r0, [sp, #104]	@ 0x68
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 8011874:	4810      	ldr	r0, [pc, #64]	@ (80118b8 <main+0x97c>)
 8011876:	f008 f937 	bl	8019ae8 <HAL_TIM_PWM_ConfigChannel>
 801187a:	b318      	cbz	r0, 80118c4 <main+0x988>
 801187c:	b672      	cpsid	i
  while (1)
 801187e:	e7fe      	b.n	801187e <main+0x942>
 8011880:	20002790 	.word	0x20002790
 8011884:	a0001000 	.word	0xa0001000
 8011888:	20002770 	.word	0x20002770
 801188c:	40002800 	.word	0x40002800
 8011890:	00010101 	.word	0x00010101
 8011894:	200026ec 	.word	0x200026ec
 8011898:	40015c04 	.word	0x40015c04
 801189c:	0002ee00 	.word	0x0002ee00
 80118a0:	20002668 	.word	0x20002668
 80118a4:	20002598 	.word	0x20002598
 80118a8:	200025e4 	.word	0x200025e4
 80118ac:	40012c00 	.word	0x40012c00
 80118b0:	20002534 	.word	0x20002534
 80118b4:	40003800 	.word	0x40003800
 80118b8:	200024e8 	.word	0x200024e8
 80118bc:	40010000 	.word	0x40010000
 80118c0:	40015c24 	.word	0x40015c24
  sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
 80118c4:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
  sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;
 80118c8:	9021      	str	r0, [sp, #132]	@ 0x84
  if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig) != HAL_OK)
 80118ca:	a91d      	add	r1, sp, #116	@ 0x74
  sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
 80118cc:	9322      	str	r3, [sp, #136]	@ 0x88
  sBreakDeadTimeConfig.Break2Polarity = TIM_BREAK2POLARITY_HIGH;
 80118ce:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
  sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;
 80118d2:	e9cd 001d 	strd	r0, r0, [sp, #116]	@ 0x74
  sBreakDeadTimeConfig.DeadTime = 0;
 80118d6:	e9cd 001f 	strd	r0, r0, [sp, #124]	@ 0x7c
  sBreakDeadTimeConfig.Break2State = TIM_BREAK2_DISABLE;
 80118da:	e9cd 0023 	strd	r0, r0, [sp, #140]	@ 0x8c
  sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
 80118de:	e9cd 0026 	strd	r0, r0, [sp, #152]	@ 0x98
  if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig) != HAL_OK)
 80118e2:	4898      	ldr	r0, [pc, #608]	@ (8011b44 <main+0xc08>)
  sBreakDeadTimeConfig.Break2Polarity = TIM_BREAK2POLARITY_HIGH;
 80118e4:	9325      	str	r3, [sp, #148]	@ 0x94
  if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig) != HAL_OK)
 80118e6:	f008 fc37 	bl	801a158 <HAL_TIMEx_ConfigBreakDeadTime>
 80118ea:	4604      	mov	r4, r0
 80118ec:	b108      	cbz	r0, 80118f2 <main+0x9b6>
 80118ee:	b672      	cpsid	i
  while (1)
 80118f0:	e7fe      	b.n	80118f0 <main+0x9b4>
  HAL_TIM_MspPostInit(&htim1);
 80118f2:	4894      	ldr	r0, [pc, #592]	@ (8011b44 <main+0xc08>)
 80118f4:	f000 ffc4 	bl	8012880 <HAL_TIM_MspPostInit>
  htim2.Instance = TIM2;
 80118f8:	4d93      	ldr	r5, [pc, #588]	@ (8011b48 <main+0xc0c>)
 80118fa:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 80118fe:	9414      	str	r4, [sp, #80]	@ 0x50
  if (HAL_TIM_Base_Init(&htim2) != HAL_OK)
 8011900:	4628      	mov	r0, r5
  TIM_OC_InitTypeDef sConfigOC = {0};
 8011902:	9423      	str	r4, [sp, #140]	@ 0x8c
  htim2.Instance = TIM2;
 8011904:	602b      	str	r3, [r5, #0]
  htim2.Init.Period = 4294967295;
 8011906:	f04f 33ff 	mov.w	r3, #4294967295
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 801190a:	612c      	str	r4, [r5, #16]
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 801190c:	61ac      	str	r4, [r5, #24]
  htim2.Init.Period = 4294967295;
 801190e:	60eb      	str	r3, [r5, #12]
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 8011910:	e9cd 4416 	strd	r4, r4, [sp, #88]	@ 0x58
 8011914:	e9cd 4418 	strd	r4, r4, [sp, #96]	@ 0x60
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8011918:	e9cd 4412 	strd	r4, r4, [sp, #72]	@ 0x48
  TIM_OC_InitTypeDef sConfigOC = {0};
 801191c:	e9cd 441d 	strd	r4, r4, [sp, #116]	@ 0x74
 8011920:	e9cd 441f 	strd	r4, r4, [sp, #124]	@ 0x7c
 8011924:	e9cd 4421 	strd	r4, r4, [sp, #132]	@ 0x84
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
 8011928:	e9c5 4401 	strd	r4, r4, [r5, #4]
  if (HAL_TIM_Base_Init(&htim2) != HAL_OK)
 801192c:	f007 ff4a 	bl	80197c4 <HAL_TIM_Base_Init>
 8011930:	b108      	cbz	r0, 8011936 <main+0x9fa>
 8011932:	b672      	cpsid	i
  while (1)
 8011934:	e7fe      	b.n	8011934 <main+0x9f8>
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8011936:	f44f 5780 	mov.w	r7, #4096	@ 0x1000
  if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK)
 801193a:	a916      	add	r1, sp, #88	@ 0x58
 801193c:	4628      	mov	r0, r5
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 801193e:	9716      	str	r7, [sp, #88]	@ 0x58
  if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK)
 8011940:	f008 fa52 	bl	8019de8 <HAL_TIM_ConfigClockSource>
 8011944:	b108      	cbz	r0, 801194a <main+0xa0e>
 8011946:	b672      	cpsid	i
  while (1)
 8011948:	e7fe      	b.n	8011948 <main+0xa0c>
  if (HAL_TIM_PWM_Init(&htim2) != HAL_OK)
 801194a:	4628      	mov	r0, r5
 801194c:	f008 f82c 	bl	80199a8 <HAL_TIM_PWM_Init>
 8011950:	b108      	cbz	r0, 8011956 <main+0xa1a>
 8011952:	b672      	cpsid	i
  while (1)
 8011954:	e7fe      	b.n	8011954 <main+0xa18>
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8011956:	9012      	str	r0, [sp, #72]	@ 0x48
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
 8011958:	a912      	add	r1, sp, #72	@ 0x48
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 801195a:	9014      	str	r0, [sp, #80]	@ 0x50
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
 801195c:	4628      	mov	r0, r5
 801195e:	f008 fba1 	bl	801a0a4 <HAL_TIMEx_MasterConfigSynchronization>
 8011962:	4602      	mov	r2, r0
 8011964:	b108      	cbz	r0, 801196a <main+0xa2e>
 8011966:	b672      	cpsid	i
  while (1)
 8011968:	e7fe      	b.n	8011968 <main+0xa2c>
  sConfigOC.Pulse = 0;
 801196a:	e9cd 601d 	strd	r6, r0, [sp, #116]	@ 0x74
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 801196e:	901f      	str	r0, [sp, #124]	@ 0x7c
  if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 8011970:	a91d      	add	r1, sp, #116	@ 0x74
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 8011972:	9021      	str	r0, [sp, #132]	@ 0x84
  if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 8011974:	4628      	mov	r0, r5
 8011976:	f008 f8b7 	bl	8019ae8 <HAL_TIM_PWM_ConfigChannel>
 801197a:	4604      	mov	r4, r0
 801197c:	b108      	cbz	r0, 8011982 <main+0xa46>
 801197e:	b672      	cpsid	i
  while (1)
 8011980:	e7fe      	b.n	8011980 <main+0xa44>
  HAL_TIM_MspPostInit(&htim2);
 8011982:	4628      	mov	r0, r5
  htim3.Instance = TIM3;
 8011984:	4d71      	ldr	r5, [pc, #452]	@ (8011b4c <main+0xc10>)
  HAL_TIM_MspPostInit(&htim2);
 8011986:	f000 ff7b 	bl	8012880 <HAL_TIM_MspPostInit>
  htim3.Instance = TIM3;
 801198a:	4b71      	ldr	r3, [pc, #452]	@ (8011b50 <main+0xc14>)
  if (HAL_TIM_Base_Init(&htim3) != HAL_OK)
 801198c:	4628      	mov	r0, r5
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 801198e:	9414      	str	r4, [sp, #80]	@ 0x50
  htim3.Instance = TIM3;
 8011990:	602b      	str	r3, [r5, #0]
  htim3.Init.Period = 65535;
 8011992:	f64f 73ff 	movw	r3, #65535	@ 0xffff
  TIM_OC_InitTypeDef sConfigOC = {0};
 8011996:	9423      	str	r4, [sp, #140]	@ 0x8c
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8011998:	612c      	str	r4, [r5, #16]
  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 801199a:	61ac      	str	r4, [r5, #24]
  htim3.Init.Period = 65535;
 801199c:	60eb      	str	r3, [r5, #12]
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 801199e:	e9cd 4416 	strd	r4, r4, [sp, #88]	@ 0x58
 80119a2:	e9cd 4418 	strd	r4, r4, [sp, #96]	@ 0x60
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 80119a6:	e9cd 4412 	strd	r4, r4, [sp, #72]	@ 0x48
  TIM_OC_InitTypeDef sConfigOC = {0};
 80119aa:	e9cd 441d 	strd	r4, r4, [sp, #116]	@ 0x74
 80119ae:	e9cd 441f 	strd	r4, r4, [sp, #124]	@ 0x7c
 80119b2:	e9cd 4421 	strd	r4, r4, [sp, #132]	@ 0x84
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
 80119b6:	e9c5 4401 	strd	r4, r4, [r5, #4]
  if (HAL_TIM_Base_Init(&htim3) != HAL_OK)
 80119ba:	f007 ff03 	bl	80197c4 <HAL_TIM_Base_Init>
 80119be:	b108      	cbz	r0, 80119c4 <main+0xa88>
 80119c0:	b672      	cpsid	i
  while (1)
 80119c2:	e7fe      	b.n	80119c2 <main+0xa86>
  if (HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig) != HAL_OK)
 80119c4:	4628      	mov	r0, r5
 80119c6:	a916      	add	r1, sp, #88	@ 0x58
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 80119c8:	9716      	str	r7, [sp, #88]	@ 0x58
  if (HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig) != HAL_OK)
 80119ca:	f008 fa0d 	bl	8019de8 <HAL_TIM_ConfigClockSource>
 80119ce:	b108      	cbz	r0, 80119d4 <main+0xa98>
 80119d0:	b672      	cpsid	i
  while (1)
 80119d2:	e7fe      	b.n	80119d2 <main+0xa96>
  if (HAL_TIM_PWM_Init(&htim3) != HAL_OK)
 80119d4:	485d      	ldr	r0, [pc, #372]	@ (8011b4c <main+0xc10>)
 80119d6:	f007 ffe7 	bl	80199a8 <HAL_TIM_PWM_Init>
 80119da:	b108      	cbz	r0, 80119e0 <main+0xaa4>
 80119dc:	b672      	cpsid	i
  while (1)
 80119de:	e7fe      	b.n	80119de <main+0xaa2>
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 80119e0:	9012      	str	r0, [sp, #72]	@ 0x48
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
 80119e2:	a912      	add	r1, sp, #72	@ 0x48
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 80119e4:	9014      	str	r0, [sp, #80]	@ 0x50
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
 80119e6:	4859      	ldr	r0, [pc, #356]	@ (8011b4c <main+0xc10>)
 80119e8:	f008 fb5c 	bl	801a0a4 <HAL_TIMEx_MasterConfigSynchronization>
 80119ec:	4602      	mov	r2, r0
 80119ee:	b108      	cbz	r0, 80119f4 <main+0xab8>
 80119f0:	b672      	cpsid	i
  while (1)
 80119f2:	e7fe      	b.n	80119f2 <main+0xab6>
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 80119f4:	2760      	movs	r7, #96	@ 0x60
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 80119f6:	9021      	str	r0, [sp, #132]	@ 0x84
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 80119f8:	a91d      	add	r1, sp, #116	@ 0x74
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 80119fa:	971d      	str	r7, [sp, #116]	@ 0x74
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 80119fc:	e9cd 001e 	strd	r0, r0, [sp, #120]	@ 0x78
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 8011a00:	4852      	ldr	r0, [pc, #328]	@ (8011b4c <main+0xc10>)
 8011a02:	f008 f871 	bl	8019ae8 <HAL_TIM_PWM_ConfigChannel>
 8011a06:	4604      	mov	r4, r0
 8011a08:	b108      	cbz	r0, 8011a0e <main+0xad2>
 8011a0a:	b672      	cpsid	i
  while (1)
 8011a0c:	e7fe      	b.n	8011a0c <main+0xad0>
  HAL_TIM_MspPostInit(&htim3);
 8011a0e:	484f      	ldr	r0, [pc, #316]	@ (8011b4c <main+0xc10>)
 8011a10:	f000 ff36 	bl	8012880 <HAL_TIM_MspPostInit>
  htim5.Instance = TIM5;
 8011a14:	4d4f      	ldr	r5, [pc, #316]	@ (8011b54 <main+0xc18>)
 8011a16:	4b50      	ldr	r3, [pc, #320]	@ (8011b58 <main+0xc1c>)
  if (HAL_TIM_Base_Init(&htim5) != HAL_OK)
 8011a18:	4628      	mov	r0, r5
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8011a1a:	9414      	str	r4, [sp, #80]	@ 0x50
  htim5.Instance = TIM5;
 8011a1c:	602b      	str	r3, [r5, #0]
  htim5.Init.Period = 4294967295;
 8011a1e:	f04f 33ff 	mov.w	r3, #4294967295
  TIM_OC_InitTypeDef sConfigOC = {0};
 8011a22:	9423      	str	r4, [sp, #140]	@ 0x8c
  htim5.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8011a24:	612c      	str	r4, [r5, #16]
  htim5.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8011a26:	61ac      	str	r4, [r5, #24]
  htim5.Init.Period = 4294967295;
 8011a28:	60eb      	str	r3, [r5, #12]
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 8011a2a:	e9cd 4416 	strd	r4, r4, [sp, #88]	@ 0x58
 8011a2e:	e9cd 4418 	strd	r4, r4, [sp, #96]	@ 0x60
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8011a32:	e9cd 4412 	strd	r4, r4, [sp, #72]	@ 0x48
  TIM_OC_InitTypeDef sConfigOC = {0};
 8011a36:	e9cd 441d 	strd	r4, r4, [sp, #116]	@ 0x74
 8011a3a:	e9cd 441f 	strd	r4, r4, [sp, #124]	@ 0x7c
 8011a3e:	e9cd 4421 	strd	r4, r4, [sp, #132]	@ 0x84
  htim5.Init.CounterMode = TIM_COUNTERMODE_UP;
 8011a42:	e9c5 4401 	strd	r4, r4, [r5, #4]
  if (HAL_TIM_Base_Init(&htim5) != HAL_OK)
 8011a46:	f007 febd 	bl	80197c4 <HAL_TIM_Base_Init>
 8011a4a:	b108      	cbz	r0, 8011a50 <main+0xb14>
 8011a4c:	b672      	cpsid	i
  while (1)
 8011a4e:	e7fe      	b.n	8011a4e <main+0xb12>
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8011a50:	f44f 5680 	mov.w	r6, #4096	@ 0x1000
  if (HAL_TIM_ConfigClockSource(&htim5, &sClockSourceConfig) != HAL_OK)
 8011a54:	a916      	add	r1, sp, #88	@ 0x58
 8011a56:	4628      	mov	r0, r5
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8011a58:	9616      	str	r6, [sp, #88]	@ 0x58
  if (HAL_TIM_ConfigClockSource(&htim5, &sClockSourceConfig) != HAL_OK)
 8011a5a:	f008 f9c5 	bl	8019de8 <HAL_TIM_ConfigClockSource>
 8011a5e:	b108      	cbz	r0, 8011a64 <main+0xb28>
 8011a60:	b672      	cpsid	i
  while (1)
 8011a62:	e7fe      	b.n	8011a62 <main+0xb26>
  if (HAL_TIM_PWM_Init(&htim5) != HAL_OK)
 8011a64:	4628      	mov	r0, r5
 8011a66:	f007 ff9f 	bl	80199a8 <HAL_TIM_PWM_Init>
 8011a6a:	b108      	cbz	r0, 8011a70 <main+0xb34>
 8011a6c:	b672      	cpsid	i
  while (1)
 8011a6e:	e7fe      	b.n	8011a6e <main+0xb32>
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8011a70:	9012      	str	r0, [sp, #72]	@ 0x48
  if (HAL_TIMEx_MasterConfigSynchronization(&htim5, &sMasterConfig) != HAL_OK)
 8011a72:	a912      	add	r1, sp, #72	@ 0x48
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8011a74:	9014      	str	r0, [sp, #80]	@ 0x50
  if (HAL_TIMEx_MasterConfigSynchronization(&htim5, &sMasterConfig) != HAL_OK)
 8011a76:	4628      	mov	r0, r5
 8011a78:	f008 fb14 	bl	801a0a4 <HAL_TIMEx_MasterConfigSynchronization>
 8011a7c:	b108      	cbz	r0, 8011a82 <main+0xb46>
 8011a7e:	b672      	cpsid	i
  while (1)
 8011a80:	e7fe      	b.n	8011a80 <main+0xb44>
  sConfigOC.Pulse = 0;
 8011a82:	e9cd 701d 	strd	r7, r0, [sp, #116]	@ 0x74
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 8011a86:	901f      	str	r0, [sp, #124]	@ 0x7c
  if (HAL_TIM_PWM_ConfigChannel(&htim5, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)
 8011a88:	220c      	movs	r2, #12
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 8011a8a:	9021      	str	r0, [sp, #132]	@ 0x84
  if (HAL_TIM_PWM_ConfigChannel(&htim5, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)
 8011a8c:	a91d      	add	r1, sp, #116	@ 0x74
 8011a8e:	4628      	mov	r0, r5
 8011a90:	f008 f82a 	bl	8019ae8 <HAL_TIM_PWM_ConfigChannel>
 8011a94:	4604      	mov	r4, r0
 8011a96:	b108      	cbz	r0, 8011a9c <main+0xb60>
 8011a98:	b672      	cpsid	i
  while (1)
 8011a9a:	e7fe      	b.n	8011a9a <main+0xb5e>
  HAL_TIM_MspPostInit(&htim5);
 8011a9c:	4628      	mov	r0, r5
  htim8.Instance = TIM8;
 8011a9e:	4d2f      	ldr	r5, [pc, #188]	@ (8011b5c <main+0xc20>)
  HAL_TIM_MspPostInit(&htim5);
 8011aa0:	f000 feee 	bl	8012880 <HAL_TIM_MspPostInit>
  htim8.Instance = TIM8;
 8011aa4:	4b2e      	ldr	r3, [pc, #184]	@ (8011b60 <main+0xc24>)
  if (HAL_TIM_Base_Init(&htim8) != HAL_OK)
 8011aa6:	4628      	mov	r0, r5
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8011aa8:	9418      	str	r4, [sp, #96]	@ 0x60
  htim8.Instance = TIM8;
 8011aaa:	602b      	str	r3, [r5, #0]
  htim8.Init.Period = 65535;
 8011aac:	f64f 73ff 	movw	r3, #65535	@ 0xffff
  htim8.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8011ab0:	61ac      	str	r4, [r5, #24]
  htim8.Init.Period = 65535;
 8011ab2:	60eb      	str	r3, [r5, #12]
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 8011ab4:	e9cd 441d 	strd	r4, r4, [sp, #116]	@ 0x74
 8011ab8:	e9cd 441f 	strd	r4, r4, [sp, #124]	@ 0x7c
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8011abc:	e9cd 4416 	strd	r4, r4, [sp, #88]	@ 0x58
  htim8.Init.CounterMode = TIM_COUNTERMODE_UP;
 8011ac0:	e9c5 4401 	strd	r4, r4, [r5, #4]
  htim8.Init.RepetitionCounter = 0;
 8011ac4:	e9c5 4404 	strd	r4, r4, [r5, #16]
  if (HAL_TIM_Base_Init(&htim8) != HAL_OK)
 8011ac8:	f007 fe7c 	bl	80197c4 <HAL_TIM_Base_Init>
 8011acc:	b108      	cbz	r0, 8011ad2 <main+0xb96>
 8011ace:	b672      	cpsid	i
  while (1)
 8011ad0:	e7fe      	b.n	8011ad0 <main+0xb94>
  if (HAL_TIM_ConfigClockSource(&htim8, &sClockSourceConfig) != HAL_OK)
 8011ad2:	a91d      	add	r1, sp, #116	@ 0x74
 8011ad4:	4628      	mov	r0, r5
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8011ad6:	961d      	str	r6, [sp, #116]	@ 0x74
  if (HAL_TIM_ConfigClockSource(&htim8, &sClockSourceConfig) != HAL_OK)
 8011ad8:	f008 f986 	bl	8019de8 <HAL_TIM_ConfigClockSource>
 8011adc:	b108      	cbz	r0, 8011ae2 <main+0xba6>
 8011ade:	b672      	cpsid	i
  while (1)
 8011ae0:	e7fe      	b.n	8011ae0 <main+0xba4>
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8011ae2:	2300      	movs	r3, #0
  if (HAL_TIMEx_MasterConfigSynchronization(&htim8, &sMasterConfig) != HAL_OK)
 8011ae4:	a916      	add	r1, sp, #88	@ 0x58
 8011ae6:	481d      	ldr	r0, [pc, #116]	@ (8011b5c <main+0xc20>)
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8011ae8:	9318      	str	r3, [sp, #96]	@ 0x60
  sMasterConfig.MasterOutputTrigger2 = TIM_TRGO2_RESET;
 8011aea:	e9cd 3316 	strd	r3, r3, [sp, #88]	@ 0x58
  if (HAL_TIMEx_MasterConfigSynchronization(&htim8, &sMasterConfig) != HAL_OK)
 8011aee:	f008 fad9 	bl	801a0a4 <HAL_TIMEx_MasterConfigSynchronization>
 8011af2:	4603      	mov	r3, r0
 8011af4:	b108      	cbz	r0, 8011afa <main+0xbbe>
 8011af6:	b672      	cpsid	i
  while (1)
 8011af8:	e7fe      	b.n	8011af8 <main+0xbbc>
  htim12.Instance = TIM12;
 8011afa:	4d1a      	ldr	r5, [pc, #104]	@ (8011b64 <main+0xc28>)
  htim12.Init.Period = 65535;
 8011afc:	f64f 72ff 	movw	r2, #65535	@ 0xffff
  htim12.Instance = TIM12;
 8011b00:	4919      	ldr	r1, [pc, #100]	@ (8011b68 <main+0xc2c>)
  TIM_OC_InitTypeDef sConfigOC = {0};
 8011b02:	9023      	str	r0, [sp, #140]	@ 0x8c
  htim12.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8011b04:	612b      	str	r3, [r5, #16]
  htim12.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8011b06:	61ab      	str	r3, [r5, #24]
  htim12.Init.Period = 65535;
 8011b08:	e9c5 0202 	strd	r0, r2, [r5, #8]
  TIM_OC_InitTypeDef sConfigOC = {0};
 8011b0c:	e9cd 001d 	strd	r0, r0, [sp, #116]	@ 0x74
 8011b10:	e9cd 001f 	strd	r0, r0, [sp, #124]	@ 0x7c
 8011b14:	e9cd 0021 	strd	r0, r0, [sp, #132]	@ 0x84
  htim12.Init.Prescaler = 0;
 8011b18:	e9c5 1000 	strd	r1, r0, [r5]
  if (HAL_TIM_PWM_Init(&htim12) != HAL_OK)
 8011b1c:	4628      	mov	r0, r5
 8011b1e:	f007 ff43 	bl	80199a8 <HAL_TIM_PWM_Init>
 8011b22:	4602      	mov	r2, r0
 8011b24:	b108      	cbz	r0, 8011b2a <main+0xbee>
 8011b26:	b672      	cpsid	i
  while (1)
 8011b28:	e7fe      	b.n	8011b28 <main+0xbec>
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 8011b2a:	2360      	movs	r3, #96	@ 0x60
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 8011b2c:	9021      	str	r0, [sp, #132]	@ 0x84
  if (HAL_TIM_PWM_ConfigChannel(&htim12, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 8011b2e:	a91d      	add	r1, sp, #116	@ 0x74
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 8011b30:	931d      	str	r3, [sp, #116]	@ 0x74
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 8011b32:	e9cd 001e 	strd	r0, r0, [sp, #120]	@ 0x78
  if (HAL_TIM_PWM_ConfigChannel(&htim12, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 8011b36:	4628      	mov	r0, r5
 8011b38:	f007 ffd6 	bl	8019ae8 <HAL_TIM_PWM_ConfigChannel>
 8011b3c:	4604      	mov	r4, r0
 8011b3e:	b1a8      	cbz	r0, 8011b6c <main+0xc30>
 8011b40:	b672      	cpsid	i
  while (1)
 8011b42:	e7fe      	b.n	8011b42 <main+0xc06>
 8011b44:	200024e8 	.word	0x200024e8
 8011b48:	2000249c 	.word	0x2000249c
 8011b4c:	20002450 	.word	0x20002450
 8011b50:	40000400 	.word	0x40000400
 8011b54:	20002404 	.word	0x20002404
 8011b58:	40000c00 	.word	0x40000c00
 8011b5c:	200023b8 	.word	0x200023b8
 8011b60:	40010400 	.word	0x40010400
 8011b64:	2000236c 	.word	0x2000236c
 8011b68:	40001800 	.word	0x40001800
  HAL_TIM_MspPostInit(&htim12);
 8011b6c:	4628      	mov	r0, r5
  huart1.Init.BaudRate = 115200;
 8011b6e:	f44f 36e1 	mov.w	r6, #115200	@ 0x1c200
  HAL_TIM_MspPostInit(&htim12);
 8011b72:	f000 fe85 	bl	8012880 <HAL_TIM_MspPostInit>
  huart1.Init.Mode = UART_MODE_TX_RX;
 8011b76:	250c      	movs	r5, #12
  huart1.Instance = USART1;
 8011b78:	482f      	ldr	r0, [pc, #188]	@ (8011c38 <main+0xcfc>)
 8011b7a:	4b30      	ldr	r3, [pc, #192]	@ (8011c3c <main+0xd00>)
  huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8011b7c:	6244      	str	r4, [r0, #36]	@ 0x24
  huart1.Instance = USART1;
 8011b7e:	6003      	str	r3, [r0, #0]
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
 8011b80:	e9c0 6401 	strd	r6, r4, [r0, #4]
  huart1.Init.Parity = UART_PARITY_NONE;
 8011b84:	e9c0 4403 	strd	r4, r4, [r0, #12]
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 8011b88:	e9c0 5405 	strd	r5, r4, [r0, #20]
  huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 8011b8c:	e9c0 4407 	strd	r4, r4, [r0, #28]
  if (HAL_UART_Init(&huart1) != HAL_OK)
 8011b90:	f008 fd68 	bl	801a664 <HAL_UART_Init>
 8011b94:	4603      	mov	r3, r0
 8011b96:	b108      	cbz	r0, 8011b9c <main+0xc60>
 8011b98:	b672      	cpsid	i
  while (1)
 8011b9a:	e7fe      	b.n	8011b9a <main+0xc5e>
  huart6.Instance = USART6;
 8011b9c:	4828      	ldr	r0, [pc, #160]	@ (8011c40 <main+0xd04>)
  huart6.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 8011b9e:	e9c0 5305 	strd	r5, r3, [r0, #20]
  huart6.Init.WordLength = UART_WORDLENGTH_8B;
 8011ba2:	e9c0 6301 	strd	r6, r3, [r0, #4]
  huart6.Init.Parity = UART_PARITY_NONE;
 8011ba6:	e9c0 3303 	strd	r3, r3, [r0, #12]
  huart6.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 8011baa:	e9c0 3307 	strd	r3, r3, [r0, #28]
  huart6.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8011bae:	6243      	str	r3, [r0, #36]	@ 0x24
  huart6.Instance = USART6;
 8011bb0:	4b24      	ldr	r3, [pc, #144]	@ (8011c44 <main+0xd08>)
 8011bb2:	6003      	str	r3, [r0, #0]
  if (HAL_UART_Init(&huart6) != HAL_OK)
 8011bb4:	f008 fd56 	bl	801a664 <HAL_UART_Init>
 8011bb8:	4605      	mov	r5, r0
 8011bba:	b108      	cbz	r0, 8011bc0 <main+0xc84>
 8011bbc:	b672      	cpsid	i
  while (1)
 8011bbe:	e7fe      	b.n	8011bbe <main+0xc82>
  MX_FATFS_Init();
 8011bc0:	f00a fd0a 	bl	801c5d8 <MX_FATFS_Init>
  hadc3.Instance = ADC3;
 8011bc4:	4c20      	ldr	r4, [pc, #128]	@ (8011c48 <main+0xd0c>)
 8011bc6:	4b21      	ldr	r3, [pc, #132]	@ (8011c4c <main+0xd10>)
  hadc3.Init.NbrOfConversion = 1;
 8011bc8:	2601      	movs	r6, #1
  if (HAL_ADC_Init(&hadc3) != HAL_OK)
 8011bca:	4620      	mov	r0, r4
  hadc3.Init.Resolution = ADC_RESOLUTION_12B;
 8011bcc:	60a5      	str	r5, [r4, #8]
  hadc3.Instance = ADC3;
 8011bce:	6023      	str	r3, [r4, #0]
  hadc3.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;
 8011bd0:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
  hadc3.Init.ScanConvMode = ADC_SCAN_DISABLE;
 8011bd4:	6125      	str	r5, [r4, #16]
  hadc3.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;
 8011bd6:	6063      	str	r3, [r4, #4]
  hadc3.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 8011bd8:	4b1d      	ldr	r3, [pc, #116]	@ (8011c50 <main+0xd14>)
  hadc3.Init.ContinuousConvMode = DISABLE;
 8011bda:	61a5      	str	r5, [r4, #24]
  hadc3.Init.DiscontinuousConvMode = DISABLE;
 8011bdc:	f884 5020 	strb.w	r5, [r4, #32]
  hadc3.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 8011be0:	60e5      	str	r5, [r4, #12]
  hadc3.Init.NbrOfConversion = 1;
 8011be2:	61e6      	str	r6, [r4, #28]
  hadc3.Init.DMAContinuousRequests = DISABLE;
 8011be4:	f884 5030 	strb.w	r5, [r4, #48]	@ 0x30
  hadc3.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 8011be8:	6166      	str	r6, [r4, #20]
  hadc3.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 8011bea:	e9c4 350a 	strd	r3, r5, [r4, #40]	@ 0x28
  ADC_ChannelConfTypeDef sConfig = {0};
 8011bee:	e9cd 551d 	strd	r5, r5, [sp, #116]	@ 0x74
 8011bf2:	e9cd 551f 	strd	r5, r5, [sp, #124]	@ 0x7c
  if (HAL_ADC_Init(&hadc3) != HAL_OK)
 8011bf6:	f001 f951 	bl	8012e9c <HAL_ADC_Init>
 8011bfa:	4603      	mov	r3, r0
 8011bfc:	b108      	cbz	r0, 8011c02 <main+0xcc6>
 8011bfe:	b672      	cpsid	i
  while (1)
 8011c00:	e7fe      	b.n	8011c00 <main+0xcc4>
  sConfig.Channel = ADC_CHANNEL_4;
 8011c02:	2204      	movs	r2, #4
  if (HAL_ADC_ConfigChannel(&hadc3, &sConfig) != HAL_OK)
 8011c04:	4620      	mov	r0, r4
 8011c06:	a91d      	add	r1, sp, #116	@ 0x74
  sConfig.SamplingTime = ADC_SAMPLETIME_3CYCLES;
 8011c08:	931f      	str	r3, [sp, #124]	@ 0x7c
  sConfig.Channel = ADC_CHANNEL_4;
 8011c0a:	e9cd 261d 	strd	r2, r6, [sp, #116]	@ 0x74
  if (HAL_ADC_ConfigChannel(&hadc3, &sConfig) != HAL_OK)
 8011c0e:	f001 f9f3 	bl	8012ff8 <HAL_ADC_ConfigChannel>
 8011c12:	4604      	mov	r4, r0
 8011c14:	b108      	cbz	r0, 8011c1a <main+0xcde>
 8011c16:	b672      	cpsid	i
  while (1)
 8011c18:	e7fe      	b.n	8011c18 <main+0xcdc>
  MX_X_CUBE_AI_Init();
 8011c1a:	f00e fb8f 	bl	802033c <MX_X_CUBE_AI_Init>
  osKernelInitialize();
 8011c1e:	f00b fdbd 	bl	801d79c <osKernelInitialize>
  defaultTaskHandle = osThreadNew(StartDefaultTask, NULL, &defaultTask_attributes);
 8011c22:	4a0c      	ldr	r2, [pc, #48]	@ (8011c54 <main+0xd18>)
 8011c24:	4621      	mov	r1, r4
 8011c26:	480c      	ldr	r0, [pc, #48]	@ (8011c58 <main+0xd1c>)
 8011c28:	f00b fe22 	bl	801d870 <osThreadNew>
 8011c2c:	4b0b      	ldr	r3, [pc, #44]	@ (8011c5c <main+0xd20>)
 8011c2e:	6018      	str	r0, [r3, #0]
  osKernelStart();
 8011c30:	f00b fde2 	bl	801d7f8 <osKernelStart>
  while (1)
 8011c34:	e7fe      	b.n	8011c34 <main+0xcf8>
 8011c36:	bf00      	nop
 8011c38:	200022e4 	.word	0x200022e4
 8011c3c:	40011000 	.word	0x40011000
 8011c40:	2000225c 	.word	0x2000225c
 8011c44:	40011400 	.word	0x40011400
 8011c48:	20002af0 	.word	0x20002af0
 8011c4c:	40012200 	.word	0x40012200
 8011c50:	0f000001 	.word	0x0f000001
 8011c54:	08034bec 	.word	0x08034bec
 8011c58:	08011cdd 	.word	0x08011cdd
 8011c5c:	20002224 	.word	0x20002224

08011c60 <chek_all_i2c>:
{
 8011c60:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for (int i=0;i<backit_len; i++) {
 8011c64:	4e19      	ldr	r6, [pc, #100]	@ (8011ccc <chek_all_i2c+0x6c>)
{
 8011c66:	b087      	sub	sp, #28
	for (int i=0;i<backit_len; i++) {
 8011c68:	6833      	ldr	r3, [r6, #0]
 8011c6a:	b323      	cbz	r3, 8011cb6 <chek_all_i2c+0x56>
 8011c6c:	4f18      	ldr	r7, [pc, #96]	@ (8011cd0 <chek_all_i2c+0x70>)
 8011c6e:	2400      	movs	r4, #0
 8011c70:	f10d 0b17 	add.w	fp, sp, #23
    return HAL_I2C_Mem_Read(&hi2c1, Address, Reg, I2C_MEMADD_SIZE_16BIT, pData, Length, 1000);
 8011c74:	f44f 797a 	mov.w	r9, #1000	@ 0x3e8
 8011c78:	f107 0a02 	add.w	sl, r7, #2
 8011c7c:	f8df 8058 	ldr.w	r8, [pc, #88]	@ 8011cd8 <chek_all_i2c+0x78>
			error_count++;
 8011c80:	4d14      	ldr	r5, [pc, #80]	@ (8011cd4 <chek_all_i2c+0x74>)
    return HAL_I2C_Mem_Read(&hi2c1, Address, Reg, I2C_MEMADD_SIZE_16BIT, pData, Length, 1000);
 8011c82:	f04f 0c01 	mov.w	ip, #1
 8011c86:	f837 2024 	ldrh.w	r2, [r7, r4, lsl #2]
 8011c8a:	2302      	movs	r3, #2
 8011c8c:	2178      	movs	r1, #120	@ 0x78
 8011c8e:	4640      	mov	r0, r8
 8011c90:	f8cd b000 	str.w	fp, [sp]
 8011c94:	e9cd c901 	strd	ip, r9, [sp, #4]
 8011c98:	f003 ff5c 	bl	8015b54 <HAL_I2C_Mem_Read>
		if (rx_data != (uint8_t) backit[i][1]) {
 8011c9c:	f81a 3024 	ldrb.w	r3, [sl, r4, lsl #2]
 8011ca0:	f89d 2017 	ldrb.w	r2, [sp, #23]
 8011ca4:	429a      	cmp	r2, r3
 8011ca6:	d009      	beq.n	8011cbc <chek_all_i2c+0x5c>
			error_count++;
 8011ca8:	682b      	ldr	r3, [r5, #0]
	for (int i=0;i<backit_len; i++) {
 8011caa:	3401      	adds	r4, #1
 8011cac:	6832      	ldr	r2, [r6, #0]
			error_count++;
 8011cae:	3301      	adds	r3, #1
	for (int i=0;i<backit_len; i++) {
 8011cb0:	42a2      	cmp	r2, r4
			error_count++;
 8011cb2:	602b      	str	r3, [r5, #0]
	for (int i=0;i<backit_len; i++) {
 8011cb4:	d8e5      	bhi.n	8011c82 <chek_all_i2c+0x22>
}
 8011cb6:	b007      	add	sp, #28
 8011cb8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	for (int i=0;i<backit_len; i++) {
 8011cbc:	3401      	adds	r4, #1
 8011cbe:	6833      	ldr	r3, [r6, #0]
 8011cc0:	42a3      	cmp	r3, r4
 8011cc2:	d8de      	bhi.n	8011c82 <chek_all_i2c+0x22>
}
 8011cc4:	b007      	add	sp, #28
 8011cc6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8011cca:	bf00      	nop
 8011ccc:	200021c8 	.word	0x200021c8
 8011cd0:	200011c8 	.word	0x200011c8
 8011cd4:	200011c4 	.word	0x200011c4
 8011cd8:	200028d8 	.word	0x200028d8

08011cdc <StartDefaultTask>:
{
 8011cdc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8011ce0:	b083      	sub	sp, #12
 8011ce2:	4c5f      	ldr	r4, [pc, #380]	@ (8011e60 <StartDefaultTask+0x184>)
  MX_USB_DEVICE_Init();
 8011ce4:	f00e f83a 	bl	801fd5c <MX_USB_DEVICE_Init>
  HAL_Delay(1000);
 8011ce8:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 8011cec:	f001 f8c4 	bl	8012e78 <HAL_Delay>
			  *(sdrambuffer + i * width + j) = 0x00;
 8011cf0:	4b5c      	ldr	r3, [pc, #368]	@ (8011e64 <StartDefaultTask+0x188>)
	  for(int i =0 ; i < 1000; i++)
 8011cf2:	2100      	movs	r1, #0
			  *(sdrambuffer + i * width + j) = 0x00;
 8011cf4:	681d      	ldr	r5, [r3, #0]
 8011cf6:	4608      	mov	r0, r1
		  for(int j =0; j <1000; j++)
 8011cf8:	2300      	movs	r3, #0
			  *(sdrambuffer + i * width + j) = 0x00;
 8011cfa:	6822      	ldr	r2, [r4, #0]
 8011cfc:	fb02 3201 	mla	r2, r2, r1, r3
		  for(int j =0; j <1000; j++)
 8011d00:	3301      	adds	r3, #1
 8011d02:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
			  *(sdrambuffer + i * width + j) = 0x00;
 8011d06:	f845 0022 	str.w	r0, [r5, r2, lsl #2]
		  for(int j =0; j <1000; j++)
 8011d0a:	d1f6      	bne.n	8011cfa <StartDefaultTask+0x1e>
	  for(int i =0 ; i < 1000; i++)
 8011d0c:	3101      	adds	r1, #1
 8011d0e:	f5b1 7f7a 	cmp.w	r1, #1000	@ 0x3e8
 8011d12:	d1f1      	bne.n	8011cf8 <StartDefaultTask+0x1c>
	  osDelay(1);
 8011d14:	2001      	movs	r0, #1
ov5640_io.Init = OV5640_I2C_Init;
 8011d16:	4d54      	ldr	r5, [pc, #336]	@ (8011e68 <StartDefaultTask+0x18c>)
	  osDelay(1);
 8011d18:	f00b fdfa 	bl	801d910 <osDelay>
	  HAL_Delay(2000);
 8011d1c:	f44f 60fa 	mov.w	r0, #2000	@ 0x7d0
 8011d20:	f001 f8aa 	bl	8012e78 <HAL_Delay>
HAL_Delay(3);     /* POWER_DOWN de-asserted during 3ms */
 8011d24:	2003      	movs	r0, #3
 8011d26:	f001 f8a7 	bl	8012e78 <HAL_Delay>
ov5640_io.Init = OV5640_I2C_Init;
 8011d2a:	4950      	ldr	r1, [pc, #320]	@ (8011e6c <StartDefaultTask+0x190>)
ov5640_io.DeInit = OV5640_I2C_DeInit;
 8011d2c:	4b50      	ldr	r3, [pc, #320]	@ (8011e70 <StartDefaultTask+0x194>)
ov5640_io.Address = 0x78;
 8011d2e:	2278      	movs	r2, #120	@ 0x78
HAL_LTDC_SetAddress(&hltdc, FRAME_BUFFER_B,0);
 8011d30:	4850      	ldr	r0, [pc, #320]	@ (8011e74 <StartDefaultTask+0x198>)
ov5640_io.Address = 0x78;
 8011d32:	812a      	strh	r2, [r5, #8]
HAL_LTDC_SetAddress(&hltdc, FRAME_BUFFER_B,0);
 8011d34:	2200      	movs	r2, #0
HAL_DCMI_Start_DMA(&hdcmi, DCMI_MODE_CONTINUOUS, FRAME_BUFFER_A, width*height/2);
 8011d36:	4f50      	ldr	r7, [pc, #320]	@ (8011e78 <StartDefaultTask+0x19c>)
		  HAL_LTDC_SetAddress(&hltdc, FRAME_BUFFER_B,0);
 8011d38:	f8df 814c 	ldr.w	r8, [pc, #332]	@ 8011e88 <StartDefaultTask+0x1ac>
ov5640_io.DeInit = OV5640_I2C_DeInit;
 8011d3c:	e9c5 1300 	strd	r1, r3, [r5]
ov5640_io.WriteReg = OV5640_I2C_WriteReg;
 8011d40:	4b4e      	ldr	r3, [pc, #312]	@ (8011e7c <StartDefaultTask+0x1a0>)
ov5640_io.ReadReg = OV5640_I2C_ReadReg;
 8011d42:	494f      	ldr	r1, [pc, #316]	@ (8011e80 <StartDefaultTask+0x1a4>)
ov5640_io.WriteReg = OV5640_I2C_WriteReg;
 8011d44:	60eb      	str	r3, [r5, #12]
ov5640_io.GetTick = OV5640_GetTick;
 8011d46:	4b4f      	ldr	r3, [pc, #316]	@ (8011e84 <StartDefaultTask+0x1a8>)
 8011d48:	e9c5 1304 	strd	r1, r3, [r5, #16]
HAL_LTDC_SetAddress(&hltdc, FRAME_BUFFER_B,0);
 8011d4c:	494e      	ldr	r1, [pc, #312]	@ (8011e88 <StartDefaultTask+0x1ac>)
 8011d4e:	f004 fa01 	bl	8016154 <HAL_LTDC_SetAddress>
OV5640_RegisterBusIO(&ov5640,&ov5640_io);
 8011d52:	4629      	mov	r1, r5
 8011d54:	484d      	ldr	r0, [pc, #308]	@ (8011e8c <StartDefaultTask+0x1b0>)
 8011d56:	f00e ffcb 	bl	8020cf0 <OV5640_RegisterBusIO>
OV5640_Init(&ov5640,OV5640_R480x272,OV5640_RGB565);
 8011d5a:	2200      	movs	r2, #0
 8011d5c:	2102      	movs	r1, #2
 8011d5e:	484b      	ldr	r0, [pc, #300]	@ (8011e8c <StartDefaultTask+0x1b0>)
 8011d60:	f00e ff22 	bl	8020ba8 <OV5640_Init>
	  if(HAL_GPIO_ReadPin(USER_GPIO_Port, USER_Pin) == 1)
 8011d64:	4d4a      	ldr	r5, [pc, #296]	@ (8011e90 <StartDefaultTask+0x1b4>)
chek_all_i2c ();
 8011d66:	f7ff ff7b 	bl	8011c60 <chek_all_i2c>
OV5640_SetPCLK(&ov5640, OV5640_PCLK_12M);
 8011d6a:	2104      	movs	r1, #4
 8011d6c:	4847      	ldr	r0, [pc, #284]	@ (8011e8c <StartDefaultTask+0x1b0>)
 8011d6e:	f00e ffe1 	bl	8020d34 <OV5640_SetPCLK>
HAL_DCMI_Start_DMA(&hdcmi, DCMI_MODE_CONTINUOUS, FRAME_BUFFER_A, width*height/2);
 8011d72:	6839      	ldr	r1, [r7, #0]
 8011d74:	6823      	ldr	r3, [r4, #0]
 8011d76:	f04f 4240 	mov.w	r2, #3221225472	@ 0xc0000000
 8011d7a:	4846      	ldr	r0, [pc, #280]	@ (8011e94 <StartDefaultTask+0x1b8>)
 8011d7c:	fb01 f303 	mul.w	r3, r1, r3
 8011d80:	2100      	movs	r1, #0
 8011d82:	085b      	lsrs	r3, r3, #1
 8011d84:	f001 fb5a 	bl	801343c <HAL_DCMI_Start_DMA>
HAL_DMA_Abort_IT(&hdma_dcmi);
 8011d88:	4843      	ldr	r0, [pc, #268]	@ (8011e98 <StartDefaultTask+0x1bc>)
 8011d8a:	f001 fd81 	bl	8013890 <HAL_DMA_Abort_IT>
hdma_dcmi.XferCpltCallback = XferCpltCallback;
 8011d8e:	4a42      	ldr	r2, [pc, #264]	@ (8011e98 <StartDefaultTask+0x1bc>)
 8011d90:	4b42      	ldr	r3, [pc, #264]	@ (8011e9c <StartDefaultTask+0x1c0>)
HAL_DMAEx_MultiBufferStart_IT(&hdma_dcmi, (uint32_t)&DCMI->DR, FRAME_BUFFER_A, FRAME_BUFFER_B, width * height/2);
 8011d92:	4943      	ldr	r1, [pc, #268]	@ (8011ea0 <StartDefaultTask+0x1c4>)
hdma_dcmi.XferCpltCallback = XferCpltCallback;
 8011d94:	63d3      	str	r3, [r2, #60]	@ 0x3c
hdma_dcmi.XferM1CpltCallback = XferM1CpltCallback;
 8011d96:	4b43      	ldr	r3, [pc, #268]	@ (8011ea4 <StartDefaultTask+0x1c8>)
HAL_DMAEx_MultiBufferStart_IT(&hdma_dcmi, (uint32_t)&DCMI->DR, FRAME_BUFFER_A, FRAME_BUFFER_B, width * height/2);
 8011d98:	483f      	ldr	r0, [pc, #252]	@ (8011e98 <StartDefaultTask+0x1bc>)
hdma_dcmi.XferM1CpltCallback = XferM1CpltCallback;
 8011d9a:	6453      	str	r3, [r2, #68]	@ 0x44
HAL_DMAEx_MultiBufferStart_IT(&hdma_dcmi, (uint32_t)&DCMI->DR, FRAME_BUFFER_A, FRAME_BUFFER_B, width * height/2);
 8011d9c:	683a      	ldr	r2, [r7, #0]
 8011d9e:	6823      	ldr	r3, [r4, #0]
 8011da0:	fb02 f303 	mul.w	r3, r2, r3
 8011da4:	f04f 4240 	mov.w	r2, #3221225472	@ 0xc0000000
 8011da8:	085b      	lsrs	r3, r3, #1
 8011daa:	9300      	str	r3, [sp, #0]
 8011dac:	4b36      	ldr	r3, [pc, #216]	@ (8011e88 <StartDefaultTask+0x1ac>)
 8011dae:	f001 ff75 	bl	8013c9c <HAL_DMAEx_MultiBufferStart_IT>
OV5640_Start(&ov5640);
 8011db2:	4836      	ldr	r0, [pc, #216]	@ (8011e8c <StartDefaultTask+0x1b0>)
 8011db4:	f00f f818 	bl	8020de8 <OV5640_Start>
	  if(HAL_GPIO_ReadPin(USER_GPIO_Port, USER_Pin) == 1)
 8011db8:	f44f 6100 	mov.w	r1, #2048	@ 0x800
 8011dbc:	4628      	mov	r0, r5
 8011dbe:	f003 fa97 	bl	80152f0 <HAL_GPIO_ReadPin>
 8011dc2:	2801      	cmp	r0, #1
 8011dc4:	d1f8      	bne.n	8011db8 <StartDefaultTask+0xdc>
		  HAL_Delay(1000);
 8011dc6:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
		  uint32_t offset = 0;
 8011dca:	f04f 0a00 	mov.w	sl, #0
		  HAL_Delay(1000);
 8011dce:	f001 f853 	bl	8012e78 <HAL_Delay>
		  HAL_DMA_Abort(&hdma_dcmi);
 8011dd2:	4831      	ldr	r0, [pc, #196]	@ (8011e98 <StartDefaultTask+0x1bc>)
 8011dd4:	f04f 4b40 	mov.w	fp, #3221225472	@ 0xc0000000
 8011dd8:	f001 fd10 	bl	80137fc <HAL_DMA_Abort>
		      if (CDC_Transmit_FS((uint8_t*)(SDRAM_START_ADDR + offset), chunk_size) == USBD_OK)
 8011ddc:	f44f 7100 	mov.w	r1, #512	@ 0x200
 8011de0:	4658      	mov	r0, fp
 8011de2:	f00e f81d 	bl	801fe20 <CDC_Transmit_FS>
 8011de6:	4681      	mov	r9, r0
		          HAL_Delay(10);
 8011de8:	200a      	movs	r0, #10
		      if (CDC_Transmit_FS((uint8_t*)(SDRAM_START_ADDR + offset), chunk_size) == USBD_OK)
 8011dea:	f1b9 0f00 	cmp.w	r9, #0
 8011dee:	d133      	bne.n	8011e58 <StartDefaultTask+0x17c>
		          offset += chunk_size;
 8011df0:	f50a 7a00 	add.w	sl, sl, #512	@ 0x200
		          HAL_Delay(10);
 8011df4:	f001 f840 	bl	8012e78 <HAL_Delay>
		  while (offset < IMAGE_SIZE)
 8011df8:	f5ba 3f7f 	cmp.w	sl, #261120	@ 0x3fc00
 8011dfc:	f10a 4b40 	add.w	fp, sl, #3221225472	@ 0xc0000000
 8011e00:	d3ec      	bcc.n	8011ddc <StartDefaultTask+0x100>
		  HAL_Delay(1000);
 8011e02:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 8011e06:	f001 f837 	bl	8012e78 <HAL_Delay>
		  HAL_LTDC_SetAddress(&hltdc, FRAME_BUFFER_B,0);
 8011e0a:	464a      	mov	r2, r9
 8011e0c:	4641      	mov	r1, r8
 8011e0e:	4819      	ldr	r0, [pc, #100]	@ (8011e74 <StartDefaultTask+0x198>)
 8011e10:	f004 f9a0 	bl	8016154 <HAL_LTDC_SetAddress>
		  HAL_DCMI_Start_DMA(&hdcmi, DCMI_MODE_CONTINUOUS, FRAME_BUFFER_A, width*height/2);
 8011e14:	683e      	ldr	r6, [r7, #0]
 8011e16:	6823      	ldr	r3, [r4, #0]
 8011e18:	4649      	mov	r1, r9
 8011e1a:	f04f 4240 	mov.w	r2, #3221225472	@ 0xc0000000
 8011e1e:	481d      	ldr	r0, [pc, #116]	@ (8011e94 <StartDefaultTask+0x1b8>)
 8011e20:	fb06 f303 	mul.w	r3, r6, r3
 8011e24:	085b      	lsrs	r3, r3, #1
 8011e26:	f001 fb09 	bl	801343c <HAL_DCMI_Start_DMA>
		  HAL_DMA_Abort_IT(&hdma_dcmi);
 8011e2a:	481b      	ldr	r0, [pc, #108]	@ (8011e98 <StartDefaultTask+0x1bc>)
 8011e2c:	f001 fd30 	bl	8013890 <HAL_DMA_Abort_IT>
		  HAL_DMAEx_MultiBufferStart_IT(&hdma_dcmi, (uint32_t)&DCMI->DR, FRAME_BUFFER_A, FRAME_BUFFER_B, width * height/2);
 8011e30:	6820      	ldr	r0, [r4, #0]
 8011e32:	683e      	ldr	r6, [r7, #0]
 8011e34:	4643      	mov	r3, r8
 8011e36:	f04f 4240 	mov.w	r2, #3221225472	@ 0xc0000000
 8011e3a:	4919      	ldr	r1, [pc, #100]	@ (8011ea0 <StartDefaultTask+0x1c4>)
 8011e3c:	fb06 fc00 	mul.w	ip, r6, r0
		  hdma_dcmi.XferCpltCallback = XferCpltCallback;
 8011e40:	4815      	ldr	r0, [pc, #84]	@ (8011e98 <StartDefaultTask+0x1bc>)
 8011e42:	4e16      	ldr	r6, [pc, #88]	@ (8011e9c <StartDefaultTask+0x1c0>)
 8011e44:	63c6      	str	r6, [r0, #60]	@ 0x3c
		  hdma_dcmi.XferM1CpltCallback = XferM1CpltCallback;
 8011e46:	4e17      	ldr	r6, [pc, #92]	@ (8011ea4 <StartDefaultTask+0x1c8>)
 8011e48:	6446      	str	r6, [r0, #68]	@ 0x44
		  HAL_DMAEx_MultiBufferStart_IT(&hdma_dcmi, (uint32_t)&DCMI->DR, FRAME_BUFFER_A, FRAME_BUFFER_B, width * height/2);
 8011e4a:	ea4f 005c 	mov.w	r0, ip, lsr #1
 8011e4e:	9000      	str	r0, [sp, #0]
 8011e50:	4811      	ldr	r0, [pc, #68]	@ (8011e98 <StartDefaultTask+0x1bc>)
 8011e52:	f001 ff23 	bl	8013c9c <HAL_DMAEx_MultiBufferStart_IT>
 8011e56:	e7af      	b.n	8011db8 <StartDefaultTask+0xdc>
		          HAL_Delay(10);
 8011e58:	200a      	movs	r0, #10
 8011e5a:	f001 f80d 	bl	8012e78 <HAL_Delay>
		  while (offset < IMAGE_SIZE)
 8011e5e:	e7bd      	b.n	8011ddc <StartDefaultTask+0x100>
 8011e60:	20000008 	.word	0x20000008
 8011e64:	20000000 	.word	0x20000000
 8011e68:	200021e0 	.word	0x200021e0
 8011e6c:	08010d15 	.word	0x08010d15
 8011e70:	08010e31 	.word	0x08010e31
 8011e74:	200027dc 	.word	0x200027dc
 8011e78:	20000004 	.word	0x20000004
 8011e7c:	08010da1 	.word	0x08010da1
 8011e80:	08010e09 	.word	0x08010e09
 8011e84:	08010e2d 	.word	0x08010e2d
 8011e88:	c003fc00 	.word	0xc003fc00
 8011e8c:	200021f8 	.word	0x200021f8
 8011e90:	40022000 	.word	0x40022000
 8011e94:	20002a7c 	.word	0x20002a7c
 8011e98:	20002a1c 	.word	0x20002a1c
 8011e9c:	08010d19 	.word	0x08010d19
 8011ea0:	50050028 	.word	0x50050028
 8011ea4:	08010d5d 	.word	0x08010d5d

08011ea8 <HAL_DCMI_VsyncEventCallback>:
}
 8011ea8:	4770      	bx	lr
 8011eaa:	bf00      	nop

08011eac <HAL_TIM_PeriodElapsedCallback>:
  if (htim->Instance == TIM6) {
 8011eac:	4b03      	ldr	r3, [pc, #12]	@ (8011ebc <HAL_TIM_PeriodElapsedCallback+0x10>)
 8011eae:	6802      	ldr	r2, [r0, #0]
 8011eb0:	429a      	cmp	r2, r3
 8011eb2:	d000      	beq.n	8011eb6 <HAL_TIM_PeriodElapsedCallback+0xa>
}
 8011eb4:	4770      	bx	lr
    HAL_IncTick();
 8011eb6:	f000 bfcd 	b.w	8012e54 <HAL_IncTick>
 8011eba:	bf00      	nop
 8011ebc:	40001000 	.word	0x40001000

08011ec0 <Error_Handler>:
 8011ec0:	b672      	cpsid	i
  while (1)
 8011ec2:	e7fe      	b.n	8011ec2 <Error_Handler+0x2>

08011ec4 <HAL_MspInit>:

  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_PWR_CLK_ENABLE();
 8011ec4:	4b0e      	ldr	r3, [pc, #56]	@ (8011f00 <HAL_MspInit+0x3c>)
  __HAL_RCC_SYSCFG_CLK_ENABLE();

  /* System interrupt init*/
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
 8011ec6:	2200      	movs	r2, #0
 8011ec8:	210f      	movs	r1, #15
 8011eca:	f06f 0001 	mvn.w	r0, #1
{
 8011ece:	b410      	push	{r4}
  __HAL_RCC_PWR_CLK_ENABLE();
 8011ed0:	6c1c      	ldr	r4, [r3, #64]	@ 0x40
{
 8011ed2:	b083      	sub	sp, #12
  __HAL_RCC_PWR_CLK_ENABLE();
 8011ed4:	f044 5480 	orr.w	r4, r4, #268435456	@ 0x10000000
 8011ed8:	641c      	str	r4, [r3, #64]	@ 0x40
 8011eda:	6c1c      	ldr	r4, [r3, #64]	@ 0x40
 8011edc:	f004 5480 	and.w	r4, r4, #268435456	@ 0x10000000
 8011ee0:	9400      	str	r4, [sp, #0]
 8011ee2:	9c00      	ldr	r4, [sp, #0]
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8011ee4:	6c5c      	ldr	r4, [r3, #68]	@ 0x44
 8011ee6:	f444 4480 	orr.w	r4, r4, #16384	@ 0x4000
 8011eea:	645c      	str	r4, [r3, #68]	@ 0x44
 8011eec:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8011eee:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 8011ef2:	9301      	str	r3, [sp, #4]
 8011ef4:	9b01      	ldr	r3, [sp, #4]

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8011ef6:	b003      	add	sp, #12
 8011ef8:	f85d 4b04 	ldr.w	r4, [sp], #4
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
 8011efc:	f001 b94c 	b.w	8013198 <HAL_NVIC_SetPriority>
 8011f00:	40023800 	.word	0x40023800

08011f04 <HAL_ADC_MspInit>:
* @retval None
*/
void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(hadc->Instance==ADC3)
 8011f04:	4b1f      	ldr	r3, [pc, #124]	@ (8011f84 <HAL_ADC_MspInit+0x80>)
 8011f06:	6802      	ldr	r2, [r0, #0]
{
 8011f08:	b510      	push	{r4, lr}
  if(hadc->Instance==ADC3)
 8011f0a:	429a      	cmp	r2, r3
{
 8011f0c:	b08a      	sub	sp, #40	@ 0x28
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8011f0e:	f04f 0400 	mov.w	r4, #0
 8011f12:	e9cd 4404 	strd	r4, r4, [sp, #16]
 8011f16:	e9cd 4406 	strd	r4, r4, [sp, #24]
 8011f1a:	9408      	str	r4, [sp, #32]
  if(hadc->Instance==ADC3)
 8011f1c:	d001      	beq.n	8011f22 <HAL_ADC_MspInit+0x1e>

  /* USER CODE END ADC3_MspInit 1 */

  }

}
 8011f1e:	b00a      	add	sp, #40	@ 0x28
 8011f20:	bd10      	pop	{r4, pc}
    __HAL_RCC_ADC3_CLK_ENABLE();
 8011f22:	f503 338b 	add.w	r3, r3, #71168	@ 0x11600
    HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 8011f26:	a904      	add	r1, sp, #16
    __HAL_RCC_ADC3_CLK_ENABLE();
 8011f28:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 8011f2a:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
 8011f2e:	645a      	str	r2, [r3, #68]	@ 0x44
 8011f30:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 8011f32:	f402 6280 	and.w	r2, r2, #1024	@ 0x400
 8011f36:	9201      	str	r2, [sp, #4]
 8011f38:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOF_CLK_ENABLE();
 8011f3a:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8011f3c:	f042 0220 	orr.w	r2, r2, #32
 8011f40:	631a      	str	r2, [r3, #48]	@ 0x30
 8011f42:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8011f44:	f002 0220 	and.w	r2, r2, #32
 8011f48:	9202      	str	r2, [sp, #8]
 8011f4a:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8011f4c:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8011f4e:	f042 0201 	orr.w	r2, r2, #1
 8011f52:	631a      	str	r2, [r3, #48]	@ 0x30
    GPIO_InitStruct.Pin = ARDUINO_A4_Pin|ARDUINO_A5_Pin|ARDUINO_A1_Pin|ARDUINO_A2_Pin
 8011f54:	f44f 62f8 	mov.w	r2, #1984	@ 0x7c0
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8011f58:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8011f5a:	f003 0301 	and.w	r3, r3, #1
 8011f5e:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Pin = ARDUINO_A4_Pin|ARDUINO_A5_Pin|ARDUINO_A1_Pin|ARDUINO_A2_Pin
 8011f60:	2303      	movs	r3, #3
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8011f62:	9803      	ldr	r0, [sp, #12]
    HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 8011f64:	4808      	ldr	r0, [pc, #32]	@ (8011f88 <HAL_ADC_MspInit+0x84>)
    GPIO_InitStruct.Pin = ARDUINO_A4_Pin|ARDUINO_A5_Pin|ARDUINO_A1_Pin|ARDUINO_A2_Pin
 8011f66:	e9cd 2304 	strd	r2, r3, [sp, #16]
    HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 8011f6a:	f003 f887 	bl	801507c <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = ARDUINO_A0_Pin;
 8011f6e:	2201      	movs	r2, #1
 8011f70:	2303      	movs	r3, #3
    HAL_GPIO_Init(ARDUINO_A0_GPIO_Port, &GPIO_InitStruct);
 8011f72:	a904      	add	r1, sp, #16
 8011f74:	4805      	ldr	r0, [pc, #20]	@ (8011f8c <HAL_ADC_MspInit+0x88>)
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8011f76:	9406      	str	r4, [sp, #24]
    GPIO_InitStruct.Pin = ARDUINO_A0_Pin;
 8011f78:	e9cd 2304 	strd	r2, r3, [sp, #16]
    HAL_GPIO_Init(ARDUINO_A0_GPIO_Port, &GPIO_InitStruct);
 8011f7c:	f003 f87e 	bl	801507c <HAL_GPIO_Init>
}
 8011f80:	b00a      	add	sp, #40	@ 0x28
 8011f82:	bd10      	pop	{r4, pc}
 8011f84:	40012200 	.word	0x40012200
 8011f88:	40021400 	.word	0x40021400
 8011f8c:	40020000 	.word	0x40020000

08011f90 <HAL_CRC_MspInit>:
* @param hcrc: CRC handle pointer
* @retval None
*/
void HAL_CRC_MspInit(CRC_HandleTypeDef* hcrc)
{
  if(hcrc->Instance==CRC)
 8011f90:	4b09      	ldr	r3, [pc, #36]	@ (8011fb8 <HAL_CRC_MspInit+0x28>)
 8011f92:	6802      	ldr	r2, [r0, #0]
 8011f94:	429a      	cmp	r2, r3
 8011f96:	d000      	beq.n	8011f9a <HAL_CRC_MspInit+0xa>
 8011f98:	4770      	bx	lr
  {
  /* USER CODE BEGIN CRC_MspInit 0 */

  /* USER CODE END CRC_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_CRC_CLK_ENABLE();
 8011f9a:	f8d3 2830 	ldr.w	r2, [r3, #2096]	@ 0x830
 8011f9e:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
{
 8011fa2:	b082      	sub	sp, #8
    __HAL_RCC_CRC_CLK_ENABLE();
 8011fa4:	f442 5280 	orr.w	r2, r2, #4096	@ 0x1000
 8011fa8:	631a      	str	r2, [r3, #48]	@ 0x30
 8011faa:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8011fac:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
 8011fb0:	9301      	str	r3, [sp, #4]
 8011fb2:	9b01      	ldr	r3, [sp, #4]

  /* USER CODE END CRC_MspInit 1 */

  }

}
 8011fb4:	b002      	add	sp, #8
 8011fb6:	4770      	bx	lr
 8011fb8:	40023000 	.word	0x40023000

08011fbc <HAL_DCMI_MspInit>:
* @retval None
*/
void HAL_DCMI_MspInit(DCMI_HandleTypeDef* hdcmi)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(hdcmi->Instance==DCMI)
 8011fbc:	4b56      	ldr	r3, [pc, #344]	@ (8012118 <HAL_DCMI_MspInit+0x15c>)
 8011fbe:	6802      	ldr	r2, [r0, #0]
{
 8011fc0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if(hdcmi->Instance==DCMI)
 8011fc4:	429a      	cmp	r2, r3
{
 8011fc6:	b08c      	sub	sp, #48	@ 0x30
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8011fc8:	f04f 0400 	mov.w	r4, #0
 8011fcc:	e9cd 4406 	strd	r4, r4, [sp, #24]
 8011fd0:	9408      	str	r4, [sp, #32]
 8011fd2:	e9cd 4409 	strd	r4, r4, [sp, #36]	@ 0x24
  if(hdcmi->Instance==DCMI)
 8011fd6:	d002      	beq.n	8011fde <HAL_DCMI_MspInit+0x22>

  /* USER CODE END DCMI_MspInit 1 */

  }

}
 8011fd8:	b00c      	add	sp, #48	@ 0x30
 8011fda:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    __HAL_RCC_DCMI_CLK_ENABLE();
 8011fde:	4b4f      	ldr	r3, [pc, #316]	@ (801211c <HAL_DCMI_MspInit+0x160>)
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8011fe0:	2703      	movs	r7, #3
 8011fe2:	260d      	movs	r6, #13
 8011fe4:	4605      	mov	r5, r0
    __HAL_RCC_DCMI_CLK_ENABLE();
 8011fe6:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
    GPIO_InitStruct.Pin = DCMI_D5_Pin;
 8011fe8:	f04f 0802 	mov.w	r8, #2
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8011fec:	484c      	ldr	r0, [pc, #304]	@ (8012120 <HAL_DCMI_MspInit+0x164>)
    __HAL_RCC_DCMI_CLK_ENABLE();
 8011fee:	f042 0201 	orr.w	r2, r2, #1
 8011ff2:	635a      	str	r2, [r3, #52]	@ 0x34
 8011ff4:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8011ff6:	f002 0201 	and.w	r2, r2, #1
 8011ffa:	9200      	str	r2, [sp, #0]
 8011ffc:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8011ffe:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8012000:	f042 0210 	orr.w	r2, r2, #16
 8012004:	631a      	str	r2, [r3, #48]	@ 0x30
 8012006:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8012008:	f002 0210 	and.w	r2, r2, #16
 801200c:	9201      	str	r2, [sp, #4]
 801200e:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8012010:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8012012:	f042 0208 	orr.w	r2, r2, #8
 8012016:	631a      	str	r2, [r3, #48]	@ 0x30
 8012018:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 801201a:	f002 0208 	and.w	r2, r2, #8
 801201e:	9202      	str	r2, [sp, #8]
 8012020:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOG_CLK_ENABLE();
 8012022:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8012024:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 8012028:	631a      	str	r2, [r3, #48]	@ 0x30
 801202a:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 801202c:	f002 0240 	and.w	r2, r2, #64	@ 0x40
 8012030:	9203      	str	r2, [sp, #12]
 8012032:	9a03      	ldr	r2, [sp, #12]
    __HAL_RCC_GPIOH_CLK_ENABLE();
 8012034:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8012036:	f042 0280 	orr.w	r2, r2, #128	@ 0x80
 801203a:	631a      	str	r2, [r3, #48]	@ 0x30
 801203c:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 801203e:	f002 0280 	and.w	r2, r2, #128	@ 0x80
 8012042:	9204      	str	r2, [sp, #16]
 8012044:	9a04      	ldr	r2, [sp, #16]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8012046:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8012048:	f042 0201 	orr.w	r2, r2, #1
 801204c:	631a      	str	r2, [r3, #48]	@ 0x30
    GPIO_InitStruct.Pin = DCMI_D6_Pin|DCMI_D7_Pin;
 801204e:	2260      	movs	r2, #96	@ 0x60
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8012050:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8012052:	f003 0301 	and.w	r3, r3, #1
 8012056:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Pin = DCMI_D6_Pin|DCMI_D7_Pin;
 8012058:	2302      	movs	r3, #2
    __HAL_RCC_GPIOA_CLK_ENABLE();
 801205a:	9905      	ldr	r1, [sp, #20]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 801205c:	a906      	add	r1, sp, #24
    GPIO_InitStruct.Pin = DCMI_D6_Pin|DCMI_D7_Pin;
 801205e:	e9cd 2306 	strd	r2, r3, [sp, #24]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8012062:	e9cd 7609 	strd	r7, r6, [sp, #36]	@ 0x24
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8012066:	f003 f809 	bl	801507c <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = DCMI_D5_Pin;
 801206a:	2308      	movs	r3, #8
    HAL_GPIO_Init(DCMI_D5_GPIO_Port, &GPIO_InitStruct);
 801206c:	a906      	add	r1, sp, #24
 801206e:	482d      	ldr	r0, [pc, #180]	@ (8012124 <HAL_DCMI_MspInit+0x168>)
    GPIO_InitStruct.Alternate = GPIO_AF13_DCMI;
 8012070:	960a      	str	r6, [sp, #40]	@ 0x28
    GPIO_InitStruct.Pin = DCMI_D5_Pin;
 8012072:	e9cd 3806 	strd	r3, r8, [sp, #24]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8012076:	e9cd 4708 	strd	r4, r7, [sp, #32]
    HAL_GPIO_Init(DCMI_D5_GPIO_Port, &GPIO_InitStruct);
 801207a:	f002 ffff 	bl	801507c <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = DCMI_VSYNC_Pin;
 801207e:	f44f 7300 	mov.w	r3, #512	@ 0x200
    HAL_GPIO_Init(DCMI_VSYNC_GPIO_Port, &GPIO_InitStruct);
 8012082:	a906      	add	r1, sp, #24
 8012084:	4828      	ldr	r0, [pc, #160]	@ (8012128 <HAL_DCMI_MspInit+0x16c>)
    GPIO_InitStruct.Pin = DCMI_VSYNC_Pin;
 8012086:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF13_DCMI;
 8012088:	e9cd 7609 	strd	r7, r6, [sp, #36]	@ 0x24
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 801208c:	e9cd 8407 	strd	r8, r4, [sp, #28]
    HAL_GPIO_Init(DCMI_VSYNC_GPIO_Port, &GPIO_InitStruct);
 8012090:	f002 fff4 	bl	801507c <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = DCMI_D4_Pin|DCMI_D3_Pin|DCMI_D0_Pin|DCMI_D2_Pin
 8012094:	f44f 43bc 	mov.w	r3, #24064	@ 0x5e00
    HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
 8012098:	a906      	add	r1, sp, #24
 801209a:	4824      	ldr	r0, [pc, #144]	@ (801212c <HAL_DCMI_MspInit+0x170>)
    GPIO_InitStruct.Pin = DCMI_D4_Pin|DCMI_D3_Pin|DCMI_D0_Pin|DCMI_D2_Pin
 801209c:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF13_DCMI;
 801209e:	e9cd 7609 	strd	r7, r6, [sp, #36]	@ 0x24
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80120a2:	e9cd 8407 	strd	r8, r4, [sp, #28]
    HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
 80120a6:	f002 ffe9 	bl	801507c <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = DCMI_HSYNC_Pin|GPIO_PIN_6;
 80120aa:	2350      	movs	r3, #80	@ 0x50
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80120ac:	4820      	ldr	r0, [pc, #128]	@ (8012130 <HAL_DCMI_MspInit+0x174>)
 80120ae:	a906      	add	r1, sp, #24
    GPIO_InitStruct.Alternate = GPIO_AF13_DCMI;
 80120b0:	960a      	str	r6, [sp, #40]	@ 0x28
    GPIO_InitStruct.Pin = DCMI_HSYNC_Pin|GPIO_PIN_6;
 80120b2:	9306      	str	r3, [sp, #24]
    hdma_dcmi.Instance = DMA2_Stream1;
 80120b4:	4e1f      	ldr	r6, [pc, #124]	@ (8012134 <HAL_DCMI_MspInit+0x178>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80120b6:	f8cd 801c 	str.w	r8, [sp, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80120ba:	e9cd 4708 	strd	r4, r7, [sp, #32]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80120be:	f002 ffdd 	bl	801507c <HAL_GPIO_Init>
    hdma_dcmi.Instance = DMA2_Stream1;
 80120c2:	4b1d      	ldr	r3, [pc, #116]	@ (8012138 <HAL_DCMI_MspInit+0x17c>)
    hdma_dcmi.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
 80120c4:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
    if (HAL_DMA_Init(&hdma_dcmi) != HAL_OK)
 80120c8:	4630      	mov	r0, r6
    hdma_dcmi.Instance = DMA2_Stream1;
 80120ca:	6033      	str	r3, [r6, #0]
    hdma_dcmi.Init.Channel = DMA_CHANNEL_1;
 80120cc:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
    hdma_dcmi.Init.Direction = DMA_PERIPH_TO_MEMORY;
 80120d0:	60b4      	str	r4, [r6, #8]
    hdma_dcmi.Init.Channel = DMA_CHANNEL_1;
 80120d2:	6073      	str	r3, [r6, #4]
    hdma_dcmi.Init.MemInc = DMA_MINC_ENABLE;
 80120d4:	f44f 6380 	mov.w	r3, #1024	@ 0x400
    hdma_dcmi.Init.PeriphInc = DMA_PINC_DISABLE;
 80120d8:	60f4      	str	r4, [r6, #12]
    hdma_dcmi.Init.MemInc = DMA_MINC_ENABLE;
 80120da:	6133      	str	r3, [r6, #16]
    hdma_dcmi.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 80120dc:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
    hdma_dcmi.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
 80120e0:	62b7      	str	r7, [r6, #40]	@ 0x28
    hdma_dcmi.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 80120e2:	6173      	str	r3, [r6, #20]
    hdma_dcmi.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
 80120e4:	2304      	movs	r3, #4
    hdma_dcmi.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
 80120e6:	61b2      	str	r2, [r6, #24]
    hdma_dcmi.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
 80120e8:	6273      	str	r3, [r6, #36]	@ 0x24
    hdma_dcmi.Init.Priority = DMA_PRIORITY_LOW;
 80120ea:	e9c6 4407 	strd	r4, r4, [r6, #28]
    hdma_dcmi.Init.PeriphBurst = DMA_PBURST_SINGLE;
 80120ee:	e9c6 440b 	strd	r4, r4, [r6, #44]	@ 0x2c
    if (HAL_DMA_Init(&hdma_dcmi) != HAL_OK)
 80120f2:	f001 faa7 	bl	8013644 <HAL_DMA_Init>
 80120f6:	b960      	cbnz	r0, 8012112 <HAL_DCMI_MspInit+0x156>
    HAL_NVIC_SetPriority(DCMI_IRQn, 5, 0);
 80120f8:	2200      	movs	r2, #0
 80120fa:	2105      	movs	r1, #5
 80120fc:	204e      	movs	r0, #78	@ 0x4e
    __HAL_LINKDMA(hdcmi,DMA_Handle,hdma_dcmi);
 80120fe:	64ae      	str	r6, [r5, #72]	@ 0x48
 8012100:	63b5      	str	r5, [r6, #56]	@ 0x38
    HAL_NVIC_SetPriority(DCMI_IRQn, 5, 0);
 8012102:	f001 f849 	bl	8013198 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(DCMI_IRQn);
 8012106:	204e      	movs	r0, #78	@ 0x4e
 8012108:	f001 f882 	bl	8013210 <HAL_NVIC_EnableIRQ>
}
 801210c:	b00c      	add	sp, #48	@ 0x30
 801210e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      Error_Handler();
 8012112:	f7ff fed5 	bl	8011ec0 <Error_Handler>
 8012116:	e7ef      	b.n	80120f8 <HAL_DCMI_MspInit+0x13c>
 8012118:	50050000 	.word	0x50050000
 801211c:	40023800 	.word	0x40023800
 8012120:	40021000 	.word	0x40021000
 8012124:	40020c00 	.word	0x40020c00
 8012128:	40021800 	.word	0x40021800
 801212c:	40021c00 	.word	0x40021c00
 8012130:	40020000 	.word	0x40020000
 8012134:	20002a1c 	.word	0x20002a1c
 8012138:	40026428 	.word	0x40026428

0801213c <HAL_DMA2D_MspInit>:
* @param hdma2d: DMA2D handle pointer
* @retval None
*/
void HAL_DMA2D_MspInit(DMA2D_HandleTypeDef* hdma2d)
{
  if(hdma2d->Instance==DMA2D)
 801213c:	4b0e      	ldr	r3, [pc, #56]	@ (8012178 <HAL_DMA2D_MspInit+0x3c>)
 801213e:	6802      	ldr	r2, [r0, #0]
 8012140:	429a      	cmp	r2, r3
 8012142:	d000      	beq.n	8012146 <HAL_DMA2D_MspInit+0xa>
 8012144:	4770      	bx	lr
  {
  /* USER CODE BEGIN DMA2D_MspInit 0 */

  /* USER CODE END DMA2D_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_DMA2D_CLK_ENABLE();
 8012146:	f5a3 43f0 	sub.w	r3, r3, #30720	@ 0x7800
    /* DMA2D interrupt Init */
    HAL_NVIC_SetPriority(DMA2D_IRQn, 5, 0);
 801214a:	205a      	movs	r0, #90	@ 0x5a
 801214c:	2200      	movs	r2, #0
 801214e:	2105      	movs	r1, #5
{
 8012150:	b510      	push	{r4, lr}
    __HAL_RCC_DMA2D_CLK_ENABLE();
 8012152:	6b1c      	ldr	r4, [r3, #48]	@ 0x30
{
 8012154:	b082      	sub	sp, #8
    __HAL_RCC_DMA2D_CLK_ENABLE();
 8012156:	f444 0400 	orr.w	r4, r4, #8388608	@ 0x800000
 801215a:	631c      	str	r4, [r3, #48]	@ 0x30
 801215c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 801215e:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 8012162:	9301      	str	r3, [sp, #4]
 8012164:	9b01      	ldr	r3, [sp, #4]
    HAL_NVIC_SetPriority(DMA2D_IRQn, 5, 0);
 8012166:	f001 f817 	bl	8013198 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(DMA2D_IRQn);
 801216a:	205a      	movs	r0, #90	@ 0x5a

  /* USER CODE END DMA2D_MspInit 1 */

  }

}
 801216c:	b002      	add	sp, #8
 801216e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    HAL_NVIC_EnableIRQ(DMA2D_IRQn);
 8012172:	f001 b84d 	b.w	8013210 <HAL_NVIC_EnableIRQ>
 8012176:	bf00      	nop
 8012178:	4002b000 	.word	0x4002b000

0801217c <HAL_ETH_MspInit>:
* @retval None
*/
void HAL_ETH_MspInit(ETH_HandleTypeDef* heth)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(heth->Instance==ETH)
 801217c:	4b35      	ldr	r3, [pc, #212]	@ (8012254 <HAL_ETH_MspInit+0xd8>)
 801217e:	6802      	ldr	r2, [r0, #0]
{
 8012180:	b5f0      	push	{r4, r5, r6, r7, lr}
  if(heth->Instance==ETH)
 8012182:	429a      	cmp	r2, r3
{
 8012184:	b08d      	sub	sp, #52	@ 0x34
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8012186:	f04f 0400 	mov.w	r4, #0
 801218a:	e9cd 4406 	strd	r4, r4, [sp, #24]
 801218e:	e9cd 4408 	strd	r4, r4, [sp, #32]
 8012192:	940a      	str	r4, [sp, #40]	@ 0x28
  if(heth->Instance==ETH)
 8012194:	d001      	beq.n	801219a <HAL_ETH_MspInit+0x1e>

  /* USER CODE END ETH_MspInit 1 */

  }

}
 8012196:	b00d      	add	sp, #52	@ 0x34
 8012198:	bdf0      	pop	{r4, r5, r6, r7, pc}
    __HAL_RCC_ETH_CLK_ENABLE();
 801219a:	f5a3 4390 	sub.w	r3, r3, #18432	@ 0x4800
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 801219e:	2603      	movs	r6, #3
 80121a0:	250b      	movs	r5, #11
    HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 80121a2:	a906      	add	r1, sp, #24
    __HAL_RCC_ETH_CLK_ENABLE();
 80121a4:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80121a6:	2702      	movs	r7, #2
    HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 80121a8:	482b      	ldr	r0, [pc, #172]	@ (8012258 <HAL_ETH_MspInit+0xdc>)
    __HAL_RCC_ETH_CLK_ENABLE();
 80121aa:	f042 7200 	orr.w	r2, r2, #33554432	@ 0x2000000
 80121ae:	631a      	str	r2, [r3, #48]	@ 0x30
 80121b0:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 80121b2:	f002 7200 	and.w	r2, r2, #33554432	@ 0x2000000
 80121b6:	9200      	str	r2, [sp, #0]
 80121b8:	9a00      	ldr	r2, [sp, #0]
 80121ba:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 80121bc:	f042 6280 	orr.w	r2, r2, #67108864	@ 0x4000000
 80121c0:	631a      	str	r2, [r3, #48]	@ 0x30
 80121c2:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 80121c4:	f002 6280 	and.w	r2, r2, #67108864	@ 0x4000000
 80121c8:	9201      	str	r2, [sp, #4]
 80121ca:	9a01      	ldr	r2, [sp, #4]
 80121cc:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 80121ce:	f042 6200 	orr.w	r2, r2, #134217728	@ 0x8000000
 80121d2:	631a      	str	r2, [r3, #48]	@ 0x30
 80121d4:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 80121d6:	f002 6200 	and.w	r2, r2, #134217728	@ 0x8000000
 80121da:	9202      	str	r2, [sp, #8]
 80121dc:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOG_CLK_ENABLE();
 80121de:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 80121e0:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 80121e4:	631a      	str	r2, [r3, #48]	@ 0x30
 80121e6:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 80121e8:	f002 0240 	and.w	r2, r2, #64	@ 0x40
 80121ec:	9203      	str	r2, [sp, #12]
 80121ee:	9a03      	ldr	r2, [sp, #12]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 80121f0:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 80121f2:	f042 0204 	orr.w	r2, r2, #4
 80121f6:	631a      	str	r2, [r3, #48]	@ 0x30
 80121f8:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 80121fa:	f002 0204 	and.w	r2, r2, #4
 80121fe:	9204      	str	r2, [sp, #16]
 8012200:	9a04      	ldr	r2, [sp, #16]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8012202:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8012204:	f042 0201 	orr.w	r2, r2, #1
 8012208:	631a      	str	r2, [r3, #48]	@ 0x30
    GPIO_InitStruct.Pin = RMII_TXD1_Pin|RMII_TXD0_Pin|RMII_TX_EN_Pin;
 801220a:	f44f 42d0 	mov.w	r2, #26624	@ 0x6800
    __HAL_RCC_GPIOA_CLK_ENABLE();
 801220e:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8012210:	f003 0301 	and.w	r3, r3, #1
 8012214:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Pin = RMII_TXD1_Pin|RMII_TXD0_Pin|RMII_TX_EN_Pin;
 8012216:	2302      	movs	r3, #2
 8012218:	e9cd 2306 	strd	r2, r3, [sp, #24]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 801221c:	9b05      	ldr	r3, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 801221e:	e9cd 6509 	strd	r6, r5, [sp, #36]	@ 0x24
    HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 8012222:	f002 ff2b 	bl	801507c <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = RMII_MDC_Pin|RMII_RXD0_Pin|RMII_RXD1_Pin;
 8012226:	2332      	movs	r3, #50	@ 0x32
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8012228:	a906      	add	r1, sp, #24
 801222a:	480c      	ldr	r0, [pc, #48]	@ (801225c <HAL_ETH_MspInit+0xe0>)
    GPIO_InitStruct.Pin = RMII_MDC_Pin|RMII_RXD0_Pin|RMII_RXD1_Pin;
 801222c:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
 801222e:	950a      	str	r5, [sp, #40]	@ 0x28
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8012230:	9707      	str	r7, [sp, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8012232:	e9cd 4608 	strd	r4, r6, [sp, #32]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8012236:	f002 ff21 	bl	801507c <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = RMII_REF_CLK_Pin|RMII_MDIO_Pin|RMII_CRS_DV_Pin;
 801223a:	2386      	movs	r3, #134	@ 0x86
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 801223c:	a906      	add	r1, sp, #24
 801223e:	4808      	ldr	r0, [pc, #32]	@ (8012260 <HAL_ETH_MspInit+0xe4>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8012240:	9707      	str	r7, [sp, #28]
    GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
 8012242:	950a      	str	r5, [sp, #40]	@ 0x28
    GPIO_InitStruct.Pin = RMII_REF_CLK_Pin|RMII_MDIO_Pin|RMII_CRS_DV_Pin;
 8012244:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8012246:	e9cd 4608 	strd	r4, r6, [sp, #32]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 801224a:	f002 ff17 	bl	801507c <HAL_GPIO_Init>
}
 801224e:	b00d      	add	sp, #52	@ 0x34
 8012250:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8012252:	bf00      	nop
 8012254:	40028000 	.word	0x40028000
 8012258:	40021800 	.word	0x40021800
 801225c:	40020800 	.word	0x40020800
 8012260:	40020000 	.word	0x40020000
 8012264:	00000000 	.word	0x00000000

08012268 <HAL_I2C_MspInit>:
* This function configures the hardware resources used in this example
* @param hi2c: I2C handle pointer
* @retval None
*/
void HAL_I2C_MspInit(I2C_HandleTypeDef* hi2c)
{
 8012268:	b510      	push	{r4, lr}
 801226a:	b0aa      	sub	sp, #168	@ 0xa8
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 801226c:	2100      	movs	r1, #0
{
 801226e:	4604      	mov	r4, r0
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 8012270:	2284      	movs	r2, #132	@ 0x84
 8012272:	a809      	add	r0, sp, #36	@ 0x24
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8012274:	9108      	str	r1, [sp, #32]
 8012276:	e9cd 1104 	strd	r1, r1, [sp, #16]
 801227a:	e9cd 1106 	strd	r1, r1, [sp, #24]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 801227e:	f020 febf 	bl	8033000 <memset>
  if(hi2c->Instance==I2C1)
 8012282:	6823      	ldr	r3, [r4, #0]
 8012284:	4a36      	ldr	r2, [pc, #216]	@ (8012360 <HAL_I2C_MspInit+0xf8>)
 8012286:	4293      	cmp	r3, r2
 8012288:	d004      	beq.n	8012294 <HAL_I2C_MspInit+0x2c>
    __HAL_RCC_I2C1_CLK_ENABLE();
  /* USER CODE BEGIN I2C1_MspInit 1 */

  /* USER CODE END I2C1_MspInit 1 */
  }
  else if(hi2c->Instance==I2C3)
 801228a:	4a36      	ldr	r2, [pc, #216]	@ (8012364 <HAL_I2C_MspInit+0xfc>)
 801228c:	4293      	cmp	r3, r2
 801228e:	d02c      	beq.n	80122ea <HAL_I2C_MspInit+0x82>
  /* USER CODE BEGIN I2C3_MspInit 1 */

  /* USER CODE END I2C3_MspInit 1 */
  }

}
 8012290:	b02a      	add	sp, #168	@ 0xa8
 8012292:	bd10      	pop	{r4, pc}
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_I2C1;
 8012294:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8012298:	a809      	add	r0, sp, #36	@ 0x24
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_I2C1;
 801229a:	9309      	str	r3, [sp, #36]	@ 0x24
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 801229c:	f005 fddc 	bl	8017e58 <HAL_RCCEx_PeriphCLKConfig>
 80122a0:	2800      	cmp	r0, #0
 80122a2:	d14c      	bne.n	801233e <HAL_I2C_MspInit+0xd6>
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80122a4:	4c30      	ldr	r4, [pc, #192]	@ (8012368 <HAL_I2C_MspInit+0x100>)
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
 80122a6:	2204      	movs	r2, #4
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80122a8:	a904      	add	r1, sp, #16
 80122aa:	4830      	ldr	r0, [pc, #192]	@ (801236c <HAL_I2C_MspInit+0x104>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80122ac:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 80122ae:	f043 0302 	orr.w	r3, r3, #2
 80122b2:	6323      	str	r3, [r4, #48]	@ 0x30
 80122b4:	6b23      	ldr	r3, [r4, #48]	@ 0x30
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
 80122b6:	9208      	str	r2, [sp, #32]
    GPIO_InitStruct.Pin = ARDUINO_SCL_D15_Pin|ARDUINO_SDA_D14_Pin;
 80122b8:	2201      	movs	r2, #1
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80122ba:	f003 0302 	and.w	r3, r3, #2
    GPIO_InitStruct.Pin = ARDUINO_SCL_D15_Pin|ARDUINO_SDA_D14_Pin;
 80122be:	ed9f 7b24 	vldr	d7, [pc, #144]	@ 8012350 <HAL_I2C_MspInit+0xe8>
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80122c2:	9300      	str	r3, [sp, #0]
 80122c4:	9b00      	ldr	r3, [sp, #0]
    GPIO_InitStruct.Pin = ARDUINO_SCL_D15_Pin|ARDUINO_SDA_D14_Pin;
 80122c6:	2300      	movs	r3, #0
 80122c8:	ed8d 7b04 	vstr	d7, [sp, #16]
 80122cc:	e9cd 2306 	strd	r2, r3, [sp, #24]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80122d0:	f002 fed4 	bl	801507c <HAL_GPIO_Init>
    __HAL_RCC_I2C1_CLK_ENABLE();
 80122d4:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 80122d6:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 80122da:	6423      	str	r3, [r4, #64]	@ 0x40
 80122dc:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 80122de:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 80122e2:	9301      	str	r3, [sp, #4]
 80122e4:	9b01      	ldr	r3, [sp, #4]
}
 80122e6:	b02a      	add	sp, #168	@ 0xa8
 80122e8:	bd10      	pop	{r4, pc}
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_I2C3;
 80122ea:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 80122ee:	a809      	add	r0, sp, #36	@ 0x24
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_I2C3;
 80122f0:	9309      	str	r3, [sp, #36]	@ 0x24
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 80122f2:	f005 fdb1 	bl	8017e58 <HAL_RCCEx_PeriphCLKConfig>
 80122f6:	bb28      	cbnz	r0, 8012344 <HAL_I2C_MspInit+0xdc>
    __HAL_RCC_GPIOH_CLK_ENABLE();
 80122f8:	4c1b      	ldr	r4, [pc, #108]	@ (8012368 <HAL_I2C_MspInit+0x100>)
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C3;
 80122fa:	2204      	movs	r2, #4
    HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
 80122fc:	a904      	add	r1, sp, #16
 80122fe:	481c      	ldr	r0, [pc, #112]	@ (8012370 <HAL_I2C_MspInit+0x108>)
    __HAL_RCC_GPIOH_CLK_ENABLE();
 8012300:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 8012302:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8012306:	6323      	str	r3, [r4, #48]	@ 0x30
 8012308:	6b23      	ldr	r3, [r4, #48]	@ 0x30
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C3;
 801230a:	9208      	str	r2, [sp, #32]
    GPIO_InitStruct.Pin = LCD_SCL_Pin|LCD_SDA_Pin;
 801230c:	2201      	movs	r2, #1
    __HAL_RCC_GPIOH_CLK_ENABLE();
 801230e:	f003 0380 	and.w	r3, r3, #128	@ 0x80
    GPIO_InitStruct.Pin = LCD_SCL_Pin|LCD_SDA_Pin;
 8012312:	ed9f 7b11 	vldr	d7, [pc, #68]	@ 8012358 <HAL_I2C_MspInit+0xf0>
    __HAL_RCC_GPIOH_CLK_ENABLE();
 8012316:	9302      	str	r3, [sp, #8]
 8012318:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Pin = LCD_SCL_Pin|LCD_SDA_Pin;
 801231a:	2303      	movs	r3, #3
 801231c:	ed8d 7b04 	vstr	d7, [sp, #16]
 8012320:	e9cd 2306 	strd	r2, r3, [sp, #24]
    HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
 8012324:	f002 feaa 	bl	801507c <HAL_GPIO_Init>
    __HAL_RCC_I2C3_CLK_ENABLE();
 8012328:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 801232a:	f443 0300 	orr.w	r3, r3, #8388608	@ 0x800000
 801232e:	6423      	str	r3, [r4, #64]	@ 0x40
 8012330:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 8012332:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 8012336:	9303      	str	r3, [sp, #12]
 8012338:	9b03      	ldr	r3, [sp, #12]
}
 801233a:	b02a      	add	sp, #168	@ 0xa8
 801233c:	bd10      	pop	{r4, pc}
      Error_Handler();
 801233e:	f7ff fdbf 	bl	8011ec0 <Error_Handler>
 8012342:	e7af      	b.n	80122a4 <HAL_I2C_MspInit+0x3c>
      Error_Handler();
 8012344:	f7ff fdbc 	bl	8011ec0 <Error_Handler>
 8012348:	e7d6      	b.n	80122f8 <HAL_I2C_MspInit+0x90>
 801234a:	bf00      	nop
 801234c:	f3af 8000 	nop.w
 8012350:	00000300 	.word	0x00000300
 8012354:	00000012 	.word	0x00000012
 8012358:	00000180 	.word	0x00000180
 801235c:	00000012 	.word	0x00000012
 8012360:	40005400 	.word	0x40005400
 8012364:	40005c00 	.word	0x40005c00
 8012368:	40023800 	.word	0x40023800
 801236c:	40020400 	.word	0x40020400
 8012370:	40021c00 	.word	0x40021c00

08012374 <HAL_LTDC_MspInit>:
* @retval None
*/
void HAL_LTDC_MspInit(LTDC_HandleTypeDef* hltdc)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(hltdc->Instance==LTDC)
 8012374:	4b44      	ldr	r3, [pc, #272]	@ (8012488 <HAL_LTDC_MspInit+0x114>)
 8012376:	6802      	ldr	r2, [r0, #0]
{
 8012378:	b5f0      	push	{r4, r5, r6, r7, lr}
  if(hltdc->Instance==LTDC)
 801237a:	429a      	cmp	r2, r3
{
 801237c:	b08d      	sub	sp, #52	@ 0x34
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 801237e:	f04f 0400 	mov.w	r4, #0
 8012382:	e9cd 4406 	strd	r4, r4, [sp, #24]
 8012386:	e9cd 4408 	strd	r4, r4, [sp, #32]
 801238a:	940a      	str	r4, [sp, #40]	@ 0x28
  if(hltdc->Instance==LTDC)
 801238c:	d001      	beq.n	8012392 <HAL_LTDC_MspInit+0x1e>

  /* USER CODE END LTDC_MspInit 1 */

  }

}
 801238e:	b00d      	add	sp, #52	@ 0x34
 8012390:	bdf0      	pop	{r4, r5, r6, r7, pc}
    __HAL_RCC_LTDC_CLK_ENABLE();
 8012392:	f503 4350 	add.w	r3, r3, #53248	@ 0xd000
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8012396:	2503      	movs	r5, #3
 8012398:	260e      	movs	r6, #14
    HAL_GPIO_Init(LCD_B0_GPIO_Port, &GPIO_InitStruct);
 801239a:	a906      	add	r1, sp, #24
    __HAL_RCC_LTDC_CLK_ENABLE();
 801239c:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 801239e:	2702      	movs	r7, #2
    HAL_GPIO_Init(LCD_B0_GPIO_Port, &GPIO_InitStruct);
 80123a0:	483a      	ldr	r0, [pc, #232]	@ (801248c <HAL_LTDC_MspInit+0x118>)
    __HAL_RCC_LTDC_CLK_ENABLE();
 80123a2:	f042 6280 	orr.w	r2, r2, #67108864	@ 0x4000000
 80123a6:	645a      	str	r2, [r3, #68]	@ 0x44
 80123a8:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 80123aa:	f002 6280 	and.w	r2, r2, #67108864	@ 0x4000000
 80123ae:	9200      	str	r2, [sp, #0]
 80123b0:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOE_CLK_ENABLE();
 80123b2:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 80123b4:	f042 0210 	orr.w	r2, r2, #16
 80123b8:	631a      	str	r2, [r3, #48]	@ 0x30
 80123ba:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 80123bc:	f002 0210 	and.w	r2, r2, #16
 80123c0:	9201      	str	r2, [sp, #4]
 80123c2:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOJ_CLK_ENABLE();
 80123c4:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 80123c6:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 80123ca:	631a      	str	r2, [r3, #48]	@ 0x30
 80123cc:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 80123ce:	f402 7200 	and.w	r2, r2, #512	@ 0x200
 80123d2:	9202      	str	r2, [sp, #8]
 80123d4:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOK_CLK_ENABLE();
 80123d6:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 80123d8:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
 80123dc:	631a      	str	r2, [r3, #48]	@ 0x30
 80123de:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 80123e0:	f402 6280 	and.w	r2, r2, #1024	@ 0x400
 80123e4:	9203      	str	r2, [sp, #12]
 80123e6:	9a03      	ldr	r2, [sp, #12]
    __HAL_RCC_GPIOG_CLK_ENABLE();
 80123e8:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 80123ea:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 80123ee:	631a      	str	r2, [r3, #48]	@ 0x30
 80123f0:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 80123f2:	f002 0240 	and.w	r2, r2, #64	@ 0x40
 80123f6:	9204      	str	r2, [sp, #16]
 80123f8:	9a04      	ldr	r2, [sp, #16]
    __HAL_RCC_GPIOI_CLK_ENABLE();
 80123fa:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 80123fc:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 8012400:	631a      	str	r2, [r3, #48]	@ 0x30
    GPIO_InitStruct.Pin = LCD_B0_Pin;
 8012402:	2210      	movs	r2, #16
    __HAL_RCC_GPIOI_CLK_ENABLE();
 8012404:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8012406:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 801240a:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Pin = LCD_B0_Pin;
 801240c:	2302      	movs	r3, #2
 801240e:	e9cd 2306 	strd	r2, r3, [sp, #24]
    __HAL_RCC_GPIOI_CLK_ENABLE();
 8012412:	9b05      	ldr	r3, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8012414:	e9cd 5609 	strd	r5, r6, [sp, #36]	@ 0x24
    HAL_GPIO_Init(LCD_B0_GPIO_Port, &GPIO_InitStruct);
 8012418:	f002 fe30 	bl	801507c <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = LCD_B1_Pin|LCD_B2_Pin|LCD_B3_Pin|LCD_G4_Pin
 801241c:	f64e 73ff 	movw	r3, #61439	@ 0xefff
    HAL_GPIO_Init(GPIOJ, &GPIO_InitStruct);
 8012420:	a906      	add	r1, sp, #24
 8012422:	481b      	ldr	r0, [pc, #108]	@ (8012490 <HAL_LTDC_MspInit+0x11c>)
    GPIO_InitStruct.Pin = LCD_B1_Pin|LCD_B2_Pin|LCD_B3_Pin|LCD_G4_Pin
 8012424:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF14_LTDC;
 8012426:	960a      	str	r6, [sp, #40]	@ 0x28
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8012428:	9707      	str	r7, [sp, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 801242a:	e9cd 4508 	strd	r4, r5, [sp, #32]
    HAL_GPIO_Init(GPIOJ, &GPIO_InitStruct);
 801242e:	f002 fe25 	bl	801507c <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = LCD_DE_Pin|LCD_B7_Pin|LCD_B6_Pin|LCD_B5_Pin
 8012432:	23f7      	movs	r3, #247	@ 0xf7
    HAL_GPIO_Init(GPIOK, &GPIO_InitStruct);
 8012434:	a906      	add	r1, sp, #24
 8012436:	4817      	ldr	r0, [pc, #92]	@ (8012494 <HAL_LTDC_MspInit+0x120>)
    GPIO_InitStruct.Pin = LCD_DE_Pin|LCD_B7_Pin|LCD_B6_Pin|LCD_B5_Pin
 8012438:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 801243a:	e9cd 7407 	strd	r7, r4, [sp, #28]
    GPIO_InitStruct.Alternate = GPIO_AF14_LTDC;
 801243e:	e9cd 5609 	strd	r5, r6, [sp, #36]	@ 0x24
    HAL_GPIO_Init(GPIOK, &GPIO_InitStruct);
 8012442:	f002 fe1b 	bl	801507c <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = LCD_B4_Pin;
 8012446:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
    HAL_GPIO_Init(LCD_B4_GPIO_Port, &GPIO_InitStruct);
 801244a:	a906      	add	r1, sp, #24
 801244c:	4812      	ldr	r0, [pc, #72]	@ (8012498 <HAL_LTDC_MspInit+0x124>)
    GPIO_InitStruct.Pin = LCD_B4_Pin;
 801244e:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF9_LTDC;
 8012450:	2309      	movs	r3, #9
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8012452:	9509      	str	r5, [sp, #36]	@ 0x24
    GPIO_InitStruct.Alternate = GPIO_AF9_LTDC;
 8012454:	930a      	str	r3, [sp, #40]	@ 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8012456:	e9cd 7407 	strd	r7, r4, [sp, #28]
    HAL_GPIO_Init(LCD_B4_GPIO_Port, &GPIO_InitStruct);
 801245a:	f002 fe0f 	bl	801507c <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = LCD_HSYNC_Pin|LCD_VSYNC_Pin|LCD_R0_Pin|LCD_CLK_Pin;
 801245e:	f44f 4346 	mov.w	r3, #50688	@ 0xc600
    HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
 8012462:	a906      	add	r1, sp, #24
 8012464:	480d      	ldr	r0, [pc, #52]	@ (801249c <HAL_LTDC_MspInit+0x128>)
    GPIO_InitStruct.Pin = LCD_HSYNC_Pin|LCD_VSYNC_Pin|LCD_R0_Pin|LCD_CLK_Pin;
 8012466:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8012468:	9707      	str	r7, [sp, #28]
    GPIO_InitStruct.Alternate = GPIO_AF14_LTDC;
 801246a:	960a      	str	r6, [sp, #40]	@ 0x28
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 801246c:	e9cd 4508 	strd	r4, r5, [sp, #32]
    HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
 8012470:	f002 fe04 	bl	801507c <HAL_GPIO_Init>
    HAL_NVIC_SetPriority(LTDC_IRQn, 5, 0);
 8012474:	4622      	mov	r2, r4
 8012476:	2105      	movs	r1, #5
 8012478:	2058      	movs	r0, #88	@ 0x58
 801247a:	f000 fe8d 	bl	8013198 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(LTDC_IRQn);
 801247e:	2058      	movs	r0, #88	@ 0x58
 8012480:	f000 fec6 	bl	8013210 <HAL_NVIC_EnableIRQ>
}
 8012484:	b00d      	add	sp, #52	@ 0x34
 8012486:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8012488:	40016800 	.word	0x40016800
 801248c:	40021000 	.word	0x40021000
 8012490:	40022400 	.word	0x40022400
 8012494:	40022800 	.word	0x40022800
 8012498:	40021800 	.word	0x40021800
 801249c:	40022000 	.word	0x40022000

080124a0 <HAL_QSPI_MspInit>:
* @retval None
*/
void HAL_QSPI_MspInit(QSPI_HandleTypeDef* hqspi)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(hqspi->Instance==QUADSPI)
 80124a0:	4b31      	ldr	r3, [pc, #196]	@ (8012568 <HAL_QSPI_MspInit+0xc8>)
 80124a2:	6802      	ldr	r2, [r0, #0]
{
 80124a4:	b5f0      	push	{r4, r5, r6, r7, lr}
  if(hqspi->Instance==QUADSPI)
 80124a6:	429a      	cmp	r2, r3
{
 80124a8:	b08b      	sub	sp, #44	@ 0x2c
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80124aa:	f04f 0400 	mov.w	r4, #0
 80124ae:	e9cd 4404 	strd	r4, r4, [sp, #16]
 80124b2:	e9cd 4406 	strd	r4, r4, [sp, #24]
 80124b6:	9408      	str	r4, [sp, #32]
  if(hqspi->Instance==QUADSPI)
 80124b8:	d001      	beq.n	80124be <HAL_QSPI_MspInit+0x1e>

  /* USER CODE END QUADSPI_MspInit 1 */

  }

}
 80124ba:	b00b      	add	sp, #44	@ 0x2c
 80124bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    __HAL_RCC_QSPI_CLK_ENABLE();
 80124be:	4b2b      	ldr	r3, [pc, #172]	@ (801256c <HAL_QSPI_MspInit+0xcc>)
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80124c0:	2503      	movs	r5, #3
 80124c2:	2609      	movs	r6, #9
    HAL_GPIO_Init(QSPI_D2_GPIO_Port, &GPIO_InitStruct);
 80124c4:	a904      	add	r1, sp, #16
    __HAL_RCC_QSPI_CLK_ENABLE();
 80124c6:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80124c8:	2702      	movs	r7, #2
    HAL_GPIO_Init(QSPI_D2_GPIO_Port, &GPIO_InitStruct);
 80124ca:	4829      	ldr	r0, [pc, #164]	@ (8012570 <HAL_QSPI_MspInit+0xd0>)
    __HAL_RCC_QSPI_CLK_ENABLE();
 80124cc:	f042 0202 	orr.w	r2, r2, #2
 80124d0:	639a      	str	r2, [r3, #56]	@ 0x38
 80124d2:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 80124d4:	f002 0202 	and.w	r2, r2, #2
 80124d8:	9200      	str	r2, [sp, #0]
 80124da:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOE_CLK_ENABLE();
 80124dc:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 80124de:	f042 0210 	orr.w	r2, r2, #16
 80124e2:	631a      	str	r2, [r3, #48]	@ 0x30
 80124e4:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 80124e6:	f002 0210 	and.w	r2, r2, #16
 80124ea:	9201      	str	r2, [sp, #4]
 80124ec:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80124ee:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 80124f0:	f042 0202 	orr.w	r2, r2, #2
 80124f4:	631a      	str	r2, [r3, #48]	@ 0x30
 80124f6:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 80124f8:	f002 0202 	and.w	r2, r2, #2
 80124fc:	9202      	str	r2, [sp, #8]
 80124fe:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8012500:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8012502:	f042 0208 	orr.w	r2, r2, #8
 8012506:	631a      	str	r2, [r3, #48]	@ 0x30
    GPIO_InitStruct.Pin = QSPI_D2_Pin;
 8012508:	2204      	movs	r2, #4
    __HAL_RCC_GPIOD_CLK_ENABLE();
 801250a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 801250c:	f003 0308 	and.w	r3, r3, #8
 8012510:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Pin = QSPI_D2_Pin;
 8012512:	2302      	movs	r3, #2
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8012514:	e9cd 5607 	strd	r5, r6, [sp, #28]
    GPIO_InitStruct.Pin = QSPI_D2_Pin;
 8012518:	e9cd 2304 	strd	r2, r3, [sp, #16]
    __HAL_RCC_GPIOD_CLK_ENABLE();
 801251c:	9b03      	ldr	r3, [sp, #12]
    HAL_GPIO_Init(QSPI_D2_GPIO_Port, &GPIO_InitStruct);
 801251e:	f002 fdad 	bl	801507c <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = QSPI_NCS_Pin;
 8012522:	2340      	movs	r3, #64	@ 0x40
    HAL_GPIO_Init(QSPI_NCS_GPIO_Port, &GPIO_InitStruct);
 8012524:	a904      	add	r1, sp, #16
 8012526:	4813      	ldr	r0, [pc, #76]	@ (8012574 <HAL_QSPI_MspInit+0xd4>)
    GPIO_InitStruct.Pin = QSPI_NCS_Pin;
 8012528:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF10_QUADSPI;
 801252a:	230a      	movs	r3, #10
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 801252c:	9705      	str	r7, [sp, #20]
    GPIO_InitStruct.Alternate = GPIO_AF10_QUADSPI;
 801252e:	9308      	str	r3, [sp, #32]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8012530:	e9cd 4506 	strd	r4, r5, [sp, #24]
    HAL_GPIO_Init(QSPI_NCS_GPIO_Port, &GPIO_InitStruct);
 8012534:	f002 fda2 	bl	801507c <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_2;
 8012538:	2304      	movs	r3, #4
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 801253a:	a904      	add	r1, sp, #16
 801253c:	480d      	ldr	r0, [pc, #52]	@ (8012574 <HAL_QSPI_MspInit+0xd4>)
    GPIO_InitStruct.Pin = GPIO_PIN_2;
 801253e:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8012540:	e9cd 7405 	strd	r7, r4, [sp, #20]
    GPIO_InitStruct.Alternate = GPIO_AF9_QUADSPI;
 8012544:	e9cd 5607 	strd	r5, r6, [sp, #28]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8012548:	f002 fd98 	bl	801507c <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = QSPI_D1_Pin|QSPI_D3_Pin|QSPI_D0_Pin;
 801254c:	f44f 5360 	mov.w	r3, #14336	@ 0x3800
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8012550:	a904      	add	r1, sp, #16
 8012552:	4809      	ldr	r0, [pc, #36]	@ (8012578 <HAL_QSPI_MspInit+0xd8>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8012554:	9705      	str	r7, [sp, #20]
    GPIO_InitStruct.Alternate = GPIO_AF9_QUADSPI;
 8012556:	9608      	str	r6, [sp, #32]
    GPIO_InitStruct.Pin = QSPI_D1_Pin|QSPI_D3_Pin|QSPI_D0_Pin;
 8012558:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 801255a:	e9cd 4506 	strd	r4, r5, [sp, #24]
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 801255e:	f002 fd8d 	bl	801507c <HAL_GPIO_Init>
}
 8012562:	b00b      	add	sp, #44	@ 0x2c
 8012564:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8012566:	bf00      	nop
 8012568:	a0001000 	.word	0xa0001000
 801256c:	40023800 	.word	0x40023800
 8012570:	40021000 	.word	0x40021000
 8012574:	40020400 	.word	0x40020400
 8012578:	40020c00 	.word	0x40020c00

0801257c <HAL_RTC_MspInit>:
* This function configures the hardware resources used in this example
* @param hrtc: RTC handle pointer
* @retval None
*/
void HAL_RTC_MspInit(RTC_HandleTypeDef* hrtc)
{
 801257c:	b510      	push	{r4, lr}
 801257e:	b0a2      	sub	sp, #136	@ 0x88
 8012580:	4604      	mov	r4, r0
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 8012582:	2284      	movs	r2, #132	@ 0x84
 8012584:	2100      	movs	r1, #0
 8012586:	a801      	add	r0, sp, #4
 8012588:	f020 fd3a 	bl	8033000 <memset>
  if(hrtc->Instance==RTC)
 801258c:	4b0c      	ldr	r3, [pc, #48]	@ (80125c0 <HAL_RTC_MspInit+0x44>)
 801258e:	6822      	ldr	r2, [r4, #0]
 8012590:	429a      	cmp	r2, r3
 8012592:	d001      	beq.n	8012598 <HAL_RTC_MspInit+0x1c>

  /* USER CODE END RTC_MspInit 1 */

  }

}
 8012594:	b022      	add	sp, #136	@ 0x88
 8012596:	bd10      	pop	{r4, pc}
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
 8012598:	2220      	movs	r2, #32
    PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSI;
 801259a:	f44f 7300 	mov.w	r3, #512	@ 0x200
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 801259e:	a801      	add	r0, sp, #4
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
 80125a0:	9201      	str	r2, [sp, #4]
    PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSI;
 80125a2:	930d      	str	r3, [sp, #52]	@ 0x34
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 80125a4:	f005 fc58 	bl	8017e58 <HAL_RCCEx_PeriphCLKConfig>
 80125a8:	b930      	cbnz	r0, 80125b8 <HAL_RTC_MspInit+0x3c>
    __HAL_RCC_RTC_ENABLE();
 80125aa:	4a06      	ldr	r2, [pc, #24]	@ (80125c4 <HAL_RTC_MspInit+0x48>)
 80125ac:	6f13      	ldr	r3, [r2, #112]	@ 0x70
 80125ae:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 80125b2:	6713      	str	r3, [r2, #112]	@ 0x70
}
 80125b4:	b022      	add	sp, #136	@ 0x88
 80125b6:	bd10      	pop	{r4, pc}
      Error_Handler();
 80125b8:	f7ff fc82 	bl	8011ec0 <Error_Handler>
 80125bc:	e7f5      	b.n	80125aa <HAL_RTC_MspInit+0x2e>
 80125be:	bf00      	nop
 80125c0:	40002800 	.word	0x40002800
 80125c4:	40023800 	.word	0x40023800

080125c8 <HAL_SD_MspInit>:
* @retval None
*/
void HAL_SD_MspInit(SD_HandleTypeDef* hsd)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(hsd->Instance==SDMMC1)
 80125c8:	4b22      	ldr	r3, [pc, #136]	@ (8012654 <HAL_SD_MspInit+0x8c>)
 80125ca:	6802      	ldr	r2, [r0, #0]
{
 80125cc:	b570      	push	{r4, r5, r6, lr}
  if(hsd->Instance==SDMMC1)
 80125ce:	429a      	cmp	r2, r3
{
 80125d0:	b08a      	sub	sp, #40	@ 0x28
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80125d2:	f04f 0400 	mov.w	r4, #0
 80125d6:	e9cd 4404 	strd	r4, r4, [sp, #16]
 80125da:	e9cd 4406 	strd	r4, r4, [sp, #24]
 80125de:	9408      	str	r4, [sp, #32]
  if(hsd->Instance==SDMMC1)
 80125e0:	d001      	beq.n	80125e6 <HAL_SD_MspInit+0x1e>

  /* USER CODE END SDMMC1_MspInit 1 */

  }

}
 80125e2:	b00a      	add	sp, #40	@ 0x28
 80125e4:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_RCC_SDMMC1_CLK_ENABLE();
 80125e6:	f503 3386 	add.w	r3, r3, #68608	@ 0x10c00
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80125ea:	2603      	movs	r6, #3
 80125ec:	250c      	movs	r5, #12
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80125ee:	a904      	add	r1, sp, #16
    __HAL_RCC_SDMMC1_CLK_ENABLE();
 80125f0:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80125f2:	4819      	ldr	r0, [pc, #100]	@ (8012658 <HAL_SD_MspInit+0x90>)
    __HAL_RCC_SDMMC1_CLK_ENABLE();
 80125f4:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
 80125f8:	645a      	str	r2, [r3, #68]	@ 0x44
 80125fa:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 80125fc:	f402 6200 	and.w	r2, r2, #2048	@ 0x800
 8012600:	9201      	str	r2, [sp, #4]
 8012602:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8012604:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8012606:	f042 0204 	orr.w	r2, r2, #4
 801260a:	631a      	str	r2, [r3, #48]	@ 0x30
 801260c:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 801260e:	f002 0204 	and.w	r2, r2, #4
 8012612:	9202      	str	r2, [sp, #8]
 8012614:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8012616:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8012618:	f042 0208 	orr.w	r2, r2, #8
 801261c:	631a      	str	r2, [r3, #48]	@ 0x30
    GPIO_InitStruct.Pin = SDMMC_CK_Pin|SDMMC_D3_Pin|SDMMC_D2_Pin|GPIO_PIN_9
 801261e:	f44f 52f8 	mov.w	r2, #7936	@ 0x1f00
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8012622:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8012624:	f003 0308 	and.w	r3, r3, #8
 8012628:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Pin = SDMMC_CK_Pin|SDMMC_D3_Pin|SDMMC_D2_Pin|GPIO_PIN_9
 801262a:	2302      	movs	r3, #2
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 801262c:	e9cd 6507 	strd	r6, r5, [sp, #28]
    GPIO_InitStruct.Pin = SDMMC_CK_Pin|SDMMC_D3_Pin|SDMMC_D2_Pin|GPIO_PIN_9
 8012630:	e9cd 2304 	strd	r2, r3, [sp, #16]
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8012634:	9b03      	ldr	r3, [sp, #12]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8012636:	f002 fd21 	bl	801507c <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = SDMMC_CMD_Pin;
 801263a:	2304      	movs	r3, #4
    HAL_GPIO_Init(SDMMC_CMD_GPIO_Port, &GPIO_InitStruct);
 801263c:	a904      	add	r1, sp, #16
 801263e:	4807      	ldr	r0, [pc, #28]	@ (801265c <HAL_SD_MspInit+0x94>)
    GPIO_InitStruct.Pin = SDMMC_CMD_Pin;
 8012640:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8012642:	2302      	movs	r3, #2
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8012644:	9406      	str	r4, [sp, #24]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8012646:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Alternate = GPIO_AF12_SDMMC1;
 8012648:	e9cd 6507 	strd	r6, r5, [sp, #28]
    HAL_GPIO_Init(SDMMC_CMD_GPIO_Port, &GPIO_InitStruct);
 801264c:	f002 fd16 	bl	801507c <HAL_GPIO_Init>
}
 8012650:	b00a      	add	sp, #40	@ 0x28
 8012652:	bd70      	pop	{r4, r5, r6, pc}
 8012654:	40012c00 	.word	0x40012c00
 8012658:	40020800 	.word	0x40020800
 801265c:	40020c00 	.word	0x40020c00

08012660 <HAL_SPDIFRX_MspInit>:
* This function configures the hardware resources used in this example
* @param hspdifrx: SPDIFRX handle pointer
* @retval None
*/
void HAL_SPDIFRX_MspInit(SPDIFRX_HandleTypeDef* hspdifrx)
{
 8012660:	b510      	push	{r4, lr}
 8012662:	b0aa      	sub	sp, #168	@ 0xa8
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8012664:	2100      	movs	r1, #0
{
 8012666:	4604      	mov	r4, r0
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 8012668:	2284      	movs	r2, #132	@ 0x84
 801266a:	a808      	add	r0, sp, #32
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 801266c:	9106      	str	r1, [sp, #24]
 801266e:	e9cd 1102 	strd	r1, r1, [sp, #8]
 8012672:	e9cd 1104 	strd	r1, r1, [sp, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 8012676:	f020 fcc3 	bl	8033000 <memset>
  if(hspdifrx->Instance==SPDIFRX)
 801267a:	6823      	ldr	r3, [r4, #0]
 801267c:	f1b3 2f40 	cmp.w	r3, #1073758208	@ 0x40004000
 8012680:	d001      	beq.n	8012686 <HAL_SPDIFRX_MspInit+0x26>

  /* USER CODE END SPDIFRX_MspInit 1 */

  }

}
 8012682:	b02a      	add	sp, #168	@ 0xa8
 8012684:	bd10      	pop	{r4, pc}
    PeriphClkInitStruct.PLLI2S.PLLI2SP = RCC_PLLP_DIV2;
 8012686:	2102      	movs	r1, #2
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SPDIFRX;
 8012688:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
 801268c:	2364      	movs	r3, #100	@ 0x64
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 801268e:	a808      	add	r0, sp, #32
    PeriphClkInitStruct.PLLI2S.PLLI2SP = RCC_PLLP_DIV2;
 8012690:	910c      	str	r1, [sp, #48]	@ 0x30
    PeriphClkInitStruct.PLLI2SDivQ = 1;
 8012692:	2101      	movs	r1, #1
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SPDIFRX;
 8012694:	e9cd 2308 	strd	r2, r3, [sp, #32]
 8012698:	2202      	movs	r2, #2
 801269a:	2302      	movs	r3, #2
    PeriphClkInitStruct.PLLI2SDivQ = 1;
 801269c:	9111      	str	r1, [sp, #68]	@ 0x44
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SPDIFRX;
 801269e:	e9cd 230a 	strd	r2, r3, [sp, #40]	@ 0x28
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 80126a2:	f005 fbd9 	bl	8017e58 <HAL_RCCEx_PeriphCLKConfig>
 80126a6:	bb08      	cbnz	r0, 80126ec <HAL_SPDIFRX_MspInit+0x8c>
    __HAL_RCC_SPDIFRX_CLK_ENABLE();
 80126a8:	4b17      	ldr	r3, [pc, #92]	@ (8012708 <HAL_SPDIFRX_MspInit+0xa8>)
    GPIO_InitStruct.Alternate = GPIO_AF8_SPDIFRX;
 80126aa:	2408      	movs	r4, #8
    HAL_GPIO_Init(SPDIF_RX0_GPIO_Port, &GPIO_InitStruct);
 80126ac:	4817      	ldr	r0, [pc, #92]	@ (801270c <HAL_SPDIFRX_MspInit+0xac>)
    __HAL_RCC_SPDIFRX_CLK_ENABLE();
 80126ae:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
    HAL_GPIO_Init(SPDIF_RX0_GPIO_Port, &GPIO_InitStruct);
 80126b0:	eb0d 0104 	add.w	r1, sp, r4
    __HAL_RCC_SPDIFRX_CLK_ENABLE();
 80126b4:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
 80126b8:	641a      	str	r2, [r3, #64]	@ 0x40
 80126ba:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 80126bc:	f402 3280 	and.w	r2, r2, #65536	@ 0x10000
 80126c0:	9200      	str	r2, [sp, #0]
 80126c2:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOD_CLK_ENABLE();
 80126c4:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 80126c6:	4322      	orrs	r2, r4
 80126c8:	631a      	str	r2, [r3, #48]	@ 0x30
 80126ca:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
    GPIO_InitStruct.Alternate = GPIO_AF8_SPDIFRX;
 80126cc:	9406      	str	r4, [sp, #24]
    __HAL_RCC_GPIOD_CLK_ENABLE();
 80126ce:	4023      	ands	r3, r4
    GPIO_InitStruct.Pin = SPDIF_RX0_Pin;
 80126d0:	ed9f 7b09 	vldr	d7, [pc, #36]	@ 80126f8 <HAL_SPDIFRX_MspInit+0x98>
    __HAL_RCC_GPIOD_CLK_ENABLE();
 80126d4:	9301      	str	r3, [sp, #4]
 80126d6:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Pin = SPDIF_RX0_Pin;
 80126d8:	ed8d 7b02 	vstr	d7, [sp, #8]
 80126dc:	ed9f 7b08 	vldr	d7, [pc, #32]	@ 8012700 <HAL_SPDIFRX_MspInit+0xa0>
 80126e0:	ed8d 7b04 	vstr	d7, [sp, #16]
    HAL_GPIO_Init(SPDIF_RX0_GPIO_Port, &GPIO_InitStruct);
 80126e4:	f002 fcca 	bl	801507c <HAL_GPIO_Init>
}
 80126e8:	b02a      	add	sp, #168	@ 0xa8
 80126ea:	bd10      	pop	{r4, pc}
      Error_Handler();
 80126ec:	f7ff fbe8 	bl	8011ec0 <Error_Handler>
 80126f0:	e7da      	b.n	80126a8 <HAL_SPDIFRX_MspInit+0x48>
 80126f2:	bf00      	nop
 80126f4:	f3af 8000 	nop.w
 80126f8:	00000080 	.word	0x00000080
 80126fc:	00000002 	.word	0x00000002
	...
 8012708:	40023800 	.word	0x40023800
 801270c:	40020c00 	.word	0x40020c00

08012710 <HAL_SPI_MspInit>:
* @retval None
*/
void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(hspi->Instance==SPI2)
 8012710:	4b21      	ldr	r3, [pc, #132]	@ (8012798 <HAL_SPI_MspInit+0x88>)
 8012712:	6802      	ldr	r2, [r0, #0]
{
 8012714:	b530      	push	{r4, r5, lr}
  if(hspi->Instance==SPI2)
 8012716:	429a      	cmp	r2, r3
{
 8012718:	b08b      	sub	sp, #44	@ 0x2c
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 801271a:	f04f 0400 	mov.w	r4, #0
 801271e:	e9cd 4404 	strd	r4, r4, [sp, #16]
 8012722:	e9cd 4406 	strd	r4, r4, [sp, #24]
 8012726:	9408      	str	r4, [sp, #32]
  if(hspi->Instance==SPI2)
 8012728:	d001      	beq.n	801272e <HAL_SPI_MspInit+0x1e>

  /* USER CODE END SPI2_MspInit 1 */

  }

}
 801272a:	b00b      	add	sp, #44	@ 0x2c
 801272c:	bd30      	pop	{r4, r5, pc}
    __HAL_RCC_SPI2_CLK_ENABLE();
 801272e:	f503 3300 	add.w	r3, r3, #131072	@ 0x20000
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
 8012732:	2505      	movs	r5, #5
    HAL_GPIO_Init(ARDUINO_SCK_D13_GPIO_Port, &GPIO_InitStruct);
 8012734:	4819      	ldr	r0, [pc, #100]	@ (801279c <HAL_SPI_MspInit+0x8c>)
    __HAL_RCC_SPI2_CLK_ENABLE();
 8012736:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 8012738:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
 801273c:	641a      	str	r2, [r3, #64]	@ 0x40
 801273e:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 8012740:	f402 4280 	and.w	r2, r2, #16384	@ 0x4000
 8012744:	9201      	str	r2, [sp, #4]
 8012746:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOI_CLK_ENABLE();
 8012748:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 801274a:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 801274e:	631a      	str	r2, [r3, #48]	@ 0x30
 8012750:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8012752:	f402 7280 	and.w	r2, r2, #256	@ 0x100
 8012756:	9202      	str	r2, [sp, #8]
 8012758:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801275a:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 801275c:	f042 0202 	orr.w	r2, r2, #2
 8012760:	631a      	str	r2, [r3, #48]	@ 0x30
    GPIO_InitStruct.Pin = ARDUINO_SCK_D13_Pin;
 8012762:	2202      	movs	r2, #2
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8012764:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
 8012766:	9508      	str	r5, [sp, #32]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8012768:	f003 0302 	and.w	r3, r3, #2
 801276c:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Pin = ARDUINO_SCK_D13_Pin;
 801276e:	2302      	movs	r3, #2
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8012770:	9903      	ldr	r1, [sp, #12]
    HAL_GPIO_Init(ARDUINO_SCK_D13_GPIO_Port, &GPIO_InitStruct);
 8012772:	a904      	add	r1, sp, #16
    GPIO_InitStruct.Pin = ARDUINO_SCK_D13_Pin;
 8012774:	e9cd 2304 	strd	r2, r3, [sp, #16]
    HAL_GPIO_Init(ARDUINO_SCK_D13_GPIO_Port, &GPIO_InitStruct);
 8012778:	f002 fc80 	bl	801507c <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = ARDUINO_MISO_D12_Pin|ARDUINO_MOSI_PWM_D11_Pin;
 801277c:	f44f 4240 	mov.w	r2, #49152	@ 0xc000
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8012780:	2302      	movs	r3, #2
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8012782:	a904      	add	r1, sp, #16
 8012784:	4806      	ldr	r0, [pc, #24]	@ (80127a0 <HAL_SPI_MspInit+0x90>)
    GPIO_InitStruct.Pin = ARDUINO_MISO_D12_Pin|ARDUINO_MOSI_PWM_D11_Pin;
 8012786:	9204      	str	r2, [sp, #16]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8012788:	e9cd 3405 	strd	r3, r4, [sp, #20]
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
 801278c:	e9cd 4507 	strd	r4, r5, [sp, #28]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8012790:	f002 fc74 	bl	801507c <HAL_GPIO_Init>
}
 8012794:	b00b      	add	sp, #44	@ 0x2c
 8012796:	bd30      	pop	{r4, r5, pc}
 8012798:	40003800 	.word	0x40003800
 801279c:	40022000 	.word	0x40022000
 80127a0:	40020400 	.word	0x40020400

080127a4 <HAL_TIM_Base_MspInit>:
* @param htim_base: TIM_Base handle pointer
* @retval None
*/
void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* htim_base)
{
  if(htim_base->Instance==TIM1)
 80127a4:	4a26      	ldr	r2, [pc, #152]	@ (8012840 <HAL_TIM_Base_MspInit+0x9c>)
{
 80127a6:	b086      	sub	sp, #24
  if(htim_base->Instance==TIM1)
 80127a8:	6803      	ldr	r3, [r0, #0]
 80127aa:	4293      	cmp	r3, r2
 80127ac:	d023      	beq.n	80127f6 <HAL_TIM_Base_MspInit+0x52>
    __HAL_RCC_TIM1_CLK_ENABLE();
  /* USER CODE BEGIN TIM1_MspInit 1 */

  /* USER CODE END TIM1_MspInit 1 */
  }
  else if(htim_base->Instance==TIM2)
 80127ae:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 80127b2:	d013      	beq.n	80127dc <HAL_TIM_Base_MspInit+0x38>
    __HAL_RCC_TIM2_CLK_ENABLE();
  /* USER CODE BEGIN TIM2_MspInit 1 */

  /* USER CODE END TIM2_MspInit 1 */
  }
  else if(htim_base->Instance==TIM3)
 80127b4:	4a23      	ldr	r2, [pc, #140]	@ (8012844 <HAL_TIM_Base_MspInit+0xa0>)
 80127b6:	4293      	cmp	r3, r2
 80127b8:	d029      	beq.n	801280e <HAL_TIM_Base_MspInit+0x6a>
    __HAL_RCC_TIM3_CLK_ENABLE();
  /* USER CODE BEGIN TIM3_MspInit 1 */

  /* USER CODE END TIM3_MspInit 1 */
  }
  else if(htim_base->Instance==TIM5)
 80127ba:	4a23      	ldr	r2, [pc, #140]	@ (8012848 <HAL_TIM_Base_MspInit+0xa4>)
 80127bc:	4293      	cmp	r3, r2
 80127be:	d032      	beq.n	8012826 <HAL_TIM_Base_MspInit+0x82>
    __HAL_RCC_TIM5_CLK_ENABLE();
  /* USER CODE BEGIN TIM5_MspInit 1 */

  /* USER CODE END TIM5_MspInit 1 */
  }
  else if(htim_base->Instance==TIM8)
 80127c0:	4a22      	ldr	r2, [pc, #136]	@ (801284c <HAL_TIM_Base_MspInit+0xa8>)
 80127c2:	4293      	cmp	r3, r2
 80127c4:	d115      	bne.n	80127f2 <HAL_TIM_Base_MspInit+0x4e>
  {
  /* USER CODE BEGIN TIM8_MspInit 0 */

  /* USER CODE END TIM8_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM8_CLK_ENABLE();
 80127c6:	4b22      	ldr	r3, [pc, #136]	@ (8012850 <HAL_TIM_Base_MspInit+0xac>)
 80127c8:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 80127ca:	f042 0202 	orr.w	r2, r2, #2
 80127ce:	645a      	str	r2, [r3, #68]	@ 0x44
 80127d0:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80127d2:	f003 0302 	and.w	r3, r3, #2
 80127d6:	9305      	str	r3, [sp, #20]
 80127d8:	9b05      	ldr	r3, [sp, #20]
  /* USER CODE BEGIN TIM8_MspInit 1 */

  /* USER CODE END TIM8_MspInit 1 */
  }

}
 80127da:	e00a      	b.n	80127f2 <HAL_TIM_Base_MspInit+0x4e>
    __HAL_RCC_TIM2_CLK_ENABLE();
 80127dc:	f503 330e 	add.w	r3, r3, #145408	@ 0x23800
 80127e0:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 80127e2:	f042 0201 	orr.w	r2, r2, #1
 80127e6:	641a      	str	r2, [r3, #64]	@ 0x40
 80127e8:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80127ea:	f003 0301 	and.w	r3, r3, #1
 80127ee:	9302      	str	r3, [sp, #8]
 80127f0:	9b02      	ldr	r3, [sp, #8]
}
 80127f2:	b006      	add	sp, #24
 80127f4:	4770      	bx	lr
    __HAL_RCC_TIM1_CLK_ENABLE();
 80127f6:	4b16      	ldr	r3, [pc, #88]	@ (8012850 <HAL_TIM_Base_MspInit+0xac>)
 80127f8:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 80127fa:	f042 0201 	orr.w	r2, r2, #1
 80127fe:	645a      	str	r2, [r3, #68]	@ 0x44
 8012800:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8012802:	f003 0301 	and.w	r3, r3, #1
 8012806:	9301      	str	r3, [sp, #4]
 8012808:	9b01      	ldr	r3, [sp, #4]
}
 801280a:	b006      	add	sp, #24
 801280c:	4770      	bx	lr
    __HAL_RCC_TIM3_CLK_ENABLE();
 801280e:	4b10      	ldr	r3, [pc, #64]	@ (8012850 <HAL_TIM_Base_MspInit+0xac>)
 8012810:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 8012812:	f042 0202 	orr.w	r2, r2, #2
 8012816:	641a      	str	r2, [r3, #64]	@ 0x40
 8012818:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 801281a:	f003 0302 	and.w	r3, r3, #2
 801281e:	9303      	str	r3, [sp, #12]
 8012820:	9b03      	ldr	r3, [sp, #12]
}
 8012822:	b006      	add	sp, #24
 8012824:	4770      	bx	lr
    __HAL_RCC_TIM5_CLK_ENABLE();
 8012826:	4b0a      	ldr	r3, [pc, #40]	@ (8012850 <HAL_TIM_Base_MspInit+0xac>)
 8012828:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 801282a:	f042 0208 	orr.w	r2, r2, #8
 801282e:	641a      	str	r2, [r3, #64]	@ 0x40
 8012830:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8012832:	f003 0308 	and.w	r3, r3, #8
 8012836:	9304      	str	r3, [sp, #16]
 8012838:	9b04      	ldr	r3, [sp, #16]
}
 801283a:	b006      	add	sp, #24
 801283c:	4770      	bx	lr
 801283e:	bf00      	nop
 8012840:	40010000 	.word	0x40010000
 8012844:	40000400 	.word	0x40000400
 8012848:	40000c00 	.word	0x40000c00
 801284c:	40010400 	.word	0x40010400
 8012850:	40023800 	.word	0x40023800

08012854 <HAL_TIM_PWM_MspInit>:
* @param htim_pwm: TIM_PWM handle pointer
* @retval None
*/
void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef* htim_pwm)
{
  if(htim_pwm->Instance==TIM12)
 8012854:	4b09      	ldr	r3, [pc, #36]	@ (801287c <HAL_TIM_PWM_MspInit+0x28>)
 8012856:	6802      	ldr	r2, [r0, #0]
 8012858:	429a      	cmp	r2, r3
 801285a:	d000      	beq.n	801285e <HAL_TIM_PWM_MspInit+0xa>
 801285c:	4770      	bx	lr
  {
  /* USER CODE BEGIN TIM12_MspInit 0 */

  /* USER CODE END TIM12_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM12_CLK_ENABLE();
 801285e:	f503 3308 	add.w	r3, r3, #139264	@ 0x22000
{
 8012862:	b082      	sub	sp, #8
    __HAL_RCC_TIM12_CLK_ENABLE();
 8012864:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 8012866:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 801286a:	641a      	str	r2, [r3, #64]	@ 0x40
 801286c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 801286e:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8012872:	9301      	str	r3, [sp, #4]
 8012874:	9b01      	ldr	r3, [sp, #4]

  /* USER CODE END TIM12_MspInit 1 */

  }

}
 8012876:	b002      	add	sp, #8
 8012878:	4770      	bx	lr
 801287a:	bf00      	nop
 801287c:	40001800 	.word	0x40001800

08012880 <HAL_TIM_MspPostInit>:

void HAL_TIM_MspPostInit(TIM_HandleTypeDef* htim)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(htim->Instance==TIM1)
 8012880:	494b      	ldr	r1, [pc, #300]	@ (80129b0 <HAL_TIM_MspPostInit+0x130>)
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8012882:	2300      	movs	r3, #0
  if(htim->Instance==TIM1)
 8012884:	6802      	ldr	r2, [r0, #0]
{
 8012886:	b510      	push	{r4, lr}
  if(htim->Instance==TIM1)
 8012888:	428a      	cmp	r2, r1
{
 801288a:	b08c      	sub	sp, #48	@ 0x30
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 801288c:	e9cd 3306 	strd	r3, r3, [sp, #24]
 8012890:	e9cd 3308 	strd	r3, r3, [sp, #32]
 8012894:	930a      	str	r3, [sp, #40]	@ 0x28
  if(htim->Instance==TIM1)
 8012896:	d023      	beq.n	80128e0 <HAL_TIM_MspPostInit+0x60>

  /* USER CODE BEGIN TIM1_MspPostInit 1 */

  /* USER CODE END TIM1_MspPostInit 1 */
  }
  else if(htim->Instance==TIM2)
 8012898:	f1b2 4f80 	cmp.w	r2, #1073741824	@ 0x40000000
 801289c:	d034      	beq.n	8012908 <HAL_TIM_MspPostInit+0x88>

  /* USER CODE BEGIN TIM2_MspPostInit 1 */

  /* USER CODE END TIM2_MspPostInit 1 */
  }
  else if(htim->Instance==TIM3)
 801289e:	4b45      	ldr	r3, [pc, #276]	@ (80129b4 <HAL_TIM_MspPostInit+0x134>)
 80128a0:	429a      	cmp	r2, r3
 80128a2:	d045      	beq.n	8012930 <HAL_TIM_MspPostInit+0xb0>

  /* USER CODE BEGIN TIM3_MspPostInit 1 */

  /* USER CODE END TIM3_MspPostInit 1 */
  }
  else if(htim->Instance==TIM5)
 80128a4:	4b44      	ldr	r3, [pc, #272]	@ (80129b8 <HAL_TIM_MspPostInit+0x138>)
 80128a6:	429a      	cmp	r2, r3
 80128a8:	d004      	beq.n	80128b4 <HAL_TIM_MspPostInit+0x34>

  /* USER CODE BEGIN TIM5_MspPostInit 1 */

  /* USER CODE END TIM5_MspPostInit 1 */
  }
  else if(htim->Instance==TIM12)
 80128aa:	4b44      	ldr	r3, [pc, #272]	@ (80129bc <HAL_TIM_MspPostInit+0x13c>)
 80128ac:	429a      	cmp	r2, r3
 80128ae:	d054      	beq.n	801295a <HAL_TIM_MspPostInit+0xda>
  /* USER CODE BEGIN TIM12_MspPostInit 1 */

  /* USER CODE END TIM12_MspPostInit 1 */
  }

}
 80128b0:	b00c      	add	sp, #48	@ 0x30
 80128b2:	bd10      	pop	{r4, pc}
    __HAL_RCC_GPIOI_CLK_ENABLE();
 80128b4:	f503 330b 	add.w	r3, r3, #142336	@ 0x22c00
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM5;
 80128b8:	2402      	movs	r4, #2
    HAL_GPIO_Init(ARDUINO_PWM_CS_D5_GPIO_Port, &GPIO_InitStruct);
 80128ba:	a906      	add	r1, sp, #24
 80128bc:	4840      	ldr	r0, [pc, #256]	@ (80129c0 <HAL_TIM_MspPostInit+0x140>)
    __HAL_RCC_GPIOI_CLK_ENABLE();
 80128be:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 80128c0:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 80128c4:	631a      	str	r2, [r3, #48]	@ 0x30
 80128c6:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM5;
 80128c8:	940a      	str	r4, [sp, #40]	@ 0x28
    __HAL_RCC_GPIOI_CLK_ENABLE();
 80128ca:	f403 7380 	and.w	r3, r3, #256	@ 0x100
    GPIO_InitStruct.Pin = ARDUINO_PWM_CS_D5_Pin;
 80128ce:	ed9f 7b2e 	vldr	d7, [pc, #184]	@ 8012988 <HAL_TIM_MspPostInit+0x108>
    __HAL_RCC_GPIOI_CLK_ENABLE();
 80128d2:	9304      	str	r3, [sp, #16]
 80128d4:	9b04      	ldr	r3, [sp, #16]
    GPIO_InitStruct.Pin = ARDUINO_PWM_CS_D5_Pin;
 80128d6:	ed8d 7b06 	vstr	d7, [sp, #24]
    HAL_GPIO_Init(ARDUINO_PWM_CS_D5_GPIO_Port, &GPIO_InitStruct);
 80128da:	f002 fbcf 	bl	801507c <HAL_GPIO_Init>
 80128de:	e7e7      	b.n	80128b0 <HAL_TIM_MspPostInit+0x30>
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80128e0:	4b38      	ldr	r3, [pc, #224]	@ (80129c4 <HAL_TIM_MspPostInit+0x144>)
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM1;
 80128e2:	2401      	movs	r4, #1
    HAL_GPIO_Init(ARDUINO_PWM_D10_GPIO_Port, &GPIO_InitStruct);
 80128e4:	a906      	add	r1, sp, #24
 80128e6:	4838      	ldr	r0, [pc, #224]	@ (80129c8 <HAL_TIM_MspPostInit+0x148>)
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80128e8:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 80128ea:	4322      	orrs	r2, r4
 80128ec:	631a      	str	r2, [r3, #48]	@ 0x30
 80128ee:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM1;
 80128f0:	940a      	str	r4, [sp, #40]	@ 0x28
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80128f2:	4023      	ands	r3, r4
    GPIO_InitStruct.Pin = ARDUINO_PWM_D10_Pin;
 80128f4:	ed9f 7b26 	vldr	d7, [pc, #152]	@ 8012990 <HAL_TIM_MspPostInit+0x110>
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80128f8:	9301      	str	r3, [sp, #4]
 80128fa:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Pin = ARDUINO_PWM_D10_Pin;
 80128fc:	ed8d 7b06 	vstr	d7, [sp, #24]
    HAL_GPIO_Init(ARDUINO_PWM_D10_GPIO_Port, &GPIO_InitStruct);
 8012900:	f002 fbbc 	bl	801507c <HAL_GPIO_Init>
}
 8012904:	b00c      	add	sp, #48	@ 0x30
 8012906:	bd10      	pop	{r4, pc}
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8012908:	4b2e      	ldr	r3, [pc, #184]	@ (80129c4 <HAL_TIM_MspPostInit+0x144>)
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 801290a:	2401      	movs	r4, #1
    HAL_GPIO_Init(ARDUINO_PWM_D9_GPIO_Port, &GPIO_InitStruct);
 801290c:	a906      	add	r1, sp, #24
 801290e:	482e      	ldr	r0, [pc, #184]	@ (80129c8 <HAL_TIM_MspPostInit+0x148>)
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8012910:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8012912:	4322      	orrs	r2, r4
 8012914:	631a      	str	r2, [r3, #48]	@ 0x30
 8012916:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 8012918:	940a      	str	r4, [sp, #40]	@ 0x28
    __HAL_RCC_GPIOA_CLK_ENABLE();
 801291a:	4023      	ands	r3, r4
    GPIO_InitStruct.Pin = ARDUINO_PWM_D9_Pin;
 801291c:	ed9f 7b1e 	vldr	d7, [pc, #120]	@ 8012998 <HAL_TIM_MspPostInit+0x118>
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8012920:	9302      	str	r3, [sp, #8]
 8012922:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Pin = ARDUINO_PWM_D9_Pin;
 8012924:	ed8d 7b06 	vstr	d7, [sp, #24]
    HAL_GPIO_Init(ARDUINO_PWM_D9_GPIO_Port, &GPIO_InitStruct);
 8012928:	f002 fba8 	bl	801507c <HAL_GPIO_Init>
}
 801292c:	b00c      	add	sp, #48	@ 0x30
 801292e:	bd10      	pop	{r4, pc}
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8012930:	f503 330d 	add.w	r3, r3, #144384	@ 0x23400
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM3;
 8012934:	2402      	movs	r4, #2
    HAL_GPIO_Init(ARDUINO_PWM_D3_GPIO_Port, &GPIO_InitStruct);
 8012936:	a906      	add	r1, sp, #24
 8012938:	4824      	ldr	r0, [pc, #144]	@ (80129cc <HAL_TIM_MspPostInit+0x14c>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801293a:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 801293c:	4322      	orrs	r2, r4
 801293e:	631a      	str	r2, [r3, #48]	@ 0x30
 8012940:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM3;
 8012942:	940a      	str	r4, [sp, #40]	@ 0x28
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8012944:	4023      	ands	r3, r4
    GPIO_InitStruct.Pin = ARDUINO_PWM_D3_Pin;
 8012946:	ed9f 7b16 	vldr	d7, [pc, #88]	@ 80129a0 <HAL_TIM_MspPostInit+0x120>
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801294a:	9303      	str	r3, [sp, #12]
 801294c:	9b03      	ldr	r3, [sp, #12]
    GPIO_InitStruct.Pin = ARDUINO_PWM_D3_Pin;
 801294e:	ed8d 7b06 	vstr	d7, [sp, #24]
    HAL_GPIO_Init(ARDUINO_PWM_D3_GPIO_Port, &GPIO_InitStruct);
 8012952:	f002 fb93 	bl	801507c <HAL_GPIO_Init>
}
 8012956:	b00c      	add	sp, #48	@ 0x30
 8012958:	bd10      	pop	{r4, pc}
    __HAL_RCC_GPIOH_CLK_ENABLE();
 801295a:	f503 3308 	add.w	r3, r3, #139264	@ 0x22000
    GPIO_InitStruct.Alternate = GPIO_AF9_TIM12;
 801295e:	2409      	movs	r4, #9
    HAL_GPIO_Init(ARDUINO_PWM_D6_GPIO_Port, &GPIO_InitStruct);
 8012960:	a906      	add	r1, sp, #24
 8012962:	481b      	ldr	r0, [pc, #108]	@ (80129d0 <HAL_TIM_MspPostInit+0x150>)
    __HAL_RCC_GPIOH_CLK_ENABLE();
 8012964:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8012966:	f042 0280 	orr.w	r2, r2, #128	@ 0x80
 801296a:	631a      	str	r2, [r3, #48]	@ 0x30
 801296c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
    GPIO_InitStruct.Alternate = GPIO_AF9_TIM12;
 801296e:	940a      	str	r4, [sp, #40]	@ 0x28
    __HAL_RCC_GPIOH_CLK_ENABLE();
 8012970:	f003 0380 	and.w	r3, r3, #128	@ 0x80
    GPIO_InitStruct.Pin = ARDUINO_PWM_D6_Pin;
 8012974:	ed9f 7b0c 	vldr	d7, [pc, #48]	@ 80129a8 <HAL_TIM_MspPostInit+0x128>
    __HAL_RCC_GPIOH_CLK_ENABLE();
 8012978:	9305      	str	r3, [sp, #20]
 801297a:	9b05      	ldr	r3, [sp, #20]
    GPIO_InitStruct.Pin = ARDUINO_PWM_D6_Pin;
 801297c:	ed8d 7b06 	vstr	d7, [sp, #24]
    HAL_GPIO_Init(ARDUINO_PWM_D6_GPIO_Port, &GPIO_InitStruct);
 8012980:	f002 fb7c 	bl	801507c <HAL_GPIO_Init>
}
 8012984:	e794      	b.n	80128b0 <HAL_TIM_MspPostInit+0x30>
 8012986:	bf00      	nop
 8012988:	00000001 	.word	0x00000001
 801298c:	00000002 	.word	0x00000002
 8012990:	00000100 	.word	0x00000100
 8012994:	00000002 	.word	0x00000002
 8012998:	00008000 	.word	0x00008000
 801299c:	00000002 	.word	0x00000002
 80129a0:	00000010 	.word	0x00000010
 80129a4:	00000002 	.word	0x00000002
 80129a8:	00000040 	.word	0x00000040
 80129ac:	00000002 	.word	0x00000002
 80129b0:	40010000 	.word	0x40010000
 80129b4:	40000400 	.word	0x40000400
 80129b8:	40000c00 	.word	0x40000c00
 80129bc:	40001800 	.word	0x40001800
 80129c0:	40022000 	.word	0x40022000
 80129c4:	40023800 	.word	0x40023800
 80129c8:	40020000 	.word	0x40020000
 80129cc:	40020400 	.word	0x40020400
 80129d0:	40021c00 	.word	0x40021c00

080129d4 <HAL_UART_MspInit>:
* This function configures the hardware resources used in this example
* @param huart: UART handle pointer
* @retval None
*/
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 80129d4:	b5d0      	push	{r4, r6, r7, lr}
 80129d6:	b0ac      	sub	sp, #176	@ 0xb0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80129d8:	2100      	movs	r1, #0
{
 80129da:	4604      	mov	r4, r0
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 80129dc:	2284      	movs	r2, #132	@ 0x84
 80129de:	a80b      	add	r0, sp, #44	@ 0x2c
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80129e0:	910a      	str	r1, [sp, #40]	@ 0x28
 80129e2:	e9cd 1106 	strd	r1, r1, [sp, #24]
 80129e6:	e9cd 1108 	strd	r1, r1, [sp, #32]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 80129ea:	f020 fb09 	bl	8033000 <memset>
  if(huart->Instance==USART1)
 80129ee:	6823      	ldr	r3, [r4, #0]
 80129f0:	4a3b      	ldr	r2, [pc, #236]	@ (8012ae0 <HAL_UART_MspInit+0x10c>)
 80129f2:	4293      	cmp	r3, r2
 80129f4:	d004      	beq.n	8012a00 <HAL_UART_MspInit+0x2c>

  /* USER CODE BEGIN USART1_MspInit 1 */

  /* USER CODE END USART1_MspInit 1 */
  }
  else if(huart->Instance==USART6)
 80129f6:	4a3b      	ldr	r2, [pc, #236]	@ (8012ae4 <HAL_UART_MspInit+0x110>)
 80129f8:	4293      	cmp	r3, r2
 80129fa:	d040      	beq.n	8012a7e <HAL_UART_MspInit+0xaa>
  /* USER CODE BEGIN USART6_MspInit 1 */

  /* USER CODE END USART6_MspInit 1 */
  }

}
 80129fc:	b02c      	add	sp, #176	@ 0xb0
 80129fe:	bdd0      	pop	{r4, r6, r7, pc}
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART1;
 8012a00:	2340      	movs	r3, #64	@ 0x40
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8012a02:	a80b      	add	r0, sp, #44	@ 0x2c
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART1;
 8012a04:	930b      	str	r3, [sp, #44]	@ 0x2c
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8012a06:	f005 fa27 	bl	8017e58 <HAL_RCCEx_PeriphCLKConfig>
 8012a0a:	2800      	cmp	r0, #0
 8012a0c:	d161      	bne.n	8012ad2 <HAL_UART_MspInit+0xfe>
    __HAL_RCC_USART1_CLK_ENABLE();
 8012a0e:	4b36      	ldr	r3, [pc, #216]	@ (8012ae8 <HAL_UART_MspInit+0x114>)
    GPIO_InitStruct.Pin = VCP_RX_Pin;
 8012a10:	2080      	movs	r0, #128	@ 0x80
 8012a12:	2102      	movs	r1, #2
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
 8012a14:	2407      	movs	r4, #7
    __HAL_RCC_USART1_CLK_ENABLE();
 8012a16:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
    GPIO_InitStruct.Pin = VCP_RX_Pin;
 8012a18:	2600      	movs	r6, #0
 8012a1a:	2700      	movs	r7, #0
    __HAL_RCC_USART1_CLK_ENABLE();
 8012a1c:	f042 0210 	orr.w	r2, r2, #16
 8012a20:	645a      	str	r2, [r3, #68]	@ 0x44
 8012a22:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 8012a24:	f002 0210 	and.w	r2, r2, #16
 8012a28:	9201      	str	r2, [sp, #4]
 8012a2a:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8012a2c:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8012a2e:	f042 0202 	orr.w	r2, r2, #2
 8012a32:	631a      	str	r2, [r3, #48]	@ 0x30
 8012a34:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8012a36:	f002 0202 	and.w	r2, r2, #2
 8012a3a:	9202      	str	r2, [sp, #8]
 8012a3c:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8012a3e:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8012a40:	f042 0201 	orr.w	r2, r2, #1
 8012a44:	631a      	str	r2, [r3, #48]	@ 0x30
 8012a46:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
 8012a48:	940a      	str	r4, [sp, #40]	@ 0x28
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8012a4a:	f003 0301 	and.w	r3, r3, #1
    GPIO_InitStruct.Pin = VCP_RX_Pin;
 8012a4e:	e9cd 0106 	strd	r0, r1, [sp, #24]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8012a52:	9303      	str	r3, [sp, #12]
    HAL_GPIO_Init(VCP_RX_GPIO_Port, &GPIO_InitStruct);
 8012a54:	a906      	add	r1, sp, #24
 8012a56:	4825      	ldr	r0, [pc, #148]	@ (8012aec <HAL_UART_MspInit+0x118>)
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8012a58:	9b03      	ldr	r3, [sp, #12]
    GPIO_InitStruct.Pin = VCP_RX_Pin;
 8012a5a:	e9cd 6708 	strd	r6, r7, [sp, #32]
    HAL_GPIO_Init(VCP_RX_GPIO_Port, &GPIO_InitStruct);
 8012a5e:	f002 fb0d 	bl	801507c <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = VCP_TX_Pin;
 8012a62:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8012a66:	2302      	movs	r3, #2
    HAL_GPIO_Init(VCP_TX_GPIO_Port, &GPIO_InitStruct);
 8012a68:	a906      	add	r1, sp, #24
 8012a6a:	4821      	ldr	r0, [pc, #132]	@ (8012af0 <HAL_UART_MspInit+0x11c>)
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
 8012a6c:	940a      	str	r4, [sp, #40]	@ 0x28
    GPIO_InitStruct.Pin = VCP_TX_Pin;
 8012a6e:	e9cd 6708 	strd	r6, r7, [sp, #32]
 8012a72:	e9cd 2306 	strd	r2, r3, [sp, #24]
    HAL_GPIO_Init(VCP_TX_GPIO_Port, &GPIO_InitStruct);
 8012a76:	f002 fb01 	bl	801507c <HAL_GPIO_Init>
}
 8012a7a:	b02c      	add	sp, #176	@ 0xb0
 8012a7c:	bdd0      	pop	{r4, r6, r7, pc}
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART6;
 8012a7e:	f44f 6300 	mov.w	r3, #2048	@ 0x800
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8012a82:	a80b      	add	r0, sp, #44	@ 0x2c
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART6;
 8012a84:	930b      	str	r3, [sp, #44]	@ 0x2c
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8012a86:	f005 f9e7 	bl	8017e58 <HAL_RCCEx_PeriphCLKConfig>
 8012a8a:	bb28      	cbnz	r0, 8012ad8 <HAL_UART_MspInit+0x104>
    __HAL_RCC_USART6_CLK_ENABLE();
 8012a8c:	4b16      	ldr	r3, [pc, #88]	@ (8012ae8 <HAL_UART_MspInit+0x114>)
    GPIO_InitStruct.Pin = ARDUINO_RX_D0_Pin|ARDUINO_TX_D1_Pin;
 8012a8e:	26c0      	movs	r6, #192	@ 0xc0
 8012a90:	2702      	movs	r7, #2
    GPIO_InitStruct.Alternate = GPIO_AF8_USART6;
 8012a92:	2408      	movs	r4, #8
    __HAL_RCC_USART6_CLK_ENABLE();
 8012a94:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8012a96:	a906      	add	r1, sp, #24
 8012a98:	4816      	ldr	r0, [pc, #88]	@ (8012af4 <HAL_UART_MspInit+0x120>)
    __HAL_RCC_USART6_CLK_ENABLE();
 8012a9a:	f042 0220 	orr.w	r2, r2, #32
 8012a9e:	645a      	str	r2, [r3, #68]	@ 0x44
 8012aa0:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 8012aa2:	f002 0220 	and.w	r2, r2, #32
 8012aa6:	9204      	str	r2, [sp, #16]
 8012aa8:	9a04      	ldr	r2, [sp, #16]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8012aaa:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8012aac:	f042 0204 	orr.w	r2, r2, #4
 8012ab0:	631a      	str	r2, [r3, #48]	@ 0x30
 8012ab2:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
    GPIO_InitStruct.Alternate = GPIO_AF8_USART6;
 8012ab4:	940a      	str	r4, [sp, #40]	@ 0x28
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8012ab6:	f003 0304 	and.w	r3, r3, #4
 8012aba:	9305      	str	r3, [sp, #20]
 8012abc:	9b05      	ldr	r3, [sp, #20]
    GPIO_InitStruct.Pin = ARDUINO_RX_D0_Pin|ARDUINO_TX_D1_Pin;
 8012abe:	e9cd 6706 	strd	r6, r7, [sp, #24]
 8012ac2:	2600      	movs	r6, #0
 8012ac4:	2703      	movs	r7, #3
 8012ac6:	e9cd 6708 	strd	r6, r7, [sp, #32]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8012aca:	f002 fad7 	bl	801507c <HAL_GPIO_Init>
}
 8012ace:	b02c      	add	sp, #176	@ 0xb0
 8012ad0:	bdd0      	pop	{r4, r6, r7, pc}
      Error_Handler();
 8012ad2:	f7ff f9f5 	bl	8011ec0 <Error_Handler>
 8012ad6:	e79a      	b.n	8012a0e <HAL_UART_MspInit+0x3a>
      Error_Handler();
 8012ad8:	f7ff f9f2 	bl	8011ec0 <Error_Handler>
 8012adc:	e7d6      	b.n	8012a8c <HAL_UART_MspInit+0xb8>
 8012ade:	bf00      	nop
 8012ae0:	40011000 	.word	0x40011000
 8012ae4:	40011400 	.word	0x40011400
 8012ae8:	40023800 	.word	0x40023800
 8012aec:	40020400 	.word	0x40020400
 8012af0:	40020000 	.word	0x40020000
 8012af4:	40020800 	.word	0x40020800

08012af8 <HAL_SDRAM_MspInit>:
static void HAL_FMC_MspInit(void){
  /* USER CODE BEGIN FMC_MspInit 0 */

  /* USER CODE END FMC_MspInit 0 */
  GPIO_InitTypeDef GPIO_InitStruct ={0};
  if (FMC_Initialized) {
 8012af8:	4b2b      	ldr	r3, [pc, #172]	@ (8012ba8 <HAL_SDRAM_MspInit+0xb0>)
  GPIO_InitTypeDef GPIO_InitStruct ={0};
 8012afa:	2200      	movs	r2, #0
  /* USER CODE BEGIN FMC_MspInit 1 */

  /* USER CODE END FMC_MspInit 1 */
}

void HAL_SDRAM_MspInit(SDRAM_HandleTypeDef* hsdram){
 8012afc:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (FMC_Initialized) {
 8012afe:	681c      	ldr	r4, [r3, #0]
void HAL_SDRAM_MspInit(SDRAM_HandleTypeDef* hsdram){
 8012b00:	b089      	sub	sp, #36	@ 0x24
  GPIO_InitTypeDef GPIO_InitStruct ={0};
 8012b02:	9204      	str	r2, [sp, #16]
  if (FMC_Initialized) {
 8012b04:	2c00      	cmp	r4, #0
 8012b06:	d14c      	bne.n	8012ba2 <HAL_SDRAM_MspInit+0xaa>
  __HAL_RCC_FMC_CLK_ENABLE();
 8012b08:	4a28      	ldr	r2, [pc, #160]	@ (8012bac <HAL_SDRAM_MspInit+0xb4>)
  FMC_Initialized = 1;
 8012b0a:	2101      	movs	r1, #1
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8012b0c:	2603      	movs	r6, #3
 8012b0e:	250c      	movs	r5, #12
  FMC_Initialized = 1;
 8012b10:	6019      	str	r1, [r3, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8012b12:	2702      	movs	r7, #2
  __HAL_RCC_FMC_CLK_ENABLE();
 8012b14:	6b93      	ldr	r3, [r2, #56]	@ 0x38
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8012b16:	4826      	ldr	r0, [pc, #152]	@ (8012bb0 <HAL_SDRAM_MspInit+0xb8>)
  __HAL_RCC_FMC_CLK_ENABLE();
 8012b18:	430b      	orrs	r3, r1
 8012b1a:	6393      	str	r3, [r2, #56]	@ 0x38
 8012b1c:	6b93      	ldr	r3, [r2, #56]	@ 0x38
  GPIO_InitStruct.Pin = FMC_NBL1_Pin|FMC_NBL0_Pin|FMC_D5_Pin|FMC_D6_Pin
 8012b1e:	f64f 7283 	movw	r2, #65411	@ 0xff83
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8012b22:	9605      	str	r6, [sp, #20]
  __HAL_RCC_FMC_CLK_ENABLE();
 8012b24:	400b      	ands	r3, r1
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8012b26:	9506      	str	r5, [sp, #24]
  __HAL_RCC_FMC_CLK_ENABLE();
 8012b28:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Pin = FMC_NBL1_Pin|FMC_NBL0_Pin|FMC_D5_Pin|FMC_D6_Pin
 8012b2a:	2302      	movs	r3, #2
  __HAL_RCC_FMC_CLK_ENABLE();
 8012b2c:	9901      	ldr	r1, [sp, #4]
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8012b2e:	a902      	add	r1, sp, #8
  GPIO_InitStruct.Pin = FMC_NBL1_Pin|FMC_NBL0_Pin|FMC_D5_Pin|FMC_D6_Pin
 8012b30:	e9cd 2302 	strd	r2, r3, [sp, #8]
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8012b34:	f002 faa2 	bl	801507c <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = FMC_SDNCAS_Pin|FMC_SDCLK_Pin|FMC_A11_Pin|FMC_A10_Pin
 8012b38:	f248 1333 	movw	r3, #33075	@ 0x8133
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 8012b3c:	a902      	add	r1, sp, #8
 8012b3e:	481d      	ldr	r0, [pc, #116]	@ (8012bb4 <HAL_SDRAM_MspInit+0xbc>)
  GPIO_InitStruct.Pin = FMC_SDNCAS_Pin|FMC_SDCLK_Pin|FMC_A11_Pin|FMC_A10_Pin
 8012b40:	9302      	str	r3, [sp, #8]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 8012b42:	9506      	str	r5, [sp, #24]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8012b44:	9703      	str	r7, [sp, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8012b46:	e9cd 4604 	strd	r4, r6, [sp, #16]
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 8012b4a:	f002 fa97 	bl	801507c <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = FMC_D2_Pin|FMC_D3_Pin|FMC_D1_Pin|FMC_D15_Pin
 8012b4e:	f24c 7303 	movw	r3, #50947	@ 0xc703
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8012b52:	a902      	add	r1, sp, #8
 8012b54:	4818      	ldr	r0, [pc, #96]	@ (8012bb8 <HAL_SDRAM_MspInit+0xc0>)
  GPIO_InitStruct.Pin = FMC_D2_Pin|FMC_D3_Pin|FMC_D1_Pin|FMC_D15_Pin
 8012b56:	9302      	str	r3, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8012b58:	e9cd 7403 	strd	r7, r4, [sp, #12]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 8012b5c:	e9cd 6505 	strd	r6, r5, [sp, #20]
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8012b60:	f002 fa8c 	bl	801507c <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = FMC_A0_Pin|FMC_A1_Pin|FMC_A2_Pin|FMC_A3_Pin
 8012b64:	f64f 033f 	movw	r3, #63551	@ 0xf83f
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 8012b68:	a902      	add	r1, sp, #8
 8012b6a:	4814      	ldr	r0, [pc, #80]	@ (8012bbc <HAL_SDRAM_MspInit+0xc4>)
  GPIO_InitStruct.Pin = FMC_A0_Pin|FMC_A1_Pin|FMC_A2_Pin|FMC_A3_Pin
 8012b6c:	9302      	str	r3, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8012b6e:	e9cd 7403 	strd	r7, r4, [sp, #12]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 8012b72:	e9cd 6505 	strd	r6, r5, [sp, #20]
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 8012b76:	f002 fa81 	bl	801507c <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = FMC_SDNME_Pin|FMC_SDNE0_Pin;
 8012b7a:	2328      	movs	r3, #40	@ 0x28
  HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
 8012b7c:	a902      	add	r1, sp, #8
 8012b7e:	4810      	ldr	r0, [pc, #64]	@ (8012bc0 <HAL_SDRAM_MspInit+0xc8>)
  GPIO_InitStruct.Pin = FMC_SDNME_Pin|FMC_SDNE0_Pin;
 8012b80:	9302      	str	r3, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8012b82:	e9cd 7403 	strd	r7, r4, [sp, #12]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 8012b86:	e9cd 6505 	strd	r6, r5, [sp, #20]
  HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
 8012b8a:	f002 fa77 	bl	801507c <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = FMC_SDCKE0_Pin;
 8012b8e:	2308      	movs	r3, #8
  HAL_GPIO_Init(FMC_SDCKE0_GPIO_Port, &GPIO_InitStruct);
 8012b90:	a902      	add	r1, sp, #8
 8012b92:	480c      	ldr	r0, [pc, #48]	@ (8012bc4 <HAL_SDRAM_MspInit+0xcc>)
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8012b94:	9703      	str	r7, [sp, #12]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 8012b96:	9506      	str	r5, [sp, #24]
  GPIO_InitStruct.Pin = FMC_SDCKE0_Pin;
 8012b98:	9302      	str	r3, [sp, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8012b9a:	e9cd 4604 	strd	r4, r6, [sp, #16]
  HAL_GPIO_Init(FMC_SDCKE0_GPIO_Port, &GPIO_InitStruct);
 8012b9e:	f002 fa6d 	bl	801507c <HAL_GPIO_Init>
  /* USER CODE END SDRAM_MspInit 0 */
  HAL_FMC_MspInit();
  /* USER CODE BEGIN SDRAM_MspInit 1 */

  /* USER CODE END SDRAM_MspInit 1 */
}
 8012ba2:	b009      	add	sp, #36	@ 0x24
 8012ba4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8012ba6:	bf00      	nop
 8012ba8:	20002b74 	.word	0x20002b74
 8012bac:	40023800 	.word	0x40023800
 8012bb0:	40021000 	.word	0x40021000
 8012bb4:	40021800 	.word	0x40021800
 8012bb8:	40020c00 	.word	0x40020c00
 8012bbc:	40021400 	.word	0x40021400
 8012bc0:	40021c00 	.word	0x40021c00
 8012bc4:	40020800 	.word	0x40020800

08012bc8 <HAL_SAI_MspInit>:
void HAL_SAI_MspInit(SAI_HandleTypeDef* hsai)
{

  GPIO_InitTypeDef GPIO_InitStruct;
/* SAI2 */
    if(hsai->Instance==SAI2_Block_A)
 8012bc8:	4a29      	ldr	r2, [pc, #164]	@ (8012c70 <HAL_SAI_MspInit+0xa8>)
 8012bca:	6803      	ldr	r3, [r0, #0]
 8012bcc:	4293      	cmp	r3, r2
{
 8012bce:	b510      	push	{r4, lr}
 8012bd0:	b088      	sub	sp, #32
    if(hsai->Instance==SAI2_Block_A)
 8012bd2:	d004      	beq.n	8012bde <HAL_SAI_MspInit+0x16>
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF10_SAI2;
    HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);

    }
    if(hsai->Instance==SAI2_Block_B)
 8012bd4:	4a27      	ldr	r2, [pc, #156]	@ (8012c74 <HAL_SAI_MspInit+0xac>)
 8012bd6:	4293      	cmp	r3, r2
 8012bd8:	d023      	beq.n	8012c22 <HAL_SAI_MspInit+0x5a>
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF10_SAI2;
    HAL_GPIO_Init(SAI2_SDB_GPIO_Port, &GPIO_InitStruct);

    }
}
 8012bda:	b008      	add	sp, #32
 8012bdc:	bd10      	pop	{r4, pc}
    if (SAI2_client == 0)
 8012bde:	4b26      	ldr	r3, [pc, #152]	@ (8012c78 <HAL_SAI_MspInit+0xb0>)
 8012be0:	4604      	mov	r4, r0
 8012be2:	681a      	ldr	r2, [r3, #0]
 8012be4:	b94a      	cbnz	r2, 8012bfa <HAL_SAI_MspInit+0x32>
       __HAL_RCC_SAI2_CLK_ENABLE();
 8012be6:	4925      	ldr	r1, [pc, #148]	@ (8012c7c <HAL_SAI_MspInit+0xb4>)
 8012be8:	6c48      	ldr	r0, [r1, #68]	@ 0x44
 8012bea:	f440 0000 	orr.w	r0, r0, #8388608	@ 0x800000
 8012bee:	6448      	str	r0, [r1, #68]	@ 0x44
 8012bf0:	6c49      	ldr	r1, [r1, #68]	@ 0x44
 8012bf2:	f401 0100 	and.w	r1, r1, #8388608	@ 0x800000
 8012bf6:	9100      	str	r1, [sp, #0]
 8012bf8:	9900      	ldr	r1, [sp, #0]
    SAI2_client ++;
 8012bfa:	3201      	adds	r2, #1
    GPIO_InitStruct.Pin = SAI2_MCLKA_Pin|SAI2_SCKA_Pin|SAI2_FSA_Pin|SAI2_SDA_Pin;
 8012bfc:	20f0      	movs	r0, #240	@ 0xf0
 8012bfe:	2102      	movs	r1, #2
    SAI2_client ++;
 8012c00:	601a      	str	r2, [r3, #0]
    GPIO_InitStruct.Alternate = GPIO_AF10_SAI2;
 8012c02:	230a      	movs	r3, #10
    GPIO_InitStruct.Pin = SAI2_MCLKA_Pin|SAI2_SCKA_Pin|SAI2_FSA_Pin|SAI2_SDA_Pin;
 8012c04:	ed9f 7b16 	vldr	d7, [pc, #88]	@ 8012c60 <HAL_SAI_MspInit+0x98>
 8012c08:	e9cd 0102 	strd	r0, r1, [sp, #8]
    HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
 8012c0c:	a902      	add	r1, sp, #8
 8012c0e:	481c      	ldr	r0, [pc, #112]	@ (8012c80 <HAL_SAI_MspInit+0xb8>)
    GPIO_InitStruct.Alternate = GPIO_AF10_SAI2;
 8012c10:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Pin = SAI2_MCLKA_Pin|SAI2_SCKA_Pin|SAI2_FSA_Pin|SAI2_SDA_Pin;
 8012c12:	ed8d 7b04 	vstr	d7, [sp, #16]
    HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
 8012c16:	f002 fa31 	bl	801507c <HAL_GPIO_Init>
    if(hsai->Instance==SAI2_Block_B)
 8012c1a:	6823      	ldr	r3, [r4, #0]
 8012c1c:	4a15      	ldr	r2, [pc, #84]	@ (8012c74 <HAL_SAI_MspInit+0xac>)
 8012c1e:	4293      	cmp	r3, r2
 8012c20:	d1db      	bne.n	8012bda <HAL_SAI_MspInit+0x12>
      if (SAI2_client == 0)
 8012c22:	4b15      	ldr	r3, [pc, #84]	@ (8012c78 <HAL_SAI_MspInit+0xb0>)
 8012c24:	681a      	ldr	r2, [r3, #0]
 8012c26:	b94a      	cbnz	r2, 8012c3c <HAL_SAI_MspInit+0x74>
       __HAL_RCC_SAI2_CLK_ENABLE();
 8012c28:	4914      	ldr	r1, [pc, #80]	@ (8012c7c <HAL_SAI_MspInit+0xb4>)
 8012c2a:	6c48      	ldr	r0, [r1, #68]	@ 0x44
 8012c2c:	f440 0000 	orr.w	r0, r0, #8388608	@ 0x800000
 8012c30:	6448      	str	r0, [r1, #68]	@ 0x44
 8012c32:	6c49      	ldr	r1, [r1, #68]	@ 0x44
 8012c34:	f401 0100 	and.w	r1, r1, #8388608	@ 0x800000
 8012c38:	9101      	str	r1, [sp, #4]
 8012c3a:	9901      	ldr	r1, [sp, #4]
    SAI2_client ++;
 8012c3c:	3201      	adds	r2, #1
    GPIO_InitStruct.Alternate = GPIO_AF10_SAI2;
 8012c3e:	210a      	movs	r1, #10
    HAL_GPIO_Init(SAI2_SDB_GPIO_Port, &GPIO_InitStruct);
 8012c40:	4810      	ldr	r0, [pc, #64]	@ (8012c84 <HAL_SAI_MspInit+0xbc>)
    SAI2_client ++;
 8012c42:	601a      	str	r2, [r3, #0]
    GPIO_InitStruct.Pin = SAI2_SDB_Pin;
 8012c44:	2200      	movs	r2, #0
 8012c46:	2300      	movs	r3, #0
    GPIO_InitStruct.Alternate = GPIO_AF10_SAI2;
 8012c48:	9106      	str	r1, [sp, #24]
    HAL_GPIO_Init(SAI2_SDB_GPIO_Port, &GPIO_InitStruct);
 8012c4a:	a902      	add	r1, sp, #8
    GPIO_InitStruct.Pin = SAI2_SDB_Pin;
 8012c4c:	ed9f 7b06 	vldr	d7, [pc, #24]	@ 8012c68 <HAL_SAI_MspInit+0xa0>
 8012c50:	e9cd 2304 	strd	r2, r3, [sp, #16]
 8012c54:	ed8d 7b02 	vstr	d7, [sp, #8]
    HAL_GPIO_Init(SAI2_SDB_GPIO_Port, &GPIO_InitStruct);
 8012c58:	f002 fa10 	bl	801507c <HAL_GPIO_Init>
}
 8012c5c:	b008      	add	sp, #32
 8012c5e:	bd10      	pop	{r4, pc}
	...
 8012c68:	00000400 	.word	0x00000400
 8012c6c:	00000002 	.word	0x00000002
 8012c70:	40015c04 	.word	0x40015c04
 8012c74:	40015c24 	.word	0x40015c24
 8012c78:	20002b70 	.word	0x20002b70
 8012c7c:	40023800 	.word	0x40023800
 8012c80:	40022000 	.word	0x40022000
 8012c84:	40021800 	.word	0x40021800

08012c88 <HAL_InitTick>:
  uint32_t              uwPrescalerValue = 0U;
  uint32_t              pFLatency;
  HAL_StatusTypeDef     status;

  /* Enable TIM6 clock */
  __HAL_RCC_TIM6_CLK_ENABLE();
 8012c88:	4b23      	ldr	r3, [pc, #140]	@ (8012d18 <HAL_InitTick+0x90>)
 8012c8a:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 8012c8c:	f042 0210 	orr.w	r2, r2, #16
{
 8012c90:	b570      	push	{r4, r5, r6, lr}
  __HAL_RCC_TIM6_CLK_ENABLE();
 8012c92:	641a      	str	r2, [r3, #64]	@ 0x40
{
 8012c94:	b088      	sub	sp, #32
  __HAL_RCC_TIM6_CLK_ENABLE();
 8012c96:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
{
 8012c98:	4605      	mov	r5, r0
  /* Get clock configuration */
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 8012c9a:	a901      	add	r1, sp, #4
 8012c9c:	a803      	add	r0, sp, #12
  __HAL_RCC_TIM6_CLK_ENABLE();
 8012c9e:	f003 0310 	and.w	r3, r3, #16
 8012ca2:	9302      	str	r3, [sp, #8]
 8012ca4:	9b02      	ldr	r3, [sp, #8]
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 8012ca6:	f005 f8b5 	bl	8017e14 <HAL_RCC_GetClockConfig>
  /* Get APB1 prescaler */
  uwAPB1Prescaler = clkconfig.APB1CLKDivider;
  /* Compute TIM6 clock */
  if (uwAPB1Prescaler == RCC_HCLK_DIV1)
 8012caa:	9b06      	ldr	r3, [sp, #24]
 8012cac:	b9d3      	cbnz	r3, 8012ce4 <HAL_InitTick+0x5c>
  {
    uwTimclock = HAL_RCC_GetPCLK1Freq();
 8012cae:	f005 f891 	bl	8017dd4 <HAL_RCC_GetPCLK1Freq>
 8012cb2:	4603      	mov	r3, r0
  {
    uwTimclock = 2UL * HAL_RCC_GetPCLK1Freq();
  }

  /* Compute the prescaler value to have TIM6 counter clock equal to 1MHz */
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 8012cb4:	4a19      	ldr	r2, [pc, #100]	@ (8012d1c <HAL_InitTick+0x94>)

  /* Initialize TIM6 */
  htim6.Instance = TIM6;
 8012cb6:	4c1a      	ldr	r4, [pc, #104]	@ (8012d20 <HAL_InitTick+0x98>)
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 8012cb8:	fba2 2303 	umull	r2, r3, r2, r3
  htim6.Instance = TIM6;
 8012cbc:	4919      	ldr	r1, [pc, #100]	@ (8012d24 <HAL_InitTick+0x9c>)
  + ClockDivision = 0
  + Counter direction = Up
  */
  htim6.Init.Period = (1000000U / 1000U) - 1U;
  htim6.Init.Prescaler = uwPrescalerValue;
  htim6.Init.ClockDivision = 0;
 8012cbe:	2200      	movs	r2, #0
  htim6.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim6.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;

  status = HAL_TIM_Base_Init(&htim6);
 8012cc0:	4620      	mov	r0, r4
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 8012cc2:	0c9b      	lsrs	r3, r3, #18
  htim6.Instance = TIM6;
 8012cc4:	6021      	str	r1, [r4, #0]
  htim6.Init.Period = (1000000U / 1000U) - 1U;
 8012cc6:	f240 31e7 	movw	r1, #999	@ 0x3e7
  htim6.Init.CounterMode = TIM_COUNTERMODE_UP;
 8012cca:	60a2      	str	r2, [r4, #8]
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 8012ccc:	3b01      	subs	r3, #1
  htim6.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8012cce:	61a2      	str	r2, [r4, #24]
  htim6.Init.Period = (1000000U / 1000U) - 1U;
 8012cd0:	e9c4 1203 	strd	r1, r2, [r4, #12]
  htim6.Init.Prescaler = uwPrescalerValue;
 8012cd4:	6063      	str	r3, [r4, #4]
  status = HAL_TIM_Base_Init(&htim6);
 8012cd6:	f006 fd75 	bl	80197c4 <HAL_TIM_Base_Init>
  if (status == HAL_OK)
 8012cda:	4606      	mov	r6, r0
 8012cdc:	b130      	cbz	r0, 8012cec <HAL_InitTick+0x64>
    }
  }

 /* Return function status */
  return status;
}
 8012cde:	4630      	mov	r0, r6
 8012ce0:	b008      	add	sp, #32
 8012ce2:	bd70      	pop	{r4, r5, r6, pc}
    uwTimclock = 2UL * HAL_RCC_GetPCLK1Freq();
 8012ce4:	f005 f876 	bl	8017dd4 <HAL_RCC_GetPCLK1Freq>
 8012ce8:	0043      	lsls	r3, r0, #1
 8012cea:	e7e3      	b.n	8012cb4 <HAL_InitTick+0x2c>
    status = HAL_TIM_Base_Start_IT(&htim6);
 8012cec:	4620      	mov	r0, r4
 8012cee:	f006 fe09 	bl	8019904 <HAL_TIM_Base_Start_IT>
    if (status == HAL_OK)
 8012cf2:	4606      	mov	r6, r0
 8012cf4:	2800      	cmp	r0, #0
 8012cf6:	d1f2      	bne.n	8012cde <HAL_InitTick+0x56>
        HAL_NVIC_EnableIRQ(TIM6_DAC_IRQn);
 8012cf8:	2036      	movs	r0, #54	@ 0x36
 8012cfa:	f000 fa89 	bl	8013210 <HAL_NVIC_EnableIRQ>
      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8012cfe:	2d0f      	cmp	r5, #15
 8012d00:	d901      	bls.n	8012d06 <HAL_InitTick+0x7e>
        status = HAL_ERROR;
 8012d02:	2601      	movs	r6, #1
 8012d04:	e7eb      	b.n	8012cde <HAL_InitTick+0x56>
        HAL_NVIC_SetPriority(TIM6_DAC_IRQn, TickPriority, 0U);
 8012d06:	4632      	mov	r2, r6
 8012d08:	4629      	mov	r1, r5
 8012d0a:	2036      	movs	r0, #54	@ 0x36
 8012d0c:	f000 fa44 	bl	8013198 <HAL_NVIC_SetPriority>
        uwTickPrio = TickPriority;
 8012d10:	4b05      	ldr	r3, [pc, #20]	@ (8012d28 <HAL_InitTick+0xa0>)
 8012d12:	601d      	str	r5, [r3, #0]
 8012d14:	e7e3      	b.n	8012cde <HAL_InitTick+0x56>
 8012d16:	bf00      	nop
 8012d18:	40023800 	.word	0x40023800
 8012d1c:	431bde83 	.word	0x431bde83
 8012d20:	20002b78 	.word	0x20002b78
 8012d24:	40001000 	.word	0x40001000
 8012d28:	20000014 	.word	0x20000014

08012d2c <NMI_Handler>:
{
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
   while (1)
 8012d2c:	e7fe      	b.n	8012d2c <NMI_Handler>
 8012d2e:	bf00      	nop

08012d30 <HardFault_Handler>:
void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8012d30:	e7fe      	b.n	8012d30 <HardFault_Handler>
 8012d32:	bf00      	nop

08012d34 <MemManage_Handler>:
void MemManage_Handler(void)
{
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 8012d34:	e7fe      	b.n	8012d34 <MemManage_Handler>
 8012d36:	bf00      	nop

08012d38 <BusFault_Handler>:
void BusFault_Handler(void)
{
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 8012d38:	e7fe      	b.n	8012d38 <BusFault_Handler>
 8012d3a:	bf00      	nop

08012d3c <UsageFault_Handler>:
void UsageFault_Handler(void)
{
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 8012d3c:	e7fe      	b.n	8012d3c <UsageFault_Handler>
 8012d3e:	bf00      	nop

08012d40 <DebugMon_Handler>:

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 8012d40:	4770      	bx	lr
 8012d42:	bf00      	nop

08012d44 <TIM6_DAC_IRQHandler>:
void TIM6_DAC_IRQHandler(void)
{
  /* USER CODE BEGIN TIM6_DAC_IRQn 0 */

  /* USER CODE END TIM6_DAC_IRQn 0 */
  HAL_TIM_IRQHandler(&htim6);
 8012d44:	4801      	ldr	r0, [pc, #4]	@ (8012d4c <TIM6_DAC_IRQHandler+0x8>)
 8012d46:	f007 b901 	b.w	8019f4c <HAL_TIM_IRQHandler>
 8012d4a:	bf00      	nop
 8012d4c:	20002b78 	.word	0x20002b78

08012d50 <DMA2_Stream1_IRQHandler>:
void DMA2_Stream1_IRQHandler(void)
{
  /* USER CODE BEGIN DMA2_Stream1_IRQn 0 */

  /* USER CODE END DMA2_Stream1_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_dcmi);
 8012d50:	4801      	ldr	r0, [pc, #4]	@ (8012d58 <DMA2_Stream1_IRQHandler+0x8>)
 8012d52:	f000 bdb1 	b.w	80138b8 <HAL_DMA_IRQHandler>
 8012d56:	bf00      	nop
 8012d58:	20002a1c 	.word	0x20002a1c

08012d5c <OTG_FS_IRQHandler>:
void OTG_FS_IRQHandler(void)
{
  /* USER CODE BEGIN OTG_FS_IRQn 0 */

  /* USER CODE END OTG_FS_IRQn 0 */
  HAL_PCD_IRQHandler(&hpcd_USB_OTG_FS);
 8012d5c:	4801      	ldr	r0, [pc, #4]	@ (8012d64 <OTG_FS_IRQHandler+0x8>)
 8012d5e:	f003 bcf5 	b.w	801674c <HAL_PCD_IRQHandler>
 8012d62:	bf00      	nop
 8012d64:	2000ce14 	.word	0x2000ce14

08012d68 <DCMI_IRQHandler>:
void DCMI_IRQHandler(void)
{
  /* USER CODE BEGIN DCMI_IRQn 0 */

  /* USER CODE END DCMI_IRQn 0 */
  HAL_DCMI_IRQHandler(&hdcmi);
 8012d68:	4801      	ldr	r0, [pc, #4]	@ (8012d70 <DCMI_IRQHandler+0x8>)
 8012d6a:	f000 bbfb 	b.w	8013564 <HAL_DCMI_IRQHandler>
 8012d6e:	bf00      	nop
 8012d70:	20002a7c 	.word	0x20002a7c

08012d74 <LTDC_IRQHandler>:
void LTDC_IRQHandler(void)
{
  /* USER CODE BEGIN LTDC_IRQn 0 */

  /* USER CODE END LTDC_IRQn 0 */
  HAL_LTDC_IRQHandler(&hltdc);
 8012d74:	4801      	ldr	r0, [pc, #4]	@ (8012d7c <LTDC_IRQHandler+0x8>)
 8012d76:	f003 b8b7 	b.w	8015ee8 <HAL_LTDC_IRQHandler>
 8012d7a:	bf00      	nop
 8012d7c:	200027dc 	.word	0x200027dc

08012d80 <DMA2D_IRQHandler>:
void DMA2D_IRQHandler(void)
{
  /* USER CODE BEGIN DMA2D_IRQn 0 */

  /* USER CODE END DMA2D_IRQn 0 */
  HAL_DMA2D_IRQHandler(&hdma2d);
 8012d80:	4801      	ldr	r0, [pc, #4]	@ (8012d88 <DMA2D_IRQHandler+0x8>)
 8012d82:	f000 bea1 	b.w	8013ac8 <HAL_DMA2D_IRQHandler>
 8012d86:	bf00      	nop
 8012d88:	200029dc 	.word	0x200029dc

08012d8c <_sbrk>:
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
  const uint8_t *max_heap = (uint8_t *)stack_limit;
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 8012d8c:	490d      	ldr	r1, [pc, #52]	@ (8012dc4 <_sbrk+0x38>)
{
 8012d8e:	4603      	mov	r3, r0
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 8012d90:	4a0d      	ldr	r2, [pc, #52]	@ (8012dc8 <_sbrk+0x3c>)
  if (NULL == __sbrk_heap_end)
 8012d92:	6808      	ldr	r0, [r1, #0]
{
 8012d94:	b510      	push	{r4, lr}
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 8012d96:	4c0d      	ldr	r4, [pc, #52]	@ (8012dcc <_sbrk+0x40>)
 8012d98:	1b12      	subs	r2, r2, r4
  if (NULL == __sbrk_heap_end)
 8012d9a:	b120      	cbz	r0, 8012da6 <_sbrk+0x1a>
  {
    __sbrk_heap_end = &_end;
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 8012d9c:	4403      	add	r3, r0
 8012d9e:	4293      	cmp	r3, r2
 8012da0:	d807      	bhi.n	8012db2 <_sbrk+0x26>
    errno = ENOMEM;
    return (void *)-1;
  }

  prev_heap_end = __sbrk_heap_end;
  __sbrk_heap_end += incr;
 8012da2:	600b      	str	r3, [r1, #0]

  return (void *)prev_heap_end;
}
 8012da4:	bd10      	pop	{r4, pc}
    __sbrk_heap_end = &_end;
 8012da6:	4c0a      	ldr	r4, [pc, #40]	@ (8012dd0 <_sbrk+0x44>)
 8012da8:	4620      	mov	r0, r4
 8012daa:	600c      	str	r4, [r1, #0]
  if (__sbrk_heap_end + incr > max_heap)
 8012dac:	4403      	add	r3, r0
 8012dae:	4293      	cmp	r3, r2
 8012db0:	d9f7      	bls.n	8012da2 <_sbrk+0x16>
    errno = ENOMEM;
 8012db2:	f020 f9cb 	bl	803314c <__errno>
 8012db6:	220c      	movs	r2, #12
 8012db8:	4603      	mov	r3, r0
    return (void *)-1;
 8012dba:	f04f 30ff 	mov.w	r0, #4294967295
    errno = ENOMEM;
 8012dbe:	601a      	str	r2, [r3, #0]
}
 8012dc0:	bd10      	pop	{r4, pc}
 8012dc2:	bf00      	nop
 8012dc4:	20002bc4 	.word	0x20002bc4
 8012dc8:	20050000 	.word	0x20050000
 8012dcc:	00001000 	.word	0x00001000
 8012dd0:	20012398 	.word	0x20012398

08012dd4 <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8012dd4:	4a03      	ldr	r2, [pc, #12]	@ (8012de4 <SystemInit+0x10>)
 8012dd6:	f8d2 3088 	ldr.w	r3, [r2, #136]	@ 0x88
 8012dda:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
 8012dde:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#endif /* USER_VECT_TAB_ADDRESS */
}
 8012de2:	4770      	bx	lr
 8012de4:	e000ed00 	.word	0xe000ed00

08012de8 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack      /* set stack pointer */
 8012de8:	f8df d034 	ldr.w	sp, [pc, #52]	@ 8012e20 <LoopFillZerobss+0xe>
  
/* Call the clock system initialization function.*/
  bl  SystemInit   
 8012dec:	f7ff fff2 	bl	8012dd4 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */  
  ldr r0, =_sdata
 8012df0:	480c      	ldr	r0, [pc, #48]	@ (8012e24 <LoopFillZerobss+0x12>)
  ldr r1, =_edata
 8012df2:	490d      	ldr	r1, [pc, #52]	@ (8012e28 <LoopFillZerobss+0x16>)
  ldr r2, =_sidata
 8012df4:	4a0d      	ldr	r2, [pc, #52]	@ (8012e2c <LoopFillZerobss+0x1a>)
  movs r3, #0
 8012df6:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8012df8:	e002      	b.n	8012e00 <LoopCopyDataInit>

08012dfa <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8012dfa:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8012dfc:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8012dfe:	3304      	adds	r3, #4

08012e00 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8012e00:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8012e02:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8012e04:	d3f9      	bcc.n	8012dfa <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8012e06:	4a0a      	ldr	r2, [pc, #40]	@ (8012e30 <LoopFillZerobss+0x1e>)
  ldr r4, =_ebss
 8012e08:	4c0a      	ldr	r4, [pc, #40]	@ (8012e34 <LoopFillZerobss+0x22>)
  movs r3, #0
 8012e0a:	2300      	movs	r3, #0
  b LoopFillZerobss
 8012e0c:	e001      	b.n	8012e12 <LoopFillZerobss>

08012e0e <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8012e0e:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8012e10:	3204      	adds	r2, #4

08012e12 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 8012e12:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8012e14:	d3fb      	bcc.n	8012e0e <FillZerobss>
  
/* Call static constructors */
    bl __libc_init_array
 8012e16:	f020 f99f 	bl	8033158 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8012e1a:	f7fe f88f 	bl	8010f3c <main>
  bx  lr    
 8012e1e:	4770      	bx	lr
  ldr   sp, =_estack      /* set stack pointer */
 8012e20:	20050000 	.word	0x20050000
  ldr r0, =_sdata
 8012e24:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8012e28:	20001058 	.word	0x20001058
  ldr r2, =_sidata
 8012e2c:	08083cc4 	.word	0x08083cc4
  ldr r2, =_sbss
 8012e30:	200011a0 	.word	0x200011a0
  ldr r4, =_ebss
 8012e34:	20012398 	.word	0x20012398

08012e38 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8012e38:	e7fe      	b.n	8012e38 <ADC_IRQHandler>
	...

08012e3c <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8012e3c:	b508      	push	{r3, lr}
#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8012e3e:	2003      	movs	r0, #3
 8012e40:	f000 f998 	bl	8013174 <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 8012e44:	2000      	movs	r0, #0
 8012e46:	f7ff ff1f 	bl	8012c88 <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
 8012e4a:	f7ff f83b 	bl	8011ec4 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
}
 8012e4e:	2000      	movs	r0, #0
 8012e50:	bd08      	pop	{r3, pc}
 8012e52:	bf00      	nop

08012e54 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 8012e54:	4a03      	ldr	r2, [pc, #12]	@ (8012e64 <HAL_IncTick+0x10>)
 8012e56:	4b04      	ldr	r3, [pc, #16]	@ (8012e68 <HAL_IncTick+0x14>)
 8012e58:	6811      	ldr	r1, [r2, #0]
 8012e5a:	781b      	ldrb	r3, [r3, #0]
 8012e5c:	440b      	add	r3, r1
 8012e5e:	6013      	str	r3, [r2, #0]
}
 8012e60:	4770      	bx	lr
 8012e62:	bf00      	nop
 8012e64:	20002bc8 	.word	0x20002bc8
 8012e68:	20000010 	.word	0x20000010

08012e6c <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8012e6c:	4b01      	ldr	r3, [pc, #4]	@ (8012e74 <HAL_GetTick+0x8>)
 8012e6e:	6818      	ldr	r0, [r3, #0]
}
 8012e70:	4770      	bx	lr
 8012e72:	bf00      	nop
 8012e74:	20002bc8 	.word	0x20002bc8

08012e78 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8012e78:	b538      	push	{r3, r4, r5, lr}
 8012e7a:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8012e7c:	f7ff fff6 	bl	8012e6c <HAL_GetTick>
 8012e80:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 8012e82:	1c63      	adds	r3, r4, #1
 8012e84:	d002      	beq.n	8012e8c <HAL_Delay+0x14>
  {
    wait += (uint32_t)(uwTickFreq);
 8012e86:	4b04      	ldr	r3, [pc, #16]	@ (8012e98 <HAL_Delay+0x20>)
 8012e88:	781b      	ldrb	r3, [r3, #0]
 8012e8a:	441c      	add	r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
 8012e8c:	f7ff ffee 	bl	8012e6c <HAL_GetTick>
 8012e90:	1b40      	subs	r0, r0, r5
 8012e92:	42a0      	cmp	r0, r4
 8012e94:	d3fa      	bcc.n	8012e8c <HAL_Delay+0x14>
  {
  }
}
 8012e96:	bd38      	pop	{r3, r4, r5, pc}
 8012e98:	20000010 	.word	0x20000010

08012e9c <HAL_ADC_Init>:
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef* hadc)
{
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  
  /* Check ADC handle */
  if(hadc == NULL)
 8012e9c:	2800      	cmp	r0, #0
 8012e9e:	f000 809d 	beq.w	8012fdc <HAL_ADC_Init+0x140>
{
 8012ea2:	b538      	push	{r3, r4, r5, lr}
  if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
  {
    assert_param(IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge));
  }

  if(hadc->State == HAL_ADC_STATE_RESET)
 8012ea4:	6c05      	ldr	r5, [r0, #64]	@ 0x40
 8012ea6:	4604      	mov	r4, r0
 8012ea8:	b13d      	cbz	r5, 8012eba <HAL_ADC_Init+0x1e>
    hadc->Lock = HAL_UNLOCKED;
  }
  
  /* Configuration of ADC parameters if previous preliminary actions are      */ 
  /* correctly completed.                                                     */
  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
 8012eaa:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 8012eac:	06db      	lsls	r3, r3, #27
 8012eae:	d50c      	bpl.n	8012eca <HAL_ADC_Init+0x2e>
  {
    tmp_hal_status = HAL_ERROR;
  }
  
  /* Release Lock */
  __HAL_UNLOCK(hadc);
 8012eb0:	2300      	movs	r3, #0
    tmp_hal_status = HAL_ERROR;
 8012eb2:	2001      	movs	r0, #1
  __HAL_UNLOCK(hadc);
 8012eb4:	f884 303c 	strb.w	r3, [r4, #60]	@ 0x3c

  /* Return function status */
  return tmp_hal_status;
}
 8012eb8:	bd38      	pop	{r3, r4, r5, pc}
    HAL_ADC_MspInit(hadc);
 8012eba:	f7ff f823 	bl	8011f04 <HAL_ADC_MspInit>
    ADC_CLEAR_ERRORCODE(hadc);
 8012ebe:	6465      	str	r5, [r4, #68]	@ 0x44
  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
 8012ec0:	6c23      	ldr	r3, [r4, #64]	@ 0x40
    hadc->Lock = HAL_UNLOCKED;
 8012ec2:	f884 503c 	strb.w	r5, [r4, #60]	@ 0x3c
  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
 8012ec6:	06db      	lsls	r3, r3, #27
 8012ec8:	d4f2      	bmi.n	8012eb0 <HAL_ADC_Init+0x14>
    ADC_STATE_CLR_SET(hadc->State,
 8012eca:	6c21      	ldr	r1, [r4, #64]	@ 0x40
 8012ecc:	4b47      	ldr	r3, [pc, #284]	@ (8012fec <HAL_ADC_Init+0x150>)
  */
static void ADC_Init(ADC_HandleTypeDef* hadc)
{
  /* Set ADC parameters */
  /* Set the ADC clock prescaler */
  ADC->CCR &= ~(ADC_CCR_ADCPRE);
 8012ece:	4a48      	ldr	r2, [pc, #288]	@ (8012ff0 <HAL_ADC_Init+0x154>)
    ADC_STATE_CLR_SET(hadc->State,
 8012ed0:	400b      	ands	r3, r1
 8012ed2:	f043 0302 	orr.w	r3, r3, #2
 8012ed6:	6423      	str	r3, [r4, #64]	@ 0x40
  ADC->CCR &= ~(ADC_CCR_ADCPRE);
 8012ed8:	6851      	ldr	r1, [r2, #4]
  ADC->CCR |=  hadc->Init.ClockPrescaler;
  
  /* Set ADC scan mode */
  hadc->Instance->CR1 &= ~(ADC_CR1_SCAN);
 8012eda:	6823      	ldr	r3, [r4, #0]
  ADC->CCR &= ~(ADC_CCR_ADCPRE);
 8012edc:	f421 3140 	bic.w	r1, r1, #196608	@ 0x30000
 8012ee0:	6051      	str	r1, [r2, #4]
  ADC->CCR |=  hadc->Init.ClockPrescaler;
 8012ee2:	6850      	ldr	r0, [r2, #4]
 8012ee4:	6861      	ldr	r1, [r4, #4]
 8012ee6:	4308      	orrs	r0, r1
  /* Enable external trigger if trigger selection is different of software  */
  /* start.                                                                 */
  /* Note: This configuration keeps the hardware feature of parameter       */
  /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
  /*       software start.                                                  */
  if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 8012ee8:	4942      	ldr	r1, [pc, #264]	@ (8012ff4 <HAL_ADC_Init+0x158>)
  ADC->CCR |=  hadc->Init.ClockPrescaler;
 8012eea:	6050      	str	r0, [r2, #4]
  hadc->Instance->CR1 &= ~(ADC_CR1_SCAN);
 8012eec:	685a      	ldr	r2, [r3, #4]
  hadc->Instance->CR1 |=  ADC_CR1_SCANCONV(hadc->Init.ScanConvMode);
 8012eee:	6920      	ldr	r0, [r4, #16]
  hadc->Instance->CR1 &= ~(ADC_CR1_SCAN);
 8012ef0:	f422 7280 	bic.w	r2, r2, #256	@ 0x100
 8012ef4:	605a      	str	r2, [r3, #4]
  hadc->Instance->CR1 |=  ADC_CR1_SCANCONV(hadc->Init.ScanConvMode);
 8012ef6:	685a      	ldr	r2, [r3, #4]
 8012ef8:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
  hadc->Instance->CR1 |=  hadc->Init.Resolution;
 8012efc:	68a0      	ldr	r0, [r4, #8]
  hadc->Instance->CR1 |=  ADC_CR1_SCANCONV(hadc->Init.ScanConvMode);
 8012efe:	605a      	str	r2, [r3, #4]
  hadc->Instance->CR1 &= ~(ADC_CR1_RES);
 8012f00:	685a      	ldr	r2, [r3, #4]
 8012f02:	f022 7240 	bic.w	r2, r2, #50331648	@ 0x3000000
 8012f06:	605a      	str	r2, [r3, #4]
  hadc->Instance->CR1 |=  hadc->Init.Resolution;
 8012f08:	685a      	ldr	r2, [r3, #4]
 8012f0a:	4302      	orrs	r2, r0
  hadc->Instance->CR2 |= hadc->Init.DataAlign;
 8012f0c:	68e0      	ldr	r0, [r4, #12]
  hadc->Instance->CR1 |=  hadc->Init.Resolution;
 8012f0e:	605a      	str	r2, [r3, #4]
  hadc->Instance->CR2 &= ~(ADC_CR2_ALIGN);
 8012f10:	689a      	ldr	r2, [r3, #8]
 8012f12:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
 8012f16:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= hadc->Init.DataAlign;
 8012f18:	689a      	ldr	r2, [r3, #8]
 8012f1a:	4302      	orrs	r2, r0
  if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 8012f1c:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
 8012f1e:	4288      	cmp	r0, r1
  hadc->Instance->CR2 |= hadc->Init.DataAlign;
 8012f20:	609a      	str	r2, [r3, #8]
  {
    /* Select external trigger to start conversion */
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
 8012f22:	689a      	ldr	r2, [r3, #8]
  if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 8012f24:	d052      	beq.n	8012fcc <HAL_ADC_Init+0x130>
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
 8012f26:	f022 6270 	bic.w	r2, r2, #251658240	@ 0xf000000
    hadc->Instance->CR2 |= hadc->Init.ExternalTrigConv;
    
    /* Select external trigger polarity */
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
    hadc->Instance->CR2 |= hadc->Init.ExternalTrigConvEdge;
 8012f2a:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
 8012f2c:	609a      	str	r2, [r3, #8]
    hadc->Instance->CR2 |= hadc->Init.ExternalTrigConv;
 8012f2e:	689a      	ldr	r2, [r3, #8]
 8012f30:	4310      	orrs	r0, r2
 8012f32:	6098      	str	r0, [r3, #8]
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
 8012f34:	689a      	ldr	r2, [r3, #8]
 8012f36:	f022 5240 	bic.w	r2, r2, #805306368	@ 0x30000000
 8012f3a:	609a      	str	r2, [r3, #8]
    hadc->Instance->CR2 |= hadc->Init.ExternalTrigConvEdge;
 8012f3c:	689a      	ldr	r2, [r3, #8]
 8012f3e:	430a      	orrs	r2, r1
 8012f40:	609a      	str	r2, [r3, #8]
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
  }
  
  /* Enable or disable ADC continuous conversion mode */
  hadc->Instance->CR2 &= ~(ADC_CR2_CONT);
 8012f42:	689a      	ldr	r2, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode);
 8012f44:	69a1      	ldr	r1, [r4, #24]
  hadc->Instance->CR2 &= ~(ADC_CR2_CONT);
 8012f46:	f022 0202 	bic.w	r2, r2, #2
 8012f4a:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode);
 8012f4c:	689a      	ldr	r2, [r3, #8]
 8012f4e:	ea42 0241 	orr.w	r2, r2, r1, lsl #1
 8012f52:	609a      	str	r2, [r3, #8]
  
  if(hadc->Init.DiscontinuousConvMode != DISABLE)
 8012f54:	f894 2020 	ldrb.w	r2, [r4, #32]
 8012f58:	2a00      	cmp	r2, #0
 8012f5a:	d041      	beq.n	8012fe0 <HAL_ADC_Init+0x144>
  {
    assert_param(IS_ADC_REGULAR_DISC_NUMBER(hadc->Init.NbrOfDiscConversion));
  
    /* Enable the selected ADC regular discontinuous mode */
    hadc->Instance->CR1 |= (uint32_t)ADC_CR1_DISCEN;
 8012f5c:	6858      	ldr	r0, [r3, #4]
    
    /* Set the number of channels to be converted in discontinuous mode */
    hadc->Instance->CR1 &= ~(ADC_CR1_DISCNUM);
    hadc->Instance->CR1 |=  ADC_CR1_DISCONTINUOUS(hadc->Init.NbrOfDiscConversion);
 8012f5e:	6a62      	ldr	r2, [r4, #36]	@ 0x24
    hadc->Instance->CR1 |= (uint32_t)ADC_CR1_DISCEN;
 8012f60:	f440 6000 	orr.w	r0, r0, #2048	@ 0x800
    hadc->Instance->CR1 |=  ADC_CR1_DISCONTINUOUS(hadc->Init.NbrOfDiscConversion);
 8012f64:	1e51      	subs	r1, r2, #1
    hadc->Instance->CR1 |= (uint32_t)ADC_CR1_DISCEN;
 8012f66:	6058      	str	r0, [r3, #4]
    hadc->Instance->CR1 &= ~(ADC_CR1_DISCNUM);
 8012f68:	685a      	ldr	r2, [r3, #4]
 8012f6a:	f422 4260 	bic.w	r2, r2, #57344	@ 0xe000
 8012f6e:	605a      	str	r2, [r3, #4]
    hadc->Instance->CR1 |=  ADC_CR1_DISCONTINUOUS(hadc->Init.NbrOfDiscConversion);
 8012f70:	685a      	ldr	r2, [r3, #4]
 8012f72:	ea42 3241 	orr.w	r2, r2, r1, lsl #13
 8012f76:	605a      	str	r2, [r3, #4]
    /* Disable the selected ADC regular discontinuous mode */
    hadc->Instance->CR1 &= ~(ADC_CR1_DISCEN);
  }
  
  /* Set ADC number of conversion */
  hadc->Instance->SQR1 &= ~(ADC_SQR1_L);
 8012f78:	6add      	ldr	r5, [r3, #44]	@ 0x2c
  hadc->Instance->SQR1 |=  ADC_SQR1(hadc->Init.NbrOfConversion);
 8012f7a:	69e2      	ldr	r2, [r4, #28]
  hadc->Instance->SQR1 &= ~(ADC_SQR1_L);
 8012f7c:	f425 0570 	bic.w	r5, r5, #15728640	@ 0xf00000
  hadc->Instance->CR2 &= ~(ADC_CR2_DDS);
  hadc->Instance->CR2 |= ADC_CR2_DMAContReq((uint32_t)hadc->Init.DMAContinuousRequests);
  
  /* Enable or disable ADC end of conversion selection */
  hadc->Instance->CR2 &= ~(ADC_CR2_EOCS);
  hadc->Instance->CR2 |= ADC_CR2_EOCSelection(hadc->Init.EOCSelection);
 8012f80:	6960      	ldr	r0, [r4, #20]
  hadc->Instance->SQR1 |=  ADC_SQR1(hadc->Init.NbrOfConversion);
 8012f82:	1e51      	subs	r1, r2, #1
  hadc->Instance->SQR1 &= ~(ADC_SQR1_L);
 8012f84:	62dd      	str	r5, [r3, #44]	@ 0x2c
  hadc->Instance->SQR1 |=  ADC_SQR1(hadc->Init.NbrOfConversion);
 8012f86:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8012f88:	ea42 5201 	orr.w	r2, r2, r1, lsl #20
 8012f8c:	62da      	str	r2, [r3, #44]	@ 0x2c
  hadc->Instance->CR2 &= ~(ADC_CR2_DDS);
 8012f8e:	689a      	ldr	r2, [r3, #8]
 8012f90:	f422 7200 	bic.w	r2, r2, #512	@ 0x200
 8012f94:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_DMAContReq((uint32_t)hadc->Init.DMAContinuousRequests);
 8012f96:	689a      	ldr	r2, [r3, #8]
 8012f98:	f894 1030 	ldrb.w	r1, [r4, #48]	@ 0x30
 8012f9c:	ea42 2241 	orr.w	r2, r2, r1, lsl #9
    ADC_CLEAR_ERRORCODE(hadc);
 8012fa0:	2100      	movs	r1, #0
  hadc->Instance->CR2 |= ADC_CR2_DMAContReq((uint32_t)hadc->Init.DMAContinuousRequests);
 8012fa2:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 &= ~(ADC_CR2_EOCS);
 8012fa4:	689a      	ldr	r2, [r3, #8]
 8012fa6:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 8012faa:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_EOCSelection(hadc->Init.EOCSelection);
 8012fac:	689a      	ldr	r2, [r3, #8]
 8012fae:	ea42 2280 	orr.w	r2, r2, r0, lsl #10
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8012fb2:	4608      	mov	r0, r1
  hadc->Instance->CR2 |= ADC_CR2_EOCSelection(hadc->Init.EOCSelection);
 8012fb4:	609a      	str	r2, [r3, #8]
    ADC_CLEAR_ERRORCODE(hadc);
 8012fb6:	6461      	str	r1, [r4, #68]	@ 0x44
    ADC_STATE_CLR_SET(hadc->State,
 8012fb8:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 8012fba:	f023 0303 	bic.w	r3, r3, #3
 8012fbe:	f043 0301 	orr.w	r3, r3, #1
 8012fc2:	6423      	str	r3, [r4, #64]	@ 0x40
  __HAL_UNLOCK(hadc);
 8012fc4:	2300      	movs	r3, #0
 8012fc6:	f884 303c 	strb.w	r3, [r4, #60]	@ 0x3c
}
 8012fca:	bd38      	pop	{r3, r4, r5, pc}
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
 8012fcc:	f022 6270 	bic.w	r2, r2, #251658240	@ 0xf000000
 8012fd0:	609a      	str	r2, [r3, #8]
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
 8012fd2:	689a      	ldr	r2, [r3, #8]
 8012fd4:	f022 5240 	bic.w	r2, r2, #805306368	@ 0x30000000
 8012fd8:	609a      	str	r2, [r3, #8]
 8012fda:	e7b2      	b.n	8012f42 <HAL_ADC_Init+0xa6>
    return HAL_ERROR;
 8012fdc:	2001      	movs	r0, #1
}
 8012fde:	4770      	bx	lr
    hadc->Instance->CR1 &= ~(ADC_CR1_DISCEN);
 8012fe0:	685a      	ldr	r2, [r3, #4]
 8012fe2:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
 8012fe6:	605a      	str	r2, [r3, #4]
 8012fe8:	e7c6      	b.n	8012f78 <HAL_ADC_Init+0xdc>
 8012fea:	bf00      	nop
 8012fec:	ffffeefd 	.word	0xffffeefd
 8012ff0:	40012300 	.word	0x40012300
 8012ff4:	0f000001 	.word	0x0f000001

08012ff8 <HAL_ADC_ConfigChannel>:
{
 8012ff8:	b570      	push	{r4, r5, r6, lr}
  __IO uint32_t counter = 0;
 8012ffa:	2300      	movs	r3, #0
{
 8012ffc:	b082      	sub	sp, #8
  __IO uint32_t counter = 0;
 8012ffe:	9301      	str	r3, [sp, #4]
  __HAL_LOCK(hadc);
 8013000:	f890 303c 	ldrb.w	r3, [r0, #60]	@ 0x3c
 8013004:	2b01      	cmp	r3, #1
 8013006:	f000 80a7 	beq.w	8013158 <HAL_ADC_ConfigChannel+0x160>
 801300a:	2201      	movs	r2, #1
 801300c:	4684      	mov	ip, r0
    hadc->Instance->SMPR1 &= ~ADC_SMPR1(ADC_SMPR1_SMP10, sConfig->Channel);
 801300e:	6803      	ldr	r3, [r0, #0]
  __HAL_LOCK(hadc);
 8013010:	f880 203c 	strb.w	r2, [r0, #60]	@ 0x3c
  if ((sConfig->Channel > ADC_CHANNEL_9) && (sConfig->Channel != ADC_INTERNAL_NONE))
 8013014:	6808      	ldr	r0, [r1, #0]
      hadc->Instance->SMPR1 |= ADC_SMPR1(sConfig->SamplingTime, ADC_CHANNEL_18);
 8013016:	688c      	ldr	r4, [r1, #8]
 8013018:	b282      	uxth	r2, r0
  if ((sConfig->Channel > ADC_CHANNEL_9) && (sConfig->Channel != ADC_INTERNAL_NONE))
 801301a:	2809      	cmp	r0, #9
    hadc->Instance->SMPR1 &= ~ADC_SMPR1(ADC_SMPR1_SMP10, sConfig->Channel);
 801301c:	eb02 0e42 	add.w	lr, r2, r2, lsl #1
  if ((sConfig->Channel > ADC_CHANNEL_9) && (sConfig->Channel != ADC_INTERNAL_NONE))
 8013020:	d92d      	bls.n	801307e <HAL_ADC_ConfigChannel+0x86>
 8013022:	f1b0 4f00 	cmp.w	r0, #2147483648	@ 0x80000000
 8013026:	d02a      	beq.n	801307e <HAL_ADC_ConfigChannel+0x86>
    hadc->Instance->SMPR1 &= ~ADC_SMPR1(ADC_SMPR1_SMP10, sConfig->Channel);
 8013028:	f1ae 0e1e 	sub.w	lr, lr, #30
 801302c:	2607      	movs	r6, #7
 801302e:	68dd      	ldr	r5, [r3, #12]
 8013030:	fa06 f60e 	lsl.w	r6, r6, lr
 8013034:	ea25 0506 	bic.w	r5, r5, r6
 8013038:	60dd      	str	r5, [r3, #12]
    if (sConfig->Channel == ADC_CHANNEL_TEMPSENSOR)
 801303a:	4d49      	ldr	r5, [pc, #292]	@ (8013160 <HAL_ADC_ConfigChannel+0x168>)
 801303c:	42a8      	cmp	r0, r5
 801303e:	f000 8086 	beq.w	801314e <HAL_ADC_ConfigChannel+0x156>
      hadc->Instance->SMPR1 |= ADC_SMPR1(sConfig->SamplingTime, sConfig->Channel);
 8013042:	68dd      	ldr	r5, [r3, #12]
 8013044:	fa04 f40e 	lsl.w	r4, r4, lr
 8013048:	432c      	orrs	r4, r5
 801304a:	60dc      	str	r4, [r3, #12]
  if (sConfig->Rank < 7)
 801304c:	684c      	ldr	r4, [r1, #4]
 801304e:	2c06      	cmp	r4, #6
    hadc->Instance->SQR3 &= ~ADC_SQR3_RK(ADC_SQR3_SQ1, sConfig->Rank);
 8013050:	eb04 0184 	add.w	r1, r4, r4, lsl #2
  if (sConfig->Rank < 7)
 8013054:	d824      	bhi.n	80130a0 <HAL_ADC_ConfigChannel+0xa8>
    hadc->Instance->SQR3 &= ~ADC_SQR3_RK(ADC_SQR3_SQ1, sConfig->Rank);
 8013056:	3905      	subs	r1, #5
 8013058:	241f      	movs	r4, #31
    hadc->Instance->SQR3 |= ADC_SQR3_RK(sConfig->Channel, sConfig->Rank);
 801305a:	408a      	lsls	r2, r1
    hadc->Instance->SQR3 &= ~ADC_SQR3_RK(ADC_SQR3_SQ1, sConfig->Rank);
 801305c:	408c      	lsls	r4, r1
 801305e:	6b59      	ldr	r1, [r3, #52]	@ 0x34
 8013060:	ea21 0104 	bic.w	r1, r1, r4
 8013064:	6359      	str	r1, [r3, #52]	@ 0x34
    hadc->Instance->SQR3 |= ADC_SQR3_RK(sConfig->Channel, sConfig->Rank);
 8013066:	6b59      	ldr	r1, [r3, #52]	@ 0x34
 8013068:	430a      	orrs	r2, r1
 801306a:	635a      	str	r2, [r3, #52]	@ 0x34
  if ((hadc->Instance == ADC1) && (sConfig->Channel == ADC_INTERNAL_NONE))
 801306c:	4a3d      	ldr	r2, [pc, #244]	@ (8013164 <HAL_ADC_ConfigChannel+0x16c>)
 801306e:	4293      	cmp	r3, r2
 8013070:	d026      	beq.n	80130c0 <HAL_ADC_ConfigChannel+0xc8>
  __HAL_UNLOCK(hadc);
 8013072:	2300      	movs	r3, #0
  return HAL_OK;
 8013074:	4618      	mov	r0, r3
  __HAL_UNLOCK(hadc);
 8013076:	f88c 303c 	strb.w	r3, [ip, #60]	@ 0x3c
}
 801307a:	b002      	add	sp, #8
 801307c:	bd70      	pop	{r4, r5, r6, pc}
    hadc->Instance->SMPR2 &= ~ADC_SMPR2(ADC_SMPR2_SMP0, sConfig->Channel);
 801307e:	2507      	movs	r5, #7
    hadc->Instance->SMPR2 |= ADC_SMPR2(sConfig->SamplingTime, sConfig->Channel);
 8013080:	fa04 f40e 	lsl.w	r4, r4, lr
    hadc->Instance->SMPR2 &= ~ADC_SMPR2(ADC_SMPR2_SMP0, sConfig->Channel);
 8013084:	fa05 fe0e 	lsl.w	lr, r5, lr
 8013088:	691d      	ldr	r5, [r3, #16]
 801308a:	ea25 050e 	bic.w	r5, r5, lr
 801308e:	611d      	str	r5, [r3, #16]
    hadc->Instance->SMPR2 |= ADC_SMPR2(sConfig->SamplingTime, sConfig->Channel);
 8013090:	691d      	ldr	r5, [r3, #16]
 8013092:	432c      	orrs	r4, r5
 8013094:	611c      	str	r4, [r3, #16]
  if (sConfig->Rank < 7)
 8013096:	684c      	ldr	r4, [r1, #4]
 8013098:	2c06      	cmp	r4, #6
    hadc->Instance->SQR3 &= ~ADC_SQR3_RK(ADC_SQR3_SQ1, sConfig->Rank);
 801309a:	eb04 0184 	add.w	r1, r4, r4, lsl #2
  if (sConfig->Rank < 7)
 801309e:	d9da      	bls.n	8013056 <HAL_ADC_ConfigChannel+0x5e>
  else if (sConfig->Rank < 13)
 80130a0:	2c0c      	cmp	r4, #12
 80130a2:	d837      	bhi.n	8013114 <HAL_ADC_ConfigChannel+0x11c>
    hadc->Instance->SQR2 &= ~ADC_SQR2_RK(ADC_SQR2_SQ7, sConfig->Rank);
 80130a4:	3923      	subs	r1, #35	@ 0x23
 80130a6:	241f      	movs	r4, #31
    hadc->Instance->SQR2 |= ADC_SQR2_RK(sConfig->Channel, sConfig->Rank);
 80130a8:	408a      	lsls	r2, r1
    hadc->Instance->SQR2 &= ~ADC_SQR2_RK(ADC_SQR2_SQ7, sConfig->Rank);
 80130aa:	408c      	lsls	r4, r1
 80130ac:	6b19      	ldr	r1, [r3, #48]	@ 0x30
 80130ae:	ea21 0104 	bic.w	r1, r1, r4
 80130b2:	6319      	str	r1, [r3, #48]	@ 0x30
    hadc->Instance->SQR2 |= ADC_SQR2_RK(sConfig->Channel, sConfig->Rank);
 80130b4:	6b19      	ldr	r1, [r3, #48]	@ 0x30
 80130b6:	430a      	orrs	r2, r1
 80130b8:	631a      	str	r2, [r3, #48]	@ 0x30
  if ((hadc->Instance == ADC1) && (sConfig->Channel == ADC_INTERNAL_NONE))
 80130ba:	4a2a      	ldr	r2, [pc, #168]	@ (8013164 <HAL_ADC_ConfigChannel+0x16c>)
 80130bc:	4293      	cmp	r3, r2
 80130be:	d1d8      	bne.n	8013072 <HAL_ADC_ConfigChannel+0x7a>
 80130c0:	f1b0 4f00 	cmp.w	r0, #2147483648	@ 0x80000000
 80130c4:	d03c      	beq.n	8013140 <HAL_ADC_ConfigChannel+0x148>
  if ((hadc->Instance == ADC1) && (sConfig->Channel == ADC_CHANNEL_VBAT))
 80130c6:	2812      	cmp	r0, #18
 80130c8:	d030      	beq.n	801312c <HAL_ADC_ConfigChannel+0x134>
  if ((hadc->Instance == ADC1) && ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) || (sConfig->Channel == ADC_CHANNEL_VREFINT)))
 80130ca:	4b25      	ldr	r3, [pc, #148]	@ (8013160 <HAL_ADC_ConfigChannel+0x168>)
 80130cc:	4298      	cmp	r0, r3
 80130ce:	d001      	beq.n	80130d4 <HAL_ADC_ConfigChannel+0xdc>
 80130d0:	2811      	cmp	r0, #17
 80130d2:	d1ce      	bne.n	8013072 <HAL_ADC_ConfigChannel+0x7a>
    ADC->CCR &= ~ADC_CCR_VBATE;
 80130d4:	4b24      	ldr	r3, [pc, #144]	@ (8013168 <HAL_ADC_ConfigChannel+0x170>)
    if(sConfig->Channel == ADC_CHANNEL_TEMPSENSOR)
 80130d6:	4922      	ldr	r1, [pc, #136]	@ (8013160 <HAL_ADC_ConfigChannel+0x168>)
    ADC->CCR &= ~ADC_CCR_VBATE;
 80130d8:	685a      	ldr	r2, [r3, #4]
    if(sConfig->Channel == ADC_CHANNEL_TEMPSENSOR)
 80130da:	4288      	cmp	r0, r1
    ADC->CCR &= ~ADC_CCR_VBATE;
 80130dc:	f422 0280 	bic.w	r2, r2, #4194304	@ 0x400000
 80130e0:	605a      	str	r2, [r3, #4]
    ADC->CCR |= ADC_CCR_TSVREFE;
 80130e2:	685a      	ldr	r2, [r3, #4]
 80130e4:	f442 0200 	orr.w	r2, r2, #8388608	@ 0x800000
 80130e8:	605a      	str	r2, [r3, #4]
    if(sConfig->Channel == ADC_CHANNEL_TEMPSENSOR)
 80130ea:	d1c2      	bne.n	8013072 <HAL_ADC_ConfigChannel+0x7a>
      counter = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000));
 80130ec:	4b1f      	ldr	r3, [pc, #124]	@ (801316c <HAL_ADC_ConfigChannel+0x174>)
 80130ee:	4a20      	ldr	r2, [pc, #128]	@ (8013170 <HAL_ADC_ConfigChannel+0x178>)
 80130f0:	681b      	ldr	r3, [r3, #0]
 80130f2:	fba2 2303 	umull	r2, r3, r2, r3
 80130f6:	0c9b      	lsrs	r3, r3, #18
 80130f8:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80130fc:	005b      	lsls	r3, r3, #1
 80130fe:	9301      	str	r3, [sp, #4]
      while(counter != 0)
 8013100:	9b01      	ldr	r3, [sp, #4]
 8013102:	2b00      	cmp	r3, #0
 8013104:	d0b5      	beq.n	8013072 <HAL_ADC_ConfigChannel+0x7a>
        counter--;
 8013106:	9b01      	ldr	r3, [sp, #4]
 8013108:	3b01      	subs	r3, #1
 801310a:	9301      	str	r3, [sp, #4]
      while(counter != 0)
 801310c:	9b01      	ldr	r3, [sp, #4]
 801310e:	2b00      	cmp	r3, #0
 8013110:	d1f9      	bne.n	8013106 <HAL_ADC_ConfigChannel+0x10e>
 8013112:	e7ae      	b.n	8013072 <HAL_ADC_ConfigChannel+0x7a>
    hadc->Instance->SQR1 &= ~ADC_SQR1_RK(ADC_SQR1_SQ13, sConfig->Rank);
 8013114:	3941      	subs	r1, #65	@ 0x41
 8013116:	241f      	movs	r4, #31
    hadc->Instance->SQR1 |= ADC_SQR1_RK(sConfig->Channel, sConfig->Rank);
 8013118:	408a      	lsls	r2, r1
    hadc->Instance->SQR1 &= ~ADC_SQR1_RK(ADC_SQR1_SQ13, sConfig->Rank);
 801311a:	408c      	lsls	r4, r1
 801311c:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
 801311e:	ea21 0104 	bic.w	r1, r1, r4
 8013122:	62d9      	str	r1, [r3, #44]	@ 0x2c
    hadc->Instance->SQR1 |= ADC_SQR1_RK(sConfig->Channel, sConfig->Rank);
 8013124:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
 8013126:	430a      	orrs	r2, r1
 8013128:	62da      	str	r2, [r3, #44]	@ 0x2c
 801312a:	e79f      	b.n	801306c <HAL_ADC_ConfigChannel+0x74>
    ADC->CCR &= ~ADC_CCR_TSVREFE;
 801312c:	4b0e      	ldr	r3, [pc, #56]	@ (8013168 <HAL_ADC_ConfigChannel+0x170>)
 801312e:	685a      	ldr	r2, [r3, #4]
 8013130:	f422 0200 	bic.w	r2, r2, #8388608	@ 0x800000
 8013134:	605a      	str	r2, [r3, #4]
    ADC->CCR |= ADC_CCR_VBATE;
 8013136:	685a      	ldr	r2, [r3, #4]
 8013138:	f442 0280 	orr.w	r2, r2, #4194304	@ 0x400000
 801313c:	605a      	str	r2, [r3, #4]
  if ((hadc->Instance == ADC1) && ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) || (sConfig->Channel == ADC_CHANNEL_VREFINT)))
 801313e:	e798      	b.n	8013072 <HAL_ADC_ConfigChannel+0x7a>
    ADC->CCR &= ~(ADC_CCR_VBATE | ADC_CCR_TSVREFE);
 8013140:	f8d2 3304 	ldr.w	r3, [r2, #772]	@ 0x304
 8013144:	f423 0340 	bic.w	r3, r3, #12582912	@ 0xc00000
 8013148:	f8c2 3304 	str.w	r3, [r2, #772]	@ 0x304
  if ((hadc->Instance == ADC1) && ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) || (sConfig->Channel == ADC_CHANNEL_VREFINT)))
 801314c:	e791      	b.n	8013072 <HAL_ADC_ConfigChannel+0x7a>
      hadc->Instance->SMPR1 |= ADC_SMPR1(sConfig->SamplingTime, ADC_CHANNEL_18);
 801314e:	68dd      	ldr	r5, [r3, #12]
 8013150:	ea45 6404 	orr.w	r4, r5, r4, lsl #24
 8013154:	60dc      	str	r4, [r3, #12]
 8013156:	e779      	b.n	801304c <HAL_ADC_ConfigChannel+0x54>
  __HAL_LOCK(hadc);
 8013158:	2002      	movs	r0, #2
}
 801315a:	b002      	add	sp, #8
 801315c:	bd70      	pop	{r4, r5, r6, pc}
 801315e:	bf00      	nop
 8013160:	10000012 	.word	0x10000012
 8013164:	40012000 	.word	0x40012000
 8013168:	40012300 	.word	0x40012300
 801316c:	2000000c 	.word	0x2000000c
 8013170:	431bde83 	.word	0x431bde83

08013174 <HAL_NVIC_SetPriorityGrouping>:
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8013174:	4906      	ldr	r1, [pc, #24]	@ (8013190 <HAL_NVIC_SetPriorityGrouping+0x1c>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8013176:	f64f 0cff 	movw	ip, #63743	@ 0xf8ff
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 801317a:	0200      	lsls	r0, r0, #8
  reg_value  =  (reg_value                                   |
 801317c:	4b05      	ldr	r3, [pc, #20]	@ (8013194 <HAL_NVIC_SetPriorityGrouping+0x20>)
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 801317e:	68ca      	ldr	r2, [r1, #12]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8013180:	f400 60e0 	and.w	r0, r0, #1792	@ 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8013184:	ea02 020c 	and.w	r2, r2, ip
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8013188:	4310      	orrs	r0, r2
  reg_value  =  (reg_value                                   |
 801318a:	4303      	orrs	r3, r0
  SCB->AIRCR =  reg_value;
 801318c:	60cb      	str	r3, [r1, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 801318e:	4770      	bx	lr
 8013190:	e000ed00 	.word	0xe000ed00
 8013194:	05fa0000 	.word	0x05fa0000

08013198 <HAL_NVIC_SetPriority>:
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8013198:	4b1a      	ldr	r3, [pc, #104]	@ (8013204 <HAL_NVIC_SetPriority+0x6c>)
 801319a:	68db      	ldr	r3, [r3, #12]
 801319c:	f3c3 2302 	ubfx	r3, r3, #8, #3
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 80131a0:	b500      	push	{lr}
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80131a2:	f1c3 0e07 	rsb	lr, r3, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80131a6:	f103 0c04 	add.w	ip, r3, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80131aa:	f1be 0f04 	cmp.w	lr, #4
 80131ae:	bf28      	it	cs
 80131b0:	f04f 0e04 	movcs.w	lr, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80131b4:	f1bc 0f06 	cmp.w	ip, #6
 80131b8:	d91a      	bls.n	80131f0 <HAL_NVIC_SetPriority+0x58>
 80131ba:	f1a3 0c03 	sub.w	ip, r3, #3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 80131be:	f04f 33ff 	mov.w	r3, #4294967295
 80131c2:	fa03 f30c 	lsl.w	r3, r3, ip
 80131c6:	ea22 0203 	bic.w	r2, r2, r3
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80131ca:	f04f 33ff 	mov.w	r3, #4294967295
  if ((int32_t)(IRQn) >= 0)
 80131ce:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80131d0:	fa03 f30e 	lsl.w	r3, r3, lr
 80131d4:	ea21 0303 	bic.w	r3, r1, r3
 80131d8:	fa03 f30c 	lsl.w	r3, r3, ip
 80131dc:	ea43 0302 	orr.w	r3, r3, r2
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80131e0:	ea4f 1303 	mov.w	r3, r3, lsl #4
 80131e4:	b2db      	uxtb	r3, r3
  if ((int32_t)(IRQn) >= 0)
 80131e6:	db06      	blt.n	80131f6 <HAL_NVIC_SetPriority+0x5e>
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80131e8:	4a07      	ldr	r2, [pc, #28]	@ (8013208 <HAL_NVIC_SetPriority+0x70>)
 80131ea:	5413      	strb	r3, [r2, r0]
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 80131ec:	f85d fb04 	ldr.w	pc, [sp], #4
 80131f0:	2200      	movs	r2, #0
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80131f2:	4694      	mov	ip, r2
 80131f4:	e7e9      	b.n	80131ca <HAL_NVIC_SetPriority+0x32>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80131f6:	f000 000f 	and.w	r0, r0, #15
 80131fa:	4a04      	ldr	r2, [pc, #16]	@ (801320c <HAL_NVIC_SetPriority+0x74>)
 80131fc:	5413      	strb	r3, [r2, r0]
 80131fe:	f85d fb04 	ldr.w	pc, [sp], #4
 8013202:	bf00      	nop
 8013204:	e000ed00 	.word	0xe000ed00
 8013208:	e000e400 	.word	0xe000e400
 801320c:	e000ed14 	.word	0xe000ed14

08013210 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 8013210:	2800      	cmp	r0, #0
 8013212:	db07      	blt.n	8013224 <HAL_NVIC_EnableIRQ+0x14>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8013214:	f000 011f 	and.w	r1, r0, #31
 8013218:	2301      	movs	r3, #1
 801321a:	0940      	lsrs	r0, r0, #5
 801321c:	4a02      	ldr	r2, [pc, #8]	@ (8013228 <HAL_NVIC_EnableIRQ+0x18>)
 801321e:	408b      	lsls	r3, r1
 8013220:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 8013224:	4770      	bx	lr
 8013226:	bf00      	nop
 8013228:	e000e100 	.word	0xe000e100

0801322c <HAL_CRC_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CRC_Init(CRC_HandleTypeDef *hcrc)
{
  /* Check the CRC handle allocation */
  if (hcrc == NULL)
 801322c:	2800      	cmp	r0, #0
 801322e:	d036      	beq.n	801329e <HAL_CRC_Init+0x72>
{
 8013230:	b510      	push	{r4, lr}
  }

  /* Check the parameters */
  assert_param(IS_CRC_ALL_INSTANCE(hcrc->Instance));

  if (hcrc->State == HAL_CRC_STATE_RESET)
 8013232:	7f43      	ldrb	r3, [r0, #29]
 8013234:	4604      	mov	r4, r0
 8013236:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
 801323a:	b363      	cbz	r3, 8013296 <HAL_CRC_Init+0x6a>
    hcrc->Lock = HAL_UNLOCKED;
    /* Init the low level hardware */
    HAL_CRC_MspInit(hcrc);
  }

  hcrc->State = HAL_CRC_STATE_BUSY;
 801323c:	2202      	movs	r2, #2

  /* check whether or not non-default generating polynomial has been
   * picked up by user */
  assert_param(IS_DEFAULT_POLYNOMIAL(hcrc->Init.DefaultPolynomialUse));
  if (hcrc->Init.DefaultPolynomialUse == DEFAULT_POLYNOMIAL_ENABLE)
 801323e:	7923      	ldrb	r3, [r4, #4]
  hcrc->State = HAL_CRC_STATE_BUSY;
 8013240:	7762      	strb	r2, [r4, #29]
  if (hcrc->Init.DefaultPolynomialUse == DEFAULT_POLYNOMIAL_ENABLE)
 8013242:	b9f3      	cbnz	r3, 8013282 <HAL_CRC_Init+0x56>
  {
    /* initialize peripheral with default generating polynomial */
    WRITE_REG(hcrc->Instance->POL, DEFAULT_CRC32_POLY);
 8013244:	6823      	ldr	r3, [r4, #0]
 8013246:	4a17      	ldr	r2, [pc, #92]	@ (80132a4 <HAL_CRC_Init+0x78>)
 8013248:	615a      	str	r2, [r3, #20]
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, CRC_POLYLENGTH_32B);
 801324a:	689a      	ldr	r2, [r3, #8]
 801324c:	f022 0218 	bic.w	r2, r2, #24
 8013250:	609a      	str	r2, [r3, #8]
  }

  /* check whether or not non-default CRC initial value has been
   * picked up by user */
  assert_param(IS_DEFAULT_INIT_VALUE(hcrc->Init.DefaultInitValueUse));
  if (hcrc->Init.DefaultInitValueUse == DEFAULT_INIT_VALUE_ENABLE)
 8013252:	7962      	ldrb	r2, [r4, #5]
 8013254:	b18a      	cbz	r2, 801327a <HAL_CRC_Init+0x4e>
  {
    WRITE_REG(hcrc->Instance->INIT, DEFAULT_CRC_INITVALUE);
  }
  else
  {
    WRITE_REG(hcrc->Instance->INIT, hcrc->Init.InitValue);
 8013256:	6922      	ldr	r2, [r4, #16]
 8013258:	611a      	str	r2, [r3, #16]
  }


  /* set input data inversion mode */
  assert_param(IS_CRC_INPUTDATA_INVERSION_MODE(hcrc->Init.InputDataInversionMode));
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_IN, hcrc->Init.InputDataInversionMode);
 801325a:	689a      	ldr	r2, [r3, #8]

  /* set output data inversion mode */
  assert_param(IS_CRC_OUTPUTDATA_INVERSION_MODE(hcrc->Init.OutputDataInversionMode));
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_OUT, hcrc->Init.OutputDataInversionMode);
 801325c:	e9d4 0105 	ldrd	r0, r1, [r4, #20]
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_IN, hcrc->Init.InputDataInversionMode);
 8013260:	f022 0260 	bic.w	r2, r2, #96	@ 0x60
 8013264:	4302      	orrs	r2, r0

  /* Change CRC peripheral state */
  hcrc->State = HAL_CRC_STATE_READY;

  /* Return function status */
  return HAL_OK;
 8013266:	2000      	movs	r0, #0
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_IN, hcrc->Init.InputDataInversionMode);
 8013268:	609a      	str	r2, [r3, #8]
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_OUT, hcrc->Init.OutputDataInversionMode);
 801326a:	689a      	ldr	r2, [r3, #8]
 801326c:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
 8013270:	430a      	orrs	r2, r1
  hcrc->State = HAL_CRC_STATE_READY;
 8013272:	2101      	movs	r1, #1
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_OUT, hcrc->Init.OutputDataInversionMode);
 8013274:	609a      	str	r2, [r3, #8]
  hcrc->State = HAL_CRC_STATE_READY;
 8013276:	7761      	strb	r1, [r4, #29]
}
 8013278:	bd10      	pop	{r4, pc}
    WRITE_REG(hcrc->Instance->INIT, DEFAULT_CRC_INITVALUE);
 801327a:	f04f 32ff 	mov.w	r2, #4294967295
 801327e:	611a      	str	r2, [r3, #16]
 8013280:	e7eb      	b.n	801325a <HAL_CRC_Init+0x2e>
    if (HAL_CRCEx_Polynomial_Set(hcrc, hcrc->Init.GeneratingPolynomial, hcrc->Init.CRCLength) != HAL_OK)
 8013282:	e9d4 1202 	ldrd	r1, r2, [r4, #8]
 8013286:	4620      	mov	r0, r4
 8013288:	f000 f80e 	bl	80132a8 <HAL_CRCEx_Polynomial_Set>
 801328c:	b908      	cbnz	r0, 8013292 <HAL_CRC_Init+0x66>
    WRITE_REG(hcrc->Instance->INIT, DEFAULT_CRC_INITVALUE);
 801328e:	6823      	ldr	r3, [r4, #0]
 8013290:	e7df      	b.n	8013252 <HAL_CRC_Init+0x26>
    return HAL_ERROR;
 8013292:	2001      	movs	r0, #1
}
 8013294:	bd10      	pop	{r4, pc}
    hcrc->Lock = HAL_UNLOCKED;
 8013296:	7702      	strb	r2, [r0, #28]
    HAL_CRC_MspInit(hcrc);
 8013298:	f7fe fe7a 	bl	8011f90 <HAL_CRC_MspInit>
 801329c:	e7ce      	b.n	801323c <HAL_CRC_Init+0x10>
    return HAL_ERROR;
 801329e:	2001      	movs	r0, #1
}
 80132a0:	4770      	bx	lr
 80132a2:	bf00      	nop
 80132a4:	04c11db7 	.word	0x04c11db7

080132a8 <HAL_CRCEx_Polynomial_Set>:

  /* Check the parameters */
  assert_param(IS_CRC_POL_LENGTH(PolyLength));

  /* Ensure that the generating polynomial is odd */
  if ((Pol & (uint32_t)(0x1U)) ==  0U)
 80132a8:	07cb      	lsls	r3, r1, #31
 80132aa:	d51a      	bpl.n	80132e2 <HAL_CRCEx_Polynomial_Set+0x3a>
  uint32_t msb = 31U; /* polynomial degree is 32 at most, so msb is initialized to max value */
 80132ac:	231f      	movs	r3, #31
{
 80132ae:	b410      	push	{r4}
     * definition. HAL_ERROR is reported if Pol degree is
     * larger than that indicated by PolyLength.
     * Look for MSB position: msb will contain the degree of
     *  the second to the largest polynomial member. E.g., for
     *  X^7 + X^6 + X^5 + X^2 + 1, msb = 6. */
    while ((msb-- > 0U) && ((Pol & ((uint32_t)(0x1U) << (msb & 0x1FU))) == 0U))
 80132b0:	3b01      	subs	r3, #1
 80132b2:	1c5c      	adds	r4, r3, #1
 80132b4:	fa21 fc03 	lsr.w	ip, r1, r3
 80132b8:	d015      	beq.n	80132e6 <HAL_CRCEx_Polynomial_Set+0x3e>
 80132ba:	f01c 0f01 	tst.w	ip, #1
 80132be:	d0f7      	beq.n	80132b0 <HAL_CRCEx_Polynomial_Set+0x8>
    {
    }

    switch (PolyLength)
 80132c0:	2a18      	cmp	r2, #24
 80132c2:	d811      	bhi.n	80132e8 <HAL_CRCEx_Polynomial_Set+0x40>
 80132c4:	e8df f002 	tbb	[pc, r2]
 80132c8:	10101016 	.word	0x10101016
 80132cc:	10101010 	.word	0x10101010
 80132d0:	10101024 	.word	0x10101024
 80132d4:	10101010 	.word	0x10101010
 80132d8:	10101021 	.word	0x10101021
 80132dc:	10101010 	.word	0x10101010
 80132e0:	14          	.byte	0x14
 80132e1:	00          	.byte	0x00
 80132e2:	2001      	movs	r0, #1
    /* set generating polynomial size */
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, PolyLength);
  }
  /* Return function status */
  return status;
}
 80132e4:	4770      	bx	lr
    switch (PolyLength)
 80132e6:	b12a      	cbz	r2, 80132f4 <HAL_CRCEx_Polynomial_Set+0x4c>
 80132e8:	2001      	movs	r0, #1
}
 80132ea:	f85d 4b04 	ldr.w	r4, [sp], #4
 80132ee:	4770      	bx	lr
        if (msb >= HAL_CRC_LENGTH_7B)
 80132f0:	2b06      	cmp	r3, #6
 80132f2:	d8f9      	bhi.n	80132e8 <HAL_CRCEx_Polynomial_Set+0x40>
    WRITE_REG(hcrc->Instance->POL, Pol);
 80132f4:	6804      	ldr	r4, [r0, #0]
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, PolyLength);
 80132f6:	2000      	movs	r0, #0
    WRITE_REG(hcrc->Instance->POL, Pol);
 80132f8:	6161      	str	r1, [r4, #20]
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, PolyLength);
 80132fa:	68a3      	ldr	r3, [r4, #8]
 80132fc:	f023 0318 	bic.w	r3, r3, #24
 8013300:	4313      	orrs	r3, r2
 8013302:	60a3      	str	r3, [r4, #8]
}
 8013304:	f85d 4b04 	ldr.w	r4, [sp], #4
 8013308:	4770      	bx	lr
        if (msb >= HAL_CRC_LENGTH_8B)
 801330a:	2b07      	cmp	r3, #7
 801330c:	d9f2      	bls.n	80132f4 <HAL_CRCEx_Polynomial_Set+0x4c>
 801330e:	e7eb      	b.n	80132e8 <HAL_CRCEx_Polynomial_Set+0x40>
        if (msb >= HAL_CRC_LENGTH_16B)
 8013310:	2b0f      	cmp	r3, #15
 8013312:	d9ef      	bls.n	80132f4 <HAL_CRCEx_Polynomial_Set+0x4c>
 8013314:	e7e8      	b.n	80132e8 <HAL_CRCEx_Polynomial_Set+0x40>
 8013316:	bf00      	nop

08013318 <DCMI_DMAXferCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void DCMI_DMAXferCplt(DMA_HandleTypeDef *hdma)
{
 8013318:	b510      	push	{r4, lr}
  uint32_t tmp ;

  DCMI_HandleTypeDef *hdcmi = (DCMI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 801331a:	6b84      	ldr	r4, [r0, #56]	@ 0x38

  if (hdcmi->XferCount != 0U)
  {
    /* Update memory 0 address location */
    tmp = ((((DMA_Stream_TypeDef *)(hdcmi->DMA_Handle->Instance))->CR) & DMA_SxCR_CT);
 801331c:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
  if (hdcmi->XferCount != 0U)
 801331e:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
    tmp = ((((DMA_Stream_TypeDef *)(hdcmi->DMA_Handle->Instance))->CR) & DMA_SxCR_CT);
 8013320:	6803      	ldr	r3, [r0, #0]
  if (hdcmi->XferCount != 0U)
 8013322:	b16a      	cbz	r2, 8013340 <DCMI_DMAXferCplt+0x28>
    tmp = ((((DMA_Stream_TypeDef *)(hdcmi->DMA_Handle->Instance))->CR) & DMA_SxCR_CT);
 8013324:	681a      	ldr	r2, [r3, #0]
    if (((hdcmi->XferCount % 2U) == 0U) && (tmp != 0U))
 8013326:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
 8013328:	0312      	lsls	r2, r2, #12
 801332a:	d501      	bpl.n	8013330 <DCMI_DMAXferCplt+0x18>
 801332c:	07c9      	lsls	r1, r1, #31
 801332e:	d532      	bpl.n	8013396 <DCMI_DMAXferCplt+0x7e>
      tmp = ((DMA_Stream_TypeDef *)(hdcmi->DMA_Handle->Instance))->M0AR;
      (void)HAL_DMAEx_ChangeMemory(hdcmi->DMA_Handle, (tmp + (8U * hdcmi->XferSize)), MEMORY0);
      hdcmi->XferCount--;
    }
    /* Update memory 1 address location */
    else if ((((DMA_Stream_TypeDef *)(hdcmi->DMA_Handle->Instance))->CR & DMA_SxCR_CT) == 0U)
 8013330:	681a      	ldr	r2, [r3, #0]
 8013332:	0312      	lsls	r2, r2, #12
 8013334:	d523      	bpl.n	801337e <DCMI_DMAXferCplt+0x66>
  {
    /* Nothing to do */
  }

  /* Check if the frame is transferred */
  if (hdcmi->XferCount == hdcmi->XferTransferNumber)
 8013336:	6c22      	ldr	r2, [r4, #64]	@ 0x40
 8013338:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 801333a:	4293      	cmp	r3, r2
 801333c:	d009      	beq.n	8013352 <DCMI_DMAXferCplt+0x3a>
    if ((hdcmi->Instance->CR & DCMI_CR_CM) == DCMI_MODE_SNAPSHOT)
    {
      hdcmi->State = HAL_DCMI_STATE_READY;
    }
  }
}
 801333e:	bd10      	pop	{r4, pc}
  else if ((((DMA_Stream_TypeDef *)(hdcmi->DMA_Handle->Instance))->CR & DMA_SxCR_CT) != 0U)
 8013340:	6819      	ldr	r1, [r3, #0]
    hdcmi->XferCount = hdcmi->XferTransferNumber;
 8013342:	6c22      	ldr	r2, [r4, #64]	@ 0x40
  else if ((((DMA_Stream_TypeDef *)(hdcmi->DMA_Handle->Instance))->CR & DMA_SxCR_CT) != 0U)
 8013344:	0308      	lsls	r0, r1, #12
 8013346:	d510      	bpl.n	801336a <DCMI_DMAXferCplt+0x52>
    ((DMA_Stream_TypeDef *)(hdcmi->DMA_Handle->Instance))->M0AR = hdcmi->pBuffPtr;
 8013348:	6c61      	ldr	r1, [r4, #68]	@ 0x44
 801334a:	60d9      	str	r1, [r3, #12]
  if (hdcmi->XferCount == hdcmi->XferTransferNumber)
 801334c:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 801334e:	4293      	cmp	r3, r2
 8013350:	d1f5      	bne.n	801333e <DCMI_DMAXferCplt+0x26>
    __HAL_DCMI_ENABLE_IT(hdcmi, DCMI_IT_FRAME);
 8013352:	6823      	ldr	r3, [r4, #0]
 8013354:	68da      	ldr	r2, [r3, #12]
 8013356:	f042 0201 	orr.w	r2, r2, #1
 801335a:	60da      	str	r2, [r3, #12]
    if ((hdcmi->Instance->CR & DCMI_CR_CM) == DCMI_MODE_SNAPSHOT)
 801335c:	681b      	ldr	r3, [r3, #0]
 801335e:	079b      	lsls	r3, r3, #30
 8013360:	d5ed      	bpl.n	801333e <DCMI_DMAXferCplt+0x26>
      hdcmi->State = HAL_DCMI_STATE_READY;
 8013362:	2301      	movs	r3, #1
 8013364:	f884 3035 	strb.w	r3, [r4, #53]	@ 0x35
}
 8013368:	bd10      	pop	{r4, pc}
  else if ((((DMA_Stream_TypeDef *)(hdcmi->DMA_Handle->Instance))->CR & DMA_SxCR_CT) == 0U)
 801336a:	6819      	ldr	r1, [r3, #0]
 801336c:	0309      	lsls	r1, r1, #12
 801336e:	d4e3      	bmi.n	8013338 <DCMI_DMAXferCplt+0x20>
    ((DMA_Stream_TypeDef *)(hdcmi->DMA_Handle->Instance))->M1AR = (tmp + (4U * hdcmi->XferSize));
 8013370:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
 8013372:	6c61      	ldr	r1, [r4, #68]	@ 0x44
 8013374:	eb01 0180 	add.w	r1, r1, r0, lsl #2
 8013378:	6119      	str	r1, [r3, #16]
    hdcmi->XferCount = hdcmi->XferTransferNumber;
 801337a:	63a2      	str	r2, [r4, #56]	@ 0x38
 801337c:	e7dc      	b.n	8013338 <DCMI_DMAXferCplt+0x20>
      tmp = ((DMA_Stream_TypeDef *)(hdcmi->DMA_Handle->Instance))->M1AR;
 801337e:	691b      	ldr	r3, [r3, #16]
      (void)HAL_DMAEx_ChangeMemory(hdcmi->DMA_Handle, (tmp + (8U * hdcmi->XferSize)), MEMORY1);
 8013380:	2201      	movs	r2, #1
 8013382:	6be1      	ldr	r1, [r4, #60]	@ 0x3c
 8013384:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
 8013388:	f001 fd2e 	bl	8014de8 <HAL_DMAEx_ChangeMemory>
      hdcmi->XferCount--;
 801338c:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
  if (hdcmi->XferCount == hdcmi->XferTransferNumber)
 801338e:	6c22      	ldr	r2, [r4, #64]	@ 0x40
      hdcmi->XferCount--;
 8013390:	3b01      	subs	r3, #1
 8013392:	63a3      	str	r3, [r4, #56]	@ 0x38
 8013394:	e7d0      	b.n	8013338 <DCMI_DMAXferCplt+0x20>
      tmp = ((DMA_Stream_TypeDef *)(hdcmi->DMA_Handle->Instance))->M0AR;
 8013396:	68db      	ldr	r3, [r3, #12]
      (void)HAL_DMAEx_ChangeMemory(hdcmi->DMA_Handle, (tmp + (8U * hdcmi->XferSize)), MEMORY0);
 8013398:	2200      	movs	r2, #0
 801339a:	6be1      	ldr	r1, [r4, #60]	@ 0x3c
 801339c:	e7f2      	b.n	8013384 <DCMI_DMAXferCplt+0x6c>
 801339e:	bf00      	nop

080133a0 <HAL_DCMI_Init>:
  if (hdcmi == NULL)
 80133a0:	2800      	cmp	r0, #0
 80133a2:	d047      	beq.n	8013434 <HAL_DCMI_Init+0x94>
{
 80133a4:	b570      	push	{r4, r5, r6, lr}
  if (hdcmi->State == HAL_DCMI_STATE_RESET)
 80133a6:	f890 3035 	ldrb.w	r3, [r0, #53]	@ 0x35
 80133aa:	4604      	mov	r4, r0
 80133ac:	2b00      	cmp	r3, #0
 80133ae:	d03e      	beq.n	801342e <HAL_DCMI_Init+0x8e>
  hdcmi->State = HAL_DCMI_STATE_BUSY;
 80133b0:	2202      	movs	r2, #2
  if (hdcmi->Init.ExtendedDataMode != DCMI_EXTEND_DATA_8B)
 80133b2:	69a3      	ldr	r3, [r4, #24]
  hdcmi->State = HAL_DCMI_STATE_BUSY;
 80133b4:	f884 2035 	strb.w	r2, [r4, #53]	@ 0x35
  if (hdcmi->Init.ExtendedDataMode != DCMI_EXTEND_DATA_8B)
 80133b8:	2b00      	cmp	r3, #0
 80133ba:	d134      	bne.n	8013426 <HAL_DCMI_Init+0x86>
                                    hdcmi->Init.JPEGMode | hdcmi->Init.ByteSelectMode | \
 80133bc:	6a60      	ldr	r0, [r4, #36]	@ 0x24
  hdcmi->Instance->CR |= (uint32_t)(hdcmi->Init.SynchroMode | hdcmi->Init.CaptureRate | \
 80133be:	6861      	ldr	r1, [r4, #4]
 80133c0:	6966      	ldr	r6, [r4, #20]
 80133c2:	430b      	orrs	r3, r1
  hdcmi->Instance->CR &= ~(DCMI_CR_PCKPOL | DCMI_CR_HSPOL  | DCMI_CR_VSPOL  | DCMI_CR_EDM_0 | \
 80133c4:	6822      	ldr	r2, [r4, #0]
  if (hdcmi->Init.SynchroMode == DCMI_SYNCHRO_EMBEDDED)
 80133c6:	2910      	cmp	r1, #16
  hdcmi->Instance->CR |= (uint32_t)(hdcmi->Init.SynchroMode | hdcmi->Init.CaptureRate | \
 80133c8:	ea43 0306 	orr.w	r3, r3, r6
 80133cc:	68e6      	ldr	r6, [r4, #12]
  hdcmi->Instance->CR &= ~(DCMI_CR_PCKPOL | DCMI_CR_HSPOL  | DCMI_CR_VSPOL  | DCMI_CR_EDM_0 | \
 80133ce:	6815      	ldr	r5, [r2, #0]
  hdcmi->Instance->CR |= (uint32_t)(hdcmi->Init.SynchroMode | hdcmi->Init.CaptureRate | \
 80133d0:	ea43 0306 	orr.w	r3, r3, r6
 80133d4:	6926      	ldr	r6, [r4, #16]
 80133d6:	ea43 0306 	orr.w	r3, r3, r6
 80133da:	68a6      	ldr	r6, [r4, #8]
 80133dc:	ea43 0306 	orr.w	r3, r3, r6
 80133e0:	6a26      	ldr	r6, [r4, #32]
 80133e2:	ea43 0306 	orr.w	r3, r3, r6
 80133e6:	6aa6      	ldr	r6, [r4, #40]	@ 0x28
 80133e8:	ea43 0306 	orr.w	r3, r3, r6
 80133ec:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 80133ee:	ea43 0306 	orr.w	r3, r3, r6
  hdcmi->Instance->CR &= ~(DCMI_CR_PCKPOL | DCMI_CR_HSPOL  | DCMI_CR_VSPOL  | DCMI_CR_EDM_0 | \
 80133f2:	4e11      	ldr	r6, [pc, #68]	@ (8013438 <HAL_DCMI_Init+0x98>)
 80133f4:	ea06 0605 	and.w	r6, r6, r5
  hdcmi->Instance->CR |= (uint32_t)(hdcmi->Init.SynchroMode | hdcmi->Init.CaptureRate | \
 80133f8:	6b25      	ldr	r5, [r4, #48]	@ 0x30
  hdcmi->Instance->CR &= ~(DCMI_CR_PCKPOL | DCMI_CR_HSPOL  | DCMI_CR_VSPOL  | DCMI_CR_EDM_0 | \
 80133fa:	6016      	str	r6, [r2, #0]
  hdcmi->Instance->CR |= (uint32_t)(hdcmi->Init.SynchroMode | hdcmi->Init.CaptureRate | \
 80133fc:	ea43 0305 	orr.w	r3, r3, r5
 8013400:	6815      	ldr	r5, [r2, #0]
 8013402:	ea43 0305 	orr.w	r3, r3, r5
 8013406:	ea43 0300 	orr.w	r3, r3, r0
 801340a:	6013      	str	r3, [r2, #0]
  if (hdcmi->Init.SynchroMode == DCMI_SYNCHRO_EMBEDDED)
 801340c:	d101      	bne.n	8013412 <HAL_DCMI_Init+0x72>
                             ((uint32_t)hdcmi->Init.SyncroCode.LineEndCode << DCMI_ESCR_LEC_Pos) | \
 801340e:	69e3      	ldr	r3, [r4, #28]
    hdcmi->Instance->ESCR = (((uint32_t)hdcmi->Init.SyncroCode.FrameStartCode)    | \
 8013410:	6193      	str	r3, [r2, #24]
  __HAL_DCMI_ENABLE_IT(hdcmi, DCMI_IT_LINE | DCMI_IT_VSYNC | DCMI_IT_ERR | DCMI_IT_OVR);
 8013412:	68d3      	ldr	r3, [r2, #12]
  hdcmi->ErrorCode = HAL_DCMI_ERROR_NONE;
 8013414:	2000      	movs	r0, #0
  hdcmi->State  = HAL_DCMI_STATE_READY;
 8013416:	2101      	movs	r1, #1
  __HAL_DCMI_ENABLE_IT(hdcmi, DCMI_IT_LINE | DCMI_IT_VSYNC | DCMI_IT_ERR | DCMI_IT_OVR);
 8013418:	f043 031e 	orr.w	r3, r3, #30
 801341c:	60d3      	str	r3, [r2, #12]
  hdcmi->ErrorCode = HAL_DCMI_ERROR_NONE;
 801341e:	64e0      	str	r0, [r4, #76]	@ 0x4c
  hdcmi->State  = HAL_DCMI_STATE_READY;
 8013420:	f884 1035 	strb.w	r1, [r4, #53]	@ 0x35
}
 8013424:	bd70      	pop	{r4, r5, r6, pc}
    hdcmi->Init.ByteSelectMode = DCMI_BSM_ALL;
 8013426:	2200      	movs	r2, #0
 8013428:	4610      	mov	r0, r2
 801342a:	6262      	str	r2, [r4, #36]	@ 0x24
 801342c:	e7c7      	b.n	80133be <HAL_DCMI_Init+0x1e>
    HAL_DCMI_MspInit(hdcmi);
 801342e:	f7fe fdc5 	bl	8011fbc <HAL_DCMI_MspInit>
 8013432:	e7bd      	b.n	80133b0 <HAL_DCMI_Init+0x10>
    return HAL_ERROR;
 8013434:	2001      	movs	r0, #1
}
 8013436:	4770      	bx	lr
 8013438:	ffe0f007 	.word	0xffe0f007

0801343c <HAL_DCMI_Start_DMA>:
{
 801343c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8013440:	4604      	mov	r4, r0
  __HAL_LOCK(hdcmi);
 8013442:	f890 0034 	ldrb.w	r0, [r0, #52]	@ 0x34
{
 8013446:	b082      	sub	sp, #8
  __HAL_LOCK(hdcmi);
 8013448:	2801      	cmp	r0, #1
 801344a:	d06c      	beq.n	8013526 <HAL_DCMI_Start_DMA+0xea>
  __HAL_DCMI_ENABLE(hdcmi);
 801344c:	6820      	ldr	r0, [r4, #0]
  hdcmi->State = HAL_DCMI_STATE_BUSY;
 801344e:	2502      	movs	r5, #2
  __HAL_LOCK(hdcmi);
 8013450:	f04f 0801 	mov.w	r8, #1
  hdcmi->DMA_Handle->XferCpltCallback = DCMI_DMAXferCplt;
 8013454:	f8df c0d8 	ldr.w	ip, [pc, #216]	@ 8013530 <HAL_DCMI_Start_DMA+0xf4>
  hdcmi->State = HAL_DCMI_STATE_BUSY;
 8013458:	f884 5035 	strb.w	r5, [r4, #53]	@ 0x35
  if (tmp_length <= 0xFFFFU)
 801345c:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
  __HAL_LOCK(hdcmi);
 8013460:	f884 8034 	strb.w	r8, [r4, #52]	@ 0x34
  __HAL_DCMI_ENABLE(hdcmi);
 8013464:	6805      	ldr	r5, [r0, #0]
  hdcmi->DMA_Handle->XferErrorCallback = DCMI_DMAError;
 8013466:	f8df e0cc 	ldr.w	lr, [pc, #204]	@ 8013534 <HAL_DCMI_Start_DMA+0xf8>
  __HAL_DCMI_ENABLE(hdcmi);
 801346a:	f445 4580 	orr.w	r5, r5, #16384	@ 0x4000
 801346e:	6005      	str	r5, [r0, #0]
  hdcmi->Instance->CR &= ~(DCMI_CR_CM);
 8013470:	6805      	ldr	r5, [r0, #0]
 8013472:	f025 0502 	bic.w	r5, r5, #2
 8013476:	6005      	str	r5, [r0, #0]
  hdcmi->Instance->CR |= (uint32_t)(DCMI_Mode);
 8013478:	6805      	ldr	r5, [r0, #0]
 801347a:	ea45 0501 	orr.w	r5, r5, r1
 801347e:	4601      	mov	r1, r0
  hdcmi->DMA_Handle->XferCpltCallback = DCMI_DMAXferCplt;
 8013480:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
  hdcmi->Instance->CR |= (uint32_t)(DCMI_Mode);
 8013482:	f841 5b28 	str.w	r5, [r1], #40
  hdcmi->DMA_Handle->XferAbortCallback = NULL;
 8013486:	f04f 0500 	mov.w	r5, #0
  hdcmi->DMA_Handle->XferCpltCallback = DCMI_DMAXferCplt;
 801348a:	f8c0 c03c 	str.w	ip, [r0, #60]	@ 0x3c
  hdcmi->DMA_Handle->XferAbortCallback = NULL;
 801348e:	6505      	str	r5, [r0, #80]	@ 0x50
  hdcmi->DMA_Handle->XferErrorCallback = DCMI_DMAError;
 8013490:	f8c0 e04c 	str.w	lr, [r0, #76]	@ 0x4c
  hdcmi->XferCount = 0;
 8013494:	63a5      	str	r5, [r4, #56]	@ 0x38
  hdcmi->XferTransferNumber = 0;
 8013496:	6425      	str	r5, [r4, #64]	@ 0x40
  hdcmi->XferSize = 0;
 8013498:	63e5      	str	r5, [r4, #60]	@ 0x3c
  hdcmi->pBuffPtr = 0;
 801349a:	6465      	str	r5, [r4, #68]	@ 0x44
  if (tmp_length <= 0xFFFFU)
 801349c:	d32e      	bcc.n	80134fc <HAL_DCMI_Start_DMA+0xc0>
    hdcmi->DMA_Handle->XferM1CpltCallback = DCMI_DMAXferCplt;
 801349e:	f8c0 c044 	str.w	ip, [r0, #68]	@ 0x44
 80134a2:	4616      	mov	r6, r2
    hdcmi->XferCount = 1;
 80134a4:	f8c4 8038 	str.w	r8, [r4, #56]	@ 0x38
    hdcmi->XferSize = tmp_length;
 80134a8:	63e3      	str	r3, [r4, #60]	@ 0x3c
    while (hdcmi->XferSize > 0xFFFFU)
 80134aa:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
    hdcmi->pBuffPtr = pData;
 80134ac:	6462      	str	r2, [r4, #68]	@ 0x44
    while (hdcmi->XferSize > 0xFFFFU)
 80134ae:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 80134b2:	d309      	bcc.n	80134c8 <HAL_DCMI_Start_DMA+0x8c>
      hdcmi->XferSize = (hdcmi->XferSize / 2U);
 80134b4:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 80134b6:	085b      	lsrs	r3, r3, #1
 80134b8:	63e3      	str	r3, [r4, #60]	@ 0x3c
      hdcmi->XferCount = hdcmi->XferCount * 2U;
 80134ba:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 80134bc:	005b      	lsls	r3, r3, #1
 80134be:	63a3      	str	r3, [r4, #56]	@ 0x38
    while (hdcmi->XferSize > 0xFFFFU)
 80134c0:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 80134c2:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 80134c6:	d2f5      	bcs.n	80134b4 <HAL_DCMI_Start_DMA+0x78>
    hdcmi->XferCount = (hdcmi->XferCount - 2U);
 80134c8:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
    if (HAL_DMAEx_MultiBufferStart_IT(hdcmi->DMA_Handle, (uint32_t)&hdcmi->Instance->DR, (uint32_t)pData, SecondMemAddress, hdcmi->XferSize) != HAL_OK)
 80134ca:	4632      	mov	r2, r6
    hdcmi->XferCount = (hdcmi->XferCount - 2U);
 80134cc:	3b02      	subs	r3, #2
 80134ce:	63a3      	str	r3, [r4, #56]	@ 0x38
    hdcmi->XferTransferNumber = hdcmi->XferCount;
 80134d0:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 80134d2:	6423      	str	r3, [r4, #64]	@ 0x40
    SecondMemAddress = (uint32_t)(pData + (4U * hdcmi->XferSize));
 80134d4:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
    if (HAL_DMAEx_MultiBufferStart_IT(hdcmi->DMA_Handle, (uint32_t)&hdcmi->Instance->DR, (uint32_t)pData, SecondMemAddress, hdcmi->XferSize) != HAL_OK)
 80134d6:	6be5      	ldr	r5, [r4, #60]	@ 0x3c
 80134d8:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 80134dc:	9500      	str	r5, [sp, #0]
 80134de:	f000 fbdd 	bl	8013c9c <HAL_DMAEx_MultiBufferStart_IT>
 80134e2:	b9a0      	cbnz	r0, 801350e <HAL_DCMI_Start_DMA+0xd2>
  hdcmi->Instance->CR |= DCMI_CR_CAPTURE;
 80134e4:	6821      	ldr	r1, [r4, #0]
  __HAL_UNLOCK(hdcmi);
 80134e6:	2200      	movs	r2, #0
  hdcmi->Instance->CR |= DCMI_CR_CAPTURE;
 80134e8:	680b      	ldr	r3, [r1, #0]
  return HAL_OK;
 80134ea:	4610      	mov	r0, r2
  hdcmi->Instance->CR |= DCMI_CR_CAPTURE;
 80134ec:	f043 0301 	orr.w	r3, r3, #1
 80134f0:	600b      	str	r3, [r1, #0]
  __HAL_UNLOCK(hdcmi);
 80134f2:	f884 2034 	strb.w	r2, [r4, #52]	@ 0x34
}
 80134f6:	b002      	add	sp, #8
 80134f8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (HAL_DMA_Start_IT(hdcmi->DMA_Handle, (uint32_t)&hdcmi->Instance->DR, (uint32_t)pData, tmp_length) != HAL_OK)
 80134fc:	f000 f93e 	bl	801377c <HAL_DMA_Start_IT>
 8013500:	2800      	cmp	r0, #0
 8013502:	d0ef      	beq.n	80134e4 <HAL_DCMI_Start_DMA+0xa8>
      hdcmi->ErrorCode = HAL_DCMI_ERROR_DMA;
 8013504:	2340      	movs	r3, #64	@ 0x40
 8013506:	64e3      	str	r3, [r4, #76]	@ 0x4c
      hdcmi->State = HAL_DCMI_STATE_READY;
 8013508:	f884 8035 	strb.w	r8, [r4, #53]	@ 0x35
      return HAL_ERROR;
 801350c:	e004      	b.n	8013518 <HAL_DCMI_Start_DMA+0xdc>
      hdcmi->ErrorCode = HAL_DCMI_ERROR_DMA;
 801350e:	2240      	movs	r2, #64	@ 0x40
      hdcmi->State = HAL_DCMI_STATE_READY;
 8013510:	2301      	movs	r3, #1
      hdcmi->ErrorCode = HAL_DCMI_ERROR_DMA;
 8013512:	64e2      	str	r2, [r4, #76]	@ 0x4c
      hdcmi->State = HAL_DCMI_STATE_READY;
 8013514:	f884 3035 	strb.w	r3, [r4, #53]	@ 0x35
      __HAL_UNLOCK(hdcmi);
 8013518:	2300      	movs	r3, #0
      return HAL_ERROR;
 801351a:	2001      	movs	r0, #1
      __HAL_UNLOCK(hdcmi);
 801351c:	f884 3034 	strb.w	r3, [r4, #52]	@ 0x34
}
 8013520:	b002      	add	sp, #8
 8013522:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  __HAL_LOCK(hdcmi);
 8013526:	2002      	movs	r0, #2
}
 8013528:	b002      	add	sp, #8
 801352a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801352e:	bf00      	nop
 8013530:	08013319 	.word	0x08013319
 8013534:	0801353d 	.word	0x0801353d

08013538 <HAL_DCMI_ErrorCallback>:
__weak void HAL_DCMI_ErrorCallback(DCMI_HandleTypeDef *hdcmi)
 8013538:	4770      	bx	lr
 801353a:	bf00      	nop

0801353c <DCMI_DMAError>:
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void DCMI_DMAError(DMA_HandleTypeDef *hdma)
{
  DCMI_HandleTypeDef *hdcmi = (DCMI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 801353c:	6b80      	ldr	r0, [r0, #56]	@ 0x38
{
 801353e:	b508      	push	{r3, lr}

  if (hdcmi->DMA_Handle->ErrorCode != HAL_DMA_ERROR_FE)
 8013540:	6c83      	ldr	r3, [r0, #72]	@ 0x48
 8013542:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8013544:	2b02      	cmp	r3, #2
 8013546:	d006      	beq.n	8013556 <DCMI_DMAError+0x1a>
  {
    /* Initialize the DCMI state*/
    hdcmi->State = HAL_DCMI_STATE_READY;
 8013548:	2301      	movs	r3, #1
 801354a:	f880 3035 	strb.w	r3, [r0, #53]	@ 0x35

    /* Set DCMI Error Code */
    hdcmi->ErrorCode |= HAL_DCMI_ERROR_DMA;
 801354e:	6cc3      	ldr	r3, [r0, #76]	@ 0x4c
 8013550:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8013554:	64c3      	str	r3, [r0, #76]	@ 0x4c
  /* DCMI error Callback */
#if (USE_HAL_DCMI_REGISTER_CALLBACKS == 1)
  /*Call registered DCMI error callback*/
  hdcmi->ErrorCallback(hdcmi);
#else
  HAL_DCMI_ErrorCallback(hdcmi);
 8013556:	f7ff ffef 	bl	8013538 <HAL_DCMI_ErrorCallback>
#endif /* USE_HAL_DCMI_REGISTER_CALLBACKS */

}
 801355a:	bd08      	pop	{r3, pc}

0801355c <HAL_DCMI_LineEventCallback>:
__weak void HAL_DCMI_LineEventCallback(DCMI_HandleTypeDef *hdcmi)
 801355c:	4770      	bx	lr
 801355e:	bf00      	nop

08013560 <HAL_DCMI_FrameEventCallback>:
__weak void HAL_DCMI_FrameEventCallback(DCMI_HandleTypeDef *hdcmi)
 8013560:	4770      	bx	lr
 8013562:	bf00      	nop

08013564 <HAL_DCMI_IRQHandler>:
{
 8013564:	b538      	push	{r3, r4, r5, lr}
  uint32_t isr_value = READ_REG(hdcmi->Instance->MISR);
 8013566:	6803      	ldr	r3, [r0, #0]
{
 8013568:	4604      	mov	r4, r0
  uint32_t isr_value = READ_REG(hdcmi->Instance->MISR);
 801356a:	691d      	ldr	r5, [r3, #16]
  if ((isr_value & DCMI_FLAG_ERRRI) == DCMI_FLAG_ERRRI)
 801356c:	0769      	lsls	r1, r5, #29
 801356e:	d448      	bmi.n	8013602 <HAL_DCMI_IRQHandler+0x9e>
  if ((isr_value & DCMI_FLAG_OVRRI) == DCMI_FLAG_OVRRI)
 8013570:	07aa      	lsls	r2, r5, #30
 8013572:	d425      	bmi.n	80135c0 <HAL_DCMI_IRQHandler+0x5c>
  if ((isr_value & DCMI_FLAG_LINERI) == DCMI_FLAG_LINERI)
 8013574:	06eb      	lsls	r3, r5, #27
 8013576:	d41c      	bmi.n	80135b2 <HAL_DCMI_IRQHandler+0x4e>
  if ((isr_value & DCMI_FLAG_VSYNCRI) == DCMI_FLAG_VSYNCRI)
 8013578:	0728      	lsls	r0, r5, #28
 801357a:	d413      	bmi.n	80135a4 <HAL_DCMI_IRQHandler+0x40>
  if ((isr_value & DCMI_FLAG_FRAMERI) == DCMI_FLAG_FRAMERI)
 801357c:	07e9      	lsls	r1, r5, #31
 801357e:	d510      	bpl.n	80135a2 <HAL_DCMI_IRQHandler+0x3e>
    if ((hdcmi->Instance->CR & DCMI_CR_CM) == DCMI_MODE_SNAPSHOT)
 8013580:	6823      	ldr	r3, [r4, #0]
 8013582:	681a      	ldr	r2, [r3, #0]
 8013584:	0792      	lsls	r2, r2, #30
 8013586:	d503      	bpl.n	8013590 <HAL_DCMI_IRQHandler+0x2c>
      __HAL_DCMI_DISABLE_IT(hdcmi, DCMI_IT_LINE | DCMI_IT_VSYNC | DCMI_IT_ERR | DCMI_IT_OVR);
 8013588:	68da      	ldr	r2, [r3, #12]
 801358a:	f022 021e 	bic.w	r2, r2, #30
 801358e:	60da      	str	r2, [r3, #12]
    __HAL_DCMI_DISABLE_IT(hdcmi, DCMI_IT_FRAME);
 8013590:	68da      	ldr	r2, [r3, #12]
    __HAL_DCMI_CLEAR_FLAG(hdcmi, DCMI_FLAG_FRAMERI);
 8013592:	2101      	movs	r1, #1
    HAL_DCMI_FrameEventCallback(hdcmi);
 8013594:	4620      	mov	r0, r4
    __HAL_DCMI_DISABLE_IT(hdcmi, DCMI_IT_FRAME);
 8013596:	f022 0201 	bic.w	r2, r2, #1
 801359a:	60da      	str	r2, [r3, #12]
    __HAL_DCMI_CLEAR_FLAG(hdcmi, DCMI_FLAG_FRAMERI);
 801359c:	6159      	str	r1, [r3, #20]
    HAL_DCMI_FrameEventCallback(hdcmi);
 801359e:	f7ff ffdf 	bl	8013560 <HAL_DCMI_FrameEventCallback>
}
 80135a2:	bd38      	pop	{r3, r4, r5, pc}
    __HAL_DCMI_CLEAR_FLAG(hdcmi, DCMI_FLAG_VSYNCRI);
 80135a4:	6823      	ldr	r3, [r4, #0]
 80135a6:	2208      	movs	r2, #8
    HAL_DCMI_VsyncEventCallback(hdcmi);
 80135a8:	4620      	mov	r0, r4
    __HAL_DCMI_CLEAR_FLAG(hdcmi, DCMI_FLAG_VSYNCRI);
 80135aa:	615a      	str	r2, [r3, #20]
    HAL_DCMI_VsyncEventCallback(hdcmi);
 80135ac:	f7fe fc7c 	bl	8011ea8 <HAL_DCMI_VsyncEventCallback>
 80135b0:	e7e4      	b.n	801357c <HAL_DCMI_IRQHandler+0x18>
    __HAL_DCMI_CLEAR_FLAG(hdcmi, DCMI_FLAG_LINERI);
 80135b2:	6823      	ldr	r3, [r4, #0]
 80135b4:	2210      	movs	r2, #16
    HAL_DCMI_LineEventCallback(hdcmi);
 80135b6:	4620      	mov	r0, r4
    __HAL_DCMI_CLEAR_FLAG(hdcmi, DCMI_FLAG_LINERI);
 80135b8:	615a      	str	r2, [r3, #20]
    HAL_DCMI_LineEventCallback(hdcmi);
 80135ba:	f7ff ffcf 	bl	801355c <HAL_DCMI_LineEventCallback>
 80135be:	e7db      	b.n	8013578 <HAL_DCMI_IRQHandler+0x14>
    __HAL_DCMI_CLEAR_FLAG(hdcmi, DCMI_FLAG_OVRRI);
 80135c0:	6823      	ldr	r3, [r4, #0]
 80135c2:	2102      	movs	r1, #2
    hdcmi->DMA_Handle->XferAbortCallback = DCMI_DMAError;
 80135c4:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
    hdcmi->State = HAL_DCMI_STATE_ERROR;
 80135c6:	2204      	movs	r2, #4
    __HAL_DCMI_CLEAR_FLAG(hdcmi, DCMI_FLAG_OVRRI);
 80135c8:	6159      	str	r1, [r3, #20]
    hdcmi->ErrorCode |= HAL_DCMI_ERROR_OVR;
 80135ca:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
 80135cc:	f043 0301 	orr.w	r3, r3, #1
 80135d0:	64e3      	str	r3, [r4, #76]	@ 0x4c
    hdcmi->DMA_Handle->XferAbortCallback = DCMI_DMAError;
 80135d2:	4b1b      	ldr	r3, [pc, #108]	@ (8013640 <HAL_DCMI_IRQHandler+0xdc>)
    hdcmi->State = HAL_DCMI_STATE_ERROR;
 80135d4:	f884 2035 	strb.w	r2, [r4, #53]	@ 0x35
    hdcmi->DMA_Handle->XferAbortCallback = DCMI_DMAError;
 80135d8:	6503      	str	r3, [r0, #80]	@ 0x50
    if (HAL_DMA_Abort_IT(hdcmi->DMA_Handle) != HAL_OK)
 80135da:	f000 f959 	bl	8013890 <HAL_DMA_Abort_IT>
 80135de:	2800      	cmp	r0, #0
 80135e0:	d0c8      	beq.n	8013574 <HAL_DCMI_IRQHandler+0x10>
  DCMI_HandleTypeDef *hdcmi = (DCMI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 80135e2:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
 80135e4:	6b98      	ldr	r0, [r3, #56]	@ 0x38
  if (hdcmi->DMA_Handle->ErrorCode != HAL_DMA_ERROR_FE)
 80135e6:	6c83      	ldr	r3, [r0, #72]	@ 0x48
 80135e8:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 80135ea:	2b02      	cmp	r3, #2
 80135ec:	d006      	beq.n	80135fc <HAL_DCMI_IRQHandler+0x98>
    hdcmi->State = HAL_DCMI_STATE_READY;
 80135ee:	2301      	movs	r3, #1
 80135f0:	f880 3035 	strb.w	r3, [r0, #53]	@ 0x35
    hdcmi->ErrorCode |= HAL_DCMI_ERROR_DMA;
 80135f4:	6cc3      	ldr	r3, [r0, #76]	@ 0x4c
 80135f6:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 80135fa:	64c3      	str	r3, [r0, #76]	@ 0x4c
  HAL_DCMI_ErrorCallback(hdcmi);
 80135fc:	f7ff ff9c 	bl	8013538 <HAL_DCMI_ErrorCallback>
}
 8013600:	e7b8      	b.n	8013574 <HAL_DCMI_IRQHandler+0x10>
    __HAL_DCMI_CLEAR_FLAG(hdcmi, DCMI_FLAG_ERRRI);
 8013602:	2204      	movs	r2, #4
    hdcmi->DMA_Handle->XferAbortCallback = DCMI_DMAError;
 8013604:	6c80      	ldr	r0, [r0, #72]	@ 0x48
    __HAL_DCMI_CLEAR_FLAG(hdcmi, DCMI_FLAG_ERRRI);
 8013606:	615a      	str	r2, [r3, #20]
    hdcmi->ErrorCode |= HAL_DCMI_ERROR_SYNC;
 8013608:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
 801360a:	f043 0302 	orr.w	r3, r3, #2
 801360e:	64e3      	str	r3, [r4, #76]	@ 0x4c
    hdcmi->DMA_Handle->XferAbortCallback = DCMI_DMAError;
 8013610:	4b0b      	ldr	r3, [pc, #44]	@ (8013640 <HAL_DCMI_IRQHandler+0xdc>)
    hdcmi->State = HAL_DCMI_STATE_ERROR;
 8013612:	f884 2035 	strb.w	r2, [r4, #53]	@ 0x35
    hdcmi->DMA_Handle->XferAbortCallback = DCMI_DMAError;
 8013616:	6503      	str	r3, [r0, #80]	@ 0x50
    if (HAL_DMA_Abort_IT(hdcmi->DMA_Handle) != HAL_OK)
 8013618:	f000 f93a 	bl	8013890 <HAL_DMA_Abort_IT>
 801361c:	2800      	cmp	r0, #0
 801361e:	d0a7      	beq.n	8013570 <HAL_DCMI_IRQHandler+0xc>
  DCMI_HandleTypeDef *hdcmi = (DCMI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8013620:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
 8013622:	6b98      	ldr	r0, [r3, #56]	@ 0x38
  if (hdcmi->DMA_Handle->ErrorCode != HAL_DMA_ERROR_FE)
 8013624:	6c83      	ldr	r3, [r0, #72]	@ 0x48
 8013626:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8013628:	2b02      	cmp	r3, #2
 801362a:	d006      	beq.n	801363a <HAL_DCMI_IRQHandler+0xd6>
    hdcmi->State = HAL_DCMI_STATE_READY;
 801362c:	2301      	movs	r3, #1
 801362e:	f880 3035 	strb.w	r3, [r0, #53]	@ 0x35
    hdcmi->ErrorCode |= HAL_DCMI_ERROR_DMA;
 8013632:	6cc3      	ldr	r3, [r0, #76]	@ 0x4c
 8013634:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8013638:	64c3      	str	r3, [r0, #76]	@ 0x4c
  HAL_DCMI_ErrorCallback(hdcmi);
 801363a:	f7ff ff7d 	bl	8013538 <HAL_DCMI_ErrorCallback>
}
 801363e:	e797      	b.n	8013570 <HAL_DCMI_IRQHandler+0xc>
 8013640:	0801353d 	.word	0x0801353d

08013644 <HAL_DMA_Init>:
  * @param  hdma Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
 8013644:	b538      	push	{r3, r4, r5, lr}
 8013646:	4604      	mov	r4, r0
  uint32_t tmp = 0U;
  uint32_t tickstart = HAL_GetTick();
 8013648:	f7ff fc10 	bl	8012e6c <HAL_GetTick>
  DMA_Base_Registers *regs;

  /* Check the DMA peripheral state */
  if(hdma == NULL)
 801364c:	2c00      	cmp	r4, #0
 801364e:	d074      	beq.n	801373a <HAL_DMA_Init+0xf6>
  /* Allocate lock resource */
  __HAL_UNLOCK(hdma);

  
  /* Disable the peripheral */
  __HAL_DMA_DISABLE(hdma);
 8013650:	6823      	ldr	r3, [r4, #0]
  __HAL_UNLOCK(hdma);
 8013652:	2200      	movs	r2, #0
  hdma->State = HAL_DMA_STATE_BUSY;
 8013654:	2102      	movs	r1, #2
 8013656:	4605      	mov	r5, r0
  __HAL_UNLOCK(hdma);
 8013658:	f884 2034 	strb.w	r2, [r4, #52]	@ 0x34
  hdma->State = HAL_DMA_STATE_BUSY;
 801365c:	f884 1035 	strb.w	r1, [r4, #53]	@ 0x35
  __HAL_DMA_DISABLE(hdma);
 8013660:	681a      	ldr	r2, [r3, #0]
 8013662:	f022 0201 	bic.w	r2, r2, #1
 8013666:	601a      	str	r2, [r3, #0]
  
  /* Check if the DMA Stream is effectively disabled */
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 8013668:	e005      	b.n	8013676 <HAL_DMA_Init+0x32>
  {
    /* Check for the Timeout */
    if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 801366a:	f7ff fbff 	bl	8012e6c <HAL_GetTick>
 801366e:	1b43      	subs	r3, r0, r5
 8013670:	2b05      	cmp	r3, #5
 8013672:	d83e      	bhi.n	80136f2 <HAL_DMA_Init+0xae>
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 8013674:	6823      	ldr	r3, [r4, #0]
 8013676:	681a      	ldr	r2, [r3, #0]
 8013678:	07d1      	lsls	r1, r2, #31
 801367a:	d4f6      	bmi.n	801366a <HAL_DMA_Init+0x26>
                      DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 801367c:	e9d4 2501 	ldrd	r2, r5, [r4, #4]
 8013680:	68e1      	ldr	r1, [r4, #12]
 8013682:	432a      	orrs	r2, r5
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8013684:	69a0      	ldr	r0, [r4, #24]
  tmp = hdma->Instance->CR;
 8013686:	681d      	ldr	r5, [r3, #0]
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8013688:	430a      	orrs	r2, r1
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 801368a:	6921      	ldr	r1, [r4, #16]
 801368c:	430a      	orrs	r2, r1
 801368e:	6961      	ldr	r1, [r4, #20]
 8013690:	430a      	orrs	r2, r1
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8013692:	69e1      	ldr	r1, [r4, #28]
 8013694:	4302      	orrs	r2, r0
 8013696:	430a      	orrs	r2, r1
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 8013698:	4934      	ldr	r1, [pc, #208]	@ (801376c <HAL_DMA_Init+0x128>)
 801369a:	4029      	ands	r1, r5
          hdma->Init.Mode                | hdma->Init.Priority;
 801369c:	6a25      	ldr	r5, [r4, #32]
 801369e:	432a      	orrs	r2, r5
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 80136a0:	430a      	orrs	r2, r1

  /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 80136a2:	6a61      	ldr	r1, [r4, #36]	@ 0x24
 80136a4:	2904      	cmp	r1, #4
 80136a6:	d02b      	beq.n	8013700 <HAL_DMA_Init+0xbc>
    /* Get memory burst and peripheral burst */
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
  }
  
  /* Write to DMA Stream CR register */
  hdma->Instance->CR = tmp;  
 80136a8:	601a      	str	r2, [r3, #0]

  /* Get the FCR register value */
  tmp = hdma->Instance->FCR;
 80136aa:	695a      	ldr	r2, [r3, #20]

  /* Clear Direct mode and FIFO threshold bits */
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 80136ac:	f022 0207 	bic.w	r2, r2, #7

  /* Prepare the DMA Stream FIFO configuration */
  tmp |= hdma->Init.FIFOMode;
 80136b0:	4311      	orrs	r1, r2
  *                     the configuration information for the specified DMA Stream. 
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 80136b2:	b2da      	uxtb	r2, r3
  hdma->Instance->FCR = tmp;
 80136b4:	6159      	str	r1, [r3, #20]
  
  /* lookup table for necessary bitshift of flags within status registers */
  static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 80136b6:	482e      	ldr	r0, [pc, #184]	@ (8013770 <HAL_DMA_Init+0x12c>)
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 80136b8:	f1a2 0110 	sub.w	r1, r2, #16
 80136bc:	4a2d      	ldr	r2, [pc, #180]	@ (8013774 <HAL_DMA_Init+0x130>)
 80136be:	fba2 5201 	umull	r5, r2, r2, r1
  
  if (stream_number > 3U)
 80136c2:	295f      	cmp	r1, #95	@ 0x5f
  hdma->State = HAL_DMA_STATE_READY;
 80136c4:	f04f 0501 	mov.w	r5, #1
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 80136c8:	f04f 0100 	mov.w	r1, #0
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 80136cc:	ea4f 1212 	mov.w	r2, r2, lsr #4
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 80136d0:	5c80      	ldrb	r0, [r0, r2]
  {
    /* return pointer to HISR and HIFCR */
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 80136d2:	4a29      	ldr	r2, [pc, #164]	@ (8013778 <HAL_DMA_Init+0x134>)
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 80136d4:	65e0      	str	r0, [r4, #92]	@ 0x5c
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 80136d6:	ea02 0203 	and.w	r2, r2, r3
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 80136da:	f04f 033f 	mov.w	r3, #63	@ 0x3f
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 80136de:	bf88      	it	hi
 80136e0:	3204      	addhi	r2, #4
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 80136e2:	4083      	lsls	r3, r0
  return HAL_OK;
 80136e4:	4608      	mov	r0, r1
 80136e6:	65a2      	str	r2, [r4, #88]	@ 0x58
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 80136e8:	6093      	str	r3, [r2, #8]
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 80136ea:	6561      	str	r1, [r4, #84]	@ 0x54
  hdma->State = HAL_DMA_STATE_READY;
 80136ec:	f884 5035 	strb.w	r5, [r4, #53]	@ 0x35
}
 80136f0:	bd38      	pop	{r3, r4, r5, pc}
      hdma->State = HAL_DMA_STATE_TIMEOUT;
 80136f2:	2303      	movs	r3, #3
      hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 80136f4:	2220      	movs	r2, #32
      return HAL_TIMEOUT;
 80136f6:	4618      	mov	r0, r3
      hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 80136f8:	6562      	str	r2, [r4, #84]	@ 0x54
      hdma->State = HAL_DMA_STATE_TIMEOUT;
 80136fa:	f884 3035 	strb.w	r3, [r4, #53]	@ 0x35
}
 80136fe:	bd38      	pop	{r3, r4, r5, pc}
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
 8013700:	e9d4 510b 	ldrd	r5, r1, [r4, #44]	@ 0x2c
 8013704:	4329      	orrs	r1, r5
 8013706:	4311      	orrs	r1, r2
    tmp |= hdma->Init.FIFOThreshold;
 8013708:	6aa2      	ldr	r2, [r4, #40]	@ 0x28
  hdma->Instance->CR = tmp;  
 801370a:	6019      	str	r1, [r3, #0]
  tmp = hdma->Instance->FCR;
 801370c:	6959      	ldr	r1, [r3, #20]
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 801370e:	f021 0107 	bic.w	r1, r1, #7
 8013712:	4311      	orrs	r1, r2
    tmp |= hdma->Init.FIFOThreshold;
 8013714:	f041 0104 	orr.w	r1, r1, #4
    if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
 8013718:	2d00      	cmp	r5, #0
 801371a:	d0ca      	beq.n	80136b2 <HAL_DMA_Init+0x6e>
{
  HAL_StatusTypeDef status = HAL_OK;
  uint32_t tmp = hdma->Init.FIFOThreshold;
  
  /* Memory Data size equal to Byte */
  if(hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
 801371c:	b178      	cbz	r0, 801373e <HAL_DMA_Init+0xfa>
      break;
    }
  }
  
  /* Memory Data size equal to Half-Word */
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 801371e:	f5b0 5f00 	cmp.w	r0, #8192	@ 0x2000
 8013722:	d016      	beq.n	8013752 <HAL_DMA_Init+0x10e>
  }
  
  /* Memory Data size equal to Word */
  else
  {
    switch (tmp)
 8013724:	2a02      	cmp	r2, #2
 8013726:	d903      	bls.n	8013730 <HAL_DMA_Init+0xec>
 8013728:	2a03      	cmp	r2, #3
 801372a:	d1c2      	bne.n	80136b2 <HAL_DMA_Init+0x6e>
    case DMA_FIFO_THRESHOLD_HALFFULL:
    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
      status = HAL_ERROR;
      break;
    case DMA_FIFO_THRESHOLD_FULL:
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 801372c:	01ea      	lsls	r2, r5, #7
 801372e:	d5c0      	bpl.n	80136b2 <HAL_DMA_Init+0x6e>
        hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 8013730:	2240      	movs	r2, #64	@ 0x40
        hdma->State = HAL_DMA_STATE_RESET;
 8013732:	2300      	movs	r3, #0
        hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 8013734:	6562      	str	r2, [r4, #84]	@ 0x54
        hdma->State = HAL_DMA_STATE_RESET;
 8013736:	f884 3035 	strb.w	r3, [r4, #53]	@ 0x35
    return HAL_ERROR;
 801373a:	2001      	movs	r0, #1
}
 801373c:	bd38      	pop	{r3, r4, r5, pc}
    switch (tmp)
 801373e:	2a01      	cmp	r2, #1
 8013740:	d003      	beq.n	801374a <HAL_DMA_Init+0x106>
 8013742:	f032 0202 	bics.w	r2, r2, #2
 8013746:	d1b4      	bne.n	80136b2 <HAL_DMA_Init+0x6e>
 8013748:	e7f0      	b.n	801372c <HAL_DMA_Init+0xe8>
      if (hdma->Init.MemBurst == DMA_MBURST_INC16)
 801374a:	f1b5 7fc0 	cmp.w	r5, #25165824	@ 0x1800000
 801374e:	d1b0      	bne.n	80136b2 <HAL_DMA_Init+0x6e>
 8013750:	e7ee      	b.n	8013730 <HAL_DMA_Init+0xec>
    switch (tmp)
 8013752:	2a03      	cmp	r2, #3
 8013754:	d8ad      	bhi.n	80136b2 <HAL_DMA_Init+0x6e>
 8013756:	a001      	add	r0, pc, #4	@ (adr r0, 801375c <HAL_DMA_Init+0x118>)
 8013758:	f850 f022 	ldr.w	pc, [r0, r2, lsl #2]
 801375c:	08013731 	.word	0x08013731
 8013760:	0801372d 	.word	0x0801372d
 8013764:	08013731 	.word	0x08013731
 8013768:	0801374b 	.word	0x0801374b
 801376c:	f010803f 	.word	0xf010803f
 8013770:	08034c28 	.word	0x08034c28
 8013774:	aaaaaaab 	.word	0xaaaaaaab
 8013778:	fffffc00 	.word	0xfffffc00

0801377c <HAL_DMA_Start_IT>:
{
 801377c:	b470      	push	{r4, r5, r6}
  __HAL_LOCK(hdma);
 801377e:	f890 c034 	ldrb.w	ip, [r0, #52]	@ 0x34
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 8013782:	6d86      	ldr	r6, [r0, #88]	@ 0x58
  __HAL_LOCK(hdma);
 8013784:	f1bc 0f01 	cmp.w	ip, #1
 8013788:	d009      	beq.n	801379e <HAL_DMA_Start_IT+0x22>
 801378a:	2401      	movs	r4, #1
 801378c:	f880 4034 	strb.w	r4, [r0, #52]	@ 0x34
  if(HAL_DMA_STATE_READY == hdma->State)
 8013790:	f890 4035 	ldrb.w	r4, [r0, #53]	@ 0x35
 8013794:	2c01      	cmp	r4, #1
 8013796:	d005      	beq.n	80137a4 <HAL_DMA_Start_IT+0x28>
    __HAL_UNLOCK(hdma);	  
 8013798:	2300      	movs	r3, #0
 801379a:	f880 3034 	strb.w	r3, [r0, #52]	@ 0x34
  __HAL_LOCK(hdma);
 801379e:	2002      	movs	r0, #2
}
 80137a0:	bc70      	pop	{r4, r5, r6}
 80137a2:	4770      	bx	lr
    hdma->State = HAL_DMA_STATE_BUSY;
 80137a4:	2502      	movs	r5, #2
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
 80137a6:	6804      	ldr	r4, [r0, #0]
    hdma->State = HAL_DMA_STATE_BUSY;
 80137a8:	f880 5035 	strb.w	r5, [r0, #53]	@ 0x35
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 80137ac:	2500      	movs	r5, #0
 80137ae:	6545      	str	r5, [r0, #84]	@ 0x54
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
 80137b0:	6825      	ldr	r5, [r4, #0]
 80137b2:	f425 2580 	bic.w	r5, r5, #262144	@ 0x40000
 80137b6:	6025      	str	r5, [r4, #0]
  hdma->Instance->NDTR = DataLength;
 80137b8:	6063      	str	r3, [r4, #4]
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 80137ba:	6883      	ldr	r3, [r0, #8]
 80137bc:	2b40      	cmp	r3, #64	@ 0x40
 80137be:	d01a      	beq.n	80137f6 <HAL_DMA_Start_IT+0x7a>
    hdma->Instance->PAR = SrcAddress;
 80137c0:	60a1      	str	r1, [r4, #8]
    hdma->Instance->M0AR = DstAddress;
 80137c2:	60e2      	str	r2, [r4, #12]
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 80137c4:	6dc1      	ldr	r1, [r0, #92]	@ 0x5c
 80137c6:	233f      	movs	r3, #63	@ 0x3f
    if(hdma->XferHalfCpltCallback != NULL)
 80137c8:	6c02      	ldr	r2, [r0, #64]	@ 0x40
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 80137ca:	408b      	lsls	r3, r1
 80137cc:	60b3      	str	r3, [r6, #8]
    hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
 80137ce:	6823      	ldr	r3, [r4, #0]
 80137d0:	f043 0316 	orr.w	r3, r3, #22
 80137d4:	6023      	str	r3, [r4, #0]
    hdma->Instance->FCR |= DMA_IT_FE;
 80137d6:	6963      	ldr	r3, [r4, #20]
 80137d8:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 80137dc:	6163      	str	r3, [r4, #20]
    if(hdma->XferHalfCpltCallback != NULL)
 80137de:	b11a      	cbz	r2, 80137e8 <HAL_DMA_Start_IT+0x6c>
      hdma->Instance->CR  |= DMA_IT_HT;
 80137e0:	6823      	ldr	r3, [r4, #0]
 80137e2:	f043 0308 	orr.w	r3, r3, #8
 80137e6:	6023      	str	r3, [r4, #0]
    __HAL_DMA_ENABLE(hdma);
 80137e8:	6823      	ldr	r3, [r4, #0]
  HAL_StatusTypeDef status = HAL_OK;
 80137ea:	2000      	movs	r0, #0
    __HAL_DMA_ENABLE(hdma);
 80137ec:	f043 0301 	orr.w	r3, r3, #1
 80137f0:	6023      	str	r3, [r4, #0]
}
 80137f2:	bc70      	pop	{r4, r5, r6}
 80137f4:	4770      	bx	lr
    hdma->Instance->PAR = DstAddress;
 80137f6:	60a2      	str	r2, [r4, #8]
    hdma->Instance->M0AR = SrcAddress;
 80137f8:	60e1      	str	r1, [r4, #12]
 80137fa:	e7e3      	b.n	80137c4 <HAL_DMA_Start_IT+0x48>

080137fc <HAL_DMA_Abort>:
{
 80137fc:	b570      	push	{r4, r5, r6, lr}
 80137fe:	4604      	mov	r4, r0
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 8013800:	6d85      	ldr	r5, [r0, #88]	@ 0x58
  uint32_t tickstart = HAL_GetTick();
 8013802:	f7ff fb33 	bl	8012e6c <HAL_GetTick>
  if(hdma->State != HAL_DMA_STATE_BUSY)
 8013806:	f894 3035 	ldrb.w	r3, [r4, #53]	@ 0x35
 801380a:	2b02      	cmp	r3, #2
 801380c:	d006      	beq.n	801381c <HAL_DMA_Abort+0x20>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 801380e:	2380      	movs	r3, #128	@ 0x80
    return HAL_ERROR;
 8013810:	2001      	movs	r0, #1
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8013812:	6563      	str	r3, [r4, #84]	@ 0x54
    __HAL_UNLOCK(hdma);
 8013814:	2300      	movs	r3, #0
 8013816:	f884 3034 	strb.w	r3, [r4, #52]	@ 0x34
}
 801381a:	bd70      	pop	{r4, r5, r6, pc}
    hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 801381c:	6823      	ldr	r3, [r4, #0]
 801381e:	4606      	mov	r6, r0
 8013820:	681a      	ldr	r2, [r3, #0]
 8013822:	f022 0216 	bic.w	r2, r2, #22
 8013826:	601a      	str	r2, [r3, #0]
    hdma->Instance->FCR &= ~(DMA_IT_FE);
 8013828:	695a      	ldr	r2, [r3, #20]
 801382a:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
 801382e:	615a      	str	r2, [r3, #20]
    if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 8013830:	6c22      	ldr	r2, [r4, #64]	@ 0x40
 8013832:	b34a      	cbz	r2, 8013888 <HAL_DMA_Abort+0x8c>
      hdma->Instance->CR  &= ~(DMA_IT_HT);
 8013834:	681a      	ldr	r2, [r3, #0]
 8013836:	f022 0208 	bic.w	r2, r2, #8
 801383a:	601a      	str	r2, [r3, #0]
    __HAL_DMA_DISABLE(hdma);
 801383c:	681a      	ldr	r2, [r3, #0]
 801383e:	f022 0201 	bic.w	r2, r2, #1
 8013842:	601a      	str	r2, [r3, #0]
    while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 8013844:	e005      	b.n	8013852 <HAL_DMA_Abort+0x56>
      if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 8013846:	f7ff fb11 	bl	8012e6c <HAL_GetTick>
 801384a:	1b83      	subs	r3, r0, r6
 801384c:	2b05      	cmp	r3, #5
 801384e:	d811      	bhi.n	8013874 <HAL_DMA_Abort+0x78>
    while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 8013850:	6823      	ldr	r3, [r4, #0]
 8013852:	681b      	ldr	r3, [r3, #0]
 8013854:	f013 0301 	ands.w	r3, r3, #1
 8013858:	d1f5      	bne.n	8013846 <HAL_DMA_Abort+0x4a>
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 801385a:	6de1      	ldr	r1, [r4, #92]	@ 0x5c
 801385c:	223f      	movs	r2, #63	@ 0x3f
  return HAL_OK;
 801385e:	4618      	mov	r0, r3
    __HAL_UNLOCK(hdma);
 8013860:	2300      	movs	r3, #0
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 8013862:	fa02 f101 	lsl.w	r1, r2, r1
    hdma->State = HAL_DMA_STATE_READY;
 8013866:	2201      	movs	r2, #1
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 8013868:	60a9      	str	r1, [r5, #8]
    hdma->State = HAL_DMA_STATE_READY;
 801386a:	f884 2035 	strb.w	r2, [r4, #53]	@ 0x35
    __HAL_UNLOCK(hdma);
 801386e:	f884 3034 	strb.w	r3, [r4, #52]	@ 0x34
}
 8013872:	bd70      	pop	{r4, r5, r6, pc}
        hdma->State = HAL_DMA_STATE_TIMEOUT;
 8013874:	2303      	movs	r3, #3
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 8013876:	2220      	movs	r2, #32
        return HAL_TIMEOUT;
 8013878:	4618      	mov	r0, r3
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 801387a:	6562      	str	r2, [r4, #84]	@ 0x54
        hdma->State = HAL_DMA_STATE_TIMEOUT;
 801387c:	f884 3035 	strb.w	r3, [r4, #53]	@ 0x35
    __HAL_UNLOCK(hdma);
 8013880:	2300      	movs	r3, #0
 8013882:	f884 3034 	strb.w	r3, [r4, #52]	@ 0x34
}
 8013886:	bd70      	pop	{r4, r5, r6, pc}
    if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 8013888:	6ca2      	ldr	r2, [r4, #72]	@ 0x48
 801388a:	2a00      	cmp	r2, #0
 801388c:	d1d2      	bne.n	8013834 <HAL_DMA_Abort+0x38>
 801388e:	e7d5      	b.n	801383c <HAL_DMA_Abort+0x40>

08013890 <HAL_DMA_Abort_IT>:
  if(hdma->State != HAL_DMA_STATE_BUSY)
 8013890:	f890 2035 	ldrb.w	r2, [r0, #53]	@ 0x35
{
 8013894:	4603      	mov	r3, r0
  if(hdma->State != HAL_DMA_STATE_BUSY)
 8013896:	2a02      	cmp	r2, #2
 8013898:	d003      	beq.n	80138a2 <HAL_DMA_Abort_IT+0x12>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 801389a:	2280      	movs	r2, #128	@ 0x80
    return HAL_ERROR;
 801389c:	2001      	movs	r0, #1
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 801389e:	655a      	str	r2, [r3, #84]	@ 0x54
    return HAL_ERROR;
 80138a0:	4770      	bx	lr
    __HAL_DMA_DISABLE(hdma);
 80138a2:	6802      	ldr	r2, [r0, #0]
    hdma->State = HAL_DMA_STATE_ABORT;
 80138a4:	2105      	movs	r1, #5
  return HAL_OK;
 80138a6:	2000      	movs	r0, #0
    hdma->State = HAL_DMA_STATE_ABORT;
 80138a8:	f883 1035 	strb.w	r1, [r3, #53]	@ 0x35
    __HAL_DMA_DISABLE(hdma);
 80138ac:	6813      	ldr	r3, [r2, #0]
 80138ae:	f023 0301 	bic.w	r3, r3, #1
 80138b2:	6013      	str	r3, [r2, #0]
}
 80138b4:	4770      	bx	lr
 80138b6:	bf00      	nop

080138b8 <HAL_DMA_IRQHandler>:
{
 80138b8:	b5f0      	push	{r4, r5, r6, r7, lr}
  __IO uint32_t count = 0;
 80138ba:	2200      	movs	r2, #0
  uint32_t timeout = SystemCoreClock / 9600;
 80138bc:	4b66      	ldr	r3, [pc, #408]	@ (8013a58 <HAL_DMA_IRQHandler+0x1a0>)
{
 80138be:	b083      	sub	sp, #12
 80138c0:	4604      	mov	r4, r0
  uint32_t timeout = SystemCoreClock / 9600;
 80138c2:	681e      	ldr	r6, [r3, #0]
  __IO uint32_t count = 0;
 80138c4:	9201      	str	r2, [sp, #4]
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 80138c6:	2208      	movs	r2, #8
 80138c8:	e9d0 7316 	ldrd	r7, r3, [r0, #88]	@ 0x58
  tmpisr = regs->ISR;
 80138cc:	683d      	ldr	r5, [r7, #0]
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 80138ce:	409a      	lsls	r2, r3
 80138d0:	422a      	tst	r2, r5
 80138d2:	d004      	beq.n	80138de <HAL_DMA_IRQHandler+0x26>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
 80138d4:	6801      	ldr	r1, [r0, #0]
 80138d6:	6808      	ldr	r0, [r1, #0]
 80138d8:	0740      	lsls	r0, r0, #29
 80138da:	f100 8097 	bmi.w	8013a0c <HAL_DMA_IRQHandler+0x154>
  if ((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
 80138de:	2201      	movs	r2, #1
 80138e0:	409a      	lsls	r2, r3
 80138e2:	422a      	tst	r2, r5
 80138e4:	d004      	beq.n	80138f0 <HAL_DMA_IRQHandler+0x38>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
 80138e6:	6821      	ldr	r1, [r4, #0]
 80138e8:	6949      	ldr	r1, [r1, #20]
 80138ea:	0608      	lsls	r0, r1, #24
 80138ec:	f100 8088 	bmi.w	8013a00 <HAL_DMA_IRQHandler+0x148>
  if ((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
 80138f0:	2204      	movs	r2, #4
 80138f2:	409a      	lsls	r2, r3
 80138f4:	422a      	tst	r2, r5
 80138f6:	d003      	beq.n	8013900 <HAL_DMA_IRQHandler+0x48>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
 80138f8:	6821      	ldr	r1, [r4, #0]
 80138fa:	6809      	ldr	r1, [r1, #0]
 80138fc:	0789      	lsls	r1, r1, #30
 80138fe:	d479      	bmi.n	80139f4 <HAL_DMA_IRQHandler+0x13c>
  if ((tmpisr & (DMA_FLAG_HTIF0_4 << hdma->StreamIndex)) != RESET)
 8013900:	2210      	movs	r2, #16
 8013902:	409a      	lsls	r2, r3
 8013904:	422a      	tst	r2, r5
 8013906:	d003      	beq.n	8013910 <HAL_DMA_IRQHandler+0x58>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
 8013908:	6821      	ldr	r1, [r4, #0]
 801390a:	6808      	ldr	r0, [r1, #0]
 801390c:	0700      	lsls	r0, r0, #28
 801390e:	d45e      	bmi.n	80139ce <HAL_DMA_IRQHandler+0x116>
  if ((tmpisr & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
 8013910:	2220      	movs	r2, #32
 8013912:	409a      	lsls	r2, r3
 8013914:	422a      	tst	r2, r5
 8013916:	d014      	beq.n	8013942 <HAL_DMA_IRQHandler+0x8a>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
 8013918:	6821      	ldr	r1, [r4, #0]
 801391a:	6808      	ldr	r0, [r1, #0]
 801391c:	06c0      	lsls	r0, r0, #27
 801391e:	d510      	bpl.n	8013942 <HAL_DMA_IRQHandler+0x8a>
      regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
 8013920:	60ba      	str	r2, [r7, #8]
      if(HAL_DMA_STATE_ABORT == hdma->State)
 8013922:	f894 2035 	ldrb.w	r2, [r4, #53]	@ 0x35
 8013926:	2a05      	cmp	r2, #5
 8013928:	d033      	beq.n	8013992 <HAL_DMA_IRQHandler+0xda>
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 801392a:	680b      	ldr	r3, [r1, #0]
 801392c:	f413 2f80 	tst.w	r3, #262144	@ 0x40000
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 8013930:	680b      	ldr	r3, [r1, #0]
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 8013932:	d07b      	beq.n	8013a2c <HAL_DMA_IRQHandler+0x174>
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 8013934:	0319      	lsls	r1, r3, #12
 8013936:	f140 8086 	bpl.w	8013a46 <HAL_DMA_IRQHandler+0x18e>
        if(hdma->XferCpltCallback != NULL)
 801393a:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 801393c:	b10b      	cbz	r3, 8013942 <HAL_DMA_IRQHandler+0x8a>
          hdma->XferCpltCallback(hdma);
 801393e:	4620      	mov	r0, r4
 8013940:	4798      	blx	r3
  if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
 8013942:	6d63      	ldr	r3, [r4, #84]	@ 0x54
 8013944:	2b00      	cmp	r3, #0
 8013946:	d040      	beq.n	80139ca <HAL_DMA_IRQHandler+0x112>
    if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
 8013948:	6d63      	ldr	r3, [r4, #84]	@ 0x54
 801394a:	07da      	lsls	r2, r3, #31
 801394c:	d51a      	bpl.n	8013984 <HAL_DMA_IRQHandler+0xcc>
      __HAL_DMA_DISABLE(hdma);
 801394e:	6822      	ldr	r2, [r4, #0]
      hdma->State = HAL_DMA_STATE_ABORT;
 8013950:	2105      	movs	r1, #5
  uint32_t timeout = SystemCoreClock / 9600;
 8013952:	4b42      	ldr	r3, [pc, #264]	@ (8013a5c <HAL_DMA_IRQHandler+0x1a4>)
      hdma->State = HAL_DMA_STATE_ABORT;
 8013954:	f884 1035 	strb.w	r1, [r4, #53]	@ 0x35
  uint32_t timeout = SystemCoreClock / 9600;
 8013958:	fba3 3606 	umull	r3, r6, r3, r6
      __HAL_DMA_DISABLE(hdma);
 801395c:	6813      	ldr	r3, [r2, #0]
 801395e:	f023 0301 	bic.w	r3, r3, #1
  uint32_t timeout = SystemCoreClock / 9600;
 8013962:	0ab6      	lsrs	r6, r6, #10
      __HAL_DMA_DISABLE(hdma);
 8013964:	6013      	str	r3, [r2, #0]
 8013966:	e002      	b.n	801396e <HAL_DMA_IRQHandler+0xb6>
      while((hdma->Instance->CR & DMA_SxCR_EN) != RESET);
 8013968:	6813      	ldr	r3, [r2, #0]
 801396a:	07db      	lsls	r3, r3, #31
 801396c:	d504      	bpl.n	8013978 <HAL_DMA_IRQHandler+0xc0>
        if (++count > timeout)
 801396e:	9b01      	ldr	r3, [sp, #4]
 8013970:	3301      	adds	r3, #1
 8013972:	42b3      	cmp	r3, r6
 8013974:	9301      	str	r3, [sp, #4]
 8013976:	d9f7      	bls.n	8013968 <HAL_DMA_IRQHandler+0xb0>
      hdma->State = HAL_DMA_STATE_READY;
 8013978:	2201      	movs	r2, #1
      __HAL_UNLOCK(hdma);
 801397a:	2300      	movs	r3, #0
      hdma->State = HAL_DMA_STATE_READY;
 801397c:	f884 2035 	strb.w	r2, [r4, #53]	@ 0x35
      __HAL_UNLOCK(hdma);
 8013980:	f884 3034 	strb.w	r3, [r4, #52]	@ 0x34
    if(hdma->XferErrorCallback != NULL)
 8013984:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
 8013986:	b303      	cbz	r3, 80139ca <HAL_DMA_IRQHandler+0x112>
      hdma->XferErrorCallback(hdma);
 8013988:	4620      	mov	r0, r4
}
 801398a:	b003      	add	sp, #12
 801398c:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
      hdma->XferErrorCallback(hdma);
 8013990:	4718      	bx	r3
        hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 8013992:	680a      	ldr	r2, [r1, #0]
 8013994:	f022 0216 	bic.w	r2, r2, #22
 8013998:	600a      	str	r2, [r1, #0]
        hdma->Instance->FCR &= ~(DMA_IT_FE);
 801399a:	694a      	ldr	r2, [r1, #20]
 801399c:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
 80139a0:	614a      	str	r2, [r1, #20]
        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 80139a2:	6c22      	ldr	r2, [r4, #64]	@ 0x40
 80139a4:	2a00      	cmp	r2, #0
 80139a6:	d053      	beq.n	8013a50 <HAL_DMA_IRQHandler+0x198>
          hdma->Instance->CR  &= ~(DMA_IT_HT);
 80139a8:	680a      	ldr	r2, [r1, #0]
 80139aa:	f022 0208 	bic.w	r2, r2, #8
 80139ae:	600a      	str	r2, [r1, #0]
        regs->IFCR = 0x3FU << hdma->StreamIndex;
 80139b0:	223f      	movs	r2, #63	@ 0x3f
        hdma->State = HAL_DMA_STATE_READY;
 80139b2:	2101      	movs	r1, #1
        regs->IFCR = 0x3FU << hdma->StreamIndex;
 80139b4:	fa02 f303 	lsl.w	r3, r2, r3
        __HAL_UNLOCK(hdma);
 80139b8:	2200      	movs	r2, #0
        regs->IFCR = 0x3FU << hdma->StreamIndex;
 80139ba:	60bb      	str	r3, [r7, #8]
        if(hdma->XferAbortCallback != NULL)
 80139bc:	6d23      	ldr	r3, [r4, #80]	@ 0x50
        hdma->State = HAL_DMA_STATE_READY;
 80139be:	f884 1035 	strb.w	r1, [r4, #53]	@ 0x35
        __HAL_UNLOCK(hdma);
 80139c2:	f884 2034 	strb.w	r2, [r4, #52]	@ 0x34
        if(hdma->XferAbortCallback != NULL)
 80139c6:	2b00      	cmp	r3, #0
 80139c8:	d1de      	bne.n	8013988 <HAL_DMA_IRQHandler+0xd0>
}
 80139ca:	b003      	add	sp, #12
 80139cc:	bdf0      	pop	{r4, r5, r6, r7, pc}
      regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
 80139ce:	60ba      	str	r2, [r7, #8]
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 80139d0:	680a      	ldr	r2, [r1, #0]
 80139d2:	f412 2f80 	tst.w	r2, #262144	@ 0x40000
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 80139d6:	680a      	ldr	r2, [r1, #0]
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 80139d8:	d122      	bne.n	8013a20 <HAL_DMA_IRQHandler+0x168>
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
 80139da:	05d2      	lsls	r2, r2, #23
 80139dc:	d403      	bmi.n	80139e6 <HAL_DMA_IRQHandler+0x12e>
          hdma->Instance->CR  &= ~(DMA_IT_HT);
 80139de:	680a      	ldr	r2, [r1, #0]
 80139e0:	f022 0208 	bic.w	r2, r2, #8
 80139e4:	600a      	str	r2, [r1, #0]
        if(hdma->XferHalfCpltCallback != NULL)
 80139e6:	6c22      	ldr	r2, [r4, #64]	@ 0x40
 80139e8:	2a00      	cmp	r2, #0
 80139ea:	d091      	beq.n	8013910 <HAL_DMA_IRQHandler+0x58>
          hdma->XferHalfCpltCallback(hdma);
 80139ec:	4620      	mov	r0, r4
 80139ee:	4790      	blx	r2
  if ((tmpisr & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
 80139f0:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
 80139f2:	e78d      	b.n	8013910 <HAL_DMA_IRQHandler+0x58>
      regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
 80139f4:	60ba      	str	r2, [r7, #8]
      hdma->ErrorCode |= HAL_DMA_ERROR_DME;
 80139f6:	6d62      	ldr	r2, [r4, #84]	@ 0x54
 80139f8:	f042 0204 	orr.w	r2, r2, #4
 80139fc:	6562      	str	r2, [r4, #84]	@ 0x54
 80139fe:	e77f      	b.n	8013900 <HAL_DMA_IRQHandler+0x48>
      regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
 8013a00:	60ba      	str	r2, [r7, #8]
      hdma->ErrorCode |= HAL_DMA_ERROR_FE;
 8013a02:	6d62      	ldr	r2, [r4, #84]	@ 0x54
 8013a04:	f042 0202 	orr.w	r2, r2, #2
 8013a08:	6562      	str	r2, [r4, #84]	@ 0x54
 8013a0a:	e771      	b.n	80138f0 <HAL_DMA_IRQHandler+0x38>
      hdma->Instance->CR  &= ~(DMA_IT_TE);
 8013a0c:	6808      	ldr	r0, [r1, #0]
 8013a0e:	f020 0004 	bic.w	r0, r0, #4
 8013a12:	6008      	str	r0, [r1, #0]
      regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
 8013a14:	60ba      	str	r2, [r7, #8]
      hdma->ErrorCode |= HAL_DMA_ERROR_TE;
 8013a16:	6d62      	ldr	r2, [r4, #84]	@ 0x54
 8013a18:	f042 0201 	orr.w	r2, r2, #1
 8013a1c:	6562      	str	r2, [r4, #84]	@ 0x54
 8013a1e:	e75e      	b.n	80138de <HAL_DMA_IRQHandler+0x26>
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 8013a20:	0311      	lsls	r1, r2, #12
 8013a22:	d5e0      	bpl.n	80139e6 <HAL_DMA_IRQHandler+0x12e>
          if(hdma->XferM1HalfCpltCallback != NULL)
 8013a24:	6ca2      	ldr	r2, [r4, #72]	@ 0x48
 8013a26:	2a00      	cmp	r2, #0
 8013a28:	d1e0      	bne.n	80139ec <HAL_DMA_IRQHandler+0x134>
 8013a2a:	e771      	b.n	8013910 <HAL_DMA_IRQHandler+0x58>
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
 8013a2c:	f413 7380 	ands.w	r3, r3, #256	@ 0x100
 8013a30:	d183      	bne.n	801393a <HAL_DMA_IRQHandler+0x82>
          hdma->Instance->CR  &= ~(DMA_IT_TC);
 8013a32:	680a      	ldr	r2, [r1, #0]
 8013a34:	f022 0210 	bic.w	r2, r2, #16
 8013a38:	600a      	str	r2, [r1, #0]
          hdma->State = HAL_DMA_STATE_READY;
 8013a3a:	2201      	movs	r2, #1
          __HAL_UNLOCK(hdma);
 8013a3c:	f884 3034 	strb.w	r3, [r4, #52]	@ 0x34
          hdma->State = HAL_DMA_STATE_READY;
 8013a40:	f884 2035 	strb.w	r2, [r4, #53]	@ 0x35
          __HAL_UNLOCK(hdma);
 8013a44:	e779      	b.n	801393a <HAL_DMA_IRQHandler+0x82>
          if(hdma->XferM1CpltCallback != NULL)
 8013a46:	6c63      	ldr	r3, [r4, #68]	@ 0x44
 8013a48:	2b00      	cmp	r3, #0
 8013a4a:	f47f af78 	bne.w	801393e <HAL_DMA_IRQHandler+0x86>
 8013a4e:	e778      	b.n	8013942 <HAL_DMA_IRQHandler+0x8a>
        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 8013a50:	6ca2      	ldr	r2, [r4, #72]	@ 0x48
 8013a52:	2a00      	cmp	r2, #0
 8013a54:	d1a8      	bne.n	80139a8 <HAL_DMA_IRQHandler+0xf0>
 8013a56:	e7ab      	b.n	80139b0 <HAL_DMA_IRQHandler+0xf8>
 8013a58:	2000000c 	.word	0x2000000c
 8013a5c:	1b4e81b5 	.word	0x1b4e81b5

08013a60 <HAL_DMA_GetError>:
  return hdma->ErrorCode;
 8013a60:	6d40      	ldr	r0, [r0, #84]	@ 0x54
}
 8013a62:	4770      	bx	lr

08013a64 <HAL_DMA2D_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA2D_Init(DMA2D_HandleTypeDef *hdma2d)
{
  /* Check the DMA2D peripheral state */
  if (hdma2d == NULL)
 8013a64:	b338      	cbz	r0, 8013ab6 <HAL_DMA2D_Init+0x52>
{
 8013a66:	b538      	push	{r3, r4, r5, lr}

    /* Init the low level hardware */
    hdma2d->MspInitCallback(hdma2d);
  }
#else
  if (hdma2d->State == HAL_DMA2D_STATE_RESET)
 8013a68:	f890 3039 	ldrb.w	r3, [r0, #57]	@ 0x39
 8013a6c:	4604      	mov	r4, r0
 8013a6e:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
 8013a72:	b1db      	cbz	r3, 8013aac <HAL_DMA2D_Init+0x48>

  /* Change DMA2D peripheral state */
  hdma2d->State = HAL_DMA2D_STATE_BUSY;

  /* DMA2D CR register configuration -------------------------------------------*/
  MODIFY_REG(hdma2d->Instance->CR, DMA2D_CR_MODE, hdma2d->Init.Mode);
 8013a74:	6823      	ldr	r3, [r4, #0]
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
 8013a76:	2102      	movs	r1, #2

  /* DMA2D OPFCCR register configuration ---------------------------------------*/
  MODIFY_REG(hdma2d->Instance->OPFCCR, DMA2D_OPFCCR_CM, hdma2d->Init.ColorMode);

  /* DMA2D OOR register configuration ------------------------------------------*/
  MODIFY_REG(hdma2d->Instance->OOR, DMA2D_OOR_LO, hdma2d->Init.OutputOffset);
 8013a78:	68e5      	ldr	r5, [r4, #12]
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
 8013a7a:	f884 1039 	strb.w	r1, [r4, #57]	@ 0x39
  MODIFY_REG(hdma2d->Instance->CR, DMA2D_CR_MODE, hdma2d->Init.Mode);
 8013a7e:	6819      	ldr	r1, [r3, #0]
  MODIFY_REG(hdma2d->Instance->OPFCCR, DMA2D_OPFCCR_CM, hdma2d->Init.ColorMode);
 8013a80:	e9d4 2001 	ldrd	r2, r0, [r4, #4]
  MODIFY_REG(hdma2d->Instance->CR, DMA2D_CR_MODE, hdma2d->Init.Mode);
 8013a84:	f421 3140 	bic.w	r1, r1, #196608	@ 0x30000
 8013a88:	4311      	orrs	r1, r2
  MODIFY_REG(hdma2d->Instance->OOR, DMA2D_OOR_LO, hdma2d->Init.OutputOffset);
 8013a8a:	4a0c      	ldr	r2, [pc, #48]	@ (8013abc <HAL_DMA2D_Init+0x58>)
  MODIFY_REG(hdma2d->Instance->CR, DMA2D_CR_MODE, hdma2d->Init.Mode);
 8013a8c:	6019      	str	r1, [r3, #0]
  MODIFY_REG(hdma2d->Instance->OPFCCR, DMA2D_OPFCCR_CM, hdma2d->Init.ColorMode);
 8013a8e:	6b59      	ldr	r1, [r3, #52]	@ 0x34
 8013a90:	f021 0107 	bic.w	r1, r1, #7
 8013a94:	4301      	orrs	r1, r0
              (hdma2d->Init.RedBlueSwap << DMA2D_OPFCCR_RBS_Pos)));
#endif /* DMA2D_ALPHA_INV_RB_SWAP_SUPPORT */


  /* Update error code */
  hdma2d->ErrorCode = HAL_DMA2D_ERROR_NONE;
 8013a96:	2000      	movs	r0, #0
  MODIFY_REG(hdma2d->Instance->OPFCCR, DMA2D_OPFCCR_CM, hdma2d->Init.ColorMode);
 8013a98:	6359      	str	r1, [r3, #52]	@ 0x34
  MODIFY_REG(hdma2d->Instance->OOR, DMA2D_OOR_LO, hdma2d->Init.OutputOffset);
 8013a9a:	6c19      	ldr	r1, [r3, #64]	@ 0x40
 8013a9c:	400a      	ands	r2, r1
 8013a9e:	432a      	orrs	r2, r5
 8013aa0:	641a      	str	r2, [r3, #64]	@ 0x40

  /* Initialize the DMA2D state*/
  hdma2d->State  = HAL_DMA2D_STATE_READY;
 8013aa2:	2301      	movs	r3, #1
  hdma2d->ErrorCode = HAL_DMA2D_ERROR_NONE;
 8013aa4:	63e0      	str	r0, [r4, #60]	@ 0x3c
  hdma2d->State  = HAL_DMA2D_STATE_READY;
 8013aa6:	f884 3039 	strb.w	r3, [r4, #57]	@ 0x39

  return HAL_OK;
}
 8013aaa:	bd38      	pop	{r3, r4, r5, pc}
    hdma2d->Lock = HAL_UNLOCKED;
 8013aac:	f880 2038 	strb.w	r2, [r0, #56]	@ 0x38
    HAL_DMA2D_MspInit(hdma2d);
 8013ab0:	f7fe fb44 	bl	801213c <HAL_DMA2D_MspInit>
 8013ab4:	e7de      	b.n	8013a74 <HAL_DMA2D_Init+0x10>
    return HAL_ERROR;
 8013ab6:	2001      	movs	r0, #1
}
 8013ab8:	4770      	bx	lr
 8013aba:	bf00      	nop
 8013abc:	ffffc000 	.word	0xffffc000

08013ac0 <HAL_DMA2D_LineEventCallback>:
  * @brief  Transfer watermark callback.
  * @param  hdma2d pointer to a DMA2D_HandleTypeDef structure that contains
  *                 the configuration information for the DMA2D.
  * @retval None
  */
__weak void HAL_DMA2D_LineEventCallback(DMA2D_HandleTypeDef *hdma2d)
 8013ac0:	4770      	bx	lr
 8013ac2:	bf00      	nop

08013ac4 <HAL_DMA2D_CLUTLoadingCpltCallback>:
  * @brief  CLUT Transfer Complete callback.
  * @param  hdma2d pointer to a DMA2D_HandleTypeDef structure that contains
  *                 the configuration information for the DMA2D.
  * @retval None
  */
__weak void HAL_DMA2D_CLUTLoadingCpltCallback(DMA2D_HandleTypeDef *hdma2d)
 8013ac4:	4770      	bx	lr
 8013ac6:	bf00      	nop

08013ac8 <HAL_DMA2D_IRQHandler>:
  uint32_t isrflags = READ_REG(hdma2d->Instance->ISR);
 8013ac8:	6803      	ldr	r3, [r0, #0]
{
 8013aca:	b570      	push	{r4, r5, r6, lr}
  uint32_t isrflags = READ_REG(hdma2d->Instance->ISR);
 8013acc:	685d      	ldr	r5, [r3, #4]
{
 8013ace:	4604      	mov	r4, r0
  uint32_t crflags = READ_REG(hdma2d->Instance->CR);
 8013ad0:	681e      	ldr	r6, [r3, #0]
  if ((isrflags & DMA2D_FLAG_TE) != 0U)
 8013ad2:	07ea      	lsls	r2, r5, #31
 8013ad4:	d501      	bpl.n	8013ada <HAL_DMA2D_IRQHandler+0x12>
    if ((crflags & DMA2D_IT_TE) != 0U)
 8013ad6:	05f1      	lsls	r1, r6, #23
 8013ad8:	d456      	bmi.n	8013b88 <HAL_DMA2D_IRQHandler+0xc0>
  if ((isrflags & DMA2D_FLAG_CE) != 0U)
 8013ada:	06aa      	lsls	r2, r5, #26
 8013adc:	d501      	bpl.n	8013ae2 <HAL_DMA2D_IRQHandler+0x1a>
    if ((crflags & DMA2D_IT_CE) != 0U)
 8013ade:	04b3      	lsls	r3, r6, #18
 8013ae0:	d43b      	bmi.n	8013b5a <HAL_DMA2D_IRQHandler+0x92>
  if ((isrflags & DMA2D_FLAG_CAE) != 0U)
 8013ae2:	0728      	lsls	r0, r5, #28
 8013ae4:	d501      	bpl.n	8013aea <HAL_DMA2D_IRQHandler+0x22>
    if ((crflags & DMA2D_IT_CAE) != 0U)
 8013ae6:	0531      	lsls	r1, r6, #20
 8013ae8:	d421      	bmi.n	8013b2e <HAL_DMA2D_IRQHandler+0x66>
  if ((isrflags & DMA2D_FLAG_TW) != 0U)
 8013aea:	076a      	lsls	r2, r5, #29
 8013aec:	d501      	bpl.n	8013af2 <HAL_DMA2D_IRQHandler+0x2a>
    if ((crflags & DMA2D_IT_TW) != 0U)
 8013aee:	0573      	lsls	r3, r6, #21
 8013af0:	d472      	bmi.n	8013bd8 <HAL_DMA2D_IRQHandler+0x110>
  if ((isrflags & DMA2D_FLAG_TC) != 0U)
 8013af2:	07a8      	lsls	r0, r5, #30
 8013af4:	d501      	bpl.n	8013afa <HAL_DMA2D_IRQHandler+0x32>
    if ((crflags & DMA2D_IT_TC) != 0U)
 8013af6:	05b1      	lsls	r1, r6, #22
 8013af8:	d404      	bmi.n	8013b04 <HAL_DMA2D_IRQHandler+0x3c>
  if ((isrflags & DMA2D_FLAG_CTC) != 0U)
 8013afa:	06ea      	lsls	r2, r5, #27
 8013afc:	d501      	bpl.n	8013b02 <HAL_DMA2D_IRQHandler+0x3a>
    if ((crflags & DMA2D_IT_CTC) != 0U)
 8013afe:	04f3      	lsls	r3, r6, #19
 8013b00:	d457      	bmi.n	8013bb2 <HAL_DMA2D_IRQHandler+0xea>
}
 8013b02:	bd70      	pop	{r4, r5, r6, pc}
      __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_TC);
 8013b04:	6823      	ldr	r3, [r4, #0]
 8013b06:	681a      	ldr	r2, [r3, #0]
 8013b08:	f422 7200 	bic.w	r2, r2, #512	@ 0x200
 8013b0c:	601a      	str	r2, [r3, #0]
      __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TC);
 8013b0e:	2202      	movs	r2, #2
 8013b10:	609a      	str	r2, [r3, #8]
      hdma2d->State = HAL_DMA2D_STATE_READY;
 8013b12:	2201      	movs	r2, #1
      hdma2d->ErrorCode |= HAL_DMA2D_ERROR_NONE;
 8013b14:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 8013b16:	63e3      	str	r3, [r4, #60]	@ 0x3c
      __HAL_UNLOCK(hdma2d);
 8013b18:	2300      	movs	r3, #0
      hdma2d->State = HAL_DMA2D_STATE_READY;
 8013b1a:	f884 2039 	strb.w	r2, [r4, #57]	@ 0x39
      __HAL_UNLOCK(hdma2d);
 8013b1e:	f884 3038 	strb.w	r3, [r4, #56]	@ 0x38
      if (hdma2d->XferCpltCallback != NULL)
 8013b22:	6923      	ldr	r3, [r4, #16]
 8013b24:	2b00      	cmp	r3, #0
 8013b26:	d0e8      	beq.n	8013afa <HAL_DMA2D_IRQHandler+0x32>
        hdma2d->XferCpltCallback(hdma2d);
 8013b28:	4620      	mov	r0, r4
 8013b2a:	4798      	blx	r3
 8013b2c:	e7e5      	b.n	8013afa <HAL_DMA2D_IRQHandler+0x32>
      __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_CAE);
 8013b2e:	6823      	ldr	r3, [r4, #0]
 8013b30:	681a      	ldr	r2, [r3, #0]
 8013b32:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
 8013b36:	601a      	str	r2, [r3, #0]
      __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CAE);
 8013b38:	2208      	movs	r2, #8
 8013b3a:	609a      	str	r2, [r3, #8]
      hdma2d->State = HAL_DMA2D_STATE_ERROR;
 8013b3c:	2204      	movs	r2, #4
      hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CAE;
 8013b3e:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 8013b40:	4313      	orrs	r3, r2
 8013b42:	63e3      	str	r3, [r4, #60]	@ 0x3c
      hdma2d->State = HAL_DMA2D_STATE_ERROR;
 8013b44:	f884 2039 	strb.w	r2, [r4, #57]	@ 0x39
      __HAL_UNLOCK(hdma2d);
 8013b48:	2200      	movs	r2, #0
      if (hdma2d->XferErrorCallback != NULL)
 8013b4a:	6963      	ldr	r3, [r4, #20]
      __HAL_UNLOCK(hdma2d);
 8013b4c:	f884 2038 	strb.w	r2, [r4, #56]	@ 0x38
      if (hdma2d->XferErrorCallback != NULL)
 8013b50:	2b00      	cmp	r3, #0
 8013b52:	d0ca      	beq.n	8013aea <HAL_DMA2D_IRQHandler+0x22>
        hdma2d->XferErrorCallback(hdma2d);
 8013b54:	4620      	mov	r0, r4
 8013b56:	4798      	blx	r3
 8013b58:	e7c7      	b.n	8013aea <HAL_DMA2D_IRQHandler+0x22>
      __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_CE);
 8013b5a:	6823      	ldr	r3, [r4, #0]
 8013b5c:	681a      	ldr	r2, [r3, #0]
 8013b5e:	f422 5200 	bic.w	r2, r2, #8192	@ 0x2000
 8013b62:	601a      	str	r2, [r3, #0]
      __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CE);
 8013b64:	2220      	movs	r2, #32
 8013b66:	609a      	str	r2, [r3, #8]
      hdma2d->State = HAL_DMA2D_STATE_ERROR;
 8013b68:	2204      	movs	r2, #4
      hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CE;
 8013b6a:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 8013b6c:	f043 0302 	orr.w	r3, r3, #2
 8013b70:	63e3      	str	r3, [r4, #60]	@ 0x3c
      hdma2d->State = HAL_DMA2D_STATE_ERROR;
 8013b72:	f884 2039 	strb.w	r2, [r4, #57]	@ 0x39
      __HAL_UNLOCK(hdma2d);
 8013b76:	2200      	movs	r2, #0
      if (hdma2d->XferErrorCallback != NULL)
 8013b78:	6963      	ldr	r3, [r4, #20]
      __HAL_UNLOCK(hdma2d);
 8013b7a:	f884 2038 	strb.w	r2, [r4, #56]	@ 0x38
      if (hdma2d->XferErrorCallback != NULL)
 8013b7e:	2b00      	cmp	r3, #0
 8013b80:	d0af      	beq.n	8013ae2 <HAL_DMA2D_IRQHandler+0x1a>
        hdma2d->XferErrorCallback(hdma2d);
 8013b82:	4620      	mov	r0, r4
 8013b84:	4798      	blx	r3
 8013b86:	e7ac      	b.n	8013ae2 <HAL_DMA2D_IRQHandler+0x1a>
      __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_TE);
 8013b88:	681a      	ldr	r2, [r3, #0]
 8013b8a:	f422 7280 	bic.w	r2, r2, #256	@ 0x100
 8013b8e:	601a      	str	r2, [r3, #0]
      hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TE;
 8013b90:	6bc2      	ldr	r2, [r0, #60]	@ 0x3c
 8013b92:	f042 0201 	orr.w	r2, r2, #1
 8013b96:	63c2      	str	r2, [r0, #60]	@ 0x3c
      __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TE);
 8013b98:	2201      	movs	r2, #1
 8013b9a:	609a      	str	r2, [r3, #8]
      hdma2d->State = HAL_DMA2D_STATE_ERROR;
 8013b9c:	2304      	movs	r3, #4
 8013b9e:	f880 3039 	strb.w	r3, [r0, #57]	@ 0x39
      __HAL_UNLOCK(hdma2d);
 8013ba2:	2300      	movs	r3, #0
 8013ba4:	f880 3038 	strb.w	r3, [r0, #56]	@ 0x38
      if (hdma2d->XferErrorCallback != NULL)
 8013ba8:	6943      	ldr	r3, [r0, #20]
 8013baa:	2b00      	cmp	r3, #0
 8013bac:	d095      	beq.n	8013ada <HAL_DMA2D_IRQHandler+0x12>
        hdma2d->XferErrorCallback(hdma2d);
 8013bae:	4798      	blx	r3
 8013bb0:	e793      	b.n	8013ada <HAL_DMA2D_IRQHandler+0x12>
      __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_CTC);
 8013bb2:	6823      	ldr	r3, [r4, #0]
      __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CTC);
 8013bb4:	2010      	movs	r0, #16
      hdma2d->State = HAL_DMA2D_STATE_READY;
 8013bb6:	2101      	movs	r1, #1
      __HAL_UNLOCK(hdma2d);
 8013bb8:	2500      	movs	r5, #0
      __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_CTC);
 8013bba:	681a      	ldr	r2, [r3, #0]
 8013bbc:	f422 5280 	bic.w	r2, r2, #4096	@ 0x1000
 8013bc0:	601a      	str	r2, [r3, #0]
      __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CTC);
 8013bc2:	6098      	str	r0, [r3, #8]
      HAL_DMA2D_CLUTLoadingCpltCallback(hdma2d);
 8013bc4:	4620      	mov	r0, r4
      hdma2d->ErrorCode |= HAL_DMA2D_ERROR_NONE;
 8013bc6:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
      __HAL_UNLOCK(hdma2d);
 8013bc8:	f884 5038 	strb.w	r5, [r4, #56]	@ 0x38
      hdma2d->ErrorCode |= HAL_DMA2D_ERROR_NONE;
 8013bcc:	63e3      	str	r3, [r4, #60]	@ 0x3c
      hdma2d->State = HAL_DMA2D_STATE_READY;
 8013bce:	f884 1039 	strb.w	r1, [r4, #57]	@ 0x39
      HAL_DMA2D_CLUTLoadingCpltCallback(hdma2d);
 8013bd2:	f7ff ff77 	bl	8013ac4 <HAL_DMA2D_CLUTLoadingCpltCallback>
}
 8013bd6:	bd70      	pop	{r4, r5, r6, pc}
      __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_TW);
 8013bd8:	6823      	ldr	r3, [r4, #0]
      HAL_DMA2D_LineEventCallback(hdma2d);
 8013bda:	4620      	mov	r0, r4
      __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_TW);
 8013bdc:	681a      	ldr	r2, [r3, #0]
 8013bde:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 8013be2:	601a      	str	r2, [r3, #0]
      __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TW);
 8013be4:	2204      	movs	r2, #4
 8013be6:	609a      	str	r2, [r3, #8]
      HAL_DMA2D_LineEventCallback(hdma2d);
 8013be8:	f7ff ff6a 	bl	8013ac0 <HAL_DMA2D_LineEventCallback>
 8013bec:	e781      	b.n	8013af2 <HAL_DMA2D_IRQHandler+0x2a>
 8013bee:	bf00      	nop

08013bf0 <HAL_DMA2D_ConfigLayer>:
  assert_param(IS_DMA2D_ALPHA_INVERTED(hdma2d->LayerCfg[LayerIdx].AlphaInverted));
  assert_param(IS_DMA2D_RB_SWAP(hdma2d->LayerCfg[LayerIdx].RedBlueSwap));
#endif /* DMA2D_ALPHA_INV_RB_SWAP_SUPPORT */

  /* Process locked */
  __HAL_LOCK(hdma2d);
 8013bf0:	f890 2038 	ldrb.w	r2, [r0, #56]	@ 0x38
 8013bf4:	2a01      	cmp	r2, #1
 8013bf6:	d04d      	beq.n	8013c94 <HAL_DMA2D_ConfigLayer+0xa4>
 8013bf8:	4603      	mov	r3, r0
#if defined (DMA2D_ALPHA_INV_RB_SWAP_SUPPORT)
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos) | \
             (pLayerCfg->AlphaInverted << DMA2D_BGPFCCR_AI_Pos) | (pLayerCfg->RedBlueSwap << DMA2D_BGPFCCR_RBS_Pos);
  regMask  = (DMA2D_BGPFCCR_CM | DMA2D_BGPFCCR_AM | DMA2D_BGPFCCR_ALPHA | DMA2D_BGPFCCR_AI | DMA2D_BGPFCCR_RBS);
#else
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos);
 8013bfa:	eb00 1c01 	add.w	ip, r0, r1, lsl #4
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
 8013bfe:	2202      	movs	r2, #2
  __HAL_LOCK(hdma2d);
 8013c00:	2001      	movs	r0, #1
{
 8013c02:	b470      	push	{r4, r5, r6}
  __HAL_LOCK(hdma2d);
 8013c04:	f883 0038 	strb.w	r0, [r3, #56]	@ 0x38
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
 8013c08:	f883 2039 	strb.w	r2, [r3, #57]	@ 0x39

  /* Configure the background DMA2D layer */
  if (LayerIdx == DMA2D_BACKGROUND_LAYER)
  {
    /* Write DMA2D BGPFCCR register */
    MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
 8013c0c:	681c      	ldr	r4, [r3, #0]
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos);
 8013c0e:	e9dc 0207 	ldrd	r0, r2, [ip, #28]
 8013c12:	ea40 4202 	orr.w	r2, r0, r2, lsl #16
  if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
 8013c16:	3809      	subs	r0, #9
 8013c18:	2801      	cmp	r0, #1
 8013c1a:	d91d      	bls.n	8013c58 <HAL_DMA2D_ConfigLayer+0x68>
    regValue |= (pLayerCfg->InputAlpha << DMA2D_BGPFCCR_ALPHA_Pos);
 8013c1c:	f8dc 0024 	ldr.w	r0, [ip, #36]	@ 0x24
 8013c20:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
  if (LayerIdx == DMA2D_BACKGROUND_LAYER)
 8013c24:	b181      	cbz	r1, 8013c48 <HAL_DMA2D_ConfigLayer+0x58>
  else
  {


    /* Write DMA2D FGPFCCR register */
    MODIFY_REG(hdma2d->Instance->FGPFCCR, regMask, regValue);
 8013c26:	69e5      	ldr	r5, [r4, #28]
 8013c28:	491b      	ldr	r1, [pc, #108]	@ (8013c98 <HAL_DMA2D_ConfigLayer+0xa8>)

    /* DMA2D FGOR register configuration -------------------------------------*/
    WRITE_REG(hdma2d->Instance->FGOR, pLayerCfg->InputOffset);
 8013c2a:	f8dc 0018 	ldr.w	r0, [ip, #24]
    MODIFY_REG(hdma2d->Instance->FGPFCCR, regMask, regValue);
 8013c2e:	4029      	ands	r1, r5
 8013c30:	4311      	orrs	r1, r2
 8013c32:	61e1      	str	r1, [r4, #28]
    WRITE_REG(hdma2d->Instance->FGOR, pLayerCfg->InputOffset);
 8013c34:	6120      	str	r0, [r4, #16]
  }
  /* Initialize the DMA2D state*/
  hdma2d->State = HAL_DMA2D_STATE_READY;

  /* Process unlocked */
  __HAL_UNLOCK(hdma2d);
 8013c36:	2200      	movs	r2, #0
  hdma2d->State = HAL_DMA2D_STATE_READY;
 8013c38:	2101      	movs	r1, #1

  return HAL_OK;
 8013c3a:	4610      	mov	r0, r2
  hdma2d->State = HAL_DMA2D_STATE_READY;
 8013c3c:	f883 1039 	strb.w	r1, [r3, #57]	@ 0x39
  __HAL_UNLOCK(hdma2d);
 8013c40:	f883 2038 	strb.w	r2, [r3, #56]	@ 0x38
}
 8013c44:	bc70      	pop	{r4, r5, r6}
 8013c46:	4770      	bx	lr
    MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
 8013c48:	6a60      	ldr	r0, [r4, #36]	@ 0x24
 8013c4a:	4913      	ldr	r1, [pc, #76]	@ (8013c98 <HAL_DMA2D_ConfigLayer+0xa8>)
 8013c4c:	4001      	ands	r1, r0
    WRITE_REG(hdma2d->Instance->BGOR, pLayerCfg->InputOffset);
 8013c4e:	6998      	ldr	r0, [r3, #24]
    MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
 8013c50:	4311      	orrs	r1, r2
 8013c52:	6261      	str	r1, [r4, #36]	@ 0x24
    WRITE_REG(hdma2d->Instance->BGOR, pLayerCfg->InputOffset);
 8013c54:	61a0      	str	r0, [r4, #24]
    if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
 8013c56:	e7ee      	b.n	8013c36 <HAL_DMA2D_ConfigLayer+0x46>
    regValue |= (pLayerCfg->InputAlpha & DMA2D_BGPFCCR_ALPHA);
 8013c58:	f8dc 5024 	ldr.w	r5, [ip, #36]	@ 0x24
 8013c5c:	f005 407f 	and.w	r0, r5, #4278190080	@ 0xff000000
 8013c60:	4302      	orrs	r2, r0
  if (LayerIdx == DMA2D_BACKGROUND_LAYER)
 8013c62:	b959      	cbnz	r1, 8013c7c <HAL_DMA2D_ConfigLayer+0x8c>
    MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
 8013c64:	6a60      	ldr	r0, [r4, #36]	@ 0x24
 8013c66:	490c      	ldr	r1, [pc, #48]	@ (8013c98 <HAL_DMA2D_ConfigLayer+0xa8>)
    WRITE_REG(hdma2d->Instance->BGOR, pLayerCfg->InputOffset);
 8013c68:	699d      	ldr	r5, [r3, #24]
    MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
 8013c6a:	4001      	ands	r1, r0
      WRITE_REG(hdma2d->Instance->BGCOLR, pLayerCfg->InputAlpha & (DMA2D_BGCOLR_BLUE | DMA2D_BGCOLR_GREEN | \
 8013c6c:	6a58      	ldr	r0, [r3, #36]	@ 0x24
    MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
 8013c6e:	4311      	orrs	r1, r2
      WRITE_REG(hdma2d->Instance->BGCOLR, pLayerCfg->InputAlpha & (DMA2D_BGCOLR_BLUE | DMA2D_BGCOLR_GREEN | \
 8013c70:	f020 407f 	bic.w	r0, r0, #4278190080	@ 0xff000000
    MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
 8013c74:	6261      	str	r1, [r4, #36]	@ 0x24
    WRITE_REG(hdma2d->Instance->BGOR, pLayerCfg->InputOffset);
 8013c76:	61a5      	str	r5, [r4, #24]
      WRITE_REG(hdma2d->Instance->BGCOLR, pLayerCfg->InputAlpha & (DMA2D_BGCOLR_BLUE | DMA2D_BGCOLR_GREEN | \
 8013c78:	62a0      	str	r0, [r4, #40]	@ 0x28
 8013c7a:	e7dc      	b.n	8013c36 <HAL_DMA2D_ConfigLayer+0x46>
    MODIFY_REG(hdma2d->Instance->FGPFCCR, regMask, regValue);
 8013c7c:	69e6      	ldr	r6, [r4, #28]
      WRITE_REG(hdma2d->Instance->FGCOLR, pLayerCfg->InputAlpha & (DMA2D_FGCOLR_BLUE | DMA2D_FGCOLR_GREEN | \
 8013c7e:	f025 457f 	bic.w	r5, r5, #4278190080	@ 0xff000000
    MODIFY_REG(hdma2d->Instance->FGPFCCR, regMask, regValue);
 8013c82:	4905      	ldr	r1, [pc, #20]	@ (8013c98 <HAL_DMA2D_ConfigLayer+0xa8>)
    WRITE_REG(hdma2d->Instance->FGOR, pLayerCfg->InputOffset);
 8013c84:	f8dc 0018 	ldr.w	r0, [ip, #24]
    MODIFY_REG(hdma2d->Instance->FGPFCCR, regMask, regValue);
 8013c88:	4031      	ands	r1, r6
 8013c8a:	4311      	orrs	r1, r2
 8013c8c:	61e1      	str	r1, [r4, #28]
    WRITE_REG(hdma2d->Instance->FGOR, pLayerCfg->InputOffset);
 8013c8e:	6120      	str	r0, [r4, #16]
      WRITE_REG(hdma2d->Instance->FGCOLR, pLayerCfg->InputAlpha & (DMA2D_FGCOLR_BLUE | DMA2D_FGCOLR_GREEN | \
 8013c90:	6225      	str	r5, [r4, #32]
 8013c92:	e7d0      	b.n	8013c36 <HAL_DMA2D_ConfigLayer+0x46>
  __HAL_LOCK(hdma2d);
 8013c94:	2002      	movs	r0, #2
}
 8013c96:	4770      	bx	lr
 8013c98:	00fcfff0 	.word	0x00fcfff0

08013c9c <HAL_DMAEx_MultiBufferStart_IT>:
  * @param  SecondMemAddress The second memory Buffer address in case of multi buffer Transfer  
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_MultiBufferStart_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t SecondMemAddress, uint32_t DataLength)
{
 8013c9c:	4684      	mov	ip, r0
  
  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
  
  /* Memory-to-memory transfer not supported in double buffering mode */
  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
 8013c9e:	6880      	ldr	r0, [r0, #8]
 8013ca0:	2880      	cmp	r0, #128	@ 0x80
 8013ca2:	d06e      	beq.n	8013d82 <HAL_DMAEx_MultiBufferStart_IT+0xe6>
{
 8013ca4:	b430      	push	{r4, r5}
    hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
    return HAL_ERROR;
  }
  
  /* Process locked */
  __HAL_LOCK(hdma);
 8013ca6:	f89c 4034 	ldrb.w	r4, [ip, #52]	@ 0x34
 8013caa:	2c01      	cmp	r4, #1
 8013cac:	d009      	beq.n	8013cc2 <HAL_DMAEx_MultiBufferStart_IT+0x26>
 8013cae:	2401      	movs	r4, #1
 8013cb0:	f88c 4034 	strb.w	r4, [ip, #52]	@ 0x34
  
  if(HAL_DMA_STATE_READY == hdma->State)
 8013cb4:	f89c 4035 	ldrb.w	r4, [ip, #53]	@ 0x35
 8013cb8:	2c01      	cmp	r4, #1
 8013cba:	d005      	beq.n	8013cc8 <HAL_DMAEx_MultiBufferStart_IT+0x2c>
    __HAL_DMA_ENABLE(hdma); 
  }
  else
  {     
    /* Process unlocked */
    __HAL_UNLOCK(hdma);	  
 8013cbc:	2300      	movs	r3, #0
 8013cbe:	f88c 3034 	strb.w	r3, [ip, #52]	@ 0x34
  __HAL_LOCK(hdma);
 8013cc2:	2002      	movs	r0, #2
    
    /* Return error status */
    status = HAL_BUSY;
  }  
  return status; 
}
 8013cc4:	bc30      	pop	{r4, r5}
 8013cc6:	4770      	bx	lr
    hdma->State = HAL_DMA_STATE_BUSY;
 8013cc8:	2502      	movs	r5, #2
    hdma->Instance->CR |= (uint32_t)DMA_SxCR_DBM;
 8013cca:	f8dc 4000 	ldr.w	r4, [ip]
{
  /* Configure DMA Stream data length */
  hdma->Instance->NDTR = DataLength;
  
  /* Peripheral to Memory */
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8013cce:	2840      	cmp	r0, #64	@ 0x40
    hdma->State = HAL_DMA_STATE_BUSY;
 8013cd0:	f88c 5035 	strb.w	r5, [ip, #53]	@ 0x35
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8013cd4:	f04f 0500 	mov.w	r5, #0
 8013cd8:	f8cc 5054 	str.w	r5, [ip, #84]	@ 0x54
    hdma->Instance->CR |= (uint32_t)DMA_SxCR_DBM;
 8013cdc:	6825      	ldr	r5, [r4, #0]
 8013cde:	f445 2580 	orr.w	r5, r5, #262144	@ 0x40000
 8013ce2:	6025      	str	r5, [r4, #0]
    hdma->Instance->M1AR = SecondMemAddress;
 8013ce4:	6123      	str	r3, [r4, #16]
  hdma->Instance->NDTR = DataLength;
 8013ce6:	9b02      	ldr	r3, [sp, #8]
 8013ce8:	6063      	str	r3, [r4, #4]
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8013cea:	f000 8123 	beq.w	8013f34 <HAL_DMAEx_MultiBufferStart_IT+0x298>
  }
  /* Memory to Peripheral */
  else
  {
    /* Configure DMA Stream source address */
    hdma->Instance->PAR = SrcAddress;
 8013cee:	60a1      	str	r1, [r4, #8]
    
    /* Configure DMA Stream destination address */
    hdma->Instance->M0AR = DstAddress;
 8013cf0:	60e2      	str	r2, [r4, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8013cf2:	4b92      	ldr	r3, [pc, #584]	@ (8013f3c <HAL_DMAEx_MultiBufferStart_IT+0x2a0>)
 8013cf4:	429c      	cmp	r4, r3
 8013cf6:	d94a      	bls.n	8013d8e <HAL_DMAEx_MultiBufferStart_IT+0xf2>
 8013cf8:	3b48      	subs	r3, #72	@ 0x48
 8013cfa:	4991      	ldr	r1, [pc, #580]	@ (8013f40 <HAL_DMAEx_MultiBufferStart_IT+0x2a4>)
 8013cfc:	4a91      	ldr	r2, [pc, #580]	@ (8013f44 <HAL_DMAEx_MultiBufferStart_IT+0x2a8>)
 8013cfe:	429c      	cmp	r4, r3
 8013d00:	bf18      	it	ne
 8013d02:	428c      	cmpne	r4, r1
 8013d04:	bf14      	ite	ne
 8013d06:	2301      	movne	r3, #1
 8013d08:	2300      	moveq	r3, #0
 8013d0a:	4294      	cmp	r4, r2
 8013d0c:	bf0c      	ite	eq
 8013d0e:	2100      	moveq	r1, #0
 8013d10:	f003 0101 	andne.w	r1, r3, #1
 8013d14:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8013d18:	4294      	cmp	r4, r2
 8013d1a:	d002      	beq.n	8013d22 <HAL_DMAEx_MultiBufferStart_IT+0x86>
 8013d1c:	2900      	cmp	r1, #0
 8013d1e:	f040 8249 	bne.w	80141b4 <HAL_DMAEx_MultiBufferStart_IT+0x518>
 8013d22:	2020      	movs	r0, #32
 8013d24:	4a88      	ldr	r2, [pc, #544]	@ (8013f48 <HAL_DMAEx_MultiBufferStart_IT+0x2ac>)
 8013d26:	60d0      	str	r0, [r2, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8013d28:	4885      	ldr	r0, [pc, #532]	@ (8013f40 <HAL_DMAEx_MultiBufferStart_IT+0x2a4>)
 8013d2a:	4284      	cmp	r4, r0
 8013d2c:	f000 829f 	beq.w	801426e <HAL_DMAEx_MultiBufferStart_IT+0x5d2>
 8013d30:	2b00      	cmp	r3, #0
 8013d32:	f000 82c8 	beq.w	80142c6 <HAL_DMAEx_MultiBufferStart_IT+0x62a>
 8013d36:	2900      	cmp	r1, #0
 8013d38:	f000 8216 	beq.w	8014168 <HAL_DMAEx_MultiBufferStart_IT+0x4cc>
 8013d3c:	2310      	movs	r3, #16
 8013d3e:	60d3      	str	r3, [r2, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8013d40:	4b81      	ldr	r3, [pc, #516]	@ (8013f48 <HAL_DMAEx_MultiBufferStart_IT+0x2ac>)
 8013d42:	2208      	movs	r2, #8
 8013d44:	60da      	str	r2, [r3, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8013d46:	4b80      	ldr	r3, [pc, #512]	@ (8013f48 <HAL_DMAEx_MultiBufferStart_IT+0x2ac>)
 8013d48:	2204      	movs	r2, #4
 8013d4a:	60da      	str	r2, [r3, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8013d4c:	2201      	movs	r2, #1
 8013d4e:	4b7e      	ldr	r3, [pc, #504]	@ (8013f48 <HAL_DMAEx_MultiBufferStart_IT+0x2ac>)
 8013d50:	60da      	str	r2, [r3, #12]
    hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
 8013d52:	6823      	ldr	r3, [r4, #0]
    if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 8013d54:	f8dc 2040 	ldr.w	r2, [ip, #64]	@ 0x40
    hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
 8013d58:	f043 0316 	orr.w	r3, r3, #22
 8013d5c:	6023      	str	r3, [r4, #0]
    hdma->Instance->FCR |= DMA_IT_FE;
 8013d5e:	6963      	ldr	r3, [r4, #20]
 8013d60:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8013d64:	6163      	str	r3, [r4, #20]
    if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 8013d66:	2a00      	cmp	r2, #0
 8013d68:	f000 821e 	beq.w	80141a8 <HAL_DMAEx_MultiBufferStart_IT+0x50c>
      hdma->Instance->CR  |= DMA_IT_HT;
 8013d6c:	6823      	ldr	r3, [r4, #0]
 8013d6e:	f043 0308 	orr.w	r3, r3, #8
 8013d72:	6023      	str	r3, [r4, #0]
    __HAL_DMA_ENABLE(hdma); 
 8013d74:	6823      	ldr	r3, [r4, #0]
  HAL_StatusTypeDef status = HAL_OK;
 8013d76:	2000      	movs	r0, #0
    __HAL_DMA_ENABLE(hdma); 
 8013d78:	f043 0301 	orr.w	r3, r3, #1
 8013d7c:	6023      	str	r3, [r4, #0]
}
 8013d7e:	bc30      	pop	{r4, r5}
 8013d80:	4770      	bx	lr
    hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
 8013d82:	f44f 7380 	mov.w	r3, #256	@ 0x100
    return HAL_ERROR;
 8013d86:	2001      	movs	r0, #1
    hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
 8013d88:	f8cc 3054 	str.w	r3, [ip, #84]	@ 0x54
}
 8013d8c:	4770      	bx	lr
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8013d8e:	4b6f      	ldr	r3, [pc, #444]	@ (8013f4c <HAL_DMAEx_MultiBufferStart_IT+0x2b0>)
 8013d90:	429c      	cmp	r4, r3
 8013d92:	f240 80f5 	bls.w	8013f80 <HAL_DMAEx_MultiBufferStart_IT+0x2e4>
 8013d96:	3ba8      	subs	r3, #168	@ 0xa8
 8013d98:	429c      	cmp	r4, r3
 8013d9a:	f000 825b 	beq.w	8014254 <HAL_DMAEx_MultiBufferStart_IT+0x5b8>
 8013d9e:	4b6c      	ldr	r3, [pc, #432]	@ (8013f50 <HAL_DMAEx_MultiBufferStart_IT+0x2b4>)
 8013da0:	429c      	cmp	r4, r3
 8013da2:	f000 81f1 	beq.w	8014188 <HAL_DMAEx_MultiBufferStart_IT+0x4ec>
 8013da6:	4b67      	ldr	r3, [pc, #412]	@ (8013f44 <HAL_DMAEx_MultiBufferStart_IT+0x2a8>)
 8013da8:	429c      	cmp	r4, r3
 8013daa:	f000 82a9 	beq.w	8014300 <HAL_DMAEx_MultiBufferStart_IT+0x664>
 8013dae:	4b69      	ldr	r3, [pc, #420]	@ (8013f54 <HAL_DMAEx_MultiBufferStart_IT+0x2b8>)
 8013db0:	429c      	cmp	r4, r3
 8013db2:	f000 8457 	beq.w	8014664 <HAL_DMAEx_MultiBufferStart_IT+0x9c8>
 8013db6:	f5a3 6389 	sub.w	r3, r3, #1096	@ 0x448
 8013dba:	429c      	cmp	r4, r3
 8013dbc:	f000 84be 	beq.w	801473c <HAL_DMAEx_MultiBufferStart_IT+0xaa0>
 8013dc0:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8013dc4:	429c      	cmp	r4, r3
 8013dc6:	f000 84fe 	beq.w	80147c6 <HAL_DMAEx_MultiBufferStart_IT+0xb2a>
 8013dca:	f5a3 7368 	sub.w	r3, r3, #928	@ 0x3a0
 8013dce:	429c      	cmp	r4, r3
 8013dd0:	f000 8566 	beq.w	80148a0 <HAL_DMAEx_MultiBufferStart_IT+0xc04>
 8013dd4:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8013dd8:	429c      	cmp	r4, r3
 8013dda:	f000 85e4 	beq.w	80149a6 <HAL_DMAEx_MultiBufferStart_IT+0xd0a>
 8013dde:	4b5e      	ldr	r3, [pc, #376]	@ (8013f58 <HAL_DMAEx_MultiBufferStart_IT+0x2bc>)
 8013de0:	495e      	ldr	r1, [pc, #376]	@ (8013f5c <HAL_DMAEx_MultiBufferStart_IT+0x2c0>)
 8013de2:	4a5f      	ldr	r2, [pc, #380]	@ (8013f60 <HAL_DMAEx_MultiBufferStart_IT+0x2c4>)
 8013de4:	429c      	cmp	r4, r3
 8013de6:	bf18      	it	ne
 8013de8:	428c      	cmpne	r4, r1
 8013dea:	bf14      	ite	ne
 8013dec:	2301      	movne	r3, #1
 8013dee:	2300      	moveq	r3, #0
 8013df0:	4294      	cmp	r4, r2
 8013df2:	bf0c      	ite	eq
 8013df4:	2300      	moveq	r3, #0
 8013df6:	f003 0301 	andne.w	r3, r3, #1
 8013dfa:	b11b      	cbz	r3, 8013e04 <HAL_DMAEx_MultiBufferStart_IT+0x168>
 8013dfc:	4b59      	ldr	r3, [pc, #356]	@ (8013f64 <HAL_DMAEx_MultiBufferStart_IT+0x2c8>)
 8013dfe:	429c      	cmp	r4, r3
 8013e00:	f040 86e7 	bne.w	8014bd2 <HAL_DMAEx_MultiBufferStart_IT+0xf36>
 8013e04:	4b50      	ldr	r3, [pc, #320]	@ (8013f48 <HAL_DMAEx_MultiBufferStart_IT+0x2ac>)
 8013e06:	f44f 1200 	mov.w	r2, #2097152	@ 0x200000
 8013e0a:	609a      	str	r2, [r3, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8013e0c:	4b52      	ldr	r3, [pc, #328]	@ (8013f58 <HAL_DMAEx_MultiBufferStart_IT+0x2bc>)
 8013e0e:	4953      	ldr	r1, [pc, #332]	@ (8013f5c <HAL_DMAEx_MultiBufferStart_IT+0x2c0>)
 8013e10:	4a53      	ldr	r2, [pc, #332]	@ (8013f60 <HAL_DMAEx_MultiBufferStart_IT+0x2c4>)
 8013e12:	429c      	cmp	r4, r3
 8013e14:	bf18      	it	ne
 8013e16:	428c      	cmpne	r4, r1
 8013e18:	bf14      	ite	ne
 8013e1a:	2301      	movne	r3, #1
 8013e1c:	2300      	moveq	r3, #0
 8013e1e:	4294      	cmp	r4, r2
 8013e20:	bf0c      	ite	eq
 8013e22:	2300      	moveq	r3, #0
 8013e24:	f003 0301 	andne.w	r3, r3, #1
 8013e28:	b11b      	cbz	r3, 8013e32 <HAL_DMAEx_MultiBufferStart_IT+0x196>
 8013e2a:	4b4e      	ldr	r3, [pc, #312]	@ (8013f64 <HAL_DMAEx_MultiBufferStart_IT+0x2c8>)
 8013e2c:	429c      	cmp	r4, r3
 8013e2e:	f040 860d 	bne.w	8014a4c <HAL_DMAEx_MultiBufferStart_IT+0xdb0>
 8013e32:	4b45      	ldr	r3, [pc, #276]	@ (8013f48 <HAL_DMAEx_MultiBufferStart_IT+0x2ac>)
 8013e34:	f44f 1280 	mov.w	r2, #1048576	@ 0x100000
 8013e38:	609a      	str	r2, [r3, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8013e3a:	4b47      	ldr	r3, [pc, #284]	@ (8013f58 <HAL_DMAEx_MultiBufferStart_IT+0x2bc>)
 8013e3c:	4947      	ldr	r1, [pc, #284]	@ (8013f5c <HAL_DMAEx_MultiBufferStart_IT+0x2c0>)
 8013e3e:	4a48      	ldr	r2, [pc, #288]	@ (8013f60 <HAL_DMAEx_MultiBufferStart_IT+0x2c4>)
 8013e40:	429c      	cmp	r4, r3
 8013e42:	bf18      	it	ne
 8013e44:	428c      	cmpne	r4, r1
 8013e46:	bf14      	ite	ne
 8013e48:	2301      	movne	r3, #1
 8013e4a:	2300      	moveq	r3, #0
 8013e4c:	4294      	cmp	r4, r2
 8013e4e:	bf0c      	ite	eq
 8013e50:	2300      	moveq	r3, #0
 8013e52:	f003 0301 	andne.w	r3, r3, #1
 8013e56:	b11b      	cbz	r3, 8013e60 <HAL_DMAEx_MultiBufferStart_IT+0x1c4>
 8013e58:	4b42      	ldr	r3, [pc, #264]	@ (8013f64 <HAL_DMAEx_MultiBufferStart_IT+0x2c8>)
 8013e5a:	429c      	cmp	r4, r3
 8013e5c:	f040 85fb 	bne.w	8014a56 <HAL_DMAEx_MultiBufferStart_IT+0xdba>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8013e60:	4b36      	ldr	r3, [pc, #216]	@ (8013f3c <HAL_DMAEx_MultiBufferStart_IT+0x2a0>)
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8013e62:	f44f 2100 	mov.w	r1, #524288	@ 0x80000
 8013e66:	4a38      	ldr	r2, [pc, #224]	@ (8013f48 <HAL_DMAEx_MultiBufferStart_IT+0x2ac>)
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8013e68:	429c      	cmp	r4, r3
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8013e6a:	6091      	str	r1, [r2, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8013e6c:	f200 820f 	bhi.w	801428e <HAL_DMAEx_MultiBufferStart_IT+0x5f2>
 8013e70:	f5a3 7368 	sub.w	r3, r3, #928	@ 0x3a0
 8013e74:	429c      	cmp	r4, r3
 8013e76:	f200 83c0 	bhi.w	80145fa <HAL_DMAEx_MultiBufferStart_IT+0x95e>
 8013e7a:	4b3b      	ldr	r3, [pc, #236]	@ (8013f68 <HAL_DMAEx_MultiBufferStart_IT+0x2cc>)
 8013e7c:	429c      	cmp	r4, r3
 8013e7e:	f240 8400 	bls.w	8014682 <HAL_DMAEx_MultiBufferStart_IT+0x9e6>
 8013e82:	4b3a      	ldr	r3, [pc, #232]	@ (8013f6c <HAL_DMAEx_MultiBufferStart_IT+0x2d0>)
 8013e84:	429c      	cmp	r4, r3
 8013e86:	f000 8516 	beq.w	80148b6 <HAL_DMAEx_MultiBufferStart_IT+0xc1a>
 8013e8a:	4b39      	ldr	r3, [pc, #228]	@ (8013f70 <HAL_DMAEx_MultiBufferStart_IT+0x2d4>)
 8013e8c:	429c      	cmp	r4, r3
 8013e8e:	f000 86b4 	beq.w	8014bfa <HAL_DMAEx_MultiBufferStart_IT+0xf5e>
 8013e92:	4b31      	ldr	r3, [pc, #196]	@ (8013f58 <HAL_DMAEx_MultiBufferStart_IT+0x2bc>)
 8013e94:	4931      	ldr	r1, [pc, #196]	@ (8013f5c <HAL_DMAEx_MultiBufferStart_IT+0x2c0>)
 8013e96:	4a32      	ldr	r2, [pc, #200]	@ (8013f60 <HAL_DMAEx_MultiBufferStart_IT+0x2c4>)
 8013e98:	429c      	cmp	r4, r3
 8013e9a:	bf18      	it	ne
 8013e9c:	428c      	cmpne	r4, r1
 8013e9e:	bf14      	ite	ne
 8013ea0:	2301      	movne	r3, #1
 8013ea2:	2300      	moveq	r3, #0
 8013ea4:	4294      	cmp	r4, r2
 8013ea6:	bf0c      	ite	eq
 8013ea8:	2300      	moveq	r3, #0
 8013eaa:	f003 0301 	andne.w	r3, r3, #1
 8013eae:	b11b      	cbz	r3, 8013eb8 <HAL_DMAEx_MultiBufferStart_IT+0x21c>
 8013eb0:	4b2c      	ldr	r3, [pc, #176]	@ (8013f64 <HAL_DMAEx_MultiBufferStart_IT+0x2c8>)
 8013eb2:	429c      	cmp	r4, r3
 8013eb4:	f040 8548 	bne.w	8014948 <HAL_DMAEx_MultiBufferStart_IT+0xcac>
 8013eb8:	4a2e      	ldr	r2, [pc, #184]	@ (8013f74 <HAL_DMAEx_MultiBufferStart_IT+0x2d8>)
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8013eba:	4b20      	ldr	r3, [pc, #128]	@ (8013f3c <HAL_DMAEx_MultiBufferStart_IT+0x2a0>)
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8013ebc:	f44f 2180 	mov.w	r1, #262144	@ 0x40000
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8013ec0:	429c      	cmp	r4, r3
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8013ec2:	60d1      	str	r1, [r2, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8013ec4:	f200 8293 	bhi.w	80143ee <HAL_DMAEx_MultiBufferStart_IT+0x752>
 8013ec8:	f5a3 7368 	sub.w	r3, r3, #928	@ 0x3a0
 8013ecc:	429c      	cmp	r4, r3
 8013ece:	f200 823a 	bhi.w	8014346 <HAL_DMAEx_MultiBufferStart_IT+0x6aa>
 8013ed2:	3b60      	subs	r3, #96	@ 0x60
 8013ed4:	429c      	cmp	r4, r3
 8013ed6:	f240 8306 	bls.w	80144e6 <HAL_DMAEx_MultiBufferStart_IT+0x84a>
 8013eda:	4b27      	ldr	r3, [pc, #156]	@ (8013f78 <HAL_DMAEx_MultiBufferStart_IT+0x2dc>)
 8013edc:	4927      	ldr	r1, [pc, #156]	@ (8013f7c <HAL_DMAEx_MultiBufferStart_IT+0x2e0>)
 8013ede:	4a23      	ldr	r2, [pc, #140]	@ (8013f6c <HAL_DMAEx_MultiBufferStart_IT+0x2d0>)
 8013ee0:	429c      	cmp	r4, r3
 8013ee2:	bf18      	it	ne
 8013ee4:	428c      	cmpne	r4, r1
 8013ee6:	bf14      	ite	ne
 8013ee8:	2301      	movne	r3, #1
 8013eea:	2300      	moveq	r3, #0
 8013eec:	4294      	cmp	r4, r2
 8013eee:	bf0c      	ite	eq
 8013ef0:	2300      	moveq	r3, #0
 8013ef2:	f003 0301 	andne.w	r3, r3, #1
 8013ef6:	2b00      	cmp	r3, #0
 8013ef8:	f000 844a 	beq.w	8014790 <HAL_DMAEx_MultiBufferStart_IT+0xaf4>
 8013efc:	4b1c      	ldr	r3, [pc, #112]	@ (8013f70 <HAL_DMAEx_MultiBufferStart_IT+0x2d4>)
 8013efe:	429c      	cmp	r4, r3
 8013f00:	f000 8446 	beq.w	8014790 <HAL_DMAEx_MultiBufferStart_IT+0xaf4>
 8013f04:	4b14      	ldr	r3, [pc, #80]	@ (8013f58 <HAL_DMAEx_MultiBufferStart_IT+0x2bc>)
 8013f06:	4915      	ldr	r1, [pc, #84]	@ (8013f5c <HAL_DMAEx_MultiBufferStart_IT+0x2c0>)
 8013f08:	4a15      	ldr	r2, [pc, #84]	@ (8013f60 <HAL_DMAEx_MultiBufferStart_IT+0x2c4>)
 8013f0a:	429c      	cmp	r4, r3
 8013f0c:	bf18      	it	ne
 8013f0e:	428c      	cmpne	r4, r1
 8013f10:	bf14      	ite	ne
 8013f12:	2301      	movne	r3, #1
 8013f14:	2300      	moveq	r3, #0
 8013f16:	4294      	cmp	r4, r2
 8013f18:	bf0c      	ite	eq
 8013f1a:	2300      	moveq	r3, #0
 8013f1c:	f003 0301 	andne.w	r3, r3, #1
 8013f20:	b11b      	cbz	r3, 8013f2a <HAL_DMAEx_MultiBufferStart_IT+0x28e>
 8013f22:	4b10      	ldr	r3, [pc, #64]	@ (8013f64 <HAL_DMAEx_MultiBufferStart_IT+0x2c8>)
 8013f24:	429c      	cmp	r4, r3
 8013f26:	f040 86b6 	bne.w	8014c96 <HAL_DMAEx_MultiBufferStart_IT+0xffa>
 8013f2a:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
 8013f2e:	4b11      	ldr	r3, [pc, #68]	@ (8013f74 <HAL_DMAEx_MultiBufferStart_IT+0x2d8>)
 8013f30:	60da      	str	r2, [r3, #12]
 8013f32:	e70e      	b.n	8013d52 <HAL_DMAEx_MultiBufferStart_IT+0xb6>
    hdma->Instance->PAR = DstAddress;
 8013f34:	60a2      	str	r2, [r4, #8]
    hdma->Instance->M0AR = SrcAddress;
 8013f36:	60e1      	str	r1, [r4, #12]
 8013f38:	e6db      	b.n	8013cf2 <HAL_DMAEx_MultiBufferStart_IT+0x56>
 8013f3a:	bf00      	nop
 8013f3c:	40026458 	.word	0x40026458
 8013f40:	40026010 	.word	0x40026010
 8013f44:	40026070 	.word	0x40026070
 8013f48:	40026400 	.word	0x40026400
 8013f4c:	400260b8 	.word	0x400260b8
 8013f50:	40026410 	.word	0x40026410
 8013f54:	40026470 	.word	0x40026470
 8013f58:	40026440 	.word	0x40026440
 8013f5c:	40026040 	.word	0x40026040
 8013f60:	400260a0 	.word	0x400260a0
 8013f64:	400264a0 	.word	0x400264a0
 8013f68:	40026058 	.word	0x40026058
 8013f6c:	40026088 	.word	0x40026088
 8013f70:	40026488 	.word	0x40026488
 8013f74:	40026000 	.word	0x40026000
 8013f78:	40026028 	.word	0x40026028
 8013f7c:	40026428 	.word	0x40026428
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8013f80:	4ba3      	ldr	r3, [pc, #652]	@ (8014210 <HAL_DMAEx_MultiBufferStart_IT+0x574>)
 8013f82:	429c      	cmp	r4, r3
 8013f84:	d87e      	bhi.n	8014084 <HAL_DMAEx_MultiBufferStart_IT+0x3e8>
 8013f86:	4ba3      	ldr	r3, [pc, #652]	@ (8014214 <HAL_DMAEx_MultiBufferStart_IT+0x578>)
 8013f88:	429c      	cmp	r4, r3
 8013f8a:	f000 819f 	beq.w	80142cc <HAL_DMAEx_MultiBufferStart_IT+0x630>
 8013f8e:	4ba2      	ldr	r3, [pc, #648]	@ (8014218 <HAL_DMAEx_MultiBufferStart_IT+0x57c>)
 8013f90:	429c      	cmp	r4, r3
 8013f92:	f000 835a 	beq.w	801464a <HAL_DMAEx_MultiBufferStart_IT+0x9ae>
 8013f96:	4ba1      	ldr	r3, [pc, #644]	@ (801421c <HAL_DMAEx_MultiBufferStart_IT+0x580>)
 8013f98:	429c      	cmp	r4, r3
 8013f9a:	f000 83aa 	beq.w	80146f2 <HAL_DMAEx_MultiBufferStart_IT+0xa56>
 8013f9e:	4ba0      	ldr	r3, [pc, #640]	@ (8014220 <HAL_DMAEx_MultiBufferStart_IT+0x584>)
 8013fa0:	429c      	cmp	r4, r3
 8013fa2:	f000 840b 	beq.w	80147bc <HAL_DMAEx_MultiBufferStart_IT+0xb20>
 8013fa6:	4b9f      	ldr	r3, [pc, #636]	@ (8014224 <HAL_DMAEx_MultiBufferStart_IT+0x588>)
 8013fa8:	429c      	cmp	r4, r3
 8013faa:	f000 848e 	beq.w	80148ca <HAL_DMAEx_MultiBufferStart_IT+0xc2e>
 8013fae:	4b9e      	ldr	r3, [pc, #632]	@ (8014228 <HAL_DMAEx_MultiBufferStart_IT+0x58c>)
 8013fb0:	429c      	cmp	r4, r3
 8013fb2:	f000 84ee 	beq.w	8014992 <HAL_DMAEx_MultiBufferStart_IT+0xcf6>
 8013fb6:	f5a3 7368 	sub.w	r3, r3, #928	@ 0x3a0
 8013fba:	429c      	cmp	r4, r3
 8013fbc:	f000 8516 	beq.w	80149ec <HAL_DMAEx_MultiBufferStart_IT+0xd50>
 8013fc0:	4b9a      	ldr	r3, [pc, #616]	@ (801422c <HAL_DMAEx_MultiBufferStart_IT+0x590>)
 8013fc2:	429c      	cmp	r4, r3
 8013fc4:	f000 8612 	beq.w	8014bec <HAL_DMAEx_MultiBufferStart_IT+0xf50>
 8013fc8:	4b99      	ldr	r3, [pc, #612]	@ (8014230 <HAL_DMAEx_MultiBufferStart_IT+0x594>)
 8013fca:	499a      	ldr	r1, [pc, #616]	@ (8014234 <HAL_DMAEx_MultiBufferStart_IT+0x598>)
 8013fcc:	4a9a      	ldr	r2, [pc, #616]	@ (8014238 <HAL_DMAEx_MultiBufferStart_IT+0x59c>)
 8013fce:	429c      	cmp	r4, r3
 8013fd0:	bf18      	it	ne
 8013fd2:	428c      	cmpne	r4, r1
 8013fd4:	bf14      	ite	ne
 8013fd6:	2301      	movne	r3, #1
 8013fd8:	2300      	moveq	r3, #0
 8013fda:	4294      	cmp	r4, r2
 8013fdc:	bf0c      	ite	eq
 8013fde:	2300      	moveq	r3, #0
 8013fe0:	f003 0301 	andne.w	r3, r3, #1
 8013fe4:	b11b      	cbz	r3, 8013fee <HAL_DMAEx_MultiBufferStart_IT+0x352>
 8013fe6:	4b95      	ldr	r3, [pc, #596]	@ (801423c <HAL_DMAEx_MultiBufferStart_IT+0x5a0>)
 8013fe8:	429c      	cmp	r4, r3
 8013fea:	f040 8424 	bne.w	8014836 <HAL_DMAEx_MultiBufferStart_IT+0xb9a>
 8013fee:	4b94      	ldr	r3, [pc, #592]	@ (8014240 <HAL_DMAEx_MultiBufferStart_IT+0x5a4>)
 8013ff0:	f44f 1200 	mov.w	r2, #2097152	@ 0x200000
 8013ff4:	609a      	str	r2, [r3, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8013ff6:	4b8f      	ldr	r3, [pc, #572]	@ (8014234 <HAL_DMAEx_MultiBufferStart_IT+0x598>)
 8013ff8:	498d      	ldr	r1, [pc, #564]	@ (8014230 <HAL_DMAEx_MultiBufferStart_IT+0x594>)
 8013ffa:	4a8f      	ldr	r2, [pc, #572]	@ (8014238 <HAL_DMAEx_MultiBufferStart_IT+0x59c>)
 8013ffc:	429c      	cmp	r4, r3
 8013ffe:	bf18      	it	ne
 8014000:	428c      	cmpne	r4, r1
 8014002:	bf14      	ite	ne
 8014004:	2301      	movne	r3, #1
 8014006:	2300      	moveq	r3, #0
 8014008:	4294      	cmp	r4, r2
 801400a:	bf0c      	ite	eq
 801400c:	2300      	moveq	r3, #0
 801400e:	f003 0301 	andne.w	r3, r3, #1
 8014012:	b11b      	cbz	r3, 801401c <HAL_DMAEx_MultiBufferStart_IT+0x380>
 8014014:	4b89      	ldr	r3, [pc, #548]	@ (801423c <HAL_DMAEx_MultiBufferStart_IT+0x5a0>)
 8014016:	429c      	cmp	r4, r3
 8014018:	f040 865b 	bne.w	8014cd2 <HAL_DMAEx_MultiBufferStart_IT+0x1036>
 801401c:	4b88      	ldr	r3, [pc, #544]	@ (8014240 <HAL_DMAEx_MultiBufferStart_IT+0x5a4>)
 801401e:	f44f 1280 	mov.w	r2, #1048576	@ 0x100000
 8014022:	609a      	str	r2, [r3, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8014024:	4b83      	ldr	r3, [pc, #524]	@ (8014234 <HAL_DMAEx_MultiBufferStart_IT+0x598>)
 8014026:	4982      	ldr	r1, [pc, #520]	@ (8014230 <HAL_DMAEx_MultiBufferStart_IT+0x594>)
 8014028:	4a83      	ldr	r2, [pc, #524]	@ (8014238 <HAL_DMAEx_MultiBufferStart_IT+0x59c>)
 801402a:	429c      	cmp	r4, r3
 801402c:	bf18      	it	ne
 801402e:	428c      	cmpne	r4, r1
 8014030:	bf14      	ite	ne
 8014032:	2301      	movne	r3, #1
 8014034:	2300      	moveq	r3, #0
 8014036:	4294      	cmp	r4, r2
 8014038:	bf0c      	ite	eq
 801403a:	2300      	moveq	r3, #0
 801403c:	f003 0301 	andne.w	r3, r3, #1
 8014040:	b11b      	cbz	r3, 801404a <HAL_DMAEx_MultiBufferStart_IT+0x3ae>
 8014042:	4b7e      	ldr	r3, [pc, #504]	@ (801423c <HAL_DMAEx_MultiBufferStart_IT+0x5a0>)
 8014044:	429c      	cmp	r4, r3
 8014046:	f040 82ab 	bne.w	80145a0 <HAL_DMAEx_MultiBufferStart_IT+0x904>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 801404a:	4b7e      	ldr	r3, [pc, #504]	@ (8014244 <HAL_DMAEx_MultiBufferStart_IT+0x5a8>)
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 801404c:	f44f 2100 	mov.w	r1, #524288	@ 0x80000
 8014050:	4a7b      	ldr	r2, [pc, #492]	@ (8014240 <HAL_DMAEx_MultiBufferStart_IT+0x5a4>)
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014052:	429c      	cmp	r4, r3
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8014054:	6091      	str	r1, [r2, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014056:	f200 8116 	bhi.w	8014286 <HAL_DMAEx_MultiBufferStart_IT+0x5ea>
 801405a:	f5a3 7368 	sub.w	r3, r3, #928	@ 0x3a0
 801405e:	429c      	cmp	r4, r3
 8014060:	f200 82c2 	bhi.w	80145e8 <HAL_DMAEx_MultiBufferStart_IT+0x94c>
 8014064:	3b60      	subs	r3, #96	@ 0x60
 8014066:	429c      	cmp	r4, r3
 8014068:	f240 8317 	bls.w	801469a <HAL_DMAEx_MultiBufferStart_IT+0x9fe>
 801406c:	4b6d      	ldr	r3, [pc, #436]	@ (8014224 <HAL_DMAEx_MultiBufferStart_IT+0x588>)
 801406e:	429c      	cmp	r4, r3
 8014070:	f040 86a5 	bne.w	8014dbe <HAL_DMAEx_MultiBufferStart_IT+0x1122>
 8014074:	f44f 7280 	mov.w	r2, #256	@ 0x100
 8014078:	f843 2c1c 	str.w	r2, [r3, #-28]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 801407c:	2240      	movs	r2, #64	@ 0x40
 801407e:	4b70      	ldr	r3, [pc, #448]	@ (8014240 <HAL_DMAEx_MultiBufferStart_IT+0x5a4>)
 8014080:	609a      	str	r2, [r3, #8]
 8014082:	e666      	b.n	8013d52 <HAL_DMAEx_MultiBufferStart_IT+0xb6>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8014084:	3b48      	subs	r3, #72	@ 0x48
 8014086:	429c      	cmp	r4, r3
 8014088:	f000 812d 	beq.w	80142e6 <HAL_DMAEx_MultiBufferStart_IT+0x64a>
 801408c:	4b62      	ldr	r3, [pc, #392]	@ (8014218 <HAL_DMAEx_MultiBufferStart_IT+0x57c>)
 801408e:	429c      	cmp	r4, r3
 8014090:	f000 82e3 	beq.w	801465a <HAL_DMAEx_MultiBufferStart_IT+0x9be>
 8014094:	4b61      	ldr	r3, [pc, #388]	@ (801421c <HAL_DMAEx_MultiBufferStart_IT+0x580>)
 8014096:	429c      	cmp	r4, r3
 8014098:	f000 8324 	beq.w	80146e4 <HAL_DMAEx_MultiBufferStart_IT+0xa48>
 801409c:	4b60      	ldr	r3, [pc, #384]	@ (8014220 <HAL_DMAEx_MultiBufferStart_IT+0x584>)
 801409e:	429c      	cmp	r4, r3
 80140a0:	f000 83bb 	beq.w	801481a <HAL_DMAEx_MultiBufferStart_IT+0xb7e>
 80140a4:	4b5f      	ldr	r3, [pc, #380]	@ (8014224 <HAL_DMAEx_MultiBufferStart_IT+0x588>)
 80140a6:	429c      	cmp	r4, r3
 80140a8:	f000 8414 	beq.w	80148d4 <HAL_DMAEx_MultiBufferStart_IT+0xc38>
 80140ac:	4b5e      	ldr	r3, [pc, #376]	@ (8014228 <HAL_DMAEx_MultiBufferStart_IT+0x58c>)
 80140ae:	429c      	cmp	r4, r3
 80140b0:	f000 846a 	beq.w	8014988 <HAL_DMAEx_MultiBufferStart_IT+0xcec>
 80140b4:	f5a3 7368 	sub.w	r3, r3, #928	@ 0x3a0
 80140b8:	429c      	cmp	r4, r3
 80140ba:	f000 848a 	beq.w	80149d2 <HAL_DMAEx_MultiBufferStart_IT+0xd36>
 80140be:	4b5b      	ldr	r3, [pc, #364]	@ (801422c <HAL_DMAEx_MultiBufferStart_IT+0x590>)
 80140c0:	429c      	cmp	r4, r3
 80140c2:	f000 858c 	beq.w	8014bde <HAL_DMAEx_MultiBufferStart_IT+0xf42>
 80140c6:	4b5b      	ldr	r3, [pc, #364]	@ (8014234 <HAL_DMAEx_MultiBufferStart_IT+0x598>)
 80140c8:	4959      	ldr	r1, [pc, #356]	@ (8014230 <HAL_DMAEx_MultiBufferStart_IT+0x594>)
 80140ca:	4a5b      	ldr	r2, [pc, #364]	@ (8014238 <HAL_DMAEx_MultiBufferStart_IT+0x59c>)
 80140cc:	429c      	cmp	r4, r3
 80140ce:	bf18      	it	ne
 80140d0:	428c      	cmpne	r4, r1
 80140d2:	bf14      	ite	ne
 80140d4:	2301      	movne	r3, #1
 80140d6:	2300      	moveq	r3, #0
 80140d8:	4294      	cmp	r4, r2
 80140da:	bf0c      	ite	eq
 80140dc:	2300      	moveq	r3, #0
 80140de:	f003 0301 	andne.w	r3, r3, #1
 80140e2:	b11b      	cbz	r3, 80140ec <HAL_DMAEx_MultiBufferStart_IT+0x450>
 80140e4:	4b55      	ldr	r3, [pc, #340]	@ (801423c <HAL_DMAEx_MultiBufferStart_IT+0x5a0>)
 80140e6:	429c      	cmp	r4, r3
 80140e8:	f040 8362 	bne.w	80147b0 <HAL_DMAEx_MultiBufferStart_IT+0xb14>
 80140ec:	4b54      	ldr	r3, [pc, #336]	@ (8014240 <HAL_DMAEx_MultiBufferStart_IT+0x5a4>)
 80140ee:	f44f 1200 	mov.w	r2, #2097152	@ 0x200000
 80140f2:	60da      	str	r2, [r3, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 80140f4:	4b4f      	ldr	r3, [pc, #316]	@ (8014234 <HAL_DMAEx_MultiBufferStart_IT+0x598>)
 80140f6:	494e      	ldr	r1, [pc, #312]	@ (8014230 <HAL_DMAEx_MultiBufferStart_IT+0x594>)
 80140f8:	4a4f      	ldr	r2, [pc, #316]	@ (8014238 <HAL_DMAEx_MultiBufferStart_IT+0x59c>)
 80140fa:	429c      	cmp	r4, r3
 80140fc:	bf18      	it	ne
 80140fe:	428c      	cmpne	r4, r1
 8014100:	bf14      	ite	ne
 8014102:	2301      	movne	r3, #1
 8014104:	2300      	moveq	r3, #0
 8014106:	4294      	cmp	r4, r2
 8014108:	bf0c      	ite	eq
 801410a:	2300      	moveq	r3, #0
 801410c:	f003 0301 	andne.w	r3, r3, #1
 8014110:	b11b      	cbz	r3, 801411a <HAL_DMAEx_MultiBufferStart_IT+0x47e>
 8014112:	4b4a      	ldr	r3, [pc, #296]	@ (801423c <HAL_DMAEx_MultiBufferStart_IT+0x5a0>)
 8014114:	429c      	cmp	r4, r3
 8014116:	f040 85a5 	bne.w	8014c64 <HAL_DMAEx_MultiBufferStart_IT+0xfc8>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 801411a:	4b4b      	ldr	r3, [pc, #300]	@ (8014248 <HAL_DMAEx_MultiBufferStart_IT+0x5ac>)
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 801411c:	f44f 1180 	mov.w	r1, #1048576	@ 0x100000
 8014120:	4a47      	ldr	r2, [pc, #284]	@ (8014240 <HAL_DMAEx_MultiBufferStart_IT+0x5a4>)
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8014122:	429c      	cmp	r4, r3
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8014124:	60d1      	str	r1, [r2, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8014126:	f200 822a 	bhi.w	801457e <HAL_DMAEx_MultiBufferStart_IT+0x8e2>
 801412a:	3b60      	subs	r3, #96	@ 0x60
 801412c:	429c      	cmp	r4, r3
 801412e:	f200 8389 	bhi.w	8014844 <HAL_DMAEx_MultiBufferStart_IT+0xba8>
 8014132:	4b3c      	ldr	r3, [pc, #240]	@ (8014224 <HAL_DMAEx_MultiBufferStart_IT+0x588>)
 8014134:	429c      	cmp	r4, r3
 8014136:	f000 8283 	beq.w	8014640 <HAL_DMAEx_MultiBufferStart_IT+0x9a4>
 801413a:	4b3b      	ldr	r3, [pc, #236]	@ (8014228 <HAL_DMAEx_MultiBufferStart_IT+0x58c>)
 801413c:	429c      	cmp	r4, r3
 801413e:	f000 8437 	beq.w	80149b0 <HAL_DMAEx_MultiBufferStart_IT+0xd14>
 8014142:	4b42      	ldr	r3, [pc, #264]	@ (801424c <HAL_DMAEx_MultiBufferStart_IT+0x5b0>)
 8014144:	429c      	cmp	r4, r3
 8014146:	f000 845e 	beq.w	8014a06 <HAL_DMAEx_MultiBufferStart_IT+0xd6a>
 801414a:	4b38      	ldr	r3, [pc, #224]	@ (801422c <HAL_DMAEx_MultiBufferStart_IT+0x590>)
 801414c:	429c      	cmp	r4, r3
 801414e:	f47f af69 	bne.w	8014024 <HAL_DMAEx_MultiBufferStart_IT+0x388>
 8014152:	f5a3 6391 	sub.w	r3, r3, #1160	@ 0x488
 8014156:	f44f 7200 	mov.w	r2, #512	@ 0x200
 801415a:	609a      	str	r2, [r3, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 801415c:	4b3c      	ldr	r3, [pc, #240]	@ (8014250 <HAL_DMAEx_MultiBufferStart_IT+0x5b4>)
 801415e:	f44f 7280 	mov.w	r2, #256	@ 0x100
 8014162:	60da      	str	r2, [r3, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8014164:	2240      	movs	r2, #64	@ 0x40
 8014166:	e5f2      	b.n	8013d4e <HAL_DMAEx_MultiBufferStart_IT+0xb2>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8014168:	2110      	movs	r1, #16
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 801416a:	2308      	movs	r3, #8
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 801416c:	60d1      	str	r1, [r2, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 801416e:	6093      	str	r3, [r2, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014170:	4b2a      	ldr	r3, [pc, #168]	@ (801421c <HAL_DMAEx_MultiBufferStart_IT+0x580>)
 8014172:	429c      	cmp	r4, r3
 8014174:	f000 80cd 	beq.w	8014312 <HAL_DMAEx_MultiBufferStart_IT+0x676>
 8014178:	4b29      	ldr	r3, [pc, #164]	@ (8014220 <HAL_DMAEx_MultiBufferStart_IT+0x584>)
 801417a:	429c      	cmp	r4, r3
 801417c:	f47f af76 	bne.w	801406c <HAL_DMAEx_MultiBufferStart_IT+0x3d0>
 8014180:	4b2f      	ldr	r3, [pc, #188]	@ (8014240 <HAL_DMAEx_MultiBufferStart_IT+0x5a4>)
 8014182:	2204      	movs	r2, #4
 8014184:	60da      	str	r2, [r3, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8014186:	e5e1      	b.n	8013d4c <HAL_DMAEx_MultiBufferStart_IT+0xb0>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8014188:	2120      	movs	r1, #32
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 801418a:	2210      	movs	r2, #16
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 801418c:	f843 1c08 	str.w	r1, [r3, #-8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8014190:	f843 2c08 	str.w	r2, [r3, #-8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8014194:	4b2e      	ldr	r3, [pc, #184]	@ (8014250 <HAL_DMAEx_MultiBufferStart_IT+0x5b4>)
 8014196:	2208      	movs	r2, #8
 8014198:	609a      	str	r2, [r3, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 801419a:	4b2d      	ldr	r3, [pc, #180]	@ (8014250 <HAL_DMAEx_MultiBufferStart_IT+0x5b4>)
 801419c:	2204      	movs	r2, #4
 801419e:	609a      	str	r2, [r3, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 80141a0:	2201      	movs	r2, #1
 80141a2:	4b2b      	ldr	r3, [pc, #172]	@ (8014250 <HAL_DMAEx_MultiBufferStart_IT+0x5b4>)
 80141a4:	609a      	str	r2, [r3, #8]
 80141a6:	e5d4      	b.n	8013d52 <HAL_DMAEx_MultiBufferStart_IT+0xb6>
    if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 80141a8:	f8dc 3048 	ldr.w	r3, [ip, #72]	@ 0x48
 80141ac:	2b00      	cmp	r3, #0
 80141ae:	f47f addd 	bne.w	8013d6c <HAL_DMAEx_MultiBufferStart_IT+0xd0>
 80141b2:	e5df      	b.n	8013d74 <HAL_DMAEx_MultiBufferStart_IT+0xd8>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 80141b4:	4b1c      	ldr	r3, [pc, #112]	@ (8014228 <HAL_DMAEx_MultiBufferStart_IT+0x58c>)
 80141b6:	491b      	ldr	r1, [pc, #108]	@ (8014224 <HAL_DMAEx_MultiBufferStart_IT+0x588>)
 80141b8:	4a24      	ldr	r2, [pc, #144]	@ (801424c <HAL_DMAEx_MultiBufferStart_IT+0x5b0>)
 80141ba:	429c      	cmp	r4, r3
 80141bc:	bf18      	it	ne
 80141be:	428c      	cmpne	r4, r1
 80141c0:	bf14      	ite	ne
 80141c2:	2301      	movne	r3, #1
 80141c4:	2300      	moveq	r3, #0
 80141c6:	4294      	cmp	r4, r2
 80141c8:	bf0c      	ite	eq
 80141ca:	2300      	moveq	r3, #0
 80141cc:	f003 0301 	andne.w	r3, r3, #1
 80141d0:	b11b      	cbz	r3, 80141da <HAL_DMAEx_MultiBufferStart_IT+0x53e>
 80141d2:	4b16      	ldr	r3, [pc, #88]	@ (801422c <HAL_DMAEx_MultiBufferStart_IT+0x590>)
 80141d4:	429c      	cmp	r4, r3
 80141d6:	f040 813d 	bne.w	8014454 <HAL_DMAEx_MultiBufferStart_IT+0x7b8>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 80141da:	4a12      	ldr	r2, [pc, #72]	@ (8014224 <HAL_DMAEx_MultiBufferStart_IT+0x588>)
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 80141dc:	f44f 6100 	mov.w	r1, #2048	@ 0x800
 80141e0:	4b1b      	ldr	r3, [pc, #108]	@ (8014250 <HAL_DMAEx_MultiBufferStart_IT+0x5b4>)
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 80141e2:	4294      	cmp	r4, r2
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 80141e4:	60d9      	str	r1, [r3, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 80141e6:	f000 8228 	beq.w	801463a <HAL_DMAEx_MultiBufferStart_IT+0x99e>
 80141ea:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 80141ee:	4294      	cmp	r4, r2
 80141f0:	f000 82d1 	beq.w	8014796 <HAL_DMAEx_MultiBufferStart_IT+0xafa>
 80141f4:	f5a2 7268 	sub.w	r2, r2, #928	@ 0x3a0
 80141f8:	4294      	cmp	r4, r2
 80141fa:	f000 8375 	beq.w	80148e8 <HAL_DMAEx_MultiBufferStart_IT+0xc4c>
 80141fe:	4b14      	ldr	r3, [pc, #80]	@ (8014250 <HAL_DMAEx_MultiBufferStart_IT+0x5b4>)
 8014200:	f44f 6180 	mov.w	r1, #1024	@ 0x400
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8014204:	f44f 7200 	mov.w	r2, #512	@ 0x200
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8014208:	60d9      	str	r1, [r3, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 801420a:	60da      	str	r2, [r3, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 801420c:	e7a6      	b.n	801415c <HAL_DMAEx_MultiBufferStart_IT+0x4c0>
 801420e:	bf00      	nop
 8014210:	40026058 	.word	0x40026058
 8014214:	40026010 	.word	0x40026010
 8014218:	40026410 	.word	0x40026410
 801421c:	40026070 	.word	0x40026070
 8014220:	40026470 	.word	0x40026470
 8014224:	40026028 	.word	0x40026028
 8014228:	40026428 	.word	0x40026428
 801422c:	40026488 	.word	0x40026488
 8014230:	40026440 	.word	0x40026440
 8014234:	40026040 	.word	0x40026040
 8014238:	400260a0 	.word	0x400260a0
 801423c:	400264a0 	.word	0x400264a0
 8014240:	40026000 	.word	0x40026000
 8014244:	40026458 	.word	0x40026458
 8014248:	400260b8 	.word	0x400260b8
 801424c:	40026088 	.word	0x40026088
 8014250:	40026400 	.word	0x40026400
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8014254:	2120      	movs	r1, #32
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8014256:	4a71      	ldr	r2, [pc, #452]	@ (801441c <HAL_DMAEx_MultiBufferStart_IT+0x780>)
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8014258:	f8c3 13f8 	str.w	r1, [r3, #1016]	@ 0x3f8
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 801425c:	2110      	movs	r1, #16
 801425e:	6091      	str	r1, [r2, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8014260:	2108      	movs	r1, #8
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014262:	2204      	movs	r2, #4
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8014264:	f8c3 13f8 	str.w	r1, [r3, #1016]	@ 0x3f8
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014268:	f8c3 23f8 	str.w	r2, [r3, #1016]	@ 0x3f8
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 801426c:	e798      	b.n	80141a0 <HAL_DMAEx_MultiBufferStart_IT+0x504>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 801426e:	2310      	movs	r3, #16
 8014270:	60d3      	str	r3, [r2, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8014272:	4b6a      	ldr	r3, [pc, #424]	@ (801441c <HAL_DMAEx_MultiBufferStart_IT+0x780>)
 8014274:	2108      	movs	r1, #8
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014276:	2204      	movs	r2, #4
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8014278:	6099      	str	r1, [r3, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 801427a:	609a      	str	r2, [r3, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 801427c:	2201      	movs	r2, #1
 801427e:	e6fe      	b.n	801407e <HAL_DMAEx_MultiBufferStart_IT+0x3e2>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8014280:	f44f 2200 	mov.w	r2, #524288	@ 0x80000
 8014284:	60da      	str	r2, [r3, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014286:	4b66      	ldr	r3, [pc, #408]	@ (8014420 <HAL_DMAEx_MultiBufferStart_IT+0x784>)
 8014288:	429c      	cmp	r4, r3
 801428a:	f000 82c1 	beq.w	8014810 <HAL_DMAEx_MultiBufferStart_IT+0xb74>
 801428e:	4b65      	ldr	r3, [pc, #404]	@ (8014424 <HAL_DMAEx_MultiBufferStart_IT+0x788>)
 8014290:	429c      	cmp	r4, r3
 8014292:	f000 8279 	beq.w	8014788 <HAL_DMAEx_MultiBufferStart_IT+0xaec>
 8014296:	4b64      	ldr	r3, [pc, #400]	@ (8014428 <HAL_DMAEx_MultiBufferStart_IT+0x78c>)
 8014298:	429c      	cmp	r4, r3
 801429a:	f43f af5f 	beq.w	801415c <HAL_DMAEx_MultiBufferStart_IT+0x4c0>
 801429e:	4b63      	ldr	r3, [pc, #396]	@ (801442c <HAL_DMAEx_MultiBufferStart_IT+0x790>)
 80142a0:	4963      	ldr	r1, [pc, #396]	@ (8014430 <HAL_DMAEx_MultiBufferStart_IT+0x794>)
 80142a2:	4a64      	ldr	r2, [pc, #400]	@ (8014434 <HAL_DMAEx_MultiBufferStart_IT+0x798>)
 80142a4:	429c      	cmp	r4, r3
 80142a6:	bf18      	it	ne
 80142a8:	428c      	cmpne	r4, r1
 80142aa:	bf14      	ite	ne
 80142ac:	2301      	movne	r3, #1
 80142ae:	2300      	moveq	r3, #0
 80142b0:	4294      	cmp	r4, r2
 80142b2:	bf0c      	ite	eq
 80142b4:	2300      	moveq	r3, #0
 80142b6:	f003 0301 	andne.w	r3, r3, #1
 80142ba:	b113      	cbz	r3, 80142c2 <HAL_DMAEx_MultiBufferStart_IT+0x626>
 80142bc:	4b5e      	ldr	r3, [pc, #376]	@ (8014438 <HAL_DMAEx_MultiBufferStart_IT+0x79c>)
 80142be:	429c      	cmp	r4, r3
 80142c0:	d16c      	bne.n	801439c <HAL_DMAEx_MultiBufferStart_IT+0x700>
 80142c2:	4a5e      	ldr	r2, [pc, #376]	@ (801443c <HAL_DMAEx_MultiBufferStart_IT+0x7a0>)
 80142c4:	e5f9      	b.n	8013eba <HAL_DMAEx_MultiBufferStart_IT+0x21e>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 80142c6:	2310      	movs	r3, #16
 80142c8:	60d3      	str	r3, [r2, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 80142ca:	e763      	b.n	8014194 <HAL_DMAEx_MultiBufferStart_IT+0x4f8>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 80142cc:	2120      	movs	r1, #32
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 80142ce:	2210      	movs	r2, #16
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 80142d0:	f843 1c08 	str.w	r1, [r3, #-8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 80142d4:	2108      	movs	r1, #8
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 80142d6:	f843 2c08 	str.w	r2, [r3, #-8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 80142da:	2204      	movs	r2, #4
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 80142dc:	f843 1c08 	str.w	r1, [r3, #-8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 80142e0:	f843 2c08 	str.w	r2, [r3, #-8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 80142e4:	e7ca      	b.n	801427c <HAL_DMAEx_MultiBufferStart_IT+0x5e0>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 80142e6:	2210      	movs	r2, #16
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 80142e8:	2120      	movs	r1, #32
 80142ea:	f843 1c04 	str.w	r1, [r3, #-4]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 80142ee:	f843 2c08 	str.w	r2, [r3, #-8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 80142f2:	2208      	movs	r2, #8
 80142f4:	f843 2c08 	str.w	r2, [r3, #-8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 80142f8:	4b48      	ldr	r3, [pc, #288]	@ (801441c <HAL_DMAEx_MultiBufferStart_IT+0x780>)
 80142fa:	2204      	movs	r2, #4
 80142fc:	60da      	str	r2, [r3, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 80142fe:	e7bd      	b.n	801427c <HAL_DMAEx_MultiBufferStart_IT+0x5e0>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8014300:	4a4e      	ldr	r2, [pc, #312]	@ (801443c <HAL_DMAEx_MultiBufferStart_IT+0x7a0>)
 8014302:	2120      	movs	r1, #32
 8014304:	6091      	str	r1, [r2, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8014306:	2210      	movs	r2, #16
 8014308:	f843 2c64 	str.w	r2, [r3, #-100]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 801430c:	4b43      	ldr	r3, [pc, #268]	@ (801441c <HAL_DMAEx_MultiBufferStart_IT+0x780>)
 801430e:	2208      	movs	r2, #8
 8014310:	60da      	str	r2, [r3, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014312:	4b42      	ldr	r3, [pc, #264]	@ (801441c <HAL_DMAEx_MultiBufferStart_IT+0x780>)
 8014314:	2204      	movs	r2, #4
 8014316:	60da      	str	r2, [r3, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8014318:	2201      	movs	r2, #1
 801431a:	e608      	b.n	8013f2e <HAL_DMAEx_MultiBufferStart_IT+0x292>
 801431c:	4b48      	ldr	r3, [pc, #288]	@ (8014440 <HAL_DMAEx_MultiBufferStart_IT+0x7a4>)
 801431e:	429c      	cmp	r4, r3
 8014320:	f240 82ff 	bls.w	8014922 <HAL_DMAEx_MultiBufferStart_IT+0xc86>
 8014324:	4b47      	ldr	r3, [pc, #284]	@ (8014444 <HAL_DMAEx_MultiBufferStart_IT+0x7a8>)
 8014326:	429c      	cmp	r4, r3
 8014328:	f43f af3a 	beq.w	80141a0 <HAL_DMAEx_MultiBufferStart_IT+0x504>
 801432c:	4b46      	ldr	r3, [pc, #280]	@ (8014448 <HAL_DMAEx_MultiBufferStart_IT+0x7ac>)
 801432e:	429c      	cmp	r4, r3
 8014330:	f43f af36 	beq.w	80141a0 <HAL_DMAEx_MultiBufferStart_IT+0x504>
 8014334:	4b45      	ldr	r3, [pc, #276]	@ (801444c <HAL_DMAEx_MultiBufferStart_IT+0x7b0>)
 8014336:	429c      	cmp	r4, r3
 8014338:	f43f af32 	beq.w	80141a0 <HAL_DMAEx_MultiBufferStart_IT+0x504>
 801433c:	f5a3 6380 	sub.w	r3, r3, #1024	@ 0x400
 8014340:	429c      	cmp	r4, r3
 8014342:	f43f af2d 	beq.w	80141a0 <HAL_DMAEx_MultiBufferStart_IT+0x504>
 8014346:	4b42      	ldr	r3, [pc, #264]	@ (8014450 <HAL_DMAEx_MultiBufferStart_IT+0x7b4>)
 8014348:	4935      	ldr	r1, [pc, #212]	@ (8014420 <HAL_DMAEx_MultiBufferStart_IT+0x784>)
 801434a:	4a36      	ldr	r2, [pc, #216]	@ (8014424 <HAL_DMAEx_MultiBufferStart_IT+0x788>)
 801434c:	429c      	cmp	r4, r3
 801434e:	bf18      	it	ne
 8014350:	428c      	cmpne	r4, r1
 8014352:	bf14      	ite	ne
 8014354:	2301      	movne	r3, #1
 8014356:	2300      	moveq	r3, #0
 8014358:	4294      	cmp	r4, r2
 801435a:	bf0c      	ite	eq
 801435c:	2300      	moveq	r3, #0
 801435e:	f003 0301 	andne.w	r3, r3, #1
 8014362:	2b00      	cmp	r3, #0
 8014364:	f000 8222 	beq.w	80147ac <HAL_DMAEx_MultiBufferStart_IT+0xb10>
 8014368:	4b2f      	ldr	r3, [pc, #188]	@ (8014428 <HAL_DMAEx_MultiBufferStart_IT+0x78c>)
 801436a:	429c      	cmp	r4, r3
 801436c:	f000 821e 	beq.w	80147ac <HAL_DMAEx_MultiBufferStart_IT+0xb10>
 8014370:	4b2e      	ldr	r3, [pc, #184]	@ (801442c <HAL_DMAEx_MultiBufferStart_IT+0x790>)
 8014372:	492f      	ldr	r1, [pc, #188]	@ (8014430 <HAL_DMAEx_MultiBufferStart_IT+0x794>)
 8014374:	4a2f      	ldr	r2, [pc, #188]	@ (8014434 <HAL_DMAEx_MultiBufferStart_IT+0x798>)
 8014376:	429c      	cmp	r4, r3
 8014378:	bf18      	it	ne
 801437a:	428c      	cmpne	r4, r1
 801437c:	bf14      	ite	ne
 801437e:	2301      	movne	r3, #1
 8014380:	2300      	moveq	r3, #0
 8014382:	4294      	cmp	r4, r2
 8014384:	bf0c      	ite	eq
 8014386:	2300      	moveq	r3, #0
 8014388:	f003 0301 	andne.w	r3, r3, #1
 801438c:	b11b      	cbz	r3, 8014396 <HAL_DMAEx_MultiBufferStart_IT+0x6fa>
 801438e:	4b2a      	ldr	r3, [pc, #168]	@ (8014438 <HAL_DMAEx_MultiBufferStart_IT+0x79c>)
 8014390:	429c      	cmp	r4, r3
 8014392:	f040 83f0 	bne.w	8014b76 <HAL_DMAEx_MultiBufferStart_IT+0xeda>
 8014396:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
 801439a:	e702      	b.n	80141a2 <HAL_DMAEx_MultiBufferStart_IT+0x506>
 801439c:	3b48      	subs	r3, #72	@ 0x48
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 801439e:	f04f 7180 	mov.w	r1, #16777216	@ 0x1000000
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 80143a2:	429c      	cmp	r4, r3
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 80143a4:	f8c2 136c 	str.w	r1, [r2, #876]	@ 0x36c
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 80143a8:	d9b8      	bls.n	801431c <HAL_DMAEx_MultiBufferStart_IT+0x680>
 80143aa:	3b48      	subs	r3, #72	@ 0x48
 80143ac:	429c      	cmp	r4, r3
 80143ae:	f43f accd 	beq.w	8013d4c <HAL_DMAEx_MultiBufferStart_IT+0xb0>
 80143b2:	f5a3 6380 	sub.w	r3, r3, #1024	@ 0x400
 80143b6:	429c      	cmp	r4, r3
 80143b8:	f43f acc8 	beq.w	8013d4c <HAL_DMAEx_MultiBufferStart_IT+0xb0>
 80143bc:	4b23      	ldr	r3, [pc, #140]	@ (801444c <HAL_DMAEx_MultiBufferStart_IT+0x7b0>)
 80143be:	429c      	cmp	r4, r3
 80143c0:	f43f acc4 	beq.w	8013d4c <HAL_DMAEx_MultiBufferStart_IT+0xb0>
 80143c4:	4b22      	ldr	r3, [pc, #136]	@ (8014450 <HAL_DMAEx_MultiBufferStart_IT+0x7b4>)
 80143c6:	4916      	ldr	r1, [pc, #88]	@ (8014420 <HAL_DMAEx_MultiBufferStart_IT+0x784>)
 80143c8:	4a16      	ldr	r2, [pc, #88]	@ (8014424 <HAL_DMAEx_MultiBufferStart_IT+0x788>)
 80143ca:	429c      	cmp	r4, r3
 80143cc:	bf18      	it	ne
 80143ce:	428c      	cmpne	r4, r1
 80143d0:	bf14      	ite	ne
 80143d2:	2301      	movne	r3, #1
 80143d4:	2300      	moveq	r3, #0
 80143d6:	4294      	cmp	r4, r2
 80143d8:	bf0c      	ite	eq
 80143da:	2300      	moveq	r3, #0
 80143dc:	f003 0301 	andne.w	r3, r3, #1
 80143e0:	2b00      	cmp	r3, #0
 80143e2:	f43f aebf 	beq.w	8014164 <HAL_DMAEx_MultiBufferStart_IT+0x4c8>
 80143e6:	4b10      	ldr	r3, [pc, #64]	@ (8014428 <HAL_DMAEx_MultiBufferStart_IT+0x78c>)
 80143e8:	429c      	cmp	r4, r3
 80143ea:	f43f aebb 	beq.w	8014164 <HAL_DMAEx_MultiBufferStart_IT+0x4c8>
 80143ee:	4b0f      	ldr	r3, [pc, #60]	@ (801442c <HAL_DMAEx_MultiBufferStart_IT+0x790>)
 80143f0:	490f      	ldr	r1, [pc, #60]	@ (8014430 <HAL_DMAEx_MultiBufferStart_IT+0x794>)
 80143f2:	4a10      	ldr	r2, [pc, #64]	@ (8014434 <HAL_DMAEx_MultiBufferStart_IT+0x798>)
 80143f4:	429c      	cmp	r4, r3
 80143f6:	bf18      	it	ne
 80143f8:	428c      	cmpne	r4, r1
 80143fa:	bf14      	ite	ne
 80143fc:	2301      	movne	r3, #1
 80143fe:	2300      	moveq	r3, #0
 8014400:	4294      	cmp	r4, r2
 8014402:	bf0c      	ite	eq
 8014404:	2300      	moveq	r3, #0
 8014406:	f003 0301 	andne.w	r3, r3, #1
 801440a:	b11b      	cbz	r3, 8014414 <HAL_DMAEx_MultiBufferStart_IT+0x778>
 801440c:	4b0a      	ldr	r3, [pc, #40]	@ (8014438 <HAL_DMAEx_MultiBufferStart_IT+0x79c>)
 801440e:	429c      	cmp	r4, r3
 8014410:	f040 8275 	bne.w	80148fe <HAL_DMAEx_MultiBufferStart_IT+0xc62>
 8014414:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
 8014418:	e499      	b.n	8013d4e <HAL_DMAEx_MultiBufferStart_IT+0xb2>
 801441a:	bf00      	nop
 801441c:	40026000 	.word	0x40026000
 8014420:	40026428 	.word	0x40026428
 8014424:	40026088 	.word	0x40026088
 8014428:	40026488 	.word	0x40026488
 801442c:	40026440 	.word	0x40026440
 8014430:	40026040 	.word	0x40026040
 8014434:	400260a0 	.word	0x400260a0
 8014438:	400264a0 	.word	0x400264a0
 801443c:	40026400 	.word	0x40026400
 8014440:	400260b8 	.word	0x400260b8
 8014444:	40026010 	.word	0x40026010
 8014448:	40026410 	.word	0x40026410
 801444c:	40026470 	.word	0x40026470
 8014450:	40026028 	.word	0x40026028
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8014454:	4baa      	ldr	r3, [pc, #680]	@ (8014700 <HAL_DMAEx_MultiBufferStart_IT+0xa64>)
 8014456:	49ab      	ldr	r1, [pc, #684]	@ (8014704 <HAL_DMAEx_MultiBufferStart_IT+0xa68>)
 8014458:	4aab      	ldr	r2, [pc, #684]	@ (8014708 <HAL_DMAEx_MultiBufferStart_IT+0xa6c>)
 801445a:	429c      	cmp	r4, r3
 801445c:	bf18      	it	ne
 801445e:	428c      	cmpne	r4, r1
 8014460:	bf14      	ite	ne
 8014462:	2301      	movne	r3, #1
 8014464:	2300      	moveq	r3, #0
 8014466:	4294      	cmp	r4, r2
 8014468:	bf0c      	ite	eq
 801446a:	2300      	moveq	r3, #0
 801446c:	f003 0301 	andne.w	r3, r3, #1
 8014470:	b11b      	cbz	r3, 801447a <HAL_DMAEx_MultiBufferStart_IT+0x7de>
 8014472:	4ba6      	ldr	r3, [pc, #664]	@ (801470c <HAL_DMAEx_MultiBufferStart_IT+0xa70>)
 8014474:	429c      	cmp	r4, r3
 8014476:	f040 81d5 	bne.w	8014824 <HAL_DMAEx_MultiBufferStart_IT+0xb88>
 801447a:	4ba5      	ldr	r3, [pc, #660]	@ (8014710 <HAL_DMAEx_MultiBufferStart_IT+0xa74>)
 801447c:	f44f 1200 	mov.w	r2, #2097152	@ 0x200000
 8014480:	60da      	str	r2, [r3, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8014482:	4b9f      	ldr	r3, [pc, #636]	@ (8014700 <HAL_DMAEx_MultiBufferStart_IT+0xa64>)
 8014484:	499f      	ldr	r1, [pc, #636]	@ (8014704 <HAL_DMAEx_MultiBufferStart_IT+0xa68>)
 8014486:	4aa0      	ldr	r2, [pc, #640]	@ (8014708 <HAL_DMAEx_MultiBufferStart_IT+0xa6c>)
 8014488:	429c      	cmp	r4, r3
 801448a:	bf18      	it	ne
 801448c:	428c      	cmpne	r4, r1
 801448e:	bf14      	ite	ne
 8014490:	2301      	movne	r3, #1
 8014492:	2300      	moveq	r3, #0
 8014494:	4294      	cmp	r4, r2
 8014496:	bf0c      	ite	eq
 8014498:	2300      	moveq	r3, #0
 801449a:	f003 0301 	andne.w	r3, r3, #1
 801449e:	b113      	cbz	r3, 80144a6 <HAL_DMAEx_MultiBufferStart_IT+0x80a>
 80144a0:	4b9a      	ldr	r3, [pc, #616]	@ (801470c <HAL_DMAEx_MultiBufferStart_IT+0xa70>)
 80144a2:	429c      	cmp	r4, r3
 80144a4:	d14a      	bne.n	801453c <HAL_DMAEx_MultiBufferStart_IT+0x8a0>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 80144a6:	4a9b      	ldr	r2, [pc, #620]	@ (8014714 <HAL_DMAEx_MultiBufferStart_IT+0xa78>)
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 80144a8:	f44f 1180 	mov.w	r1, #1048576	@ 0x100000
 80144ac:	4b98      	ldr	r3, [pc, #608]	@ (8014710 <HAL_DMAEx_MultiBufferStart_IT+0xa74>)
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 80144ae:	4294      	cmp	r4, r2
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 80144b0:	60d9      	str	r1, [r3, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 80144b2:	f63f aee5 	bhi.w	8014280 <HAL_DMAEx_MultiBufferStart_IT+0x5e4>
 80144b6:	f5a3 7352 	sub.w	r3, r3, #840	@ 0x348
 80144ba:	429c      	cmp	r4, r3
 80144bc:	d863      	bhi.n	8014586 <HAL_DMAEx_MultiBufferStart_IT+0x8ea>
 80144be:	3b60      	subs	r3, #96	@ 0x60
 80144c0:	429c      	cmp	r4, r3
 80144c2:	f67f ae36 	bls.w	8014132 <HAL_DMAEx_MultiBufferStart_IT+0x496>
 80144c6:	4b94      	ldr	r3, [pc, #592]	@ (8014718 <HAL_DMAEx_MultiBufferStart_IT+0xa7c>)
 80144c8:	429c      	cmp	r4, r3
 80144ca:	f000 81e4 	beq.w	8014896 <HAL_DMAEx_MultiBufferStart_IT+0xbfa>
 80144ce:	4b93      	ldr	r3, [pc, #588]	@ (801471c <HAL_DMAEx_MultiBufferStart_IT+0xa80>)
 80144d0:	429c      	cmp	r4, r3
 80144d2:	f040 846a 	bne.w	8014daa <HAL_DMAEx_MultiBufferStart_IT+0x110e>
 80144d6:	4b92      	ldr	r3, [pc, #584]	@ (8014720 <HAL_DMAEx_MultiBufferStart_IT+0xa84>)
 80144d8:	f44f 7200 	mov.w	r2, #512	@ 0x200
 80144dc:	60da      	str	r2, [r3, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 80144de:	4b90      	ldr	r3, [pc, #576]	@ (8014720 <HAL_DMAEx_MultiBufferStart_IT+0xa84>)
 80144e0:	f44f 7280 	mov.w	r2, #256	@ 0x100
 80144e4:	609a      	str	r2, [r3, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 80144e6:	4b8d      	ldr	r3, [pc, #564]	@ (801471c <HAL_DMAEx_MultiBufferStart_IT+0xa80>)
 80144e8:	498e      	ldr	r1, [pc, #568]	@ (8014724 <HAL_DMAEx_MultiBufferStart_IT+0xa88>)
 80144ea:	4a8f      	ldr	r2, [pc, #572]	@ (8014728 <HAL_DMAEx_MultiBufferStart_IT+0xa8c>)
 80144ec:	429c      	cmp	r4, r3
 80144ee:	bf18      	it	ne
 80144f0:	428c      	cmpne	r4, r1
 80144f2:	bf14      	ite	ne
 80144f4:	2301      	movne	r3, #1
 80144f6:	2300      	moveq	r3, #0
 80144f8:	4294      	cmp	r4, r2
 80144fa:	bf0c      	ite	eq
 80144fc:	2300      	moveq	r3, #0
 80144fe:	f003 0301 	andne.w	r3, r3, #1
 8014502:	2b00      	cmp	r3, #0
 8014504:	f43f adba 	beq.w	801407c <HAL_DMAEx_MultiBufferStart_IT+0x3e0>
 8014508:	4b88      	ldr	r3, [pc, #544]	@ (801472c <HAL_DMAEx_MultiBufferStart_IT+0xa90>)
 801450a:	429c      	cmp	r4, r3
 801450c:	f43f adb6 	beq.w	801407c <HAL_DMAEx_MultiBufferStart_IT+0x3e0>
 8014510:	4b7b      	ldr	r3, [pc, #492]	@ (8014700 <HAL_DMAEx_MultiBufferStart_IT+0xa64>)
 8014512:	497c      	ldr	r1, [pc, #496]	@ (8014704 <HAL_DMAEx_MultiBufferStart_IT+0xa68>)
 8014514:	4a7c      	ldr	r2, [pc, #496]	@ (8014708 <HAL_DMAEx_MultiBufferStart_IT+0xa6c>)
 8014516:	429c      	cmp	r4, r3
 8014518:	bf18      	it	ne
 801451a:	428c      	cmpne	r4, r1
 801451c:	bf14      	ite	ne
 801451e:	2301      	movne	r3, #1
 8014520:	2300      	moveq	r3, #0
 8014522:	4294      	cmp	r4, r2
 8014524:	bf0c      	ite	eq
 8014526:	2300      	moveq	r3, #0
 8014528:	f003 0301 	andne.w	r3, r3, #1
 801452c:	b11b      	cbz	r3, 8014536 <HAL_DMAEx_MultiBufferStart_IT+0x89a>
 801452e:	4b77      	ldr	r3, [pc, #476]	@ (801470c <HAL_DMAEx_MultiBufferStart_IT+0xa70>)
 8014530:	429c      	cmp	r4, r3
 8014532:	f040 8393 	bne.w	8014c5c <HAL_DMAEx_MultiBufferStart_IT+0xfc0>
 8014536:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
 801453a:	e5a0      	b.n	801407e <HAL_DMAEx_MultiBufferStart_IT+0x3e2>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 801453c:	3b48      	subs	r3, #72	@ 0x48
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 801453e:	f502 7258 	add.w	r2, r2, #864	@ 0x360
 8014542:	f04f 6180 	mov.w	r1, #67108864	@ 0x4000000
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8014546:	429c      	cmp	r4, r3
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8014548:	60d1      	str	r1, [r2, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 801454a:	f200 82eb 	bhi.w	8014b24 <HAL_DMAEx_MultiBufferStart_IT+0xe88>
 801454e:	4b78      	ldr	r3, [pc, #480]	@ (8014730 <HAL_DMAEx_MultiBufferStart_IT+0xa94>)
 8014550:	429c      	cmp	r4, r3
 8014552:	f240 82d7 	bls.w	8014b04 <HAL_DMAEx_MultiBufferStart_IT+0xe68>
 8014556:	3ba8      	subs	r3, #168	@ 0xa8
 8014558:	429c      	cmp	r4, r3
 801455a:	f000 8422 	beq.w	8014da2 <HAL_DMAEx_MultiBufferStart_IT+0x1106>
 801455e:	4b75      	ldr	r3, [pc, #468]	@ (8014734 <HAL_DMAEx_MultiBufferStart_IT+0xa98>)
 8014560:	429c      	cmp	r4, r3
 8014562:	f43f ae17 	beq.w	8014194 <HAL_DMAEx_MultiBufferStart_IT+0x4f8>
 8014566:	4b74      	ldr	r3, [pc, #464]	@ (8014738 <HAL_DMAEx_MultiBufferStart_IT+0xa9c>)
 8014568:	429c      	cmp	r4, r3
 801456a:	f000 81d6 	beq.w	801491a <HAL_DMAEx_MultiBufferStart_IT+0xc7e>
 801456e:	4b6a      	ldr	r3, [pc, #424]	@ (8014718 <HAL_DMAEx_MultiBufferStart_IT+0xa7c>)
 8014570:	429c      	cmp	r4, r3
 8014572:	f000 81c8 	beq.w	8014906 <HAL_DMAEx_MultiBufferStart_IT+0xc6a>
 8014576:	4b69      	ldr	r3, [pc, #420]	@ (801471c <HAL_DMAEx_MultiBufferStart_IT+0xa80>)
 8014578:	429c      	cmp	r4, r3
 801457a:	f000 81c9 	beq.w	8014910 <HAL_DMAEx_MultiBufferStart_IT+0xc74>
 801457e:	4b69      	ldr	r3, [pc, #420]	@ (8014724 <HAL_DMAEx_MultiBufferStart_IT+0xa88>)
 8014580:	429c      	cmp	r4, r3
 8014582:	f000 810b 	beq.w	801479c <HAL_DMAEx_MultiBufferStart_IT+0xb00>
 8014586:	4b68      	ldr	r3, [pc, #416]	@ (8014728 <HAL_DMAEx_MultiBufferStart_IT+0xa8c>)
 8014588:	429c      	cmp	r4, r3
 801458a:	f000 81a8 	beq.w	80148de <HAL_DMAEx_MultiBufferStart_IT+0xc42>
 801458e:	4b67      	ldr	r3, [pc, #412]	@ (801472c <HAL_DMAEx_MultiBufferStart_IT+0xa90>)
 8014590:	429c      	cmp	r4, r3
 8014592:	f47f ac52 	bne.w	8013e3a <HAL_DMAEx_MultiBufferStart_IT+0x19e>
 8014596:	f44f 7200 	mov.w	r2, #512	@ 0x200
 801459a:	f843 2c80 	str.w	r2, [r3, #-128]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 801459e:	e5dd      	b.n	801415c <HAL_DMAEx_MultiBufferStart_IT+0x4c0>
 80145a0:	3b48      	subs	r3, #72	@ 0x48
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 80145a2:	f04f 7100 	mov.w	r1, #33554432	@ 0x2000000
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 80145a6:	429c      	cmp	r4, r3
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 80145a8:	f842 1c98 	str.w	r1, [r2, #-152]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 80145ac:	f200 80d2 	bhi.w	8014754 <HAL_DMAEx_MultiBufferStart_IT+0xab8>
 80145b0:	f5a3 7368 	sub.w	r3, r3, #928	@ 0x3a0
 80145b4:	429c      	cmp	r4, r3
 80145b6:	f240 83dc 	bls.w	8014d72 <HAL_DMAEx_MultiBufferStart_IT+0x10d6>
 80145ba:	3ba8      	subs	r3, #168	@ 0xa8
 80145bc:	429c      	cmp	r4, r3
 80145be:	f000 8299 	beq.w	8014af4 <HAL_DMAEx_MultiBufferStart_IT+0xe58>
 80145c2:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 80145c6:	429c      	cmp	r4, r3
 80145c8:	f43f ade7 	beq.w	801419a <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
 80145cc:	f5a3 7368 	sub.w	r3, r3, #928	@ 0x3a0
 80145d0:	429c      	cmp	r4, r3
 80145d2:	f000 828f 	beq.w	8014af4 <HAL_DMAEx_MultiBufferStart_IT+0xe58>
 80145d6:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 80145da:	429c      	cmp	r4, r3
 80145dc:	f000 826b 	beq.w	8014ab6 <HAL_DMAEx_MultiBufferStart_IT+0xe1a>
 80145e0:	4b50      	ldr	r3, [pc, #320]	@ (8014724 <HAL_DMAEx_MultiBufferStart_IT+0xa88>)
 80145e2:	429c      	cmp	r4, r3
 80145e4:	f000 80de 	beq.w	80147a4 <HAL_DMAEx_MultiBufferStart_IT+0xb08>
 80145e8:	4b4f      	ldr	r3, [pc, #316]	@ (8014728 <HAL_DMAEx_MultiBufferStart_IT+0xa8c>)
 80145ea:	429c      	cmp	r4, r3
 80145ec:	f000 8168 	beq.w	80148c0 <HAL_DMAEx_MultiBufferStart_IT+0xc24>
 80145f0:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 80145f4:	429c      	cmp	r4, r3
 80145f6:	f000 81e1 	beq.w	80149bc <HAL_DMAEx_MultiBufferStart_IT+0xd20>
 80145fa:	4b42      	ldr	r3, [pc, #264]	@ (8014704 <HAL_DMAEx_MultiBufferStart_IT+0xa68>)
 80145fc:	4940      	ldr	r1, [pc, #256]	@ (8014700 <HAL_DMAEx_MultiBufferStart_IT+0xa64>)
 80145fe:	4a42      	ldr	r2, [pc, #264]	@ (8014708 <HAL_DMAEx_MultiBufferStart_IT+0xa6c>)
 8014600:	429c      	cmp	r4, r3
 8014602:	bf18      	it	ne
 8014604:	428c      	cmpne	r4, r1
 8014606:	bf14      	ite	ne
 8014608:	2301      	movne	r3, #1
 801460a:	2300      	moveq	r3, #0
 801460c:	4294      	cmp	r4, r2
 801460e:	bf0c      	ite	eq
 8014610:	2300      	moveq	r3, #0
 8014612:	f003 0301 	andne.w	r3, r3, #1
 8014616:	b11b      	cbz	r3, 8014620 <HAL_DMAEx_MultiBufferStart_IT+0x984>
 8014618:	4b3c      	ldr	r3, [pc, #240]	@ (801470c <HAL_DMAEx_MultiBufferStart_IT+0xa70>)
 801461a:	429c      	cmp	r4, r3
 801461c:	f040 82af 	bne.w	8014b7e <HAL_DMAEx_MultiBufferStart_IT+0xee2>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8014620:	4b3c      	ldr	r3, [pc, #240]	@ (8014714 <HAL_DMAEx_MultiBufferStart_IT+0xa78>)
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014622:	f44f 2180 	mov.w	r1, #262144	@ 0x40000
 8014626:	4a3a      	ldr	r2, [pc, #232]	@ (8014710 <HAL_DMAEx_MultiBufferStart_IT+0xa74>)
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8014628:	429c      	cmp	r4, r3
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 801462a:	6091      	str	r1, [r2, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 801462c:	f63f aedf 	bhi.w	80143ee <HAL_DMAEx_MultiBufferStart_IT+0x752>
 8014630:	4b3f      	ldr	r3, [pc, #252]	@ (8014730 <HAL_DMAEx_MultiBufferStart_IT+0xa94>)
 8014632:	429c      	cmp	r4, r3
 8014634:	f63f ae9c 	bhi.w	8014370 <HAL_DMAEx_MultiBufferStart_IT+0x6d4>
 8014638:	e44b      	b.n	8013ed2 <HAL_DMAEx_MultiBufferStart_IT+0x236>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 801463a:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 801463e:	60da      	str	r2, [r3, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8014640:	4b37      	ldr	r3, [pc, #220]	@ (8014720 <HAL_DMAEx_MultiBufferStart_IT+0xa84>)
 8014642:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8014646:	609a      	str	r2, [r3, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014648:	e749      	b.n	80144de <HAL_DMAEx_MultiBufferStart_IT+0x842>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 801464a:	f5a3 6382 	sub.w	r3, r3, #1040	@ 0x410
 801464e:	2220      	movs	r2, #32
 8014650:	609a      	str	r2, [r3, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8014652:	4b2f      	ldr	r3, [pc, #188]	@ (8014710 <HAL_DMAEx_MultiBufferStart_IT+0xa74>)
 8014654:	2210      	movs	r2, #16
 8014656:	609a      	str	r2, [r3, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8014658:	e59c      	b.n	8014194 <HAL_DMAEx_MultiBufferStart_IT+0x4f8>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 801465a:	f5a3 6382 	sub.w	r3, r3, #1040	@ 0x410
 801465e:	2220      	movs	r2, #32
 8014660:	60da      	str	r2, [r3, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8014662:	e7f6      	b.n	8014652 <HAL_DMAEx_MultiBufferStart_IT+0x9b6>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8014664:	4b2a      	ldr	r3, [pc, #168]	@ (8014710 <HAL_DMAEx_MultiBufferStart_IT+0xa74>)
 8014666:	2220      	movs	r2, #32
 8014668:	609a      	str	r2, [r3, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 801466a:	4b29      	ldr	r3, [pc, #164]	@ (8014710 <HAL_DMAEx_MultiBufferStart_IT+0xa74>)
 801466c:	2210      	movs	r2, #16
 801466e:	60da      	str	r2, [r3, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8014670:	f7ff bb66 	b.w	8013d40 <HAL_DMAEx_MultiBufferStart_IT+0xa4>
 8014674:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8014678:	60d3      	str	r3, [r2, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 801467a:	4b28      	ldr	r3, [pc, #160]	@ (801471c <HAL_DMAEx_MultiBufferStart_IT+0xa80>)
 801467c:	429c      	cmp	r4, r3
 801467e:	f43f af2e 	beq.w	80144de <HAL_DMAEx_MultiBufferStart_IT+0x842>
 8014682:	4b28      	ldr	r3, [pc, #160]	@ (8014724 <HAL_DMAEx_MultiBufferStart_IT+0xa88>)
 8014684:	429c      	cmp	r4, r3
 8014686:	f000 8189 	beq.w	801499c <HAL_DMAEx_MultiBufferStart_IT+0xd00>
 801468a:	4b27      	ldr	r3, [pc, #156]	@ (8014728 <HAL_DMAEx_MultiBufferStart_IT+0xa8c>)
 801468c:	429c      	cmp	r4, r3
 801468e:	f000 819b 	beq.w	80149c8 <HAL_DMAEx_MultiBufferStart_IT+0xd2c>
 8014692:	4b26      	ldr	r3, [pc, #152]	@ (801472c <HAL_DMAEx_MultiBufferStart_IT+0xa90>)
 8014694:	429c      	cmp	r4, r3
 8014696:	f000 82be 	beq.w	8014c16 <HAL_DMAEx_MultiBufferStart_IT+0xf7a>
 801469a:	4b19      	ldr	r3, [pc, #100]	@ (8014700 <HAL_DMAEx_MultiBufferStart_IT+0xa64>)
 801469c:	4919      	ldr	r1, [pc, #100]	@ (8014704 <HAL_DMAEx_MultiBufferStart_IT+0xa68>)
 801469e:	4a1a      	ldr	r2, [pc, #104]	@ (8014708 <HAL_DMAEx_MultiBufferStart_IT+0xa6c>)
 80146a0:	429c      	cmp	r4, r3
 80146a2:	bf18      	it	ne
 80146a4:	428c      	cmpne	r4, r1
 80146a6:	bf14      	ite	ne
 80146a8:	2301      	movne	r3, #1
 80146aa:	2300      	moveq	r3, #0
 80146ac:	4294      	cmp	r4, r2
 80146ae:	bf0c      	ite	eq
 80146b0:	2300      	moveq	r3, #0
 80146b2:	f003 0301 	andne.w	r3, r3, #1
 80146b6:	b11b      	cbz	r3, 80146c0 <HAL_DMAEx_MultiBufferStart_IT+0xa24>
 80146b8:	4b14      	ldr	r3, [pc, #80]	@ (801470c <HAL_DMAEx_MultiBufferStart_IT+0xa70>)
 80146ba:	429c      	cmp	r4, r3
 80146bc:	f040 82b2 	bne.w	8014c24 <HAL_DMAEx_MultiBufferStart_IT+0xf88>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 80146c0:	4b14      	ldr	r3, [pc, #80]	@ (8014714 <HAL_DMAEx_MultiBufferStart_IT+0xa78>)
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 80146c2:	f44f 2180 	mov.w	r1, #262144	@ 0x40000
 80146c6:	4a16      	ldr	r2, [pc, #88]	@ (8014720 <HAL_DMAEx_MultiBufferStart_IT+0xa84>)
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 80146c8:	429c      	cmp	r4, r3
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 80146ca:	6091      	str	r1, [r2, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 80146cc:	f63f ae8f 	bhi.w	80143ee <HAL_DMAEx_MultiBufferStart_IT+0x752>
 80146d0:	f5a3 7368 	sub.w	r3, r3, #928	@ 0x3a0
 80146d4:	429c      	cmp	r4, r3
 80146d6:	f63f ae5e 	bhi.w	8014396 <HAL_DMAEx_MultiBufferStart_IT+0x6fa>
 80146da:	3b60      	subs	r3, #96	@ 0x60
 80146dc:	429c      	cmp	r4, r3
 80146de:	f63f ac24 	bhi.w	8013f2a <HAL_DMAEx_MultiBufferStart_IT+0x28e>
 80146e2:	e728      	b.n	8014536 <HAL_DMAEx_MultiBufferStart_IT+0x89a>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 80146e4:	2120      	movs	r1, #32
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 80146e6:	2210      	movs	r2, #16
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 80146e8:	f843 1c64 	str.w	r1, [r3, #-100]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 80146ec:	f843 2c64 	str.w	r2, [r3, #-100]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 80146f0:	e60c      	b.n	801430c <HAL_DMAEx_MultiBufferStart_IT+0x670>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 80146f2:	2120      	movs	r1, #32
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 80146f4:	2210      	movs	r2, #16
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 80146f6:	f843 1c68 	str.w	r1, [r3, #-104]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 80146fa:	f843 2c64 	str.w	r2, [r3, #-100]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 80146fe:	e605      	b.n	801430c <HAL_DMAEx_MultiBufferStart_IT+0x670>
 8014700:	40026440 	.word	0x40026440
 8014704:	40026040 	.word	0x40026040
 8014708:	400260a0 	.word	0x400260a0
 801470c:	400264a0 	.word	0x400264a0
 8014710:	40026400 	.word	0x40026400
 8014714:	40026458 	.word	0x40026458
 8014718:	40026470 	.word	0x40026470
 801471c:	40026028 	.word	0x40026028
 8014720:	40026000 	.word	0x40026000
 8014724:	40026428 	.word	0x40026428
 8014728:	40026088 	.word	0x40026088
 801472c:	40026488 	.word	0x40026488
 8014730:	400260b8 	.word	0x400260b8
 8014734:	40026410 	.word	0x40026410
 8014738:	40026070 	.word	0x40026070
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 801473c:	4bb4      	ldr	r3, [pc, #720]	@ (8014a10 <HAL_DMAEx_MultiBufferStart_IT+0xd74>)
 801473e:	f44f 6200 	mov.w	r2, #2048	@ 0x800
 8014742:	609a      	str	r2, [r3, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8014744:	4bb3      	ldr	r3, [pc, #716]	@ (8014a14 <HAL_DMAEx_MultiBufferStart_IT+0xd78>)
 8014746:	f44f 6180 	mov.w	r1, #1024	@ 0x400
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 801474a:	f44f 7200 	mov.w	r2, #512	@ 0x200
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 801474e:	6099      	str	r1, [r3, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8014750:	609a      	str	r2, [r3, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014752:	e6c4      	b.n	80144de <HAL_DMAEx_MultiBufferStart_IT+0x842>
 8014754:	4bb0      	ldr	r3, [pc, #704]	@ (8014a18 <HAL_DMAEx_MultiBufferStart_IT+0xd7c>)
 8014756:	429c      	cmp	r4, r3
 8014758:	f000 831e 	beq.w	8014d98 <HAL_DMAEx_MultiBufferStart_IT+0x10fc>
 801475c:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8014760:	429c      	cmp	r4, r3
 8014762:	f000 8319 	beq.w	8014d98 <HAL_DMAEx_MultiBufferStart_IT+0x10fc>
 8014766:	f5a3 7368 	sub.w	r3, r3, #928	@ 0x3a0
 801476a:	429c      	cmp	r4, r3
 801476c:	f000 82e7 	beq.w	8014d3e <HAL_DMAEx_MultiBufferStart_IT+0x10a2>
 8014770:	4baa      	ldr	r3, [pc, #680]	@ (8014a1c <HAL_DMAEx_MultiBufferStart_IT+0xd80>)
 8014772:	429c      	cmp	r4, r3
 8014774:	f43f aae7 	beq.w	8013d46 <HAL_DMAEx_MultiBufferStart_IT+0xaa>
 8014778:	4ba9      	ldr	r3, [pc, #676]	@ (8014a20 <HAL_DMAEx_MultiBufferStart_IT+0xd84>)
 801477a:	429c      	cmp	r4, r3
 801477c:	d048      	beq.n	8014810 <HAL_DMAEx_MultiBufferStart_IT+0xb74>
 801477e:	f5a3 7368 	sub.w	r3, r3, #928	@ 0x3a0
 8014782:	429c      	cmp	r4, r3
 8014784:	f47f ad8b 	bne.w	801429e <HAL_DMAEx_MultiBufferStart_IT+0x602>
 8014788:	4ba1      	ldr	r3, [pc, #644]	@ (8014a10 <HAL_DMAEx_MultiBufferStart_IT+0xd74>)
 801478a:	f44f 7280 	mov.w	r2, #256	@ 0x100
 801478e:	60da      	str	r2, [r3, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8014790:	2240      	movs	r2, #64	@ 0x40
 8014792:	f7ff bbcc 	b.w	8013f2e <HAL_DMAEx_MultiBufferStart_IT+0x292>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8014796:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 801479a:	60da      	str	r2, [r3, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 801479c:	4b9c      	ldr	r3, [pc, #624]	@ (8014a10 <HAL_DMAEx_MultiBufferStart_IT+0xd74>)
 801479e:	f44f 7200 	mov.w	r2, #512	@ 0x200
 80147a2:	609a      	str	r2, [r3, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 80147a4:	4b9a      	ldr	r3, [pc, #616]	@ (8014a10 <HAL_DMAEx_MultiBufferStart_IT+0xd74>)
 80147a6:	f44f 7280 	mov.w	r2, #256	@ 0x100
 80147aa:	609a      	str	r2, [r3, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 80147ac:	2240      	movs	r2, #64	@ 0x40
 80147ae:	e4f8      	b.n	80141a2 <HAL_DMAEx_MultiBufferStart_IT+0x506>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 80147b0:	f5a3 6394 	sub.w	r3, r3, #1184	@ 0x4a0
 80147b4:	f04f 6200 	mov.w	r2, #134217728	@ 0x8000000
 80147b8:	60da      	str	r2, [r3, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 80147ba:	e49b      	b.n	80140f4 <HAL_DMAEx_MultiBufferStart_IT+0x458>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 80147bc:	f5a3 638e 	sub.w	r3, r3, #1136	@ 0x470
 80147c0:	2220      	movs	r2, #32
 80147c2:	609a      	str	r2, [r3, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 80147c4:	e751      	b.n	801466a <HAL_DMAEx_MultiBufferStart_IT+0x9ce>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 80147c6:	4b92      	ldr	r3, [pc, #584]	@ (8014a10 <HAL_DMAEx_MultiBufferStart_IT+0xd74>)
 80147c8:	f44f 6200 	mov.w	r2, #2048	@ 0x800
 80147cc:	609a      	str	r2, [r3, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 80147ce:	4b90      	ldr	r3, [pc, #576]	@ (8014a10 <HAL_DMAEx_MultiBufferStart_IT+0xd74>)
 80147d0:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 80147d4:	609a      	str	r2, [r3, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 80147d6:	e7e1      	b.n	801479c <HAL_DMAEx_MultiBufferStart_IT+0xb00>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 80147d8:	4a8f      	ldr	r2, [pc, #572]	@ (8014a18 <HAL_DMAEx_MultiBufferStart_IT+0xd7c>)
 80147da:	4294      	cmp	r4, r2
 80147dc:	f000 8167 	beq.w	8014aae <HAL_DMAEx_MultiBufferStart_IT+0xe12>
 80147e0:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 80147e4:	4294      	cmp	r4, r2
 80147e6:	f000 8162 	beq.w	8014aae <HAL_DMAEx_MultiBufferStart_IT+0xe12>
 80147ea:	f5a2 7268 	sub.w	r2, r2, #928	@ 0x3a0
 80147ee:	4294      	cmp	r4, r2
 80147f0:	f000 815d 	beq.w	8014aae <HAL_DMAEx_MultiBufferStart_IT+0xe12>
 80147f4:	4b89      	ldr	r3, [pc, #548]	@ (8014a1c <HAL_DMAEx_MultiBufferStart_IT+0xd80>)
 80147f6:	429c      	cmp	r4, r3
 80147f8:	f43f aaa5 	beq.w	8013d46 <HAL_DMAEx_MultiBufferStart_IT+0xaa>
 80147fc:	f5a3 6389 	sub.w	r3, r3, #1096	@ 0x448
 8014800:	429c      	cmp	r4, r3
 8014802:	f000 8261 	beq.w	8014cc8 <HAL_DMAEx_MultiBufferStart_IT+0x102c>
 8014806:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 801480a:	429c      	cmp	r4, r3
 801480c:	f47f ad43 	bne.w	8014296 <HAL_DMAEx_MultiBufferStart_IT+0x5fa>
 8014810:	4b7f      	ldr	r3, [pc, #508]	@ (8014a10 <HAL_DMAEx_MultiBufferStart_IT+0xd74>)
 8014812:	f44f 7280 	mov.w	r2, #256	@ 0x100
 8014816:	60da      	str	r2, [r3, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8014818:	e595      	b.n	8014346 <HAL_DMAEx_MultiBufferStart_IT+0x6aa>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 801481a:	f5a3 638e 	sub.w	r3, r3, #1136	@ 0x470
 801481e:	2220      	movs	r2, #32
 8014820:	60da      	str	r2, [r3, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8014822:	e722      	b.n	801466a <HAL_DMAEx_MultiBufferStart_IT+0x9ce>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8014824:	4b7a      	ldr	r3, [pc, #488]	@ (8014a10 <HAL_DMAEx_MultiBufferStart_IT+0xd74>)
 8014826:	f04f 6200 	mov.w	r2, #134217728	@ 0x8000000
 801482a:	60da      	str	r2, [r3, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 801482c:	4b7d      	ldr	r3, [pc, #500]	@ (8014a24 <HAL_DMAEx_MultiBufferStart_IT+0xd88>)
 801482e:	429c      	cmp	r4, r3
 8014830:	f47f ae27 	bne.w	8014482 <HAL_DMAEx_MultiBufferStart_IT+0x7e6>
 8014834:	e4e3      	b.n	80141fe <HAL_DMAEx_MultiBufferStart_IT+0x562>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8014836:	f5a3 6394 	sub.w	r3, r3, #1184	@ 0x4a0
 801483a:	f04f 6200 	mov.w	r2, #134217728	@ 0x8000000
 801483e:	609a      	str	r2, [r3, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8014840:	f7ff bbd9 	b.w	8013ff6 <HAL_DMAEx_MultiBufferStart_IT+0x35a>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8014844:	4b77      	ldr	r3, [pc, #476]	@ (8014a24 <HAL_DMAEx_MultiBufferStart_IT+0xd88>)
 8014846:	429c      	cmp	r4, r3
 8014848:	f000 81de 	beq.w	8014c08 <HAL_DMAEx_MultiBufferStart_IT+0xf6c>
 801484c:	4b76      	ldr	r3, [pc, #472]	@ (8014a28 <HAL_DMAEx_MultiBufferStart_IT+0xd8c>)
 801484e:	4977      	ldr	r1, [pc, #476]	@ (8014a2c <HAL_DMAEx_MultiBufferStart_IT+0xd90>)
 8014850:	4a77      	ldr	r2, [pc, #476]	@ (8014a30 <HAL_DMAEx_MultiBufferStart_IT+0xd94>)
 8014852:	429c      	cmp	r4, r3
 8014854:	bf18      	it	ne
 8014856:	428c      	cmpne	r4, r1
 8014858:	bf14      	ite	ne
 801485a:	2301      	movne	r3, #1
 801485c:	2300      	moveq	r3, #0
 801485e:	4294      	cmp	r4, r2
 8014860:	bf0c      	ite	eq
 8014862:	2300      	moveq	r3, #0
 8014864:	f003 0301 	andne.w	r3, r3, #1
 8014868:	b11b      	cbz	r3, 8014872 <HAL_DMAEx_MultiBufferStart_IT+0xbd6>
 801486a:	4b72      	ldr	r3, [pc, #456]	@ (8014a34 <HAL_DMAEx_MultiBufferStart_IT+0xd98>)
 801486c:	429c      	cmp	r4, r3
 801486e:	f040 8216 	bne.w	8014c9e <HAL_DMAEx_MultiBufferStart_IT+0x1002>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014872:	4b71      	ldr	r3, [pc, #452]	@ (8014a38 <HAL_DMAEx_MultiBufferStart_IT+0xd9c>)
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8014874:	f44f 2100 	mov.w	r1, #524288	@ 0x80000
 8014878:	4a66      	ldr	r2, [pc, #408]	@ (8014a14 <HAL_DMAEx_MultiBufferStart_IT+0xd78>)
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 801487a:	429c      	cmp	r4, r3
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 801487c:	60d1      	str	r1, [r2, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 801487e:	f63f ad0a 	bhi.w	8014296 <HAL_DMAEx_MultiBufferStart_IT+0x5fa>
 8014882:	f5a3 7368 	sub.w	r3, r3, #928	@ 0x3a0
 8014886:	429c      	cmp	r4, r3
 8014888:	f63f aeaa 	bhi.w	80145e0 <HAL_DMAEx_MultiBufferStart_IT+0x944>
 801488c:	3b60      	subs	r3, #96	@ 0x60
 801488e:	429c      	cmp	r4, r3
 8014890:	f63f aafb 	bhi.w	8013e8a <HAL_DMAEx_MultiBufferStart_IT+0x1ee>
 8014894:	e6f9      	b.n	801468a <HAL_DMAEx_MultiBufferStart_IT+0x9ee>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8014896:	4b5f      	ldr	r3, [pc, #380]	@ (8014a14 <HAL_DMAEx_MultiBufferStart_IT+0xd78>)
 8014898:	2208      	movs	r2, #8
 801489a:	60da      	str	r2, [r3, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 801489c:	f7ff ba53 	b.w	8013d46 <HAL_DMAEx_MultiBufferStart_IT+0xaa>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 80148a0:	4a5b      	ldr	r2, [pc, #364]	@ (8014a10 <HAL_DMAEx_MultiBufferStart_IT+0xd74>)
 80148a2:	f44f 6100 	mov.w	r1, #2048	@ 0x800
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 80148a6:	4b5b      	ldr	r3, [pc, #364]	@ (8014a14 <HAL_DMAEx_MultiBufferStart_IT+0xd78>)
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 80148a8:	6091      	str	r1, [r2, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 80148aa:	f44f 6180 	mov.w	r1, #1024	@ 0x400
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 80148ae:	f44f 7200 	mov.w	r2, #512	@ 0x200
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 80148b2:	60d9      	str	r1, [r3, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 80148b4:	60da      	str	r2, [r3, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 80148b6:	4b57      	ldr	r3, [pc, #348]	@ (8014a14 <HAL_DMAEx_MultiBufferStart_IT+0xd78>)
 80148b8:	f44f 7280 	mov.w	r2, #256	@ 0x100
 80148bc:	60da      	str	r2, [r3, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 80148be:	e767      	b.n	8014790 <HAL_DMAEx_MultiBufferStart_IT+0xaf4>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 80148c0:	4b53      	ldr	r3, [pc, #332]	@ (8014a10 <HAL_DMAEx_MultiBufferStart_IT+0xd74>)
 80148c2:	f44f 7280 	mov.w	r2, #256	@ 0x100
 80148c6:	609a      	str	r2, [r3, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 80148c8:	e762      	b.n	8014790 <HAL_DMAEx_MultiBufferStart_IT+0xaf4>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 80148ca:	f44f 6200 	mov.w	r2, #2048	@ 0x800
 80148ce:	f843 2c20 	str.w	r2, [r3, #-32]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 80148d2:	e737      	b.n	8014744 <HAL_DMAEx_MultiBufferStart_IT+0xaa8>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 80148d4:	f44f 6200 	mov.w	r2, #2048	@ 0x800
 80148d8:	f843 2c1c 	str.w	r2, [r3, #-28]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 80148dc:	e732      	b.n	8014744 <HAL_DMAEx_MultiBufferStart_IT+0xaa8>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 80148de:	f44f 7200 	mov.w	r2, #512	@ 0x200
 80148e2:	f8c3 2380 	str.w	r2, [r3, #896]	@ 0x380
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 80148e6:	e7e6      	b.n	80148b6 <HAL_DMAEx_MultiBufferStart_IT+0xc1a>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 80148e8:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 80148ec:	60da      	str	r2, [r3, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 80148ee:	4b53      	ldr	r3, [pc, #332]	@ (8014a3c <HAL_DMAEx_MultiBufferStart_IT+0xda0>)
 80148f0:	429c      	cmp	r4, r3
 80148f2:	d1a7      	bne.n	8014844 <HAL_DMAEx_MultiBufferStart_IT+0xba8>
 80148f4:	f44f 7200 	mov.w	r2, #512	@ 0x200
 80148f8:	f843 2c7c 	str.w	r2, [r3, #-124]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 80148fc:	e7db      	b.n	80148b6 <HAL_DMAEx_MultiBufferStart_IT+0xc1a>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 80148fe:	f44f 0280 	mov.w	r2, #4194304	@ 0x400000
 8014902:	f7ff ba24 	b.w	8013d4e <HAL_DMAEx_MultiBufferStart_IT+0xb2>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8014906:	4b42      	ldr	r3, [pc, #264]	@ (8014a10 <HAL_DMAEx_MultiBufferStart_IT+0xd74>)
 8014908:	2208      	movs	r2, #8
 801490a:	609a      	str	r2, [r3, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 801490c:	f7ff ba1b 	b.w	8013d46 <HAL_DMAEx_MultiBufferStart_IT+0xaa>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8014910:	4b3f      	ldr	r3, [pc, #252]	@ (8014a10 <HAL_DMAEx_MultiBufferStart_IT+0xd74>)
 8014912:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8014916:	609a      	str	r2, [r3, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014918:	e5e1      	b.n	80144de <HAL_DMAEx_MultiBufferStart_IT+0x842>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 801491a:	4b3d      	ldr	r3, [pc, #244]	@ (8014a10 <HAL_DMAEx_MultiBufferStart_IT+0xd74>)
 801491c:	2208      	movs	r2, #8
 801491e:	609a      	str	r2, [r3, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014920:	e4f7      	b.n	8014312 <HAL_DMAEx_MultiBufferStart_IT+0x676>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8014922:	4b47      	ldr	r3, [pc, #284]	@ (8014a40 <HAL_DMAEx_MultiBufferStart_IT+0xda4>)
 8014924:	429c      	cmp	r4, r3
 8014926:	d91f      	bls.n	8014968 <HAL_DMAEx_MultiBufferStart_IT+0xccc>
 8014928:	4b3b      	ldr	r3, [pc, #236]	@ (8014a18 <HAL_DMAEx_MultiBufferStart_IT+0xd7c>)
 801492a:	429c      	cmp	r4, r3
 801492c:	f43f acf4 	beq.w	8014318 <HAL_DMAEx_MultiBufferStart_IT+0x67c>
 8014930:	4a44      	ldr	r2, [pc, #272]	@ (8014a44 <HAL_DMAEx_MultiBufferStart_IT+0xda8>)
 8014932:	4b45      	ldr	r3, [pc, #276]	@ (8014a48 <HAL_DMAEx_MultiBufferStart_IT+0xdac>)
 8014934:	4294      	cmp	r4, r2
 8014936:	bf18      	it	ne
 8014938:	429c      	cmpne	r4, r3
 801493a:	f43f aced 	beq.w	8014318 <HAL_DMAEx_MultiBufferStart_IT+0x67c>
 801493e:	3360      	adds	r3, #96	@ 0x60
 8014940:	429c      	cmp	r4, r3
 8014942:	f47f aaca 	bne.w	8013eda <HAL_DMAEx_MultiBufferStart_IT+0x23e>
 8014946:	e4e7      	b.n	8014318 <HAL_DMAEx_MultiBufferStart_IT+0x67c>
 8014948:	3b48      	subs	r3, #72	@ 0x48
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 801494a:	f04f 7180 	mov.w	r1, #16777216	@ 0x1000000
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 801494e:	429c      	cmp	r4, r3
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014950:	f842 1c94 	str.w	r1, [r2, #-148]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8014954:	f200 812e 	bhi.w	8014bb4 <HAL_DMAEx_MultiBufferStart_IT+0xf18>
 8014958:	f5a3 7368 	sub.w	r3, r3, #928	@ 0x3a0
 801495c:	429c      	cmp	r4, r3
 801495e:	f63f ace1 	bhi.w	8014324 <HAL_DMAEx_MultiBufferStart_IT+0x688>
 8014962:	4b37      	ldr	r3, [pc, #220]	@ (8014a40 <HAL_DMAEx_MultiBufferStart_IT+0xda4>)
 8014964:	429c      	cmp	r4, r3
 8014966:	d8e3      	bhi.n	8014930 <HAL_DMAEx_MultiBufferStart_IT+0xc94>
 8014968:	4b2b      	ldr	r3, [pc, #172]	@ (8014a18 <HAL_DMAEx_MultiBufferStart_IT+0xd7c>)
 801496a:	429c      	cmp	r4, r3
 801496c:	f43f ac86 	beq.w	801427c <HAL_DMAEx_MultiBufferStart_IT+0x5e0>
 8014970:	4a34      	ldr	r2, [pc, #208]	@ (8014a44 <HAL_DMAEx_MultiBufferStart_IT+0xda8>)
 8014972:	4b35      	ldr	r3, [pc, #212]	@ (8014a48 <HAL_DMAEx_MultiBufferStart_IT+0xdac>)
 8014974:	4294      	cmp	r4, r2
 8014976:	bf18      	it	ne
 8014978:	429c      	cmpne	r4, r3
 801497a:	f43f ac7f 	beq.w	801427c <HAL_DMAEx_MultiBufferStart_IT+0x5e0>
 801497e:	3360      	adds	r3, #96	@ 0x60
 8014980:	429c      	cmp	r4, r3
 8014982:	f43f ac7b 	beq.w	801427c <HAL_DMAEx_MultiBufferStart_IT+0x5e0>
 8014986:	e5ae      	b.n	80144e6 <HAL_DMAEx_MultiBufferStart_IT+0x84a>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8014988:	4b22      	ldr	r3, [pc, #136]	@ (8014a14 <HAL_DMAEx_MultiBufferStart_IT+0xd78>)
 801498a:	f44f 6200 	mov.w	r2, #2048	@ 0x800
 801498e:	60da      	str	r2, [r3, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8014990:	e71d      	b.n	80147ce <HAL_DMAEx_MultiBufferStart_IT+0xb32>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8014992:	4b20      	ldr	r3, [pc, #128]	@ (8014a14 <HAL_DMAEx_MultiBufferStart_IT+0xd78>)
 8014994:	f44f 6200 	mov.w	r2, #2048	@ 0x800
 8014998:	609a      	str	r2, [r3, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 801499a:	e718      	b.n	80147ce <HAL_DMAEx_MultiBufferStart_IT+0xb32>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 801499c:	4b1d      	ldr	r3, [pc, #116]	@ (8014a14 <HAL_DMAEx_MultiBufferStart_IT+0xd78>)
 801499e:	f44f 7280 	mov.w	r2, #256	@ 0x100
 80149a2:	609a      	str	r2, [r3, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 80149a4:	e702      	b.n	80147ac <HAL_DMAEx_MultiBufferStart_IT+0xb10>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 80149a6:	f44f 6200 	mov.w	r2, #2048	@ 0x800
 80149aa:	f843 2c80 	str.w	r2, [r3, #-128]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 80149ae:	e73d      	b.n	801482c <HAL_DMAEx_MultiBufferStart_IT+0xb90>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 80149b0:	f5a3 6385 	sub.w	r3, r3, #1064	@ 0x428
 80149b4:	f44f 7200 	mov.w	r2, #512	@ 0x200
 80149b8:	609a      	str	r2, [r3, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 80149ba:	e6f3      	b.n	80147a4 <HAL_DMAEx_MultiBufferStart_IT+0xb08>
 80149bc:	f44f 7280 	mov.w	r2, #256	@ 0x100
 80149c0:	f843 2c80 	str.w	r2, [r3, #-128]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 80149c4:	f7ff bbce 	b.w	8014164 <HAL_DMAEx_MultiBufferStart_IT+0x4c8>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 80149c8:	f44f 7280 	mov.w	r2, #256	@ 0x100
 80149cc:	f843 2c80 	str.w	r2, [r3, #-128]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 80149d0:	e6de      	b.n	8014790 <HAL_DMAEx_MultiBufferStart_IT+0xaf4>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 80149d2:	f44f 6280 	mov.w	r2, #1024	@ 0x400
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 80149d6:	f44f 6100 	mov.w	r1, #2048	@ 0x800
 80149da:	f843 1c7c 	str.w	r1, [r3, #-124]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 80149de:	f843 2c7c 	str.w	r2, [r3, #-124]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 80149e2:	f44f 7200 	mov.w	r2, #512	@ 0x200
 80149e6:	f843 2c7c 	str.w	r2, [r3, #-124]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 80149ea:	e764      	b.n	80148b6 <HAL_DMAEx_MultiBufferStart_IT+0xc1a>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 80149ec:	f44f 6280 	mov.w	r2, #1024	@ 0x400
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 80149f0:	f44f 6100 	mov.w	r1, #2048	@ 0x800
 80149f4:	f843 1c80 	str.w	r1, [r3, #-128]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 80149f8:	f843 2c7c 	str.w	r2, [r3, #-124]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 80149fc:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8014a00:	f843 2c7c 	str.w	r2, [r3, #-124]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014a04:	e757      	b.n	80148b6 <HAL_DMAEx_MultiBufferStart_IT+0xc1a>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8014a06:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8014a0a:	f843 2c80 	str.w	r2, [r3, #-128]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014a0e:	e752      	b.n	80148b6 <HAL_DMAEx_MultiBufferStart_IT+0xc1a>
 8014a10:	40026400 	.word	0x40026400
 8014a14:	40026000 	.word	0x40026000
 8014a18:	40026010 	.word	0x40026010
 8014a1c:	40026470 	.word	0x40026470
 8014a20:	40026428 	.word	0x40026428
 8014a24:	40026488 	.word	0x40026488
 8014a28:	40026440 	.word	0x40026440
 8014a2c:	40026040 	.word	0x40026040
 8014a30:	400260a0 	.word	0x400260a0
 8014a34:	400264a0 	.word	0x400264a0
 8014a38:	40026458 	.word	0x40026458
 8014a3c:	40026088 	.word	0x40026088
 8014a40:	40026058 	.word	0x40026058
 8014a44:	40026070 	.word	0x40026070
 8014a48:	40026410 	.word	0x40026410
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8014a4c:	f04f 6280 	mov.w	r2, #67108864	@ 0x4000000
 8014a50:	f843 2c98 	str.w	r2, [r3, #-152]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8014a54:	e593      	b.n	801457e <HAL_DMAEx_MultiBufferStart_IT+0x8e2>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014a56:	f502 726e 	add.w	r2, r2, #952	@ 0x3b8
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8014a5a:	3ba0      	subs	r3, #160	@ 0xa0
 8014a5c:	f04f 7100 	mov.w	r1, #33554432	@ 0x2000000
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014a60:	4294      	cmp	r4, r2
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8014a62:	6099      	str	r1, [r3, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014a64:	f63f aeb8 	bhi.w	80147d8 <HAL_DMAEx_MultiBufferStart_IT+0xb3c>
 8014a68:	f5a3 7352 	sub.w	r3, r3, #840	@ 0x348
 8014a6c:	429c      	cmp	r4, r3
 8014a6e:	d912      	bls.n	8014a96 <HAL_DMAEx_MultiBufferStart_IT+0xdfa>
 8014a70:	4bb5      	ldr	r3, [pc, #724]	@ (8014d48 <HAL_DMAEx_MultiBufferStart_IT+0x10ac>)
 8014a72:	429c      	cmp	r4, r3
 8014a74:	f43f ab91 	beq.w	801419a <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
 8014a78:	4bb4      	ldr	r3, [pc, #720]	@ (8014d4c <HAL_DMAEx_MultiBufferStart_IT+0x10b0>)
 8014a7a:	429c      	cmp	r4, r3
 8014a7c:	d03a      	beq.n	8014af4 <HAL_DMAEx_MultiBufferStart_IT+0xe58>
 8014a7e:	4bb4      	ldr	r3, [pc, #720]	@ (8014d50 <HAL_DMAEx_MultiBufferStart_IT+0x10b4>)
 8014a80:	429c      	cmp	r4, r3
 8014a82:	d018      	beq.n	8014ab6 <HAL_DMAEx_MultiBufferStart_IT+0xe1a>
 8014a84:	4bb3      	ldr	r3, [pc, #716]	@ (8014d54 <HAL_DMAEx_MultiBufferStart_IT+0x10b8>)
 8014a86:	429c      	cmp	r4, r3
 8014a88:	f47f adaa 	bne.w	80145e0 <HAL_DMAEx_MultiBufferStart_IT+0x944>
 8014a8c:	4bb2      	ldr	r3, [pc, #712]	@ (8014d58 <HAL_DMAEx_MultiBufferStart_IT+0x10bc>)
 8014a8e:	f44f 7280 	mov.w	r2, #256	@ 0x100
 8014a92:	609a      	str	r2, [r3, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8014a94:	e527      	b.n	80144e6 <HAL_DMAEx_MultiBufferStart_IT+0x84a>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014a96:	4bb1      	ldr	r3, [pc, #708]	@ (8014d5c <HAL_DMAEx_MultiBufferStart_IT+0x10c0>)
 8014a98:	429c      	cmp	r4, r3
 8014a9a:	d914      	bls.n	8014ac6 <HAL_DMAEx_MultiBufferStart_IT+0xe2a>
 8014a9c:	4bb0      	ldr	r3, [pc, #704]	@ (8014d60 <HAL_DMAEx_MultiBufferStart_IT+0x10c4>)
 8014a9e:	429c      	cmp	r4, r3
 8014aa0:	f43f ac2a 	beq.w	80142f8 <HAL_DMAEx_MultiBufferStart_IT+0x65c>
 8014aa4:	4ba8      	ldr	r3, [pc, #672]	@ (8014d48 <HAL_DMAEx_MultiBufferStart_IT+0x10ac>)
 8014aa6:	429c      	cmp	r4, r3
 8014aa8:	f47f ab62 	bne.w	8014170 <HAL_DMAEx_MultiBufferStart_IT+0x4d4>
 8014aac:	4bad      	ldr	r3, [pc, #692]	@ (8014d64 <HAL_DMAEx_MultiBufferStart_IT+0x10c8>)
 8014aae:	2204      	movs	r2, #4
 8014ab0:	60da      	str	r2, [r3, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8014ab2:	f7ff bb75 	b.w	80141a0 <HAL_DMAEx_MultiBufferStart_IT+0x504>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014ab6:	4ba8      	ldr	r3, [pc, #672]	@ (8014d58 <HAL_DMAEx_MultiBufferStart_IT+0x10bc>)
 8014ab8:	2204      	movs	r2, #4
 8014aba:	609a      	str	r2, [r3, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8014abc:	f7ff b946 	b.w	8013d4c <HAL_DMAEx_MultiBufferStart_IT+0xb0>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014ac0:	4ba6      	ldr	r3, [pc, #664]	@ (8014d5c <HAL_DMAEx_MultiBufferStart_IT+0x10c0>)
 8014ac2:	429c      	cmp	r4, r3
 8014ac4:	d8ee      	bhi.n	8014aa4 <HAL_DMAEx_MultiBufferStart_IT+0xe08>
 8014ac6:	4ba6      	ldr	r3, [pc, #664]	@ (8014d60 <HAL_DMAEx_MultiBufferStart_IT+0x10c4>)
 8014ac8:	429c      	cmp	r4, r3
 8014aca:	d026      	beq.n	8014b1a <HAL_DMAEx_MultiBufferStart_IT+0xe7e>
 8014acc:	4b9e      	ldr	r3, [pc, #632]	@ (8014d48 <HAL_DMAEx_MultiBufferStart_IT+0x10ac>)
 8014ace:	429c      	cmp	r4, r3
 8014ad0:	d104      	bne.n	8014adc <HAL_DMAEx_MultiBufferStart_IT+0xe40>
 8014ad2:	4ba4      	ldr	r3, [pc, #656]	@ (8014d64 <HAL_DMAEx_MultiBufferStart_IT+0x10c8>)
 8014ad4:	2204      	movs	r2, #4
 8014ad6:	609a      	str	r2, [r3, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8014ad8:	f7ff bb62 	b.w	80141a0 <HAL_DMAEx_MultiBufferStart_IT+0x504>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014adc:	4b9b      	ldr	r3, [pc, #620]	@ (8014d4c <HAL_DMAEx_MultiBufferStart_IT+0x10b0>)
 8014ade:	429c      	cmp	r4, r3
 8014ae0:	d00c      	beq.n	8014afc <HAL_DMAEx_MultiBufferStart_IT+0xe60>
 8014ae2:	4b9b      	ldr	r3, [pc, #620]	@ (8014d50 <HAL_DMAEx_MultiBufferStart_IT+0x10b4>)
 8014ae4:	429c      	cmp	r4, r3
 8014ae6:	f47f adc8 	bne.w	801467a <HAL_DMAEx_MultiBufferStart_IT+0x9de>
 8014aea:	4b9e      	ldr	r3, [pc, #632]	@ (8014d64 <HAL_DMAEx_MultiBufferStart_IT+0x10c8>)
 8014aec:	2204      	movs	r2, #4
 8014aee:	609a      	str	r2, [r3, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8014af0:	f7ff b92c 	b.w	8013d4c <HAL_DMAEx_MultiBufferStart_IT+0xb0>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014af4:	4b98      	ldr	r3, [pc, #608]	@ (8014d58 <HAL_DMAEx_MultiBufferStart_IT+0x10bc>)
 8014af6:	2204      	movs	r2, #4
 8014af8:	609a      	str	r2, [r3, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8014afa:	e40d      	b.n	8014318 <HAL_DMAEx_MultiBufferStart_IT+0x67c>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014afc:	4b99      	ldr	r3, [pc, #612]	@ (8014d64 <HAL_DMAEx_MultiBufferStart_IT+0x10c8>)
 8014afe:	2204      	movs	r2, #4
 8014b00:	609a      	str	r2, [r3, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8014b02:	e409      	b.n	8014318 <HAL_DMAEx_MultiBufferStart_IT+0x67c>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8014b04:	4b95      	ldr	r3, [pc, #596]	@ (8014d5c <HAL_DMAEx_MultiBufferStart_IT+0x10c0>)
 8014b06:	429c      	cmp	r4, r3
 8014b08:	f240 812e 	bls.w	8014d68 <HAL_DMAEx_MultiBufferStart_IT+0x10cc>
 8014b0c:	4b94      	ldr	r3, [pc, #592]	@ (8014d60 <HAL_DMAEx_MultiBufferStart_IT+0x10c4>)
 8014b0e:	429c      	cmp	r4, r3
 8014b10:	f040 80b3 	bne.w	8014c7a <HAL_DMAEx_MultiBufferStart_IT+0xfde>
 8014b14:	4b93      	ldr	r3, [pc, #588]	@ (8014d64 <HAL_DMAEx_MultiBufferStart_IT+0x10c8>)
 8014b16:	2208      	movs	r2, #8
 8014b18:	60da      	str	r2, [r3, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014b1a:	4b92      	ldr	r3, [pc, #584]	@ (8014d64 <HAL_DMAEx_MultiBufferStart_IT+0x10c8>)
 8014b1c:	2204      	movs	r2, #4
 8014b1e:	609a      	str	r2, [r3, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8014b20:	f7ff bbac 	b.w	801427c <HAL_DMAEx_MultiBufferStart_IT+0x5e0>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8014b24:	f5a3 6389 	sub.w	r3, r3, #1096	@ 0x448
 8014b28:	429c      	cmp	r4, r3
 8014b2a:	f000 80f0 	beq.w	8014d0e <HAL_DMAEx_MultiBufferStart_IT+0x1072>
 8014b2e:	4b87      	ldr	r3, [pc, #540]	@ (8014d4c <HAL_DMAEx_MultiBufferStart_IT+0x10b0>)
 8014b30:	429c      	cmp	r4, r3
 8014b32:	d014      	beq.n	8014b5e <HAL_DMAEx_MultiBufferStart_IT+0xec2>
 8014b34:	4b86      	ldr	r3, [pc, #536]	@ (8014d50 <HAL_DMAEx_MultiBufferStart_IT+0x10b4>)
 8014b36:	429c      	cmp	r4, r3
 8014b38:	f43f a902 	beq.w	8013d40 <HAL_DMAEx_MultiBufferStart_IT+0xa4>
 8014b3c:	4b85      	ldr	r3, [pc, #532]	@ (8014d54 <HAL_DMAEx_MultiBufferStart_IT+0x10b8>)
 8014b3e:	429c      	cmp	r4, r3
 8014b40:	f43f ad98 	beq.w	8014674 <HAL_DMAEx_MultiBufferStart_IT+0x9d8>
 8014b44:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8014b48:	429c      	cmp	r4, r3
 8014b4a:	d00c      	beq.n	8014b66 <HAL_DMAEx_MultiBufferStart_IT+0xeca>
 8014b4c:	f5a3 7368 	sub.w	r3, r3, #928	@ 0x3a0
 8014b50:	429c      	cmp	r4, r3
 8014b52:	d00c      	beq.n	8014b6e <HAL_DMAEx_MultiBufferStart_IT+0xed2>
 8014b54:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
 8014b58:	60d3      	str	r3, [r2, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014b5a:	f7ff bb9c 	b.w	8014296 <HAL_DMAEx_MultiBufferStart_IT+0x5fa>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8014b5e:	2308      	movs	r3, #8
 8014b60:	60d3      	str	r3, [r2, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014b62:	f7ff bbd6 	b.w	8014312 <HAL_DMAEx_MultiBufferStart_IT+0x676>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8014b66:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8014b6a:	60d3      	str	r3, [r2, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014b6c:	e78a      	b.n	8014a84 <HAL_DMAEx_MultiBufferStart_IT+0xde8>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8014b6e:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8014b72:	60d3      	str	r3, [r2, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014b74:	e69f      	b.n	80148b6 <HAL_DMAEx_MultiBufferStart_IT+0xc1a>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8014b76:	f44f 0280 	mov.w	r2, #4194304	@ 0x400000
 8014b7a:	f7ff bb12 	b.w	80141a2 <HAL_DMAEx_MultiBufferStart_IT+0x506>
 8014b7e:	3b48      	subs	r3, #72	@ 0x48
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014b80:	f04f 7180 	mov.w	r1, #16777216	@ 0x1000000
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8014b84:	429c      	cmp	r4, r3
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014b86:	f8c2 1368 	str.w	r1, [r2, #872]	@ 0x368
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8014b8a:	d813      	bhi.n	8014bb4 <HAL_DMAEx_MultiBufferStart_IT+0xf18>
 8014b8c:	f5a3 7368 	sub.w	r3, r3, #928	@ 0x3a0
 8014b90:	429c      	cmp	r4, r3
 8014b92:	f67f aec6 	bls.w	8014922 <HAL_DMAEx_MultiBufferStart_IT+0xc86>
 8014b96:	3ba8      	subs	r3, #168	@ 0xa8
 8014b98:	429c      	cmp	r4, r3
 8014b9a:	f43f ab01 	beq.w	80141a0 <HAL_DMAEx_MultiBufferStart_IT+0x504>
 8014b9e:	4b6b      	ldr	r3, [pc, #428]	@ (8014d4c <HAL_DMAEx_MultiBufferStart_IT+0x10b0>)
 8014ba0:	429c      	cmp	r4, r3
 8014ba2:	f43f aafd 	beq.w	80141a0 <HAL_DMAEx_MultiBufferStart_IT+0x504>
 8014ba6:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8014baa:	429c      	cmp	r4, r3
 8014bac:	f43f aaf8 	beq.w	80141a0 <HAL_DMAEx_MultiBufferStart_IT+0x504>
 8014bb0:	f7ff bbde 	b.w	8014370 <HAL_DMAEx_MultiBufferStart_IT+0x6d4>
 8014bb4:	4b64      	ldr	r3, [pc, #400]	@ (8014d48 <HAL_DMAEx_MultiBufferStart_IT+0x10ac>)
 8014bb6:	429c      	cmp	r4, r3
 8014bb8:	f43f a8c8 	beq.w	8013d4c <HAL_DMAEx_MultiBufferStart_IT+0xb0>
 8014bbc:	f5a3 6380 	sub.w	r3, r3, #1024	@ 0x400
 8014bc0:	429c      	cmp	r4, r3
 8014bc2:	f43f a8c3 	beq.w	8013d4c <HAL_DMAEx_MultiBufferStart_IT+0xb0>
 8014bc6:	4b61      	ldr	r3, [pc, #388]	@ (8014d4c <HAL_DMAEx_MultiBufferStart_IT+0x10b0>)
 8014bc8:	429c      	cmp	r4, r3
 8014bca:	f47f abf7 	bne.w	80143bc <HAL_DMAEx_MultiBufferStart_IT+0x720>
 8014bce:	f7ff b8bd 	b.w	8013d4c <HAL_DMAEx_MultiBufferStart_IT+0xb0>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8014bd2:	f04f 6200 	mov.w	r2, #134217728	@ 0x8000000
 8014bd6:	f843 2c98 	str.w	r2, [r3, #-152]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8014bda:	f7ff b917 	b.w	8013e0c <HAL_DMAEx_MultiBufferStart_IT+0x170>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8014bde:	f5a3 6391 	sub.w	r3, r3, #1160	@ 0x488
 8014be2:	f44f 6200 	mov.w	r2, #2048	@ 0x800
 8014be6:	60da      	str	r2, [r3, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8014be8:	f7ff bb09 	b.w	80141fe <HAL_DMAEx_MultiBufferStart_IT+0x562>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8014bec:	f5a3 6391 	sub.w	r3, r3, #1160	@ 0x488
 8014bf0:	f44f 6200 	mov.w	r2, #2048	@ 0x800
 8014bf4:	609a      	str	r2, [r3, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8014bf6:	f7ff bb02 	b.w	80141fe <HAL_DMAEx_MultiBufferStart_IT+0x562>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014bfa:	f5a3 6391 	sub.w	r3, r3, #1160	@ 0x488
 8014bfe:	f44f 7280 	mov.w	r2, #256	@ 0x100
 8014c02:	60da      	str	r2, [r3, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8014c04:	f7ff baae 	b.w	8014164 <HAL_DMAEx_MultiBufferStart_IT+0x4c8>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8014c08:	f5a3 6391 	sub.w	r3, r3, #1160	@ 0x488
 8014c0c:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8014c10:	60da      	str	r2, [r3, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014c12:	f7ff baa3 	b.w	801415c <HAL_DMAEx_MultiBufferStart_IT+0x4c0>
 8014c16:	f5a3 6391 	sub.w	r3, r3, #1160	@ 0x488
 8014c1a:	f44f 7280 	mov.w	r2, #256	@ 0x100
 8014c1e:	609a      	str	r2, [r3, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8014c20:	f7ff baa0 	b.w	8014164 <HAL_DMAEx_MultiBufferStart_IT+0x4c8>
 8014c24:	3b48      	subs	r3, #72	@ 0x48
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014c26:	f04f 7180 	mov.w	r1, #16777216	@ 0x1000000
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8014c2a:	429c      	cmp	r4, r3
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014c2c:	f842 1c98 	str.w	r1, [r2, #-152]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8014c30:	d8c0      	bhi.n	8014bb4 <HAL_DMAEx_MultiBufferStart_IT+0xf18>
 8014c32:	f5a3 7368 	sub.w	r3, r3, #928	@ 0x3a0
 8014c36:	429c      	cmp	r4, r3
 8014c38:	f63f ab74 	bhi.w	8014324 <HAL_DMAEx_MultiBufferStart_IT+0x688>
 8014c3c:	3b60      	subs	r3, #96	@ 0x60
 8014c3e:	429c      	cmp	r4, r3
 8014c40:	f63f ae72 	bhi.w	8014928 <HAL_DMAEx_MultiBufferStart_IT+0xc8c>
 8014c44:	4a40      	ldr	r2, [pc, #256]	@ (8014d48 <HAL_DMAEx_MultiBufferStart_IT+0x10ac>)
 8014c46:	4b41      	ldr	r3, [pc, #260]	@ (8014d4c <HAL_DMAEx_MultiBufferStart_IT+0x10b0>)
 8014c48:	4294      	cmp	r4, r2
 8014c4a:	bf18      	it	ne
 8014c4c:	429c      	cmpne	r4, r3
 8014c4e:	f43f ab15 	beq.w	801427c <HAL_DMAEx_MultiBufferStart_IT+0x5e0>
 8014c52:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8014c56:	429c      	cmp	r4, r3
 8014c58:	f43f ab10 	beq.w	801427c <HAL_DMAEx_MultiBufferStart_IT+0x5e0>
 8014c5c:	f44f 0280 	mov.w	r2, #4194304	@ 0x400000
 8014c60:	f7ff ba0d 	b.w	801407e <HAL_DMAEx_MultiBufferStart_IT+0x3e2>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8014c64:	f5a3 737a 	sub.w	r3, r3, #1000	@ 0x3e8
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8014c68:	f04f 6180 	mov.w	r1, #67108864	@ 0x4000000
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8014c6c:	429c      	cmp	r4, r3
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8014c6e:	f842 1c94 	str.w	r1, [r2, #-148]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8014c72:	d84f      	bhi.n	8014d14 <HAL_DMAEx_MultiBufferStart_IT+0x1078>
 8014c74:	4b39      	ldr	r3, [pc, #228]	@ (8014d5c <HAL_DMAEx_MultiBufferStart_IT+0x10c0>)
 8014c76:	429c      	cmp	r4, r3
 8014c78:	d976      	bls.n	8014d68 <HAL_DMAEx_MultiBufferStart_IT+0x10cc>
 8014c7a:	4b33      	ldr	r3, [pc, #204]	@ (8014d48 <HAL_DMAEx_MultiBufferStart_IT+0x10ac>)
 8014c7c:	429c      	cmp	r4, r3
 8014c7e:	d104      	bne.n	8014c8a <HAL_DMAEx_MultiBufferStart_IT+0xfee>
 8014c80:	4b38      	ldr	r3, [pc, #224]	@ (8014d64 <HAL_DMAEx_MultiBufferStart_IT+0x10c8>)
 8014c82:	2208      	movs	r2, #8
 8014c84:	60da      	str	r2, [r3, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014c86:	f7ff ba88 	b.w	801419a <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8014c8a:	4b30      	ldr	r3, [pc, #192]	@ (8014d4c <HAL_DMAEx_MultiBufferStart_IT+0x10b0>)
 8014c8c:	429c      	cmp	r4, r3
 8014c8e:	f47f ac1a 	bne.w	80144c6 <HAL_DMAEx_MultiBufferStart_IT+0x82a>
 8014c92:	f7ff bb3b 	b.w	801430c <HAL_DMAEx_MultiBufferStart_IT+0x670>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8014c96:	f44f 0280 	mov.w	r2, #4194304	@ 0x400000
 8014c9a:	f7ff b948 	b.w	8013f2e <HAL_DMAEx_MultiBufferStart_IT+0x292>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014c9e:	3b48      	subs	r3, #72	@ 0x48
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8014ca0:	f04f 7100 	mov.w	r1, #33554432	@ 0x2000000
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014ca4:	429c      	cmp	r4, r3
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8014ca6:	f842 1c94 	str.w	r1, [r2, #-148]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014caa:	d83c      	bhi.n	8014d26 <HAL_DMAEx_MultiBufferStart_IT+0x108a>
 8014cac:	f5a3 7368 	sub.w	r3, r3, #928	@ 0x3a0
 8014cb0:	429c      	cmp	r4, r3
 8014cb2:	f67f af05 	bls.w	8014ac0 <HAL_DMAEx_MultiBufferStart_IT+0xe24>
 8014cb6:	3ba8      	subs	r3, #168	@ 0xa8
 8014cb8:	429c      	cmp	r4, r3
 8014cba:	f47f aed9 	bne.w	8014a70 <HAL_DMAEx_MultiBufferStart_IT+0xdd4>
 8014cbe:	2204      	movs	r2, #4
 8014cc0:	f8c3 23f8 	str.w	r2, [r3, #1016]	@ 0x3f8
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8014cc4:	f7ff bb28 	b.w	8014318 <HAL_DMAEx_MultiBufferStart_IT+0x67c>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014cc8:	4b23      	ldr	r3, [pc, #140]	@ (8014d58 <HAL_DMAEx_MultiBufferStart_IT+0x10bc>)
 8014cca:	f44f 7280 	mov.w	r2, #256	@ 0x100
 8014cce:	60da      	str	r2, [r3, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8014cd0:	e409      	b.n	80144e6 <HAL_DMAEx_MultiBufferStart_IT+0x84a>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8014cd2:	f5a3 6394 	sub.w	r3, r3, #1184	@ 0x4a0
 8014cd6:	f04f 6280 	mov.w	r2, #67108864	@ 0x4000000
 8014cda:	609a      	str	r2, [r3, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8014cdc:	4b1a      	ldr	r3, [pc, #104]	@ (8014d48 <HAL_DMAEx_MultiBufferStart_IT+0x10ac>)
 8014cde:	429c      	cmp	r4, r3
 8014ce0:	d104      	bne.n	8014cec <HAL_DMAEx_MultiBufferStart_IT+0x1050>
 8014ce2:	4b20      	ldr	r3, [pc, #128]	@ (8014d64 <HAL_DMAEx_MultiBufferStart_IT+0x10c8>)
 8014ce4:	2208      	movs	r2, #8
 8014ce6:	609a      	str	r2, [r3, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014ce8:	f7ff ba57 	b.w	801419a <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8014cec:	4b17      	ldr	r3, [pc, #92]	@ (8014d4c <HAL_DMAEx_MultiBufferStart_IT+0x10b0>)
 8014cee:	429c      	cmp	r4, r3
 8014cf0:	d008      	beq.n	8014d04 <HAL_DMAEx_MultiBufferStart_IT+0x1068>
 8014cf2:	4b17      	ldr	r3, [pc, #92]	@ (8014d50 <HAL_DMAEx_MultiBufferStart_IT+0x10b4>)
 8014cf4:	429c      	cmp	r4, r3
 8014cf6:	f47f aa1c 	bne.w	8014132 <HAL_DMAEx_MultiBufferStart_IT+0x496>
 8014cfa:	4b1a      	ldr	r3, [pc, #104]	@ (8014d64 <HAL_DMAEx_MultiBufferStart_IT+0x10c8>)
 8014cfc:	2208      	movs	r2, #8
 8014cfe:	609a      	str	r2, [r3, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014d00:	f7ff b821 	b.w	8013d46 <HAL_DMAEx_MultiBufferStart_IT+0xaa>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8014d04:	4b17      	ldr	r3, [pc, #92]	@ (8014d64 <HAL_DMAEx_MultiBufferStart_IT+0x10c8>)
 8014d06:	2208      	movs	r2, #8
 8014d08:	609a      	str	r2, [r3, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014d0a:	f7ff bb02 	b.w	8014312 <HAL_DMAEx_MultiBufferStart_IT+0x676>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8014d0e:	2308      	movs	r3, #8
 8014d10:	60d3      	str	r3, [r2, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014d12:	e702      	b.n	8014b1a <HAL_DMAEx_MultiBufferStart_IT+0xe7e>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8014d14:	3ba8      	subs	r3, #168	@ 0xa8
 8014d16:	429c      	cmp	r4, r3
 8014d18:	f47f ac21 	bne.w	801455e <HAL_DMAEx_MultiBufferStart_IT+0x8c2>
 8014d1c:	2208      	movs	r2, #8
 8014d1e:	f8c3 23f8 	str.w	r2, [r3, #1016]	@ 0x3f8
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014d22:	f7ff baf6 	b.w	8014312 <HAL_DMAEx_MultiBufferStart_IT+0x676>
 8014d26:	4b0e      	ldr	r3, [pc, #56]	@ (8014d60 <HAL_DMAEx_MultiBufferStart_IT+0x10c4>)
 8014d28:	429c      	cmp	r4, r3
 8014d2a:	d035      	beq.n	8014d98 <HAL_DMAEx_MultiBufferStart_IT+0x10fc>
 8014d2c:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8014d30:	429c      	cmp	r4, r3
 8014d32:	d031      	beq.n	8014d98 <HAL_DMAEx_MultiBufferStart_IT+0x10fc>
 8014d34:	f5a3 7368 	sub.w	r3, r3, #928	@ 0x3a0
 8014d38:	429c      	cmp	r4, r3
 8014d3a:	f47f ad5b 	bne.w	80147f4 <HAL_DMAEx_MultiBufferStart_IT+0xb58>
 8014d3e:	2204      	movs	r2, #4
 8014d40:	f8c3 239c 	str.w	r2, [r3, #924]	@ 0x39c
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8014d44:	f7ff ba2c 	b.w	80141a0 <HAL_DMAEx_MultiBufferStart_IT+0x504>
 8014d48:	40026410 	.word	0x40026410
 8014d4c:	40026070 	.word	0x40026070
 8014d50:	40026470 	.word	0x40026470
 8014d54:	40026028 	.word	0x40026028
 8014d58:	40026400 	.word	0x40026400
 8014d5c:	40026058 	.word	0x40026058
 8014d60:	40026010 	.word	0x40026010
 8014d64:	40026000 	.word	0x40026000
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8014d68:	4b19      	ldr	r3, [pc, #100]	@ (8014dd0 <HAL_DMAEx_MultiBufferStart_IT+0x1134>)
 8014d6a:	429c      	cmp	r4, r3
 8014d6c:	d1b6      	bne.n	8014cdc <HAL_DMAEx_MultiBufferStart_IT+0x1040>
 8014d6e:	f7ff ba80 	b.w	8014272 <HAL_DMAEx_MultiBufferStart_IT+0x5d6>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014d72:	4b18      	ldr	r3, [pc, #96]	@ (8014dd4 <HAL_DMAEx_MultiBufferStart_IT+0x1138>)
 8014d74:	429c      	cmp	r4, r3
 8014d76:	f63f ae91 	bhi.w	8014a9c <HAL_DMAEx_MultiBufferStart_IT+0xe00>
 8014d7a:	4b17      	ldr	r3, [pc, #92]	@ (8014dd8 <HAL_DMAEx_MultiBufferStart_IT+0x113c>)
 8014d7c:	429c      	cmp	r4, r3
 8014d7e:	f43f aea8 	beq.w	8014ad2 <HAL_DMAEx_MultiBufferStart_IT+0xe36>
 8014d82:	f5a3 7368 	sub.w	r3, r3, #928	@ 0x3a0
 8014d86:	429c      	cmp	r4, r3
 8014d88:	f43f aeb8 	beq.w	8014afc <HAL_DMAEx_MultiBufferStart_IT+0xe60>
 8014d8c:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8014d90:	429c      	cmp	r4, r3
 8014d92:	f43f aeaa 	beq.w	8014aea <HAL_DMAEx_MultiBufferStart_IT+0xe4e>
 8014d96:	e474      	b.n	8014682 <HAL_DMAEx_MultiBufferStart_IT+0x9e6>
 8014d98:	4b10      	ldr	r3, [pc, #64]	@ (8014ddc <HAL_DMAEx_MultiBufferStart_IT+0x1140>)
 8014d9a:	2204      	movs	r2, #4
 8014d9c:	60da      	str	r2, [r3, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8014d9e:	f7ff b9ff 	b.w	80141a0 <HAL_DMAEx_MultiBufferStart_IT+0x504>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8014da2:	2308      	movs	r3, #8
 8014da4:	6093      	str	r3, [r2, #8]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014da6:	f7ff bab4 	b.w	8014312 <HAL_DMAEx_MultiBufferStart_IT+0x676>
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8014daa:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8014dae:	429c      	cmp	r4, r3
 8014db0:	f47f ad9d 	bne.w	80148ee <HAL_DMAEx_MultiBufferStart_IT+0xc52>
 8014db4:	4b0a      	ldr	r3, [pc, #40]	@ (8014de0 <HAL_DMAEx_MultiBufferStart_IT+0x1144>)
 8014db6:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8014dba:	60da      	str	r2, [r3, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8014dbc:	e4f2      	b.n	80147a4 <HAL_DMAEx_MultiBufferStart_IT+0xb08>
 8014dbe:	4b09      	ldr	r3, [pc, #36]	@ (8014de4 <HAL_DMAEx_MultiBufferStart_IT+0x1148>)
 8014dc0:	429c      	cmp	r4, r3
 8014dc2:	f47f a85e 	bne.w	8013e82 <HAL_DMAEx_MultiBufferStart_IT+0x1e6>
 8014dc6:	4b06      	ldr	r3, [pc, #24]	@ (8014de0 <HAL_DMAEx_MultiBufferStart_IT+0x1144>)
 8014dc8:	f44f 7280 	mov.w	r2, #256	@ 0x100
 8014dcc:	60da      	str	r2, [r3, #12]
    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8014dce:	e4ed      	b.n	80147ac <HAL_DMAEx_MultiBufferStart_IT+0xb10>
 8014dd0:	40026010 	.word	0x40026010
 8014dd4:	40026058 	.word	0x40026058
 8014dd8:	40026410 	.word	0x40026410
 8014ddc:	40026400 	.word	0x40026400
 8014de0:	40026000 	.word	0x40026000
 8014de4:	40026428 	.word	0x40026428

08014de8 <HAL_DMAEx_ChangeMemory>:
    hdma->Instance->M0AR = Address;
 8014de8:	6803      	ldr	r3, [r0, #0]
  if(memory == MEMORY0)
 8014dea:	b912      	cbnz	r2, 8014df2 <HAL_DMAEx_ChangeMemory+0xa>
}
 8014dec:	2000      	movs	r0, #0
    hdma->Instance->M0AR = Address;
 8014dee:	60d9      	str	r1, [r3, #12]
}
 8014df0:	4770      	bx	lr
 8014df2:	2000      	movs	r0, #0
    hdma->Instance->M1AR = Address;
 8014df4:	6119      	str	r1, [r3, #16]
}
 8014df6:	4770      	bx	lr

08014df8 <HAL_ETH_Init>:
  */
HAL_StatusTypeDef HAL_ETH_Init(ETH_HandleTypeDef *heth)
{
  uint32_t tickstart;

  if (heth == NULL)
 8014df8:	2800      	cmp	r0, #0
 8014dfa:	f000 812a 	beq.w	8015052 <HAL_ETH_Init+0x25a>
  {
    return HAL_ERROR;
  }
  if (heth->gState == HAL_ETH_STATE_RESET)
 8014dfe:	f8d0 3084 	ldr.w	r3, [r0, #132]	@ 0x84
{
 8014e02:	b5f0      	push	{r4, r5, r6, r7, lr}
 8014e04:	4605      	mov	r5, r0
 8014e06:	b083      	sub	sp, #12
  if (heth->gState == HAL_ETH_STATE_RESET)
 8014e08:	2b00      	cmp	r3, #0
 8014e0a:	f000 811c 	beq.w	8015046 <HAL_ETH_Init+0x24e>
    HAL_ETH_MspInit(heth);

#endif /* (USE_HAL_ETH_REGISTER_CALLBACKS) */
  }

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8014e0e:	4992      	ldr	r1, [pc, #584]	@ (8015058 <HAL_ETH_Init+0x260>)

  /* Select MII or RMII Mode*/
  SYSCFG->PMC &= ~(SYSCFG_PMC_MII_RMII_SEL);
  SYSCFG->PMC |= (uint32_t)heth->Init.MediaInterface;
 8014e10:	68ac      	ldr	r4, [r5, #8]
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8014e12:	6c48      	ldr	r0, [r1, #68]	@ 0x44
  (void)SYSCFG->PMC;

  /* Ethernet Software reset */
  /* Set the SWR bit: resets all MAC subsystem internal registers and logic */
  /* After reset all the registers holds their respective reset values */
  SET_BIT(heth->Instance->DMABMR, ETH_DMABMR_SR);
 8014e14:	682a      	ldr	r2, [r5, #0]
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8014e16:	f440 4080 	orr.w	r0, r0, #16384	@ 0x4000
  SYSCFG->PMC &= ~(SYSCFG_PMC_MII_RMII_SEL);
 8014e1a:	4b90      	ldr	r3, [pc, #576]	@ (801505c <HAL_ETH_Init+0x264>)
  SET_BIT(heth->Instance->DMABMR, ETH_DMABMR_SR);
 8014e1c:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8014e20:	6448      	str	r0, [r1, #68]	@ 0x44
 8014e22:	6c49      	ldr	r1, [r1, #68]	@ 0x44
 8014e24:	f401 4180 	and.w	r1, r1, #16384	@ 0x4000
 8014e28:	9101      	str	r1, [sp, #4]
 8014e2a:	9901      	ldr	r1, [sp, #4]
  SYSCFG->PMC &= ~(SYSCFG_PMC_MII_RMII_SEL);
 8014e2c:	6859      	ldr	r1, [r3, #4]
 8014e2e:	f421 0100 	bic.w	r1, r1, #8388608	@ 0x800000
 8014e32:	6059      	str	r1, [r3, #4]
  SYSCFG->PMC |= (uint32_t)heth->Init.MediaInterface;
 8014e34:	6859      	ldr	r1, [r3, #4]
 8014e36:	4321      	orrs	r1, r4
 8014e38:	6059      	str	r1, [r3, #4]
  (void)SYSCFG->PMC;
 8014e3a:	685b      	ldr	r3, [r3, #4]
  SET_BIT(heth->Instance->DMABMR, ETH_DMABMR_SR);
 8014e3c:	6813      	ldr	r3, [r2, #0]
 8014e3e:	f043 0301 	orr.w	r3, r3, #1
 8014e42:	6013      	str	r3, [r2, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 8014e44:	f7fe f812 	bl	8012e6c <HAL_GetTick>
 8014e48:	4606      	mov	r6, r0

  /* Wait for software reset */
  while (READ_BIT(heth->Instance->DMABMR, ETH_DMABMR_SR) > 0U)
 8014e4a:	e006      	b.n	8014e5a <HAL_ETH_Init+0x62>
  {
    if (((HAL_GetTick() - tickstart) > ETH_SWRESET_TIMEOUT))
 8014e4c:	f7fe f80e 	bl	8012e6c <HAL_GetTick>
 8014e50:	1b80      	subs	r0, r0, r6
 8014e52:	f5b0 7ffa 	cmp.w	r0, #500	@ 0x1f4
 8014e56:	f200 80ed 	bhi.w	8015034 <HAL_ETH_Init+0x23c>
  while (READ_BIT(heth->Instance->DMABMR, ETH_DMABMR_SR) > 0U)
 8014e5a:	682b      	ldr	r3, [r5, #0]
 8014e5c:	f503 5280 	add.w	r2, r3, #4096	@ 0x1000
 8014e60:	6814      	ldr	r4, [r2, #0]
 8014e62:	f014 0401 	ands.w	r4, r4, #1
 8014e66:	d1f1      	bne.n	8014e4c <HAL_ETH_Init+0x54>
{
  uint32_t tmpreg1;

  /*------------------------ ETHERNET MACCR Configuration --------------------*/
  /* Get the ETHERNET MACCR value */
  tmpreg1 = (heth->Instance)->MACCR;
 8014e68:	681a      	ldr	r2, [r3, #0]
  (heth->Instance)->MACCR = (uint32_t)tmpreg1;

  /* Wait until the write operation will be taken into account :
  at least four TX_CLK/RX_CLK clock cycles */
  tmpreg1 = (heth->Instance)->MACCR;
  HAL_Delay(ETH_REG_WRITE_DELAY);
 8014e6a:	2001      	movs	r0, #1
  tmpreg1 &= ETH_MACCR_CLEAR_MASK;
 8014e6c:	497c      	ldr	r1, [pc, #496]	@ (8015060 <HAL_ETH_Init+0x268>)
 8014e6e:	4011      	ands	r1, r2
  tmpreg1 |= (uint32_t)(((uint32_t)macconf->CRCStripTypePacket << 25U) |
 8014e70:	4a7c      	ldr	r2, [pc, #496]	@ (8015064 <HAL_ETH_Init+0x26c>)
 8014e72:	430a      	orrs	r2, r1
  (heth->Instance)->MACCR = (uint32_t)tmpreg1;
 8014e74:	601a      	str	r2, [r3, #0]
  tmpreg1 = (heth->Instance)->MACCR;
 8014e76:	681e      	ldr	r6, [r3, #0]
  HAL_Delay(ETH_REG_WRITE_DELAY);
 8014e78:	f7fd fffe 	bl	8012e78 <HAL_Delay>
  (heth->Instance)->MACCR = tmpreg1;
 8014e7c:	682a      	ldr	r2, [r5, #0]
  /*----------------------- ETHERNET MACFCR Configuration --------------------*/

  /* Get the ETHERNET MACFCR value */
  tmpreg1 = (heth->Instance)->MACFCR;
  /* Clear xx bits */
  tmpreg1 &= ETH_MACFCR_CLEAR_MASK;
 8014e7e:	f64f 7141 	movw	r1, #65345	@ 0xff41
  (heth->Instance)->MACFCR = (uint32_t)tmpreg1;

  /* Wait until the write operation will be taken into account :
  at least four TX_CLK/RX_CLK clock cycles */
  tmpreg1 = (heth->Instance)->MACFCR;
  HAL_Delay(ETH_REG_WRITE_DELAY);
 8014e82:	2001      	movs	r0, #1
  (heth->Instance)->MACCR = tmpreg1;
 8014e84:	6016      	str	r6, [r2, #0]
  tmpreg1 = (heth->Instance)->MACFCR;
 8014e86:	6993      	ldr	r3, [r2, #24]
  tmpreg1 &= ETH_MACFCR_CLEAR_MASK;
 8014e88:	400b      	ands	r3, r1
  tmpreg1 |= (uint32_t)((macconf->PauseTime << 16U) |
 8014e8a:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
  (heth->Instance)->MACFCR = (uint32_t)tmpreg1;
 8014e8e:	6193      	str	r3, [r2, #24]
  tmpreg1 = (heth->Instance)->MACFCR;
 8014e90:	6996      	ldr	r6, [r2, #24]
  HAL_Delay(ETH_REG_WRITE_DELAY);
 8014e92:	f7fd fff1 	bl	8012e78 <HAL_Delay>
  (heth->Instance)->MACFCR = tmpreg1;
 8014e96:	682a      	ldr	r2, [r5, #0]

  /*----------------------- ETHERNET DMAOMR Configuration --------------------*/
  /* Get the ETHERNET DMAOMR value */
  tmpreg1 = (heth->Instance)->DMAOMR;
  /* Clear xx bits */
  tmpreg1 &= ETH_DMAOMR_CLEAR_MASK;
 8014e98:	4973      	ldr	r1, [pc, #460]	@ (8015068 <HAL_ETH_Init+0x270>)
  tmpreg1 = (heth->Instance)->DMAOMR;
 8014e9a:	f502 5380 	add.w	r3, r2, #4096	@ 0x1000
  (heth->Instance)->MACFCR = tmpreg1;
 8014e9e:	6196      	str	r6, [r2, #24]

  tmpreg1 |= (uint32_t)(((uint32_t)((dmaconf->DropTCPIPChecksumErrorFrame == DISABLE) ? 1U : 0U) << 26U) |
 8014ea0:	4a72      	ldr	r2, [pc, #456]	@ (801506c <HAL_ETH_Init+0x274>)
  tmpreg1 = (heth->Instance)->DMAOMR;
 8014ea2:	6998      	ldr	r0, [r3, #24]
  tmpreg1 &= ETH_DMAOMR_CLEAR_MASK;
 8014ea4:	4001      	ands	r1, r0
  (heth->Instance)->DMAOMR = (uint32_t)tmpreg1;

  /* Wait until the write operation will be taken into account:
  at least four TX_CLK/RX_CLK clock cycles */
  tmpreg1 = (heth->Instance)->DMAOMR;
  HAL_Delay(ETH_REG_WRITE_DELAY);
 8014ea6:	2001      	movs	r0, #1
  tmpreg1 |= (uint32_t)(((uint32_t)((dmaconf->DropTCPIPChecksumErrorFrame == DISABLE) ? 1U : 0U) << 26U) |
 8014ea8:	430a      	orrs	r2, r1
  (heth->Instance)->DMAOMR = (uint32_t)tmpreg1;
 8014eaa:	619a      	str	r2, [r3, #24]
  tmpreg1 = (heth->Instance)->DMAOMR;
 8014eac:	699e      	ldr	r6, [r3, #24]
  HAL_Delay(ETH_REG_WRITE_DELAY);
 8014eae:	f7fd ffe3 	bl	8012e78 <HAL_Delay>
  (heth->Instance)->DMAOMR = tmpreg1;
 8014eb2:	682b      	ldr	r3, [r5, #0]
                                        ETH_DMABMR_USP); /* Enable use of separate PBL for Rx and Tx */

  /* Wait until the write operation will be taken into account:
     at least four TX_CLK/RX_CLK clock cycles */
  tmpreg1 = (heth->Instance)->DMABMR;
  HAL_Delay(ETH_REG_WRITE_DELAY);
 8014eb4:	2001      	movs	r0, #1
  (heth->Instance)->DMABMR = (uint32_t)(((uint32_t)dmaconf->AddressAlignedBeats << 25U) |
 8014eb6:	4a6e      	ldr	r2, [pc, #440]	@ (8015070 <HAL_ETH_Init+0x278>)
  (heth->Instance)->DMAOMR = tmpreg1;
 8014eb8:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8014ebc:	619e      	str	r6, [r3, #24]
  (heth->Instance)->DMABMR = (uint32_t)(((uint32_t)dmaconf->AddressAlignedBeats << 25U) |
 8014ebe:	601a      	str	r2, [r3, #0]
  tmpreg1 = (heth->Instance)->DMABMR;
 8014ec0:	681f      	ldr	r7, [r3, #0]
  HAL_Delay(ETH_REG_WRITE_DELAY);
 8014ec2:	f7fd ffd9 	bl	8012e78 <HAL_Delay>
  (heth->Instance)->DMABMR = tmpreg1;
 8014ec6:	682a      	ldr	r2, [r5, #0]
  uint32_t i;

  /* Fill each DMATxDesc descriptor with the right values */
  for (i = 0; i < (uint32_t)ETH_TX_DESC_CNT; i++)
  {
    dmatxdesc = heth->Init.TxDesc + i;
 8014ec8:	68eb      	ldr	r3, [r5, #12]
  (heth->Instance)->DMABMR = tmpreg1;
 8014eca:	f502 5680 	add.w	r6, r2, #4096	@ 0x1000
    WRITE_REG(dmatxdesc->DESC3, 0x0U);

    WRITE_REG(heth->TxDescList.TxDesc[i], (uint32_t)dmatxdesc);

    /* Set Second Address Chained bit */
    SET_BIT(dmatxdesc->DESC0, ETH_DMATXDESC_TCH);
 8014ece:	4619      	mov	r1, r3
  (heth->Instance)->DMABMR = tmpreg1;
 8014ed0:	6037      	str	r7, [r6, #0]
    WRITE_REG(dmatxdesc->DESC0, 0x0U);
 8014ed2:	601c      	str	r4, [r3, #0]
    WRITE_REG(dmatxdesc->DESC1, 0x0U);
 8014ed4:	605c      	str	r4, [r3, #4]
    WRITE_REG(dmatxdesc->DESC2, 0x0U);
 8014ed6:	609c      	str	r4, [r3, #8]
    WRITE_REG(dmatxdesc->DESC3, 0x0U);
 8014ed8:	60dc      	str	r4, [r3, #12]
    SET_BIT(dmatxdesc->DESC0, ETH_DMATXDESC_TCH);
 8014eda:	6818      	ldr	r0, [r3, #0]
    WRITE_REG(heth->TxDescList.TxDesc[i], (uint32_t)dmatxdesc);
 8014edc:	61ab      	str	r3, [r5, #24]
    SET_BIT(dmatxdesc->DESC0, ETH_DMATXDESC_TCH);
 8014ede:	f440 1080 	orr.w	r0, r0, #1048576	@ 0x100000
 8014ee2:	f841 0b28 	str.w	r0, [r1], #40

    if (i < ((uint32_t)ETH_TX_DESC_CNT - 1U))
    {
      WRITE_REG(dmatxdesc->DESC3, (uint32_t)(heth->Init.TxDesc + i + 1U));
 8014ee6:	60d9      	str	r1, [r3, #12]
    {
      WRITE_REG(dmatxdesc->DESC3, (uint32_t)(heth->Init.TxDesc));
    }

    /* Set the DMA Tx descriptors checksum insertion */
    SET_BIT(dmatxdesc->DESC0, ETH_DMATXDESC_CHECKSUMTCPUDPICMPFULL);
 8014ee8:	6818      	ldr	r0, [r3, #0]
 8014eea:	f440 0040 	orr.w	r0, r0, #12582912	@ 0xc00000
 8014eee:	6018      	str	r0, [r3, #0]
      WRITE_REG(dmatxdesc->DESC3, (uint32_t)(heth->Init.TxDesc + i + 1U));
 8014ef0:	f103 0050 	add.w	r0, r3, #80	@ 0x50
    WRITE_REG(dmatxdesc->DESC0, 0x0U);
 8014ef4:	629c      	str	r4, [r3, #40]	@ 0x28
    WRITE_REG(dmatxdesc->DESC1, 0x0U);
 8014ef6:	62dc      	str	r4, [r3, #44]	@ 0x2c
    WRITE_REG(dmatxdesc->DESC2, 0x0U);
 8014ef8:	631c      	str	r4, [r3, #48]	@ 0x30
    WRITE_REG(dmatxdesc->DESC3, 0x0U);
 8014efa:	635c      	str	r4, [r3, #52]	@ 0x34
    WRITE_REG(heth->TxDescList.TxDesc[i], (uint32_t)dmatxdesc);
 8014efc:	61e9      	str	r1, [r5, #28]
    SET_BIT(dmatxdesc->DESC0, ETH_DMATXDESC_TCH);
 8014efe:	6a99      	ldr	r1, [r3, #40]	@ 0x28
 8014f00:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 8014f04:	6299      	str	r1, [r3, #40]	@ 0x28
      WRITE_REG(dmatxdesc->DESC3, (uint32_t)(heth->Init.TxDesc + i + 1U));
 8014f06:	6358      	str	r0, [r3, #52]	@ 0x34
    SET_BIT(dmatxdesc->DESC0, ETH_DMATXDESC_CHECKSUMTCPUDPICMPFULL);
 8014f08:	6a99      	ldr	r1, [r3, #40]	@ 0x28
 8014f0a:	f441 0140 	orr.w	r1, r1, #12582912	@ 0xc00000
 8014f0e:	6299      	str	r1, [r3, #40]	@ 0x28
    WRITE_REG(dmatxdesc->DESC0, 0x0U);
 8014f10:	651c      	str	r4, [r3, #80]	@ 0x50
    WRITE_REG(dmatxdesc->DESC1, 0x0U);
 8014f12:	655c      	str	r4, [r3, #84]	@ 0x54
    WRITE_REG(dmatxdesc->DESC2, 0x0U);
 8014f14:	659c      	str	r4, [r3, #88]	@ 0x58
    WRITE_REG(dmatxdesc->DESC3, 0x0U);
 8014f16:	65dc      	str	r4, [r3, #92]	@ 0x5c
    SET_BIT(dmatxdesc->DESC0, ETH_DMATXDESC_TCH);
 8014f18:	6d19      	ldr	r1, [r3, #80]	@ 0x50
    WRITE_REG(heth->TxDescList.TxDesc[i], (uint32_t)dmatxdesc);
 8014f1a:	6228      	str	r0, [r5, #32]
      WRITE_REG(dmatxdesc->DESC3, (uint32_t)(heth->Init.TxDesc + i + 1U));
 8014f1c:	f103 0078 	add.w	r0, r3, #120	@ 0x78
    SET_BIT(dmatxdesc->DESC0, ETH_DMATXDESC_TCH);
 8014f20:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 8014f24:	6519      	str	r1, [r3, #80]	@ 0x50
      WRITE_REG(dmatxdesc->DESC3, (uint32_t)(heth->Init.TxDesc + i + 1U));
 8014f26:	65d8      	str	r0, [r3, #92]	@ 0x5c
    SET_BIT(dmatxdesc->DESC0, ETH_DMATXDESC_CHECKSUMTCPUDPICMPFULL);
 8014f28:	6d19      	ldr	r1, [r3, #80]	@ 0x50
 8014f2a:	f441 0140 	orr.w	r1, r1, #12582912	@ 0xc00000
 8014f2e:	6519      	str	r1, [r3, #80]	@ 0x50
    WRITE_REG(dmatxdesc->DESC0, 0x0U);
 8014f30:	679c      	str	r4, [r3, #120]	@ 0x78
    WRITE_REG(dmatxdesc->DESC1, 0x0U);
 8014f32:	67dc      	str	r4, [r3, #124]	@ 0x7c
    WRITE_REG(dmatxdesc->DESC2, 0x0U);
 8014f34:	f8c3 4080 	str.w	r4, [r3, #128]	@ 0x80
    WRITE_REG(dmatxdesc->DESC3, 0x0U);
 8014f38:	f8c3 4084 	str.w	r4, [r3, #132]	@ 0x84
    SET_BIT(dmatxdesc->DESC0, ETH_DMATXDESC_TCH);
 8014f3c:	6f99      	ldr	r1, [r3, #120]	@ 0x78
    WRITE_REG(heth->TxDescList.TxDesc[i], (uint32_t)dmatxdesc);
 8014f3e:	6268      	str	r0, [r5, #36]	@ 0x24
    SET_BIT(dmatxdesc->DESC0, ETH_DMATXDESC_TCH);
 8014f40:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 8014f44:	6799      	str	r1, [r3, #120]	@ 0x78
      WRITE_REG(dmatxdesc->DESC3, (uint32_t)(heth->Init.TxDesc));
 8014f46:	f8c3 3084 	str.w	r3, [r3, #132]	@ 0x84
    SET_BIT(dmatxdesc->DESC0, ETH_DMATXDESC_CHECKSUMTCPUDPICMPFULL);
 8014f4a:	6f98      	ldr	r0, [r3, #120]	@ 0x78

    /* Set Own bit of the Rx descriptor Status */
    dmarxdesc->DESC0 = ETH_DMARXDESC_OWN;

    /* Set Buffer1 size and Second Address Chained bit */
    dmarxdesc->DESC1 = heth->Init.RxBuffLen | ETH_DMARXDESC_RCH;
 8014f4c:	6969      	ldr	r1, [r5, #20]
    SET_BIT(dmatxdesc->DESC0, ETH_DMATXDESC_CHECKSUMTCPUDPICMPFULL);
 8014f4e:	f440 0040 	orr.w	r0, r0, #12582912	@ 0xc00000
    dmarxdesc->DESC1 = heth->Init.RxBuffLen | ETH_DMARXDESC_RCH;
 8014f52:	f441 4180 	orr.w	r1, r1, #16384	@ 0x4000
    SET_BIT(dmatxdesc->DESC0, ETH_DMATXDESC_CHECKSUMTCPUDPICMPFULL);
 8014f56:	6798      	str	r0, [r3, #120]	@ 0x78
    dmarxdesc->DESC0 = ETH_DMARXDESC_OWN;
 8014f58:	f04f 4000 	mov.w	r0, #2147483648	@ 0x80000000
  heth->TxDescList.CurTxDesc = 0;
 8014f5c:	62ac      	str	r4, [r5, #40]	@ 0x28
  WRITE_REG(heth->Instance->DMATDLAR, (uint32_t) heth->Init.TxDesc);
 8014f5e:	6133      	str	r3, [r6, #16]
    dmarxdesc =  heth->Init.RxDesc + i;
 8014f60:	692b      	ldr	r3, [r5, #16]
    WRITE_REG(dmarxdesc->DESC0, 0x0U);
 8014f62:	601c      	str	r4, [r3, #0]
    /* Set Rx descritors addresses */
    WRITE_REG(heth->RxDescList.RxDesc[i], (uint32_t)dmarxdesc);

    if (i < ((uint32_t)ETH_RX_DESC_CNT - 1U))
    {
      WRITE_REG(dmarxdesc->DESC3, (uint32_t)(heth->Init.RxDesc + i + 1U));
 8014f64:	f103 0c28 	add.w	ip, r3, #40	@ 0x28
    WRITE_REG(dmarxdesc->DESC1, 0x0U);
 8014f68:	605c      	str	r4, [r3, #4]
    WRITE_REG(dmarxdesc->DESC2, 0x0U);
 8014f6a:	609c      	str	r4, [r3, #8]
    WRITE_REG(dmarxdesc->DESC3, 0x0U);
 8014f6c:	60dc      	str	r4, [r3, #12]
    dmarxdesc->DESC0 = ETH_DMARXDESC_OWN;
 8014f6e:	6018      	str	r0, [r3, #0]
    dmarxdesc->DESC1 = heth->Init.RxBuffLen | ETH_DMARXDESC_RCH;
 8014f70:	6059      	str	r1, [r3, #4]
    dmarxdesc->DESC1 &= ~ETH_DMARXDESC_DIC;
 8014f72:	685f      	ldr	r7, [r3, #4]
 8014f74:	f027 4700 	bic.w	r7, r7, #2147483648	@ 0x80000000
    WRITE_REG(dmarxdesc->BackupAddr0, 0x0U);
 8014f78:	e9c3 4408 	strd	r4, r4, [r3, #32]
    dmarxdesc->DESC1 &= ~ETH_DMARXDESC_DIC;
 8014f7c:	605f      	str	r7, [r3, #4]
    WRITE_REG(heth->RxDescList.RxDesc[i], (uint32_t)dmarxdesc);
 8014f7e:	64ab      	str	r3, [r5, #72]	@ 0x48
      WRITE_REG(dmarxdesc->DESC3, (uint32_t)(heth->Init.RxDesc + i + 1U));
 8014f80:	f8c3 c00c 	str.w	ip, [r3, #12]
    WRITE_REG(dmarxdesc->DESC0, 0x0U);
 8014f84:	629c      	str	r4, [r3, #40]	@ 0x28
    WRITE_REG(dmarxdesc->DESC1, 0x0U);
 8014f86:	62dc      	str	r4, [r3, #44]	@ 0x2c
    WRITE_REG(dmarxdesc->DESC2, 0x0U);
 8014f88:	631c      	str	r4, [r3, #48]	@ 0x30
    WRITE_REG(dmarxdesc->DESC3, 0x0U);
 8014f8a:	635c      	str	r4, [r3, #52]	@ 0x34
    WRITE_REG(dmarxdesc->BackupAddr0, 0x0U);
 8014f8c:	e9c3 4412 	strd	r4, r4, [r3, #72]	@ 0x48
    dmarxdesc->DESC0 = ETH_DMARXDESC_OWN;
 8014f90:	6298      	str	r0, [r3, #40]	@ 0x28
    dmarxdesc->DESC1 = heth->Init.RxBuffLen | ETH_DMARXDESC_RCH;
 8014f92:	62d9      	str	r1, [r3, #44]	@ 0x2c
    dmarxdesc->DESC1 &= ~ETH_DMARXDESC_DIC;
 8014f94:	6adf      	ldr	r7, [r3, #44]	@ 0x2c
 8014f96:	f027 4700 	bic.w	r7, r7, #2147483648	@ 0x80000000
 8014f9a:	62df      	str	r7, [r3, #44]	@ 0x2c
    WRITE_REG(heth->RxDescList.RxDesc[i], (uint32_t)dmarxdesc);
 8014f9c:	f8c5 c04c 	str.w	ip, [r5, #76]	@ 0x4c
      WRITE_REG(dmarxdesc->DESC3, (uint32_t)(heth->Init.RxDesc + i + 1U));
 8014fa0:	f103 0c50 	add.w	ip, r3, #80	@ 0x50
 8014fa4:	f8c3 c034 	str.w	ip, [r3, #52]	@ 0x34
    WRITE_REG(dmarxdesc->DESC0, 0x0U);
 8014fa8:	651c      	str	r4, [r3, #80]	@ 0x50
    WRITE_REG(dmarxdesc->DESC1, 0x0U);
 8014faa:	655c      	str	r4, [r3, #84]	@ 0x54
    WRITE_REG(dmarxdesc->DESC2, 0x0U);
 8014fac:	659c      	str	r4, [r3, #88]	@ 0x58
    WRITE_REG(dmarxdesc->DESC3, 0x0U);
 8014fae:	65dc      	str	r4, [r3, #92]	@ 0x5c
    dmarxdesc->DESC0 = ETH_DMARXDESC_OWN;
 8014fb0:	6518      	str	r0, [r3, #80]	@ 0x50
    dmarxdesc->DESC1 = heth->Init.RxBuffLen | ETH_DMARXDESC_RCH;
 8014fb2:	6559      	str	r1, [r3, #84]	@ 0x54
    dmarxdesc->DESC1 &= ~ETH_DMARXDESC_DIC;
 8014fb4:	6d5f      	ldr	r7, [r3, #84]	@ 0x54
 8014fb6:	f027 4700 	bic.w	r7, r7, #2147483648	@ 0x80000000
 8014fba:	655f      	str	r7, [r3, #84]	@ 0x54
      WRITE_REG(dmarxdesc->DESC3, (uint32_t)(heth->Init.RxDesc + i + 1U));
 8014fbc:	f103 0778 	add.w	r7, r3, #120	@ 0x78
    WRITE_REG(dmarxdesc->BackupAddr0, 0x0U);
 8014fc0:	e9c3 441c 	strd	r4, r4, [r3, #112]	@ 0x70
    WRITE_REG(heth->RxDescList.RxDesc[i], (uint32_t)dmarxdesc);
 8014fc4:	f8c5 c050 	str.w	ip, [r5, #80]	@ 0x50
      WRITE_REG(dmarxdesc->DESC3, (uint32_t)(heth->Init.RxDesc + i + 1U));
 8014fc8:	65df      	str	r7, [r3, #92]	@ 0x5c
    WRITE_REG(dmarxdesc->DESC0, 0x0U);
 8014fca:	679c      	str	r4, [r3, #120]	@ 0x78
    WRITE_REG(dmarxdesc->DESC1, 0x0U);
 8014fcc:	67dc      	str	r4, [r3, #124]	@ 0x7c
    WRITE_REG(dmarxdesc->DESC2, 0x0U);
 8014fce:	f8c3 4080 	str.w	r4, [r3, #128]	@ 0x80
    WRITE_REG(dmarxdesc->DESC3, 0x0U);
 8014fd2:	f8c3 4084 	str.w	r4, [r3, #132]	@ 0x84
    dmarxdesc->DESC0 = ETH_DMARXDESC_OWN;
 8014fd6:	6798      	str	r0, [r3, #120]	@ 0x78
    dmarxdesc->DESC1 = heth->Init.RxBuffLen | ETH_DMARXDESC_RCH;
 8014fd8:	67d9      	str	r1, [r3, #124]	@ 0x7c
    dmarxdesc->DESC1 &= ~ETH_DMARXDESC_DIC;
 8014fda:	6fd9      	ldr	r1, [r3, #124]	@ 0x7c
 8014fdc:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
    WRITE_REG(dmarxdesc->BackupAddr0, 0x0U);
 8014fe0:	e9c3 4426 	strd	r4, r4, [r3, #152]	@ 0x98
    dmarxdesc->DESC1 &= ~ETH_DMARXDESC_DIC;
 8014fe4:	67d9      	str	r1, [r3, #124]	@ 0x7c
    WRITE_REG(heth->RxDescList.RxDesc[i], (uint32_t)dmarxdesc);
 8014fe6:	656f      	str	r7, [r5, #84]	@ 0x54
    }
    else
    {
      WRITE_REG(dmarxdesc->DESC3, (uint32_t)(heth->Init.RxDesc));
 8014fe8:	f8c3 3084 	str.w	r3, [r3, #132]	@ 0x84
    }
  }

  WRITE_REG(heth->RxDescList.RxDescIdx, 0U);
  WRITE_REG(heth->RxDescList.RxDescCnt, 0U);
 8014fec:	662c      	str	r4, [r5, #96]	@ 0x60
  WRITE_REG(heth->RxDescList.RxBuildDescIdx, 0U);
 8014fee:	e9c5 441a 	strd	r4, r4, [r5, #104]	@ 0x68
  WRITE_REG(heth->RxDescList.RxBuildDescCnt, 0U);
  WRITE_REG(heth->RxDescList.ItMode, 0U);
 8014ff2:	e9c5 4416 	strd	r4, r4, [r5, #88]	@ 0x58
  ETH_MACAddressConfig(heth, ETH_MAC_ADDRESS0, heth->Init.MACAddr);
 8014ff6:	6869      	ldr	r1, [r5, #4]

  /* Set Receive Descriptor List Address */
  WRITE_REG(heth->Instance->DMARDLAR, (uint32_t) heth->Init.RxDesc);
 8014ff8:	60f3      	str	r3, [r6, #12]
  (*(__IO uint32_t *)((uint32_t)(ETH_MAC_ADDR_HBASE + MacAddr))) = tmpreg1;
 8014ffa:	4b1e      	ldr	r3, [pc, #120]	@ (8015074 <HAL_ETH_Init+0x27c>)
  tmpreg1 = ((uint32_t)Addr[5U] << 8U) | (uint32_t)Addr[4U];
 8014ffc:	8888      	ldrh	r0, [r1, #4]
  (*(__IO uint32_t *)((uint32_t)(ETH_MAC_ADDR_HBASE + MacAddr))) = tmpreg1;
 8014ffe:	6418      	str	r0, [r3, #64]	@ 0x40
  return HAL_OK;
 8015000:	4620      	mov	r0, r4
  tmpreg1 = ((uint32_t)Addr[3U] << 24U) | ((uint32_t)Addr[2U] << 16U) | ((uint32_t)Addr[1U] << 8U) | Addr[0U];
 8015002:	6809      	ldr	r1, [r1, #0]
  (*(__IO uint32_t *)((uint32_t)(ETH_MAC_ADDR_LBASE + MacAddr))) = tmpreg1;
 8015004:	6459      	str	r1, [r3, #68]	@ 0x44
  SET_BIT(heth->Instance->MACIMR, ETH_MACIMR_TSTIM | ETH_MACIMR_PMTIM);
 8015006:	6bd1      	ldr	r1, [r2, #60]	@ 0x3c
  SET_BIT(heth->Instance->MMCRIMR, ETH_MMCRIMR_RGUFM | ETH_MMCRIMR_RFAEM | \
 8015008:	4b1b      	ldr	r3, [pc, #108]	@ (8015078 <HAL_ETH_Init+0x280>)
  SET_BIT(heth->Instance->MACIMR, ETH_MACIMR_TSTIM | ETH_MACIMR_PMTIM);
 801500a:	f441 7102 	orr.w	r1, r1, #520	@ 0x208
 801500e:	63d1      	str	r1, [r2, #60]	@ 0x3c
  SET_BIT(heth->Instance->MMCRIMR, ETH_MMCRIMR_RGUFM | ETH_MMCRIMR_RFAEM | \
 8015010:	f8d2 110c 	ldr.w	r1, [r2, #268]	@ 0x10c
 8015014:	430b      	orrs	r3, r1
  heth->gState = HAL_ETH_STATE_READY;
 8015016:	2110      	movs	r1, #16
  SET_BIT(heth->Instance->MMCRIMR, ETH_MMCRIMR_RGUFM | ETH_MMCRIMR_RFAEM | \
 8015018:	f8c2 310c 	str.w	r3, [r2, #268]	@ 0x10c
  SET_BIT(heth->Instance->MMCTIMR, ETH_MMCTIMR_TGFM | ETH_MMCTIMR_TGFMSCM | \
 801501c:	f8d2 3110 	ldr.w	r3, [r2, #272]	@ 0x110
 8015020:	f443 1303 	orr.w	r3, r3, #2146304	@ 0x20c000
 8015024:	f8c2 3110 	str.w	r3, [r2, #272]	@ 0x110
  heth->ErrorCode = HAL_ETH_ERROR_NONE;
 8015028:	f8c5 4088 	str.w	r4, [r5, #136]	@ 0x88
  heth->gState = HAL_ETH_STATE_READY;
 801502c:	f8c5 1084 	str.w	r1, [r5, #132]	@ 0x84
}
 8015030:	b003      	add	sp, #12
 8015032:	bdf0      	pop	{r4, r5, r6, r7, pc}
      heth->ErrorCode = HAL_ETH_ERROR_TIMEOUT;
 8015034:	2204      	movs	r2, #4
      heth->gState = HAL_ETH_STATE_ERROR;
 8015036:	23e0      	movs	r3, #224	@ 0xe0
    return HAL_ERROR;
 8015038:	2001      	movs	r0, #1
      heth->ErrorCode = HAL_ETH_ERROR_TIMEOUT;
 801503a:	f8c5 2088 	str.w	r2, [r5, #136]	@ 0x88
      heth->gState = HAL_ETH_STATE_ERROR;
 801503e:	f8c5 3084 	str.w	r3, [r5, #132]	@ 0x84
}
 8015042:	b003      	add	sp, #12
 8015044:	bdf0      	pop	{r4, r5, r6, r7, pc}
    heth->gState = HAL_ETH_STATE_BUSY;
 8015046:	2323      	movs	r3, #35	@ 0x23
 8015048:	f8c0 3084 	str.w	r3, [r0, #132]	@ 0x84
    HAL_ETH_MspInit(heth);
 801504c:	f7fd f896 	bl	801217c <HAL_ETH_MspInit>
 8015050:	e6dd      	b.n	8014e0e <HAL_ETH_Init+0x16>
    return HAL_ERROR;
 8015052:	2001      	movs	r0, #1
}
 8015054:	4770      	bx	lr
 8015056:	bf00      	nop
 8015058:	40023800 	.word	0x40023800
 801505c:	40013800 	.word	0x40013800
 8015060:	fd20810f 	.word	0xfd20810f
 8015064:	02004e00 	.word	0x02004e00
 8015068:	f8de3f23 	.word	0xf8de3f23
 801506c:	02200004 	.word	0x02200004
 8015070:	02c12080 	.word	0x02c12080
 8015074:	40028000 	.word	0x40028000
 8015078:	00020060 	.word	0x00020060

0801507c <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 801507c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  for (position = 0; position < GPIO_NUMBER; position++)
 8015080:	2300      	movs	r3, #0
{
 8015082:	b085      	sub	sp, #20
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01) << position;
 8015084:	f04f 0b01 	mov.w	fp, #1
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8015088:	680c      	ldr	r4, [r1, #0]
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 801508a:	f8df a244 	ldr.w	sl, [pc, #580]	@ 80152d0 <HAL_GPIO_Init+0x254>

        temp = SYSCFG->EXTICR[position >> 2];
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 801508e:	4689      	mov	r9, r1
 8015090:	e003      	b.n	801509a <HAL_GPIO_Init+0x1e>
  for (position = 0; position < GPIO_NUMBER; position++)
 8015092:	3301      	adds	r3, #1
 8015094:	2b10      	cmp	r3, #16
 8015096:	f000 809b 	beq.w	80151d0 <HAL_GPIO_Init+0x154>
    ioposition = ((uint32_t)0x01) << position;
 801509a:	fa0b f203 	lsl.w	r2, fp, r3
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 801509e:	ea02 0804 	and.w	r8, r2, r4
    if (iocurrent == ioposition)
 80150a2:	43a2      	bics	r2, r4
 80150a4:	d1f5      	bne.n	8015092 <HAL_GPIO_Init+0x16>
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 80150a6:	f8d9 1004 	ldr.w	r1, [r9, #4]
 80150aa:	ea4f 0c43 	mov.w	ip, r3, lsl #1
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 80150ae:	2503      	movs	r5, #3
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 80150b0:	f001 0203 	and.w	r2, r1, #3
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 80150b4:	fa05 f50c 	lsl.w	r5, r5, ip
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 80150b8:	1e57      	subs	r7, r2, #1
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 80150ba:	43ed      	mvns	r5, r5
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 80150bc:	2f01      	cmp	r7, #1
 80150be:	f240 808a 	bls.w	80151d6 <HAL_GPIO_Init+0x15a>
      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 80150c2:	2a03      	cmp	r2, #3
 80150c4:	f040 80c3 	bne.w	801524e <HAL_GPIO_Init+0x1d2>
      temp = GPIOx->MODER;
 80150c8:	6807      	ldr	r7, [r0, #0]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 80150ca:	fa02 f20c 	lsl.w	r2, r2, ip
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 80150ce:	f411 3f40 	tst.w	r1, #196608	@ 0x30000
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 80150d2:	ea05 0507 	and.w	r5, r5, r7
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 80150d6:	ea42 0205 	orr.w	r2, r2, r5
      GPIOx->MODER = temp;
 80150da:	6002      	str	r2, [r0, #0]
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 80150dc:	d0d9      	beq.n	8015092 <HAL_GPIO_Init+0x16>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80150de:	f8da 2044 	ldr.w	r2, [sl, #68]	@ 0x44
 80150e2:	f023 0503 	bic.w	r5, r3, #3
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 80150e6:	f003 0703 	and.w	r7, r3, #3
 80150ea:	260f      	movs	r6, #15
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80150ec:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
 80150f0:	f105 4580 	add.w	r5, r5, #1073741824	@ 0x40000000
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 80150f4:	00bf      	lsls	r7, r7, #2
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80150f6:	f8ca 2044 	str.w	r2, [sl, #68]	@ 0x44
 80150fa:	f505 359c 	add.w	r5, r5, #79872	@ 0x13800
 80150fe:	f8da 2044 	ldr.w	r2, [sl, #68]	@ 0x44
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8015102:	fa06 fc07 	lsl.w	ip, r6, r7
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 8015106:	4e6f      	ldr	r6, [pc, #444]	@ (80152c4 <HAL_GPIO_Init+0x248>)
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8015108:	f402 4280 	and.w	r2, r2, #16384	@ 0x4000
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 801510c:	42b0      	cmp	r0, r6
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 801510e:	9203      	str	r2, [sp, #12]
 8015110:	9a03      	ldr	r2, [sp, #12]
        temp = SYSCFG->EXTICR[position >> 2];
 8015112:	68aa      	ldr	r2, [r5, #8]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8015114:	ea22 020c 	bic.w	r2, r2, ip
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 8015118:	d031      	beq.n	801517e <HAL_GPIO_Init+0x102>
 801511a:	f506 6680 	add.w	r6, r6, #1024	@ 0x400
 801511e:	42b0      	cmp	r0, r6
 8015120:	f000 80a0 	beq.w	8015264 <HAL_GPIO_Init+0x1e8>
 8015124:	4e68      	ldr	r6, [pc, #416]	@ (80152c8 <HAL_GPIO_Init+0x24c>)
 8015126:	42b0      	cmp	r0, r6
 8015128:	f000 80a2 	beq.w	8015270 <HAL_GPIO_Init+0x1f4>
 801512c:	f8df c1a4 	ldr.w	ip, [pc, #420]	@ 80152d4 <HAL_GPIO_Init+0x258>
 8015130:	4560      	cmp	r0, ip
 8015132:	f000 80a3 	beq.w	801527c <HAL_GPIO_Init+0x200>
 8015136:	f8df c1a0 	ldr.w	ip, [pc, #416]	@ 80152d8 <HAL_GPIO_Init+0x25c>
 801513a:	4560      	cmp	r0, ip
 801513c:	f000 80a4 	beq.w	8015288 <HAL_GPIO_Init+0x20c>
 8015140:	f8df c198 	ldr.w	ip, [pc, #408]	@ 80152dc <HAL_GPIO_Init+0x260>
 8015144:	4560      	cmp	r0, ip
 8015146:	f000 80ab 	beq.w	80152a0 <HAL_GPIO_Init+0x224>
 801514a:	f8df c194 	ldr.w	ip, [pc, #404]	@ 80152e0 <HAL_GPIO_Init+0x264>
 801514e:	4560      	cmp	r0, ip
 8015150:	f000 80ac 	beq.w	80152ac <HAL_GPIO_Init+0x230>
 8015154:	f8df c18c 	ldr.w	ip, [pc, #396]	@ 80152e4 <HAL_GPIO_Init+0x268>
 8015158:	4560      	cmp	r0, ip
 801515a:	f000 809b 	beq.w	8015294 <HAL_GPIO_Init+0x218>
 801515e:	f8df c188 	ldr.w	ip, [pc, #392]	@ 80152e8 <HAL_GPIO_Init+0x26c>
 8015162:	4560      	cmp	r0, ip
 8015164:	f000 80a8 	beq.w	80152b8 <HAL_GPIO_Init+0x23c>
 8015168:	f8df c180 	ldr.w	ip, [pc, #384]	@ 80152ec <HAL_GPIO_Init+0x270>
 801516c:	4560      	cmp	r0, ip
 801516e:	bf0c      	ite	eq
 8015170:	f04f 0c09 	moveq.w	ip, #9
 8015174:	f04f 0c0a 	movne.w	ip, #10
 8015178:	fa0c f707 	lsl.w	r7, ip, r7
 801517c:	433a      	orrs	r2, r7
        SYSCFG->EXTICR[position >> 2] = temp;
 801517e:	60aa      	str	r2, [r5, #8]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
        temp &= ~((uint32_t)iocurrent);
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00u)
 8015180:	02ce      	lsls	r6, r1, #11
        temp = EXTI->RTSR;
 8015182:	4a52      	ldr	r2, [pc, #328]	@ (80152cc <HAL_GPIO_Init+0x250>)
        temp &= ~((uint32_t)iocurrent);
 8015184:	ea6f 0508 	mvn.w	r5, r8
        {
          temp |= iocurrent;
        }
        EXTI->RTSR = temp;
 8015188:	4e50      	ldr	r6, [pc, #320]	@ (80152cc <HAL_GPIO_Init+0x250>)
  for (position = 0; position < GPIO_NUMBER; position++)
 801518a:	f103 0301 	add.w	r3, r3, #1
        temp = EXTI->RTSR;
 801518e:	6892      	ldr	r2, [r2, #8]
        temp &= ~((uint32_t)iocurrent);
 8015190:	bf54      	ite	pl
 8015192:	402a      	andpl	r2, r5
          temp |= iocurrent;
 8015194:	ea48 0202 	orrmi.w	r2, r8, r2

        temp = EXTI->FTSR;
        temp &= ~((uint32_t)iocurrent);
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00u)
 8015198:	028f      	lsls	r7, r1, #10
        EXTI->RTSR = temp;
 801519a:	60b2      	str	r2, [r6, #8]
        temp = EXTI->FTSR;
 801519c:	68f2      	ldr	r2, [r6, #12]
        {
          temp |= iocurrent;
        }
        EXTI->FTSR = temp;
 801519e:	4e4b      	ldr	r6, [pc, #300]	@ (80152cc <HAL_GPIO_Init+0x250>)
        temp &= ~((uint32_t)iocurrent);
 80151a0:	bf54      	ite	pl
 80151a2:	402a      	andpl	r2, r5
          temp |= iocurrent;
 80151a4:	ea48 0202 	orrmi.w	r2, r8, r2
        EXTI->FTSR = temp;
 80151a8:	60f2      	str	r2, [r6, #12]

        temp = EXTI->EMR;
 80151aa:	6872      	ldr	r2, [r6, #4]
        temp &= ~((uint32_t)iocurrent);
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00u)
 80151ac:	038e      	lsls	r6, r1, #14
        {
          temp |= iocurrent;
        }
        EXTI->EMR = temp;
 80151ae:	4e47      	ldr	r6, [pc, #284]	@ (80152cc <HAL_GPIO_Init+0x250>)
        temp &= ~((uint32_t)iocurrent);
 80151b0:	bf54      	ite	pl
 80151b2:	402a      	andpl	r2, r5
          temp |= iocurrent;
 80151b4:	ea48 0202 	orrmi.w	r2, r8, r2

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
        temp &= ~((uint32_t)iocurrent);
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00u)
 80151b8:	03c9      	lsls	r1, r1, #15
        {
          temp |= iocurrent;
        }
        EXTI->IMR = temp;
 80151ba:	4944      	ldr	r1, [pc, #272]	@ (80152cc <HAL_GPIO_Init+0x250>)
        EXTI->EMR = temp;
 80151bc:	6072      	str	r2, [r6, #4]
        temp = EXTI->IMR;
 80151be:	6832      	ldr	r2, [r6, #0]
        temp &= ~((uint32_t)iocurrent);
 80151c0:	bf54      	ite	pl
 80151c2:	402a      	andpl	r2, r5
          temp |= iocurrent;
 80151c4:	ea48 0202 	orrmi.w	r2, r8, r2
  for (position = 0; position < GPIO_NUMBER; position++)
 80151c8:	2b10      	cmp	r3, #16
        EXTI->IMR = temp;
 80151ca:	600a      	str	r2, [r1, #0]
  for (position = 0; position < GPIO_NUMBER; position++)
 80151cc:	f47f af65 	bne.w	801509a <HAL_GPIO_Init+0x1e>
      }
    }
  }
}
 80151d0:	b005      	add	sp, #20
 80151d2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        temp = GPIOx->OSPEEDR;
 80151d6:	6887      	ldr	r7, [r0, #8]
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 80151d8:	2a02      	cmp	r2, #2
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 80151da:	ea07 0e05 	and.w	lr, r7, r5
        temp |= (GPIO_Init->Speed << (position * 2));
 80151de:	f8d9 700c 	ldr.w	r7, [r9, #12]
 80151e2:	fa07 f70c 	lsl.w	r7, r7, ip
 80151e6:	ea47 070e 	orr.w	r7, r7, lr
        GPIOx->OSPEEDR = temp;
 80151ea:	6087      	str	r7, [r0, #8]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 80151ec:	f3c1 1700 	ubfx	r7, r1, #4, #1
        temp = GPIOx->OTYPER;
 80151f0:	f8d0 e004 	ldr.w	lr, [r0, #4]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 80151f4:	fa07 f703 	lsl.w	r7, r7, r3
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 80151f8:	ea2e 0e08 	bic.w	lr, lr, r8
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 80151fc:	ea47 070e 	orr.w	r7, r7, lr
        GPIOx->OTYPER = temp;
 8015200:	6047      	str	r7, [r0, #4]
        temp |= ((GPIO_Init->Pull) << (position * 2));
 8015202:	f8d9 7008 	ldr.w	r7, [r9, #8]
        temp = GPIOx->PUPDR;
 8015206:	f8d0 e00c 	ldr.w	lr, [r0, #12]
        temp |= ((GPIO_Init->Pull) << (position * 2));
 801520a:	fa07 f70c 	lsl.w	r7, r7, ip
        temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
 801520e:	ea0e 0e05 	and.w	lr, lr, r5
        temp |= ((GPIO_Init->Pull) << (position * 2));
 8015212:	ea47 070e 	orr.w	r7, r7, lr
        GPIOx->PUPDR = temp;
 8015216:	60c7      	str	r7, [r0, #12]
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 8015218:	f47f af56 	bne.w	80150c8 <HAL_GPIO_Init+0x4c>
        temp = GPIOx->AFR[position >> 3];
 801521c:	08df      	lsrs	r7, r3, #3
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 801521e:	f003 0e07 	and.w	lr, r3, #7
 8015222:	eb00 0787 	add.w	r7, r0, r7, lsl #2
 8015226:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
        temp = GPIOx->AFR[position >> 3];
 801522a:	6a3e      	ldr	r6, [r7, #32]
 801522c:	9701      	str	r7, [sp, #4]
 801522e:	9600      	str	r6, [sp, #0]
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8015230:	260f      	movs	r6, #15
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 8015232:	f8d9 7010 	ldr.w	r7, [r9, #16]
 8015236:	fa07 f70e 	lsl.w	r7, r7, lr
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 801523a:	fa06 fe0e 	lsl.w	lr, r6, lr
 801523e:	9e00      	ldr	r6, [sp, #0]
 8015240:	ea26 0e0e 	bic.w	lr, r6, lr
        GPIOx->AFR[position >> 3] = temp;
 8015244:	9e01      	ldr	r6, [sp, #4]
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 8015246:	ea47 070e 	orr.w	r7, r7, lr
        GPIOx->AFR[position >> 3] = temp;
 801524a:	6237      	str	r7, [r6, #32]
 801524c:	e73c      	b.n	80150c8 <HAL_GPIO_Init+0x4c>
        temp = GPIOx->PUPDR;
 801524e:	68c7      	ldr	r7, [r0, #12]
        temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
 8015250:	ea07 0e05 	and.w	lr, r7, r5
        temp |= ((GPIO_Init->Pull) << (position * 2));
 8015254:	f8d9 7008 	ldr.w	r7, [r9, #8]
 8015258:	fa07 f70c 	lsl.w	r7, r7, ip
 801525c:	ea47 070e 	orr.w	r7, r7, lr
        GPIOx->PUPDR = temp;
 8015260:	60c7      	str	r7, [r0, #12]
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 8015262:	e731      	b.n	80150c8 <HAL_GPIO_Init+0x4c>
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 8015264:	f04f 0c01 	mov.w	ip, #1
 8015268:	fa0c f707 	lsl.w	r7, ip, r7
 801526c:	433a      	orrs	r2, r7
 801526e:	e786      	b.n	801517e <HAL_GPIO_Init+0x102>
 8015270:	f04f 0c02 	mov.w	ip, #2
 8015274:	fa0c f707 	lsl.w	r7, ip, r7
 8015278:	433a      	orrs	r2, r7
 801527a:	e780      	b.n	801517e <HAL_GPIO_Init+0x102>
 801527c:	f04f 0c03 	mov.w	ip, #3
 8015280:	fa0c f707 	lsl.w	r7, ip, r7
 8015284:	433a      	orrs	r2, r7
 8015286:	e77a      	b.n	801517e <HAL_GPIO_Init+0x102>
 8015288:	f04f 0c04 	mov.w	ip, #4
 801528c:	fa0c f707 	lsl.w	r7, ip, r7
 8015290:	433a      	orrs	r2, r7
 8015292:	e774      	b.n	801517e <HAL_GPIO_Init+0x102>
 8015294:	f04f 0c07 	mov.w	ip, #7
 8015298:	fa0c f707 	lsl.w	r7, ip, r7
 801529c:	433a      	orrs	r2, r7
 801529e:	e76e      	b.n	801517e <HAL_GPIO_Init+0x102>
 80152a0:	f04f 0c05 	mov.w	ip, #5
 80152a4:	fa0c f707 	lsl.w	r7, ip, r7
 80152a8:	433a      	orrs	r2, r7
 80152aa:	e768      	b.n	801517e <HAL_GPIO_Init+0x102>
 80152ac:	f04f 0c06 	mov.w	ip, #6
 80152b0:	fa0c f707 	lsl.w	r7, ip, r7
 80152b4:	433a      	orrs	r2, r7
 80152b6:	e762      	b.n	801517e <HAL_GPIO_Init+0x102>
 80152b8:	f04f 0c08 	mov.w	ip, #8
 80152bc:	fa0c f707 	lsl.w	r7, ip, r7
 80152c0:	433a      	orrs	r2, r7
 80152c2:	e75c      	b.n	801517e <HAL_GPIO_Init+0x102>
 80152c4:	40020000 	.word	0x40020000
 80152c8:	40020800 	.word	0x40020800
 80152cc:	40013c00 	.word	0x40013c00
 80152d0:	40023800 	.word	0x40023800
 80152d4:	40020c00 	.word	0x40020c00
 80152d8:	40021000 	.word	0x40021000
 80152dc:	40021400 	.word	0x40021400
 80152e0:	40021800 	.word	0x40021800
 80152e4:	40021c00 	.word	0x40021c00
 80152e8:	40022000 	.word	0x40022000
 80152ec:	40022400 	.word	0x40022400

080152f0 <HAL_GPIO_ReadPin>:
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
 80152f0:	6903      	ldr	r3, [r0, #16]
 80152f2:	4219      	tst	r1, r3
  else
  {
    bitstatus = GPIO_PIN_RESET;
  }
  return bitstatus;
}
 80152f4:	bf14      	ite	ne
 80152f6:	2001      	movne	r0, #1
 80152f8:	2000      	moveq	r0, #0
 80152fa:	4770      	bx	lr

080152fc <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 80152fc:	b902      	cbnz	r2, 8015300 <HAL_GPIO_WritePin+0x4>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16;
 80152fe:	0409      	lsls	r1, r1, #16
 8015300:	6181      	str	r1, [r0, #24]
  }
}
 8015302:	4770      	bx	lr

08015304 <I2C_WaitOnFlagUntilTimeout.constprop.0>:
  * @param  Status The actual Flag status (SET or RESET).
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status,
 8015304:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
                                                    uint32_t Timeout, uint32_t Tickstart)
{
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8015308:	6803      	ldr	r3, [r0, #0]
 801530a:	699a      	ldr	r2, [r3, #24]
 801530c:	0414      	lsls	r4, r2, #16
 801530e:	f140 8088 	bpl.w	8015422 <I2C_WaitOnFlagUntilTimeout.constprop.0+0x11e>
 8015312:	4604      	mov	r4, r0
 8015314:	4688      	mov	r8, r1
  HAL_I2C_ModeTypeDef tmp2;

  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_AF))
  {
    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8015316:	f04f 0910 	mov.w	r9, #16
  uint32_t itflag   = hi2c->Instance->ISR;
 801531a:	699e      	ldr	r6, [r3, #24]
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_AF))
 801531c:	f016 0610 	ands.w	r6, r6, #16
 8015320:	f000 8082 	beq.w	8015428 <I2C_WaitOnFlagUntilTimeout.constprop.0+0x124>
  uint32_t error_code = 0;
 8015324:	2600      	movs	r6, #0
  uint32_t tickstart = Tickstart;
 8015326:	4645      	mov	r5, r8
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8015328:	f8c3 901c 	str.w	r9, [r3, #28]
  HAL_StatusTypeDef status = HAL_OK;
 801532c:	4637      	mov	r7, r6

    /* Wait until STOP Flag is set or timeout occurred */
    /* AutoEnd should be initiate after AF */
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
 801532e:	699a      	ldr	r2, [r3, #24]
 8015330:	0692      	lsls	r2, r2, #26
 8015332:	d427      	bmi.n	8015384 <I2C_WaitOnFlagUntilTimeout.constprop.0+0x80>
 8015334:	bb4f      	cbnz	r7, 801538a <I2C_WaitOnFlagUntilTimeout.constprop.0+0x86>
    {
      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
      {
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 8015336:	f7fd fd99 	bl	8012e6c <HAL_GetTick>
 801533a:	1b40      	subs	r0, r0, r5
        {
          tmp1 = (uint32_t)(hi2c->Instance->CR2 & I2C_CR2_STOP);
 801533c:	6823      	ldr	r3, [r4, #0]
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 801533e:	2819      	cmp	r0, #25
 8015340:	d9f5      	bls.n	801532e <I2C_WaitOnFlagUntilTimeout.constprop.0+0x2a>
          tmp1 = (uint32_t)(hi2c->Instance->CR2 & I2C_CR2_STOP);
 8015342:	6858      	ldr	r0, [r3, #4]
          tmp2 = hi2c->Mode;
 8015344:	f894 2042 	ldrb.w	r2, [r4, #66]	@ 0x42

          /* In case of I2C still busy, try to regenerate a STOP manually */
          if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET) && \
 8015348:	6999      	ldr	r1, [r3, #24]
          tmp2 = hi2c->Mode;
 801534a:	b2d2      	uxtb	r2, r2
          if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET) && \
 801534c:	0409      	lsls	r1, r1, #16
 801534e:	d50b      	bpl.n	8015368 <I2C_WaitOnFlagUntilTimeout.constprop.0+0x64>
              (tmp1 != I2C_CR2_STOP) && \
 8015350:	0440      	lsls	r0, r0, #17
 8015352:	d409      	bmi.n	8015368 <I2C_WaitOnFlagUntilTimeout.constprop.0+0x64>
 8015354:	2a20      	cmp	r2, #32
 8015356:	d007      	beq.n	8015368 <I2C_WaitOnFlagUntilTimeout.constprop.0+0x64>
              (tmp2 != HAL_I2C_MODE_SLAVE))
          {
            /* Generate Stop */
            hi2c->Instance->CR2 |= I2C_CR2_STOP;
 8015358:	685a      	ldr	r2, [r3, #4]
 801535a:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
 801535e:	605a      	str	r2, [r3, #4]

            /* Update Tick with new reference */
            tickstart = HAL_GetTick();
 8015360:	f7fd fd84 	bl	8012e6c <HAL_GetTick>
          }

          while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8015364:	6823      	ldr	r3, [r4, #0]
            tickstart = HAL_GetTick();
 8015366:	4605      	mov	r5, r0
          while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8015368:	699a      	ldr	r2, [r3, #24]
 801536a:	0691      	lsls	r1, r2, #26
 801536c:	d4df      	bmi.n	801532e <I2C_WaitOnFlagUntilTimeout.constprop.0+0x2a>
          {
            /* Check for the Timeout */
            if ((HAL_GetTick() - tickstart) > I2C_TIMEOUT_STOPF)
 801536e:	f7fd fd7d 	bl	8012e6c <HAL_GetTick>
 8015372:	1b40      	subs	r0, r0, r5
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
 8015374:	6823      	ldr	r3, [r4, #0]
            if ((HAL_GetTick() - tickstart) > I2C_TIMEOUT_STOPF)
 8015376:	2819      	cmp	r0, #25
 8015378:	d9f6      	bls.n	8015368 <I2C_WaitOnFlagUntilTimeout.constprop.0+0x64>
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
 801537a:	699a      	ldr	r2, [r3, #24]
            {
              error_code |= HAL_I2C_ERROR_TIMEOUT;
 801537c:	2620      	movs	r6, #32

              status = HAL_ERROR;
 801537e:	2701      	movs	r7, #1
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
 8015380:	0692      	lsls	r2, r2, #26
 8015382:	d5d7      	bpl.n	8015334 <I2C_WaitOnFlagUntilTimeout.constprop.0+0x30>
        }
      }
    }

    /* In case STOP Flag is detected, clear it */
    if (status == HAL_OK)
 8015384:	b90f      	cbnz	r7, 801538a <I2C_WaitOnFlagUntilTimeout.constprop.0+0x86>
    {
      /* Clear STOP Flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8015386:	2220      	movs	r2, #32
 8015388:	61da      	str	r2, [r3, #28]
    }

    error_code |= HAL_I2C_ERROR_AF;
 801538a:	f046 0604 	orr.w	r6, r6, #4

    status = HAL_ERROR;
 801538e:	2501      	movs	r5, #1
  }

  /* Refresh Content of Status register */
  itflag = hi2c->Instance->ISR;
 8015390:	699a      	ldr	r2, [r3, #24]

  /* Then verify if an additional errors occurs */
  /* Check if a Bus error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_BERR))
 8015392:	05d7      	lsls	r7, r2, #23
 8015394:	d531      	bpl.n	80153fa <I2C_WaitOnFlagUntilTimeout.constprop.0+0xf6>
  {
    error_code |= HAL_I2C_ERROR_BERR;

    /* Clear BERR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
 8015396:	f44f 7180 	mov.w	r1, #256	@ 0x100

    status = HAL_ERROR;
  }

  /* Check if an Over-Run/Under-Run error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_OVR))
 801539a:	0550      	lsls	r0, r2, #21
    error_code |= HAL_I2C_ERROR_BERR;
 801539c:	f046 0601 	orr.w	r6, r6, #1
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
 80153a0:	61d9      	str	r1, [r3, #28]
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_OVR))
 80153a2:	d504      	bpl.n	80153ae <I2C_WaitOnFlagUntilTimeout.constprop.0+0xaa>
  {
    error_code |= HAL_I2C_ERROR_OVR;

    /* Clear OVR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
 80153a4:	f44f 6180 	mov.w	r1, #1024	@ 0x400
    error_code |= HAL_I2C_ERROR_OVR;
 80153a8:	f046 0608 	orr.w	r6, r6, #8
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
 80153ac:	61d9      	str	r1, [r3, #28]

    status = HAL_ERROR;
  }

  /* Check if an Arbitration Loss error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_ARLO))
 80153ae:	0592      	lsls	r2, r2, #22
 80153b0:	d504      	bpl.n	80153bc <I2C_WaitOnFlagUntilTimeout.constprop.0+0xb8>
  {
    error_code |= HAL_I2C_ERROR_ARLO;

    /* Clear ARLO flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
 80153b2:	f44f 7200 	mov.w	r2, #512	@ 0x200
    error_code |= HAL_I2C_ERROR_ARLO;
 80153b6:	f046 0602 	orr.w	r6, r6, #2
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
 80153ba:	61da      	str	r2, [r3, #28]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 80153bc:	699a      	ldr	r2, [r3, #24]
 80153be:	0795      	lsls	r5, r2, #30
 80153c0:	d501      	bpl.n	80153c6 <I2C_WaitOnFlagUntilTimeout.constprop.0+0xc2>
    hi2c->Instance->TXDR = 0x00U;
 80153c2:	2200      	movs	r2, #0
 80153c4:	629a      	str	r2, [r3, #40]	@ 0x28
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 80153c6:	699a      	ldr	r2, [r3, #24]
 80153c8:	07d0      	lsls	r0, r2, #31
 80153ca:	d403      	bmi.n	80153d4 <I2C_WaitOnFlagUntilTimeout.constprop.0+0xd0>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 80153cc:	699a      	ldr	r2, [r3, #24]
 80153ce:	f042 0201 	orr.w	r2, r2, #1
 80153d2:	619a      	str	r2, [r3, #24]
  {
    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 80153d4:	685a      	ldr	r2, [r3, #4]

    hi2c->ErrorCode |= error_code;
    hi2c->State = HAL_I2C_STATE_READY;
 80153d6:	2020      	movs	r0, #32
    I2C_RESET_CR2(hi2c);
 80153d8:	4d19      	ldr	r5, [pc, #100]	@ (8015440 <I2C_WaitOnFlagUntilTimeout.constprop.0+0x13c>)
    hi2c->Mode = HAL_I2C_MODE_NONE;
 80153da:	2100      	movs	r1, #0
    I2C_RESET_CR2(hi2c);
 80153dc:	402a      	ands	r2, r5
 80153de:	605a      	str	r2, [r3, #4]
    hi2c->ErrorCode |= error_code;
 80153e0:	6c63      	ldr	r3, [r4, #68]	@ 0x44
 80153e2:	4333      	orrs	r3, r6
 80153e4:	6463      	str	r3, [r4, #68]	@ 0x44
    hi2c->State = HAL_I2C_STATE_READY;
 80153e6:	f884 0041 	strb.w	r0, [r4, #65]	@ 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
 80153ea:	f884 1042 	strb.w	r1, [r4, #66]	@ 0x42
          __HAL_UNLOCK(hi2c);
 80153ee:	2300      	movs	r3, #0
      return HAL_ERROR;
 80153f0:	2001      	movs	r0, #1
          __HAL_UNLOCK(hi2c);
 80153f2:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
}
 80153f6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_OVR))
 80153fa:	0551      	lsls	r1, r2, #21
 80153fc:	d4d2      	bmi.n	80153a4 <I2C_WaitOnFlagUntilTimeout.constprop.0+0xa0>
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_ARLO))
 80153fe:	0597      	lsls	r7, r2, #22
 8015400:	d4d7      	bmi.n	80153b2 <I2C_WaitOnFlagUntilTimeout.constprop.0+0xae>
  if (status != HAL_OK)
 8015402:	2d00      	cmp	r5, #0
 8015404:	d1da      	bne.n	80153bc <I2C_WaitOnFlagUntilTimeout.constprop.0+0xb8>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8015406:	f7fd fd31 	bl	8012e6c <HAL_GetTick>
 801540a:	eba0 0008 	sub.w	r0, r0, r8
        if ((__HAL_I2C_GET_FLAG(hi2c, Flag) == Status))
 801540e:	6823      	ldr	r3, [r4, #0]
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8015410:	2819      	cmp	r0, #25
 8015412:	d902      	bls.n	801541a <I2C_WaitOnFlagUntilTimeout.constprop.0+0x116>
        if ((__HAL_I2C_GET_FLAG(hi2c, Flag) == Status))
 8015414:	699a      	ldr	r2, [r3, #24]
 8015416:	0411      	lsls	r1, r2, #16
 8015418:	d408      	bmi.n	801542c <I2C_WaitOnFlagUntilTimeout.constprop.0+0x128>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 801541a:	699a      	ldr	r2, [r3, #24]
 801541c:	0412      	lsls	r2, r2, #16
 801541e:	f53f af7c 	bmi.w	801531a <I2C_WaitOnFlagUntilTimeout.constprop.0+0x16>
  return HAL_OK;
 8015422:	2000      	movs	r0, #0
}
 8015424:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  HAL_StatusTypeDef status = HAL_OK;
 8015428:	4635      	mov	r5, r6
 801542a:	e7b1      	b.n	8015390 <I2C_WaitOnFlagUntilTimeout.constprop.0+0x8c>
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 801542c:	6c63      	ldr	r3, [r4, #68]	@ 0x44
          hi2c->State = HAL_I2C_STATE_READY;
 801542e:	2220      	movs	r2, #32
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8015430:	4313      	orrs	r3, r2
 8015432:	6463      	str	r3, [r4, #68]	@ 0x44
          hi2c->State = HAL_I2C_STATE_READY;
 8015434:	f884 2041 	strb.w	r2, [r4, #65]	@ 0x41
          hi2c->Mode = HAL_I2C_MODE_NONE;
 8015438:	f884 5042 	strb.w	r5, [r4, #66]	@ 0x42
          return HAL_ERROR;
 801543c:	e7d7      	b.n	80153ee <I2C_WaitOnFlagUntilTimeout.constprop.0+0xea>
 801543e:	bf00      	nop
 8015440:	fe00e800 	.word	0xfe00e800

08015444 <I2C_WaitOnTXISFlagUntilTimeout>:
{
 8015444:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 8015448:	6803      	ldr	r3, [r0, #0]
{
 801544a:	4680      	mov	r8, r0
 801544c:	460d      	mov	r5, r1
 801544e:	4692      	mov	sl, r2
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8015450:	2710      	movs	r7, #16
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 8015452:	699c      	ldr	r4, [r3, #24]
 8015454:	f014 0402 	ands.w	r4, r4, #2
 8015458:	f040 80a5 	bne.w	80155a6 <I2C_WaitOnTXISFlagUntilTimeout+0x162>
  uint32_t itflag   = hi2c->Instance->ISR;
 801545c:	699a      	ldr	r2, [r3, #24]
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_AF))
 801545e:	f012 0c10 	ands.w	ip, r2, #16
 8015462:	d078      	beq.n	8015556 <I2C_WaitOnTXISFlagUntilTimeout+0x112>
  uint32_t tickstart = Tickstart;
 8015464:	46d1      	mov	r9, sl
  HAL_StatusTypeDef status = HAL_OK;
 8015466:	4626      	mov	r6, r4
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8015468:	61df      	str	r7, [r3, #28]
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
 801546a:	1c68      	adds	r0, r5, #1
 801546c:	d001      	beq.n	8015472 <I2C_WaitOnTXISFlagUntilTimeout+0x2e>
 801546e:	e041      	b.n	80154f4 <I2C_WaitOnTXISFlagUntilTimeout+0xb0>
 8015470:	b92e      	cbnz	r6, 801547e <I2C_WaitOnTXISFlagUntilTimeout+0x3a>
 8015472:	699a      	ldr	r2, [r3, #24]
 8015474:	0691      	lsls	r1, r2, #26
 8015476:	d5fb      	bpl.n	8015470 <I2C_WaitOnTXISFlagUntilTimeout+0x2c>
    if (status == HAL_OK)
 8015478:	b90e      	cbnz	r6, 801547e <I2C_WaitOnTXISFlagUntilTimeout+0x3a>
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 801547a:	2220      	movs	r2, #32
 801547c:	61da      	str	r2, [r3, #28]
  itflag = hi2c->Instance->ISR;
 801547e:	699a      	ldr	r2, [r3, #24]
    error_code |= HAL_I2C_ERROR_AF;
 8015480:	f044 0c04 	orr.w	ip, r4, #4
    status = HAL_ERROR;
 8015484:	2101      	movs	r1, #1
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_BERR))
 8015486:	05d0      	lsls	r0, r2, #23
 8015488:	d569      	bpl.n	801555e <I2C_WaitOnTXISFlagUntilTimeout+0x11a>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
 801548a:	f44f 7180 	mov.w	r1, #256	@ 0x100
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_OVR))
 801548e:	0557      	lsls	r7, r2, #21
    error_code |= HAL_I2C_ERROR_BERR;
 8015490:	f04c 0c01 	orr.w	ip, ip, #1
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
 8015494:	61d9      	str	r1, [r3, #28]
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_OVR))
 8015496:	d504      	bpl.n	80154a2 <I2C_WaitOnTXISFlagUntilTimeout+0x5e>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
 8015498:	f44f 6180 	mov.w	r1, #1024	@ 0x400
    error_code |= HAL_I2C_ERROR_OVR;
 801549c:	f04c 0c08 	orr.w	ip, ip, #8
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
 80154a0:	61d9      	str	r1, [r3, #28]
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_ARLO))
 80154a2:	0595      	lsls	r5, r2, #22
 80154a4:	d504      	bpl.n	80154b0 <I2C_WaitOnTXISFlagUntilTimeout+0x6c>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
 80154a6:	f44f 7200 	mov.w	r2, #512	@ 0x200
    error_code |= HAL_I2C_ERROR_ARLO;
 80154aa:	f04c 0c02 	orr.w	ip, ip, #2
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
 80154ae:	61da      	str	r2, [r3, #28]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 80154b0:	699a      	ldr	r2, [r3, #24]
 80154b2:	0790      	lsls	r0, r2, #30
 80154b4:	d501      	bpl.n	80154ba <I2C_WaitOnTXISFlagUntilTimeout+0x76>
    hi2c->Instance->TXDR = 0x00U;
 80154b6:	2200      	movs	r2, #0
 80154b8:	629a      	str	r2, [r3, #40]	@ 0x28
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 80154ba:	699a      	ldr	r2, [r3, #24]
 80154bc:	07d1      	lsls	r1, r2, #31
 80154be:	d403      	bmi.n	80154c8 <I2C_WaitOnTXISFlagUntilTimeout+0x84>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 80154c0:	699a      	ldr	r2, [r3, #24]
 80154c2:	f042 0201 	orr.w	r2, r2, #1
 80154c6:	619a      	str	r2, [r3, #24]
    I2C_RESET_CR2(hi2c);
 80154c8:	685a      	ldr	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 80154ca:	2020      	movs	r0, #32
    I2C_RESET_CR2(hi2c);
 80154cc:	4c37      	ldr	r4, [pc, #220]	@ (80155ac <I2C_WaitOnTXISFlagUntilTimeout+0x168>)
    hi2c->Mode = HAL_I2C_MODE_NONE;
 80154ce:	2100      	movs	r1, #0
    I2C_RESET_CR2(hi2c);
 80154d0:	4022      	ands	r2, r4
 80154d2:	605a      	str	r2, [r3, #4]
    hi2c->ErrorCode |= error_code;
 80154d4:	f8d8 3044 	ldr.w	r3, [r8, #68]	@ 0x44
 80154d8:	ea43 030c 	orr.w	r3, r3, ip
 80154dc:	f8c8 3044 	str.w	r3, [r8, #68]	@ 0x44
    hi2c->State = HAL_I2C_STATE_READY;
 80154e0:	f888 0041 	strb.w	r0, [r8, #65]	@ 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
 80154e4:	f888 1042 	strb.w	r1, [r8, #66]	@ 0x42
          __HAL_UNLOCK(hi2c);
 80154e8:	2300      	movs	r3, #0
      return HAL_ERROR;
 80154ea:	2001      	movs	r0, #1
          __HAL_UNLOCK(hi2c);
 80154ec:	f888 3040 	strb.w	r3, [r8, #64]	@ 0x40
}
 80154f0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
 80154f4:	699a      	ldr	r2, [r3, #24]
 80154f6:	0692      	lsls	r2, r2, #26
 80154f8:	d4be      	bmi.n	8015478 <I2C_WaitOnTXISFlagUntilTimeout+0x34>
 80154fa:	2e00      	cmp	r6, #0
 80154fc:	d1bf      	bne.n	801547e <I2C_WaitOnTXISFlagUntilTimeout+0x3a>
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 80154fe:	f7fd fcb5 	bl	8012e6c <HAL_GetTick>
 8015502:	eba0 0009 	sub.w	r0, r0, r9
          tmp1 = (uint32_t)(hi2c->Instance->CR2 & I2C_CR2_STOP);
 8015506:	f8d8 3000 	ldr.w	r3, [r8]
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 801550a:	4285      	cmp	r5, r0
 801550c:	d301      	bcc.n	8015512 <I2C_WaitOnTXISFlagUntilTimeout+0xce>
 801550e:	2d00      	cmp	r5, #0
 8015510:	d1f0      	bne.n	80154f4 <I2C_WaitOnTXISFlagUntilTimeout+0xb0>
          tmp1 = (uint32_t)(hi2c->Instance->CR2 & I2C_CR2_STOP);
 8015512:	6858      	ldr	r0, [r3, #4]
          tmp2 = hi2c->Mode;
 8015514:	f898 2042 	ldrb.w	r2, [r8, #66]	@ 0x42
          if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET) && \
 8015518:	6999      	ldr	r1, [r3, #24]
          tmp2 = hi2c->Mode;
 801551a:	b2d2      	uxtb	r2, r2
          if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET) && \
 801551c:	0409      	lsls	r1, r1, #16
 801551e:	d50c      	bpl.n	801553a <I2C_WaitOnTXISFlagUntilTimeout+0xf6>
              (tmp1 != I2C_CR2_STOP) && \
 8015520:	0441      	lsls	r1, r0, #17
 8015522:	d40a      	bmi.n	801553a <I2C_WaitOnTXISFlagUntilTimeout+0xf6>
 8015524:	2a20      	cmp	r2, #32
 8015526:	d008      	beq.n	801553a <I2C_WaitOnTXISFlagUntilTimeout+0xf6>
            hi2c->Instance->CR2 |= I2C_CR2_STOP;
 8015528:	685a      	ldr	r2, [r3, #4]
 801552a:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
 801552e:	605a      	str	r2, [r3, #4]
            tickstart = HAL_GetTick();
 8015530:	f7fd fc9c 	bl	8012e6c <HAL_GetTick>
          while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8015534:	f8d8 3000 	ldr.w	r3, [r8]
            tickstart = HAL_GetTick();
 8015538:	4681      	mov	r9, r0
          while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 801553a:	699a      	ldr	r2, [r3, #24]
 801553c:	0692      	lsls	r2, r2, #26
 801553e:	d494      	bmi.n	801546a <I2C_WaitOnTXISFlagUntilTimeout+0x26>
            if ((HAL_GetTick() - tickstart) > I2C_TIMEOUT_STOPF)
 8015540:	f7fd fc94 	bl	8012e6c <HAL_GetTick>
 8015544:	eba0 0009 	sub.w	r0, r0, r9
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
 8015548:	f8d8 3000 	ldr.w	r3, [r8]
            if ((HAL_GetTick() - tickstart) > I2C_TIMEOUT_STOPF)
 801554c:	2819      	cmp	r0, #25
 801554e:	d9f4      	bls.n	801553a <I2C_WaitOnTXISFlagUntilTimeout+0xf6>
              error_code |= HAL_I2C_ERROR_TIMEOUT;
 8015550:	2420      	movs	r4, #32
              status = HAL_ERROR;
 8015552:	2601      	movs	r6, #1
 8015554:	e789      	b.n	801546a <I2C_WaitOnTXISFlagUntilTimeout+0x26>
  itflag = hi2c->Instance->ISR;
 8015556:	699a      	ldr	r2, [r3, #24]
  HAL_StatusTypeDef status = HAL_OK;
 8015558:	4661      	mov	r1, ip
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_BERR))
 801555a:	05d0      	lsls	r0, r2, #23
 801555c:	d495      	bmi.n	801548a <I2C_WaitOnTXISFlagUntilTimeout+0x46>
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_OVR))
 801555e:	0556      	lsls	r6, r2, #21
 8015560:	d49a      	bmi.n	8015498 <I2C_WaitOnTXISFlagUntilTimeout+0x54>
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_ARLO))
 8015562:	0594      	lsls	r4, r2, #22
 8015564:	d49f      	bmi.n	80154a6 <I2C_WaitOnTXISFlagUntilTimeout+0x62>
  if (status != HAL_OK)
 8015566:	2900      	cmp	r1, #0
 8015568:	d1a2      	bne.n	80154b0 <I2C_WaitOnTXISFlagUntilTimeout+0x6c>
    if (Timeout != HAL_MAX_DELAY)
 801556a:	1c6a      	adds	r2, r5, #1
 801556c:	f43f af71 	beq.w	8015452 <I2C_WaitOnTXISFlagUntilTimeout+0xe>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8015570:	f7fd fc7c 	bl	8012e6c <HAL_GetTick>
 8015574:	eba0 030a 	sub.w	r3, r0, sl
 8015578:	42ab      	cmp	r3, r5
        if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET))
 801557a:	f8d8 3000 	ldr.w	r3, [r8]
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 801557e:	d802      	bhi.n	8015586 <I2C_WaitOnTXISFlagUntilTimeout+0x142>
 8015580:	2d00      	cmp	r5, #0
 8015582:	f47f af65 	bne.w	8015450 <I2C_WaitOnTXISFlagUntilTimeout+0xc>
        if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET))
 8015586:	699a      	ldr	r2, [r3, #24]
 8015588:	f012 0202 	ands.w	r2, r2, #2
 801558c:	f47f af60 	bne.w	8015450 <I2C_WaitOnTXISFlagUntilTimeout+0xc>
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8015590:	f8d8 3044 	ldr.w	r3, [r8, #68]	@ 0x44
          hi2c->State = HAL_I2C_STATE_READY;
 8015594:	2120      	movs	r1, #32
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8015596:	430b      	orrs	r3, r1
 8015598:	f8c8 3044 	str.w	r3, [r8, #68]	@ 0x44
          hi2c->State = HAL_I2C_STATE_READY;
 801559c:	f888 1041 	strb.w	r1, [r8, #65]	@ 0x41
          hi2c->Mode = HAL_I2C_MODE_NONE;
 80155a0:	f888 2042 	strb.w	r2, [r8, #66]	@ 0x42
          return HAL_ERROR;
 80155a4:	e7a0      	b.n	80154e8 <I2C_WaitOnTXISFlagUntilTimeout+0xa4>
  return HAL_OK;
 80155a6:	2000      	movs	r0, #0
}
 80155a8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80155ac:	fe00e800 	.word	0xfe00e800

080155b0 <I2C_WaitOnFlagUntilTimeout>:
{
 80155b0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80155b4:	461c      	mov	r4, r3
 80155b6:	4683      	mov	fp, r0
 80155b8:	460e      	mov	r6, r1
 80155ba:	4615      	mov	r5, r2
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 80155bc:	6803      	ldr	r3, [r0, #0]
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 80155be:	f04f 0810 	mov.w	r8, #16
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 80155c2:	699a      	ldr	r2, [r3, #24]
 80155c4:	ea36 0202 	bics.w	r2, r6, r2
 80155c8:	bf0c      	ite	eq
 80155ca:	2201      	moveq	r2, #1
 80155cc:	2200      	movne	r2, #0
 80155ce:	42aa      	cmp	r2, r5
 80155d0:	f040 80af 	bne.w	8015732 <I2C_WaitOnFlagUntilTimeout+0x182>
  uint32_t itflag   = hi2c->Instance->ISR;
 80155d4:	699a      	ldr	r2, [r3, #24]
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_AF))
 80155d6:	f012 0c10 	ands.w	ip, r2, #16
 80155da:	d07d      	beq.n	80156d8 <I2C_WaitOnFlagUntilTimeout+0x128>
  uint32_t error_code = 0;
 80155dc:	f04f 0900 	mov.w	r9, #0
  uint32_t tickstart = Tickstart;
 80155e0:	f8dd a028 	ldr.w	sl, [sp, #40]	@ 0x28
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 80155e4:	f8c3 801c 	str.w	r8, [r3, #28]
  HAL_StatusTypeDef status = HAL_OK;
 80155e8:	464f      	mov	r7, r9
 80155ea:	1c60      	adds	r0, r4, #1
 80155ec:	d001      	beq.n	80155f2 <I2C_WaitOnFlagUntilTimeout+0x42>
 80155ee:	e041      	b.n	8015674 <I2C_WaitOnFlagUntilTimeout+0xc4>
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
 80155f0:	b92f      	cbnz	r7, 80155fe <I2C_WaitOnFlagUntilTimeout+0x4e>
 80155f2:	699a      	ldr	r2, [r3, #24]
 80155f4:	0691      	lsls	r1, r2, #26
 80155f6:	d5fb      	bpl.n	80155f0 <I2C_WaitOnFlagUntilTimeout+0x40>
    if (status == HAL_OK)
 80155f8:	b90f      	cbnz	r7, 80155fe <I2C_WaitOnFlagUntilTimeout+0x4e>
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 80155fa:	2220      	movs	r2, #32
 80155fc:	61da      	str	r2, [r3, #28]
  itflag = hi2c->Instance->ISR;
 80155fe:	699a      	ldr	r2, [r3, #24]
    error_code |= HAL_I2C_ERROR_AF;
 8015600:	f049 0c04 	orr.w	ip, r9, #4
    status = HAL_ERROR;
 8015604:	2101      	movs	r1, #1
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_BERR))
 8015606:	05d7      	lsls	r7, r2, #23
 8015608:	d56a      	bpl.n	80156e0 <I2C_WaitOnFlagUntilTimeout+0x130>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
 801560a:	f44f 7180 	mov.w	r1, #256	@ 0x100
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_OVR))
 801560e:	0554      	lsls	r4, r2, #21
    error_code |= HAL_I2C_ERROR_BERR;
 8015610:	f04c 0c01 	orr.w	ip, ip, #1
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
 8015614:	61d9      	str	r1, [r3, #28]
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_OVR))
 8015616:	d504      	bpl.n	8015622 <I2C_WaitOnFlagUntilTimeout+0x72>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
 8015618:	f44f 6180 	mov.w	r1, #1024	@ 0x400
    error_code |= HAL_I2C_ERROR_OVR;
 801561c:	f04c 0c08 	orr.w	ip, ip, #8
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
 8015620:	61d9      	str	r1, [r3, #28]
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_ARLO))
 8015622:	0592      	lsls	r2, r2, #22
 8015624:	d504      	bpl.n	8015630 <I2C_WaitOnFlagUntilTimeout+0x80>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
 8015626:	f44f 7200 	mov.w	r2, #512	@ 0x200
    error_code |= HAL_I2C_ERROR_ARLO;
 801562a:	f04c 0c02 	orr.w	ip, ip, #2
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
 801562e:	61da      	str	r2, [r3, #28]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 8015630:	699a      	ldr	r2, [r3, #24]
 8015632:	0790      	lsls	r0, r2, #30
 8015634:	d501      	bpl.n	801563a <I2C_WaitOnFlagUntilTimeout+0x8a>
    hi2c->Instance->TXDR = 0x00U;
 8015636:	2200      	movs	r2, #0
 8015638:	629a      	str	r2, [r3, #40]	@ 0x28
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 801563a:	699a      	ldr	r2, [r3, #24]
 801563c:	07d1      	lsls	r1, r2, #31
 801563e:	d403      	bmi.n	8015648 <I2C_WaitOnFlagUntilTimeout+0x98>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 8015640:	699a      	ldr	r2, [r3, #24]
 8015642:	f042 0201 	orr.w	r2, r2, #1
 8015646:	619a      	str	r2, [r3, #24]
    I2C_RESET_CR2(hi2c);
 8015648:	685a      	ldr	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 801564a:	2020      	movs	r0, #32
    I2C_RESET_CR2(hi2c);
 801564c:	4c3a      	ldr	r4, [pc, #232]	@ (8015738 <I2C_WaitOnFlagUntilTimeout+0x188>)
    hi2c->Mode = HAL_I2C_MODE_NONE;
 801564e:	2100      	movs	r1, #0
    I2C_RESET_CR2(hi2c);
 8015650:	4022      	ands	r2, r4
 8015652:	605a      	str	r2, [r3, #4]
    hi2c->ErrorCode |= error_code;
 8015654:	f8db 3044 	ldr.w	r3, [fp, #68]	@ 0x44
 8015658:	ea43 030c 	orr.w	r3, r3, ip
 801565c:	f8cb 3044 	str.w	r3, [fp, #68]	@ 0x44
    hi2c->State = HAL_I2C_STATE_READY;
 8015660:	f88b 0041 	strb.w	r0, [fp, #65]	@ 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8015664:	f88b 1042 	strb.w	r1, [fp, #66]	@ 0x42
          __HAL_UNLOCK(hi2c);
 8015668:	2300      	movs	r3, #0
      return HAL_ERROR;
 801566a:	2001      	movs	r0, #1
          __HAL_UNLOCK(hi2c);
 801566c:	f88b 3040 	strb.w	r3, [fp, #64]	@ 0x40
}
 8015670:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
 8015674:	699a      	ldr	r2, [r3, #24]
 8015676:	0692      	lsls	r2, r2, #26
 8015678:	d4be      	bmi.n	80155f8 <I2C_WaitOnFlagUntilTimeout+0x48>
 801567a:	2f00      	cmp	r7, #0
 801567c:	d1bf      	bne.n	80155fe <I2C_WaitOnFlagUntilTimeout+0x4e>
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 801567e:	f7fd fbf5 	bl	8012e6c <HAL_GetTick>
 8015682:	eba0 000a 	sub.w	r0, r0, sl
          tmp1 = (uint32_t)(hi2c->Instance->CR2 & I2C_CR2_STOP);
 8015686:	f8db 3000 	ldr.w	r3, [fp]
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 801568a:	4284      	cmp	r4, r0
 801568c:	d301      	bcc.n	8015692 <I2C_WaitOnFlagUntilTimeout+0xe2>
 801568e:	2c00      	cmp	r4, #0
 8015690:	d1f0      	bne.n	8015674 <I2C_WaitOnFlagUntilTimeout+0xc4>
          tmp1 = (uint32_t)(hi2c->Instance->CR2 & I2C_CR2_STOP);
 8015692:	6859      	ldr	r1, [r3, #4]
          tmp2 = hi2c->Mode;
 8015694:	f89b 2042 	ldrb.w	r2, [fp, #66]	@ 0x42
          if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET) && \
 8015698:	6998      	ldr	r0, [r3, #24]
          tmp2 = hi2c->Mode;
 801569a:	b2d2      	uxtb	r2, r2
          if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET) && \
 801569c:	0400      	lsls	r0, r0, #16
 801569e:	d50c      	bpl.n	80156ba <I2C_WaitOnFlagUntilTimeout+0x10a>
              (tmp1 != I2C_CR2_STOP) && \
 80156a0:	0449      	lsls	r1, r1, #17
 80156a2:	d40a      	bmi.n	80156ba <I2C_WaitOnFlagUntilTimeout+0x10a>
 80156a4:	2a20      	cmp	r2, #32
 80156a6:	d008      	beq.n	80156ba <I2C_WaitOnFlagUntilTimeout+0x10a>
            hi2c->Instance->CR2 |= I2C_CR2_STOP;
 80156a8:	685a      	ldr	r2, [r3, #4]
 80156aa:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
 80156ae:	605a      	str	r2, [r3, #4]
            tickstart = HAL_GetTick();
 80156b0:	f7fd fbdc 	bl	8012e6c <HAL_GetTick>
          while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 80156b4:	f8db 3000 	ldr.w	r3, [fp]
            tickstart = HAL_GetTick();
 80156b8:	4682      	mov	sl, r0
          while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 80156ba:	699a      	ldr	r2, [r3, #24]
 80156bc:	0692      	lsls	r2, r2, #26
 80156be:	d494      	bmi.n	80155ea <I2C_WaitOnFlagUntilTimeout+0x3a>
            if ((HAL_GetTick() - tickstart) > I2C_TIMEOUT_STOPF)
 80156c0:	f7fd fbd4 	bl	8012e6c <HAL_GetTick>
 80156c4:	eba0 000a 	sub.w	r0, r0, sl
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
 80156c8:	f8db 3000 	ldr.w	r3, [fp]
            if ((HAL_GetTick() - tickstart) > I2C_TIMEOUT_STOPF)
 80156cc:	2819      	cmp	r0, #25
 80156ce:	d9f4      	bls.n	80156ba <I2C_WaitOnFlagUntilTimeout+0x10a>
              error_code |= HAL_I2C_ERROR_TIMEOUT;
 80156d0:	f04f 0920 	mov.w	r9, #32
              status = HAL_ERROR;
 80156d4:	2701      	movs	r7, #1
 80156d6:	e788      	b.n	80155ea <I2C_WaitOnFlagUntilTimeout+0x3a>
  itflag = hi2c->Instance->ISR;
 80156d8:	699a      	ldr	r2, [r3, #24]
  HAL_StatusTypeDef status = HAL_OK;
 80156da:	4661      	mov	r1, ip
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_BERR))
 80156dc:	05d7      	lsls	r7, r2, #23
 80156de:	d494      	bmi.n	801560a <I2C_WaitOnFlagUntilTimeout+0x5a>
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_OVR))
 80156e0:	0550      	lsls	r0, r2, #21
 80156e2:	d499      	bmi.n	8015618 <I2C_WaitOnFlagUntilTimeout+0x68>
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_ARLO))
 80156e4:	0597      	lsls	r7, r2, #22
 80156e6:	d49e      	bmi.n	8015626 <I2C_WaitOnFlagUntilTimeout+0x76>
  if (status != HAL_OK)
 80156e8:	2900      	cmp	r1, #0
 80156ea:	d1a1      	bne.n	8015630 <I2C_WaitOnFlagUntilTimeout+0x80>
    if (Timeout != HAL_MAX_DELAY)
 80156ec:	1c62      	adds	r2, r4, #1
 80156ee:	f43f af68 	beq.w	80155c2 <I2C_WaitOnFlagUntilTimeout+0x12>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80156f2:	f7fd fbbb 	bl	8012e6c <HAL_GetTick>
 80156f6:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 80156f8:	1ac3      	subs	r3, r0, r3
 80156fa:	42a3      	cmp	r3, r4
        if ((__HAL_I2C_GET_FLAG(hi2c, Flag) == Status))
 80156fc:	f8db 3000 	ldr.w	r3, [fp]
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8015700:	d802      	bhi.n	8015708 <I2C_WaitOnFlagUntilTimeout+0x158>
 8015702:	2c00      	cmp	r4, #0
 8015704:	f47f af5d 	bne.w	80155c2 <I2C_WaitOnFlagUntilTimeout+0x12>
        if ((__HAL_I2C_GET_FLAG(hi2c, Flag) == Status))
 8015708:	699a      	ldr	r2, [r3, #24]
 801570a:	ea36 0202 	bics.w	r2, r6, r2
 801570e:	bf0c      	ite	eq
 8015710:	2201      	moveq	r2, #1
 8015712:	2200      	movne	r2, #0
 8015714:	42aa      	cmp	r2, r5
 8015716:	f47f af54 	bne.w	80155c2 <I2C_WaitOnFlagUntilTimeout+0x12>
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 801571a:	f8db 3044 	ldr.w	r3, [fp, #68]	@ 0x44
          hi2c->State = HAL_I2C_STATE_READY;
 801571e:	2120      	movs	r1, #32
          hi2c->Mode = HAL_I2C_MODE_NONE;
 8015720:	2200      	movs	r2, #0
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8015722:	430b      	orrs	r3, r1
 8015724:	f8cb 3044 	str.w	r3, [fp, #68]	@ 0x44
          hi2c->State = HAL_I2C_STATE_READY;
 8015728:	f88b 1041 	strb.w	r1, [fp, #65]	@ 0x41
          hi2c->Mode = HAL_I2C_MODE_NONE;
 801572c:	f88b 2042 	strb.w	r2, [fp, #66]	@ 0x42
          return HAL_ERROR;
 8015730:	e79a      	b.n	8015668 <I2C_WaitOnFlagUntilTimeout+0xb8>
  return HAL_OK;
 8015732:	2000      	movs	r0, #0
}
 8015734:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8015738:	fe00e800 	.word	0xfe00e800

0801573c <I2C_WaitOnSTOPFlagUntilTimeout>:
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 801573c:	6803      	ldr	r3, [r0, #0]
{
 801573e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8015742:	4617      	mov	r7, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8015744:	699a      	ldr	r2, [r3, #24]
 8015746:	0694      	lsls	r4, r2, #26
 8015748:	f100 8092 	bmi.w	8015870 <I2C_WaitOnSTOPFlagUntilTimeout+0x134>
 801574c:	4605      	mov	r5, r0
 801574e:	460e      	mov	r6, r1
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8015750:	f04f 0810 	mov.w	r8, #16
  uint32_t itflag   = hi2c->Instance->ISR;
 8015754:	699a      	ldr	r2, [r3, #24]
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_AF))
 8015756:	f012 0c10 	ands.w	ip, r2, #16
 801575a:	f000 808c 	beq.w	8015876 <I2C_WaitOnSTOPFlagUntilTimeout+0x13a>
  uint32_t error_code = 0;
 801575e:	2400      	movs	r4, #0
  uint32_t tickstart = Tickstart;
 8015760:	46b9      	mov	r9, r7
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8015762:	f8c3 801c 	str.w	r8, [r3, #28]
  HAL_StatusTypeDef status = HAL_OK;
 8015766:	46a2      	mov	sl, r4
 8015768:	1c70      	adds	r0, r6, #1
 801576a:	d003      	beq.n	8015774 <I2C_WaitOnSTOPFlagUntilTimeout+0x38>
 801576c:	e043      	b.n	80157f6 <I2C_WaitOnSTOPFlagUntilTimeout+0xba>
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
 801576e:	f1ba 0f00 	cmp.w	sl, #0
 8015772:	d107      	bne.n	8015784 <I2C_WaitOnSTOPFlagUntilTimeout+0x48>
 8015774:	699a      	ldr	r2, [r3, #24]
 8015776:	0691      	lsls	r1, r2, #26
 8015778:	d5f9      	bpl.n	801576e <I2C_WaitOnSTOPFlagUntilTimeout+0x32>
    if (status == HAL_OK)
 801577a:	f1ba 0f00 	cmp.w	sl, #0
 801577e:	d101      	bne.n	8015784 <I2C_WaitOnSTOPFlagUntilTimeout+0x48>
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8015780:	2220      	movs	r2, #32
 8015782:	61da      	str	r2, [r3, #28]
    error_code |= HAL_I2C_ERROR_AF;
 8015784:	f044 0c04 	orr.w	ip, r4, #4
    status = HAL_ERROR;
 8015788:	2101      	movs	r1, #1
  itflag = hi2c->Instance->ISR;
 801578a:	699a      	ldr	r2, [r3, #24]
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_BERR))
 801578c:	05d0      	lsls	r0, r2, #23
 801578e:	d55a      	bpl.n	8015846 <I2C_WaitOnSTOPFlagUntilTimeout+0x10a>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
 8015790:	f44f 7180 	mov.w	r1, #256	@ 0x100
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_OVR))
 8015794:	0554      	lsls	r4, r2, #21
    error_code |= HAL_I2C_ERROR_BERR;
 8015796:	f04c 0c01 	orr.w	ip, ip, #1
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
 801579a:	61d9      	str	r1, [r3, #28]
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_OVR))
 801579c:	d504      	bpl.n	80157a8 <I2C_WaitOnSTOPFlagUntilTimeout+0x6c>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
 801579e:	f44f 6180 	mov.w	r1, #1024	@ 0x400
    error_code |= HAL_I2C_ERROR_OVR;
 80157a2:	f04c 0c08 	orr.w	ip, ip, #8
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
 80157a6:	61d9      	str	r1, [r3, #28]
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_ARLO))
 80157a8:	0596      	lsls	r6, r2, #22
 80157aa:	d504      	bpl.n	80157b6 <I2C_WaitOnSTOPFlagUntilTimeout+0x7a>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
 80157ac:	f44f 7200 	mov.w	r2, #512	@ 0x200
    error_code |= HAL_I2C_ERROR_ARLO;
 80157b0:	f04c 0c02 	orr.w	ip, ip, #2
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
 80157b4:	61da      	str	r2, [r3, #28]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 80157b6:	699a      	ldr	r2, [r3, #24]
 80157b8:	0790      	lsls	r0, r2, #30
 80157ba:	d501      	bpl.n	80157c0 <I2C_WaitOnSTOPFlagUntilTimeout+0x84>
    hi2c->Instance->TXDR = 0x00U;
 80157bc:	2200      	movs	r2, #0
 80157be:	629a      	str	r2, [r3, #40]	@ 0x28
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 80157c0:	699a      	ldr	r2, [r3, #24]
 80157c2:	07d1      	lsls	r1, r2, #31
 80157c4:	d403      	bmi.n	80157ce <I2C_WaitOnSTOPFlagUntilTimeout+0x92>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 80157c6:	699a      	ldr	r2, [r3, #24]
 80157c8:	f042 0201 	orr.w	r2, r2, #1
 80157cc:	619a      	str	r2, [r3, #24]
    I2C_RESET_CR2(hi2c);
 80157ce:	685a      	ldr	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 80157d0:	2020      	movs	r0, #32
    I2C_RESET_CR2(hi2c);
 80157d2:	4c33      	ldr	r4, [pc, #204]	@ (80158a0 <I2C_WaitOnSTOPFlagUntilTimeout+0x164>)
    hi2c->Mode = HAL_I2C_MODE_NONE;
 80157d4:	2100      	movs	r1, #0
    I2C_RESET_CR2(hi2c);
 80157d6:	4022      	ands	r2, r4
 80157d8:	605a      	str	r2, [r3, #4]
    hi2c->ErrorCode |= error_code;
 80157da:	6c6b      	ldr	r3, [r5, #68]	@ 0x44
 80157dc:	ea43 030c 	orr.w	r3, r3, ip
 80157e0:	646b      	str	r3, [r5, #68]	@ 0x44
    hi2c->State = HAL_I2C_STATE_READY;
 80157e2:	f885 0041 	strb.w	r0, [r5, #65]	@ 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
 80157e6:	f885 1042 	strb.w	r1, [r5, #66]	@ 0x42
        __HAL_UNLOCK(hi2c);
 80157ea:	2300      	movs	r3, #0
      return HAL_ERROR;
 80157ec:	2001      	movs	r0, #1
        __HAL_UNLOCK(hi2c);
 80157ee:	f885 3040 	strb.w	r3, [r5, #64]	@ 0x40
}
 80157f2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
 80157f6:	699a      	ldr	r2, [r3, #24]
 80157f8:	0692      	lsls	r2, r2, #26
 80157fa:	d4be      	bmi.n	801577a <I2C_WaitOnSTOPFlagUntilTimeout+0x3e>
 80157fc:	f1ba 0f00 	cmp.w	sl, #0
 8015800:	d1c0      	bne.n	8015784 <I2C_WaitOnSTOPFlagUntilTimeout+0x48>
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 8015802:	f7fd fb33 	bl	8012e6c <HAL_GetTick>
 8015806:	eba0 0009 	sub.w	r0, r0, r9
          tmp1 = (uint32_t)(hi2c->Instance->CR2 & I2C_CR2_STOP);
 801580a:	682b      	ldr	r3, [r5, #0]
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 801580c:	4286      	cmp	r6, r0
 801580e:	d301      	bcc.n	8015814 <I2C_WaitOnSTOPFlagUntilTimeout+0xd8>
 8015810:	2e00      	cmp	r6, #0
 8015812:	d1f0      	bne.n	80157f6 <I2C_WaitOnSTOPFlagUntilTimeout+0xba>
          tmp1 = (uint32_t)(hi2c->Instance->CR2 & I2C_CR2_STOP);
 8015814:	6858      	ldr	r0, [r3, #4]
          tmp2 = hi2c->Mode;
 8015816:	f895 2042 	ldrb.w	r2, [r5, #66]	@ 0x42
          if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET) && \
 801581a:	6999      	ldr	r1, [r3, #24]
          tmp2 = hi2c->Mode;
 801581c:	b2d2      	uxtb	r2, r2
          if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET) && \
 801581e:	0409      	lsls	r1, r1, #16
 8015820:	d503      	bpl.n	801582a <I2C_WaitOnSTOPFlagUntilTimeout+0xee>
              (tmp1 != I2C_CR2_STOP) && \
 8015822:	0441      	lsls	r1, r0, #17
 8015824:	d401      	bmi.n	801582a <I2C_WaitOnSTOPFlagUntilTimeout+0xee>
 8015826:	2a20      	cmp	r2, #32
 8015828:	d130      	bne.n	801588c <I2C_WaitOnSTOPFlagUntilTimeout+0x150>
          while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 801582a:	699a      	ldr	r2, [r3, #24]
 801582c:	0692      	lsls	r2, r2, #26
 801582e:	d49b      	bmi.n	8015768 <I2C_WaitOnSTOPFlagUntilTimeout+0x2c>
            if ((HAL_GetTick() - tickstart) > I2C_TIMEOUT_STOPF)
 8015830:	f7fd fb1c 	bl	8012e6c <HAL_GetTick>
 8015834:	eba0 0009 	sub.w	r0, r0, r9
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
 8015838:	682b      	ldr	r3, [r5, #0]
            if ((HAL_GetTick() - tickstart) > I2C_TIMEOUT_STOPF)
 801583a:	2819      	cmp	r0, #25
 801583c:	d9f5      	bls.n	801582a <I2C_WaitOnSTOPFlagUntilTimeout+0xee>
              error_code |= HAL_I2C_ERROR_TIMEOUT;
 801583e:	2420      	movs	r4, #32
              status = HAL_ERROR;
 8015840:	f04f 0a01 	mov.w	sl, #1
 8015844:	e790      	b.n	8015768 <I2C_WaitOnSTOPFlagUntilTimeout+0x2c>
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_OVR))
 8015846:	0550      	lsls	r0, r2, #21
 8015848:	d4a9      	bmi.n	801579e <I2C_WaitOnSTOPFlagUntilTimeout+0x62>
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_ARLO))
 801584a:	0594      	lsls	r4, r2, #22
 801584c:	d4ae      	bmi.n	80157ac <I2C_WaitOnSTOPFlagUntilTimeout+0x70>
  if (status != HAL_OK)
 801584e:	2900      	cmp	r1, #0
 8015850:	d1b1      	bne.n	80157b6 <I2C_WaitOnSTOPFlagUntilTimeout+0x7a>
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8015852:	f7fd fb0b 	bl	8012e6c <HAL_GetTick>
 8015856:	1bc0      	subs	r0, r0, r7
      if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET))
 8015858:	682b      	ldr	r3, [r5, #0]
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 801585a:	42b0      	cmp	r0, r6
 801585c:	d800      	bhi.n	8015860 <I2C_WaitOnSTOPFlagUntilTimeout+0x124>
 801585e:	b91e      	cbnz	r6, 8015868 <I2C_WaitOnSTOPFlagUntilTimeout+0x12c>
      if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET))
 8015860:	699a      	ldr	r2, [r3, #24]
 8015862:	f012 0220 	ands.w	r2, r2, #32
 8015866:	d008      	beq.n	801587a <I2C_WaitOnSTOPFlagUntilTimeout+0x13e>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8015868:	699a      	ldr	r2, [r3, #24]
 801586a:	0692      	lsls	r2, r2, #26
 801586c:	f57f af72 	bpl.w	8015754 <I2C_WaitOnSTOPFlagUntilTimeout+0x18>
  return HAL_OK;
 8015870:	2000      	movs	r0, #0
}
 8015872:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  HAL_StatusTypeDef status = HAL_OK;
 8015876:	4661      	mov	r1, ip
 8015878:	e787      	b.n	801578a <I2C_WaitOnSTOPFlagUntilTimeout+0x4e>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 801587a:	6c6b      	ldr	r3, [r5, #68]	@ 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 801587c:	2120      	movs	r1, #32
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 801587e:	430b      	orrs	r3, r1
 8015880:	646b      	str	r3, [r5, #68]	@ 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 8015882:	f885 1041 	strb.w	r1, [r5, #65]	@ 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8015886:	f885 2042 	strb.w	r2, [r5, #66]	@ 0x42
        return HAL_ERROR;
 801588a:	e7ae      	b.n	80157ea <I2C_WaitOnSTOPFlagUntilTimeout+0xae>
            hi2c->Instance->CR2 |= I2C_CR2_STOP;
 801588c:	685a      	ldr	r2, [r3, #4]
 801588e:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
 8015892:	605a      	str	r2, [r3, #4]
            tickstart = HAL_GetTick();
 8015894:	f7fd faea 	bl	8012e6c <HAL_GetTick>
          while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8015898:	682b      	ldr	r3, [r5, #0]
            tickstart = HAL_GetTick();
 801589a:	4681      	mov	r9, r0
 801589c:	e7c5      	b.n	801582a <I2C_WaitOnSTOPFlagUntilTimeout+0xee>
 801589e:	bf00      	nop
 80158a0:	fe00e800 	.word	0xfe00e800

080158a4 <HAL_I2C_Init>:
  if (hi2c == NULL)
 80158a4:	2800      	cmp	r0, #0
 80158a6:	d053      	beq.n	8015950 <HAL_I2C_Init+0xac>
{
 80158a8:	b510      	push	{r4, lr}
  if (hi2c->State == HAL_I2C_STATE_RESET)
 80158aa:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
 80158ae:	4604      	mov	r4, r0
 80158b0:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
 80158b4:	2b00      	cmp	r3, #0
 80158b6:	d046      	beq.n	8015946 <HAL_I2C_Init+0xa2>
  __HAL_I2C_DISABLE(hi2c);
 80158b8:	6823      	ldr	r3, [r4, #0]
  hi2c->State = HAL_I2C_STATE_BUSY;
 80158ba:	2124      	movs	r1, #36	@ 0x24
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 80158bc:	6862      	ldr	r2, [r4, #4]
  hi2c->State = HAL_I2C_STATE_BUSY;
 80158be:	f884 1041 	strb.w	r1, [r4, #65]	@ 0x41
  __HAL_I2C_DISABLE(hi2c);
 80158c2:	6819      	ldr	r1, [r3, #0]
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 80158c4:	f022 6270 	bic.w	r2, r2, #251658240	@ 0xf000000
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 80158c8:	68e0      	ldr	r0, [r4, #12]
  __HAL_I2C_DISABLE(hi2c);
 80158ca:	f021 0101 	bic.w	r1, r1, #1
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 80158ce:	2801      	cmp	r0, #1
  __HAL_I2C_DISABLE(hi2c);
 80158d0:	6019      	str	r1, [r3, #0]
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 80158d2:	611a      	str	r2, [r3, #16]
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 80158d4:	689a      	ldr	r2, [r3, #8]
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
 80158d6:	68a1      	ldr	r1, [r4, #8]
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 80158d8:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
 80158dc:	609a      	str	r2, [r3, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 80158de:	d009      	beq.n	80158f4 <HAL_I2C_Init+0x50>
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 80158e0:	f441 4104 	orr.w	r1, r1, #33792	@ 0x8400
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 80158e4:	2802      	cmp	r0, #2
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 80158e6:	6099      	str	r1, [r3, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 80158e8:	d107      	bne.n	80158fa <HAL_I2C_Init+0x56>
    SET_BIT(hi2c->Instance->CR2, I2C_CR2_ADD10);
 80158ea:	685a      	ldr	r2, [r3, #4]
 80158ec:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
 80158f0:	605a      	str	r2, [r3, #4]
 80158f2:	e006      	b.n	8015902 <HAL_I2C_Init+0x5e>
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
 80158f4:	f441 4100 	orr.w	r1, r1, #32768	@ 0x8000
 80158f8:	6099      	str	r1, [r3, #8]
    CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_ADD10);
 80158fa:	685a      	ldr	r2, [r3, #4]
 80158fc:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
 8015900:	605a      	str	r2, [r3, #4]
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 8015902:	6858      	ldr	r0, [r3, #4]
  hi2c->State = HAL_I2C_STATE_READY;
 8015904:	f04f 0c20 	mov.w	ip, #32
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 8015908:	4912      	ldr	r1, [pc, #72]	@ (8015954 <HAL_I2C_Init+0xb0>)
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
 801590a:	6922      	ldr	r2, [r4, #16]
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 801590c:	4301      	orrs	r1, r0
 801590e:	6059      	str	r1, [r3, #4]
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 8015910:	68d9      	ldr	r1, [r3, #12]
 8015912:	f421 4100 	bic.w	r1, r1, #32768	@ 0x8000
 8015916:	60d9      	str	r1, [r3, #12]
                          (hi2c->Init.OwnAddress2Masks << 8));
 8015918:	e9d4 0105 	ldrd	r0, r1, [r4, #20]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
 801591c:	4302      	orrs	r2, r0
 801591e:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 8015922:	e9d4 1007 	ldrd	r1, r0, [r4, #28]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
 8015926:	60da      	str	r2, [r3, #12]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8015928:	2200      	movs	r2, #0
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 801592a:	4301      	orrs	r1, r0
  return HAL_OK;
 801592c:	4610      	mov	r0, r2
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 801592e:	6019      	str	r1, [r3, #0]
  __HAL_I2C_ENABLE(hi2c);
 8015930:	6819      	ldr	r1, [r3, #0]
 8015932:	f041 0101 	orr.w	r1, r1, #1
 8015936:	6019      	str	r1, [r3, #0]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8015938:	6462      	str	r2, [r4, #68]	@ 0x44
  hi2c->State = HAL_I2C_STATE_READY;
 801593a:	f884 c041 	strb.w	ip, [r4, #65]	@ 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
 801593e:	6322      	str	r2, [r4, #48]	@ 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8015940:	f884 2042 	strb.w	r2, [r4, #66]	@ 0x42
}
 8015944:	bd10      	pop	{r4, pc}
    hi2c->Lock = HAL_UNLOCKED;
 8015946:	f880 2040 	strb.w	r2, [r0, #64]	@ 0x40
    HAL_I2C_MspInit(hi2c);
 801594a:	f7fc fc8d 	bl	8012268 <HAL_I2C_MspInit>
 801594e:	e7b3      	b.n	80158b8 <HAL_I2C_Init+0x14>
    return HAL_ERROR;
 8015950:	2001      	movs	r0, #1
}
 8015952:	4770      	bx	lr
 8015954:	02008000 	.word	0x02008000

08015958 <HAL_I2C_Mem_Write>:
{
 8015958:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801595c:	4604      	mov	r4, r0
  if (hi2c->State == HAL_I2C_STATE_READY)
 801595e:	f890 0041 	ldrb.w	r0, [r0, #65]	@ 0x41
{
 8015962:	b083      	sub	sp, #12
  if (hi2c->State == HAL_I2C_STATE_READY)
 8015964:	2820      	cmp	r0, #32
{
 8015966:	f8bd a034 	ldrh.w	sl, [sp, #52]	@ 0x34
 801596a:	9f0e      	ldr	r7, [sp, #56]	@ 0x38
  if (hi2c->State == HAL_I2C_STATE_READY)
 801596c:	d11e      	bne.n	80159ac <HAL_I2C_Mem_Write+0x54>
    if ((pData == NULL) || (Size == 0U))
 801596e:	4698      	mov	r8, r3
 8015970:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 8015972:	b1bb      	cbz	r3, 80159a4 <HAL_I2C_Mem_Write+0x4c>
 8015974:	f1ba 0f00 	cmp.w	sl, #0
 8015978:	d014      	beq.n	80159a4 <HAL_I2C_Mem_Write+0x4c>
    __HAL_LOCK(hi2c);
 801597a:	f894 3040 	ldrb.w	r3, [r4, #64]	@ 0x40
 801597e:	2b01      	cmp	r3, #1
 8015980:	d014      	beq.n	80159ac <HAL_I2C_Mem_Write+0x54>
 8015982:	2301      	movs	r3, #1
 8015984:	460d      	mov	r5, r1
 8015986:	4691      	mov	r9, r2
 8015988:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
    tickstart = HAL_GetTick();
 801598c:	f7fd fa6e 	bl	8012e6c <HAL_GetTick>
 8015990:	4606      	mov	r6, r0
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 8015992:	4620      	mov	r0, r4
 8015994:	4631      	mov	r1, r6
 8015996:	f7ff fcb5 	bl	8015304 <I2C_WaitOnFlagUntilTimeout.constprop.0>
 801599a:	b158      	cbz	r0, 80159b4 <HAL_I2C_Mem_Write+0x5c>
      return  HAL_ERROR;
 801599c:	2001      	movs	r0, #1
}
 801599e:	b003      	add	sp, #12
 80159a0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
 80159a4:	f44f 7300 	mov.w	r3, #512	@ 0x200
 80159a8:	6463      	str	r3, [r4, #68]	@ 0x44
      return  HAL_ERROR;
 80159aa:	e7f7      	b.n	801599c <HAL_I2C_Mem_Write+0x44>
    __HAL_LOCK(hi2c);
 80159ac:	2002      	movs	r0, #2
}
 80159ae:	b003      	add	sp, #12
 80159b0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    hi2c->pBuffPtr  = pData;
 80159b4:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* Declaration of tmp to prevent undefined behavior of volatile usage */
  uint32_t tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
 80159b6:	f3c5 0b09 	ubfx	fp, r5, #0, #10
                             (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
                             (uint32_t)Mode | (uint32_t)Request) & (~0x80000000U));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2, \
 80159ba:	6821      	ldr	r1, [r4, #0]
    hi2c->pBuffPtr  = pData;
 80159bc:	6263      	str	r3, [r4, #36]	@ 0x24
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
 80159be:	2321      	movs	r3, #33	@ 0x21
  MODIFY_REG(hi2c->Instance->CR2, \
 80159c0:	4a5f      	ldr	r2, [pc, #380]	@ (8015b40 <HAL_I2C_Mem_Write+0x1e8>)
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
 80159c2:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 80159c6:	2340      	movs	r3, #64	@ 0x40
    hi2c->XferISR   = NULL;
 80159c8:	6360      	str	r0, [r4, #52]	@ 0x34
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 80159ca:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 80159ce:	6460      	str	r0, [r4, #68]	@ 0x44
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 80159d0:	4620      	mov	r0, r4
    hi2c->XferCount = Size;
 80159d2:	f8a4 a02a 	strh.w	sl, [r4, #42]	@ 0x2a
  MODIFY_REG(hi2c->Instance->CR2, \
 80159d6:	684b      	ldr	r3, [r1, #4]
 80159d8:	4013      	ands	r3, r2
                             (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
 80159da:	fa5f f288 	uxtb.w	r2, r8
  MODIFY_REG(hi2c->Instance->CR2, \
 80159de:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 80159e2:	4a58      	ldr	r2, [pc, #352]	@ (8015b44 <HAL_I2C_Mem_Write+0x1ec>)
 80159e4:	ea43 030b 	orr.w	r3, r3, fp
 80159e8:	431a      	orrs	r2, r3
 80159ea:	604a      	str	r2, [r1, #4]
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 80159ec:	4632      	mov	r2, r6
 80159ee:	4639      	mov	r1, r7
 80159f0:	f7ff fd28 	bl	8015444 <I2C_WaitOnTXISFlagUntilTimeout>
 80159f4:	2800      	cmp	r0, #0
 80159f6:	d176      	bne.n	8015ae6 <HAL_I2C_Mem_Write+0x18e>
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
 80159f8:	f1b8 0f01 	cmp.w	r8, #1
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 80159fc:	6823      	ldr	r3, [r4, #0]
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
 80159fe:	d169      	bne.n	8015ad4 <HAL_I2C_Mem_Write+0x17c>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8015a00:	fa5f f289 	uxtb.w	r2, r9
 8015a04:	629a      	str	r2, [r3, #40]	@ 0x28
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, Tickstart) != HAL_OK)
 8015a06:	463b      	mov	r3, r7
 8015a08:	2200      	movs	r2, #0
 8015a0a:	2180      	movs	r1, #128	@ 0x80
 8015a0c:	4620      	mov	r0, r4
 8015a0e:	9600      	str	r6, [sp, #0]
 8015a10:	f7ff fdce 	bl	80155b0 <I2C_WaitOnFlagUntilTimeout>
 8015a14:	2800      	cmp	r0, #0
 8015a16:	d166      	bne.n	8015ae6 <HAL_I2C_Mem_Write+0x18e>
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8015a18:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
  MODIFY_REG(hi2c->Instance->CR2, \
 8015a1a:	6822      	ldr	r2, [r4, #0]
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8015a1c:	b29b      	uxth	r3, r3
 8015a1e:	2bff      	cmp	r3, #255	@ 0xff
 8015a20:	d965      	bls.n	8015aee <HAL_I2C_Mem_Write+0x196>
  MODIFY_REG(hi2c->Instance->CR2, \
 8015a22:	6853      	ldr	r3, [r2, #4]
 8015a24:	4948      	ldr	r1, [pc, #288]	@ (8015b48 <HAL_I2C_Mem_Write+0x1f0>)
 8015a26:	400b      	ands	r3, r1
 8015a28:	4948      	ldr	r1, [pc, #288]	@ (8015b4c <HAL_I2C_Mem_Write+0x1f4>)
 8015a2a:	ea43 030b 	orr.w	r3, r3, fp
 8015a2e:	4319      	orrs	r1, r3
      hi2c->XferSize = MAX_NBYTE_SIZE;
 8015a30:	23ff      	movs	r3, #255	@ 0xff
 8015a32:	8523      	strh	r3, [r4, #40]	@ 0x28
  MODIFY_REG(hi2c->Instance->CR2, \
 8015a34:	6051      	str	r1, [r2, #4]
             ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | \
               (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | \
               I2C_CR2_START | I2C_CR2_STOP)), tmp);
}
 8015a36:	e003      	b.n	8015a40 <HAL_I2C_Mem_Write+0xe8>
    } while (hi2c->XferCount > 0U);
 8015a38:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
 8015a3a:	b29b      	uxth	r3, r3
 8015a3c:	2b00      	cmp	r3, #0
 8015a3e:	d069      	beq.n	8015b14 <HAL_I2C_Mem_Write+0x1bc>
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8015a40:	4632      	mov	r2, r6
 8015a42:	4639      	mov	r1, r7
 8015a44:	4620      	mov	r0, r4
 8015a46:	f7ff fcfd 	bl	8015444 <I2C_WaitOnTXISFlagUntilTimeout>
 8015a4a:	4602      	mov	r2, r0
 8015a4c:	2800      	cmp	r0, #0
 8015a4e:	d1a5      	bne.n	801599c <HAL_I2C_Mem_Write+0x44>
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
 8015a50:	6a60      	ldr	r0, [r4, #36]	@ 0x24
 8015a52:	6825      	ldr	r5, [r4, #0]
 8015a54:	f810 1b01 	ldrb.w	r1, [r0], #1
      hi2c->XferSize--;
 8015a58:	8d23      	ldrh	r3, [r4, #40]	@ 0x28
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
 8015a5a:	62a9      	str	r1, [r5, #40]	@ 0x28
      hi2c->XferCount--;
 8015a5c:	f8b4 c02a 	ldrh.w	ip, [r4, #42]	@ 0x2a
      hi2c->XferSize--;
 8015a60:	3b01      	subs	r3, #1
      hi2c->pBuffPtr++;
 8015a62:	6260      	str	r0, [r4, #36]	@ 0x24
      hi2c->XferCount--;
 8015a64:	f10c 3cff 	add.w	ip, ip, #4294967295
      hi2c->XferSize--;
 8015a68:	b29b      	uxth	r3, r3
      hi2c->XferCount--;
 8015a6a:	fa1f fc8c 	uxth.w	ip, ip
      hi2c->XferSize--;
 8015a6e:	8523      	strh	r3, [r4, #40]	@ 0x28
      hi2c->XferCount--;
 8015a70:	f8a4 c02a 	strh.w	ip, [r4, #42]	@ 0x2a
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 8015a74:	8d61      	ldrh	r1, [r4, #42]	@ 0x2a
 8015a76:	b289      	uxth	r1, r1
 8015a78:	2b00      	cmp	r3, #0
 8015a7a:	d1dd      	bne.n	8015a38 <HAL_I2C_Mem_Write+0xe0>
 8015a7c:	2900      	cmp	r1, #0
 8015a7e:	d0db      	beq.n	8015a38 <HAL_I2C_Mem_Write+0xe0>
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 8015a80:	463b      	mov	r3, r7
 8015a82:	2180      	movs	r1, #128	@ 0x80
 8015a84:	4620      	mov	r0, r4
 8015a86:	9600      	str	r6, [sp, #0]
 8015a88:	f7ff fd92 	bl	80155b0 <I2C_WaitOnFlagUntilTimeout>
          hi2c->XferSize = MAX_NBYTE_SIZE;
 8015a8c:	f04f 0cff 	mov.w	ip, #255	@ 0xff
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 8015a90:	2800      	cmp	r0, #0
 8015a92:	d183      	bne.n	801599c <HAL_I2C_Mem_Write+0x44>
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8015a94:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
  MODIFY_REG(hi2c->Instance->CR2, \
 8015a96:	f8df e0b0 	ldr.w	lr, [pc, #176]	@ 8015b48 <HAL_I2C_Mem_Write+0x1f0>
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8015a9a:	b29b      	uxth	r3, r3
  MODIFY_REG(hi2c->Instance->CR2, \
 8015a9c:	492b      	ldr	r1, [pc, #172]	@ (8015b4c <HAL_I2C_Mem_Write+0x1f4>)
 8015a9e:	4670      	mov	r0, lr
 8015aa0:	6822      	ldr	r2, [r4, #0]
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8015aa2:	4563      	cmp	r3, ip
 8015aa4:	d909      	bls.n	8015aba <HAL_I2C_Mem_Write+0x162>
  MODIFY_REG(hi2c->Instance->CR2, \
 8015aa6:	6853      	ldr	r3, [r2, #4]
          hi2c->XferSize = MAX_NBYTE_SIZE;
 8015aa8:	f8a4 c028 	strh.w	ip, [r4, #40]	@ 0x28
  MODIFY_REG(hi2c->Instance->CR2, \
 8015aac:	ea03 030e 	and.w	r3, r3, lr
 8015ab0:	ea43 030b 	orr.w	r3, r3, fp
 8015ab4:	4319      	orrs	r1, r3
 8015ab6:	6051      	str	r1, [r2, #4]
}
 8015ab8:	e7be      	b.n	8015a38 <HAL_I2C_Mem_Write+0xe0>
          hi2c->XferSize = hi2c->XferCount;
 8015aba:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
  MODIFY_REG(hi2c->Instance->CR2, \
 8015abc:	6851      	ldr	r1, [r2, #4]
          hi2c->XferSize = hi2c->XferCount;
 8015abe:	b29b      	uxth	r3, r3
  MODIFY_REG(hi2c->Instance->CR2, \
 8015ac0:	4001      	ands	r1, r0
          hi2c->XferSize = hi2c->XferCount;
 8015ac2:	8523      	strh	r3, [r4, #40]	@ 0x28
                             (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
 8015ac4:	b2db      	uxtb	r3, r3
  MODIFY_REG(hi2c->Instance->CR2, \
 8015ac6:	ea4b 4303 	orr.w	r3, fp, r3, lsl #16
 8015aca:	430b      	orrs	r3, r1
 8015acc:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
 8015ad0:	6053      	str	r3, [r2, #4]
}
 8015ad2:	e7b1      	b.n	8015a38 <HAL_I2C_Mem_Write+0xe0>
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
 8015ad4:	ea4f 2219 	mov.w	r2, r9, lsr #8
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8015ad8:	4639      	mov	r1, r7
 8015ada:	4620      	mov	r0, r4
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
 8015adc:	629a      	str	r2, [r3, #40]	@ 0x28
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8015ade:	4632      	mov	r2, r6
 8015ae0:	f7ff fcb0 	bl	8015444 <I2C_WaitOnTXISFlagUntilTimeout>
 8015ae4:	b188      	cbz	r0, 8015b0a <HAL_I2C_Mem_Write+0x1b2>
      __HAL_UNLOCK(hi2c);
 8015ae6:	2300      	movs	r3, #0
 8015ae8:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
      return HAL_ERROR;
 8015aec:	e756      	b.n	801599c <HAL_I2C_Mem_Write+0x44>
      hi2c->XferSize = hi2c->XferCount;
 8015aee:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
  MODIFY_REG(hi2c->Instance->CR2, \
 8015af0:	4815      	ldr	r0, [pc, #84]	@ (8015b48 <HAL_I2C_Mem_Write+0x1f0>)
      hi2c->XferSize = hi2c->XferCount;
 8015af2:	b29b      	uxth	r3, r3
  MODIFY_REG(hi2c->Instance->CR2, \
 8015af4:	6851      	ldr	r1, [r2, #4]
      hi2c->XferSize = hi2c->XferCount;
 8015af6:	8523      	strh	r3, [r4, #40]	@ 0x28
                             (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
 8015af8:	b2db      	uxtb	r3, r3
  MODIFY_REG(hi2c->Instance->CR2, \
 8015afa:	4001      	ands	r1, r0
 8015afc:	ea4b 4303 	orr.w	r3, fp, r3, lsl #16
 8015b00:	430b      	orrs	r3, r1
 8015b02:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
 8015b06:	6053      	str	r3, [r2, #4]
}
 8015b08:	e79a      	b.n	8015a40 <HAL_I2C_Mem_Write+0xe8>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8015b0a:	fa5f f289 	uxtb.w	r2, r9
 8015b0e:	6823      	ldr	r3, [r4, #0]
 8015b10:	629a      	str	r2, [r3, #40]	@ 0x28
 8015b12:	e778      	b.n	8015a06 <HAL_I2C_Mem_Write+0xae>
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8015b14:	4632      	mov	r2, r6
 8015b16:	4639      	mov	r1, r7
 8015b18:	4620      	mov	r0, r4
 8015b1a:	f7ff fe0f 	bl	801573c <I2C_WaitOnSTOPFlagUntilTimeout>
 8015b1e:	2800      	cmp	r0, #0
 8015b20:	f47f af3c 	bne.w	801599c <HAL_I2C_Mem_Write+0x44>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8015b24:	6823      	ldr	r3, [r4, #0]
 8015b26:	2120      	movs	r1, #32
    I2C_RESET_CR2(hi2c);
 8015b28:	4d09      	ldr	r5, [pc, #36]	@ (8015b50 <HAL_I2C_Mem_Write+0x1f8>)
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8015b2a:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
 8015b2c:	685a      	ldr	r2, [r3, #4]
 8015b2e:	402a      	ands	r2, r5
 8015b30:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 8015b32:	f884 1041 	strb.w	r1, [r4, #65]	@ 0x41
    __HAL_UNLOCK(hi2c);
 8015b36:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 8015b3a:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
    return HAL_OK;
 8015b3e:	e72e      	b.n	801599e <HAL_I2C_Mem_Write+0x46>
 8015b40:	fc009800 	.word	0xfc009800
 8015b44:	01002000 	.word	0x01002000
 8015b48:	fc009c00 	.word	0xfc009c00
 8015b4c:	01ff0000 	.word	0x01ff0000
 8015b50:	fe00e800 	.word	0xfe00e800

08015b54 <HAL_I2C_Mem_Read>:
{
 8015b54:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8015b58:	4604      	mov	r4, r0
  if (hi2c->State == HAL_I2C_STATE_READY)
 8015b5a:	f890 0041 	ldrb.w	r0, [r0, #65]	@ 0x41
{
 8015b5e:	b082      	sub	sp, #8
  if (hi2c->State == HAL_I2C_STATE_READY)
 8015b60:	2820      	cmp	r0, #32
{
 8015b62:	f8bd a02c 	ldrh.w	sl, [sp, #44]	@ 0x2c
 8015b66:	9f0c      	ldr	r7, [sp, #48]	@ 0x30
  if (hi2c->State == HAL_I2C_STATE_READY)
 8015b68:	d11e      	bne.n	8015ba8 <HAL_I2C_Mem_Read+0x54>
    if ((pData == NULL) || (Size == 0U))
 8015b6a:	4698      	mov	r8, r3
 8015b6c:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8015b6e:	b1bb      	cbz	r3, 8015ba0 <HAL_I2C_Mem_Read+0x4c>
 8015b70:	f1ba 0f00 	cmp.w	sl, #0
 8015b74:	d014      	beq.n	8015ba0 <HAL_I2C_Mem_Read+0x4c>
    __HAL_LOCK(hi2c);
 8015b76:	f894 3040 	ldrb.w	r3, [r4, #64]	@ 0x40
 8015b7a:	2b01      	cmp	r3, #1
 8015b7c:	d014      	beq.n	8015ba8 <HAL_I2C_Mem_Read+0x54>
 8015b7e:	2301      	movs	r3, #1
 8015b80:	460d      	mov	r5, r1
 8015b82:	4691      	mov	r9, r2
 8015b84:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
    tickstart = HAL_GetTick();
 8015b88:	f7fd f970 	bl	8012e6c <HAL_GetTick>
 8015b8c:	4606      	mov	r6, r0
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 8015b8e:	4620      	mov	r0, r4
 8015b90:	4631      	mov	r1, r6
 8015b92:	f7ff fbb7 	bl	8015304 <I2C_WaitOnFlagUntilTimeout.constprop.0>
 8015b96:	b158      	cbz	r0, 8015bb0 <HAL_I2C_Mem_Read+0x5c>
      return  HAL_ERROR;
 8015b98:	2001      	movs	r0, #1
}
 8015b9a:	b002      	add	sp, #8
 8015b9c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
 8015ba0:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8015ba4:	6463      	str	r3, [r4, #68]	@ 0x44
      return  HAL_ERROR;
 8015ba6:	e7f7      	b.n	8015b98 <HAL_I2C_Mem_Read+0x44>
    __HAL_LOCK(hi2c);
 8015ba8:	2002      	movs	r0, #2
}
 8015baa:	b002      	add	sp, #8
 8015bac:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    hi2c->pBuffPtr  = pData;
 8015bb0:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
  uint32_t tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
 8015bb2:	f3c5 0509 	ubfx	r5, r5, #0, #10
  MODIFY_REG(hi2c->Instance->CR2, \
 8015bb6:	6822      	ldr	r2, [r4, #0]
    hi2c->pBuffPtr  = pData;
 8015bb8:	6263      	str	r3, [r4, #36]	@ 0x24
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
 8015bba:	2322      	movs	r3, #34	@ 0x22
  MODIFY_REG(hi2c->Instance->CR2, \
 8015bbc:	495f      	ldr	r1, [pc, #380]	@ (8015d3c <HAL_I2C_Mem_Read+0x1e8>)
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
 8015bbe:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 8015bc2:	2340      	movs	r3, #64	@ 0x40
    hi2c->XferISR   = NULL;
 8015bc4:	6360      	str	r0, [r4, #52]	@ 0x34
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 8015bc6:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8015bca:	6460      	str	r0, [r4, #68]	@ 0x44
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8015bcc:	4620      	mov	r0, r4
    hi2c->XferCount = Size;
 8015bce:	f8a4 a02a 	strh.w	sl, [r4, #42]	@ 0x2a
  MODIFY_REG(hi2c->Instance->CR2, \
 8015bd2:	6853      	ldr	r3, [r2, #4]
 8015bd4:	400b      	ands	r3, r1
                             (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
 8015bd6:	fa5f f188 	uxtb.w	r1, r8
  MODIFY_REG(hi2c->Instance->CR2, \
 8015bda:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8015bde:	4639      	mov	r1, r7
  MODIFY_REG(hi2c->Instance->CR2, \
 8015be0:	432b      	orrs	r3, r5
 8015be2:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 8015be6:	6053      	str	r3, [r2, #4]
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8015be8:	4632      	mov	r2, r6
 8015bea:	f7ff fc2b 	bl	8015444 <I2C_WaitOnTXISFlagUntilTimeout>
 8015bee:	2800      	cmp	r0, #0
 8015bf0:	d177      	bne.n	8015ce2 <HAL_I2C_Mem_Read+0x18e>
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
 8015bf2:	f1b8 0f01 	cmp.w	r8, #1
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8015bf6:	6823      	ldr	r3, [r4, #0]
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
 8015bf8:	d16a      	bne.n	8015cd0 <HAL_I2C_Mem_Read+0x17c>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8015bfa:	fa5f f289 	uxtb.w	r2, r9
 8015bfe:	629a      	str	r2, [r3, #40]	@ 0x28
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)
 8015c00:	463b      	mov	r3, r7
 8015c02:	2200      	movs	r2, #0
 8015c04:	2140      	movs	r1, #64	@ 0x40
 8015c06:	4620      	mov	r0, r4
 8015c08:	9600      	str	r6, [sp, #0]
 8015c0a:	f7ff fcd1 	bl	80155b0 <I2C_WaitOnFlagUntilTimeout>
 8015c0e:	2800      	cmp	r0, #0
 8015c10:	d167      	bne.n	8015ce2 <HAL_I2C_Mem_Read+0x18e>
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8015c12:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
  MODIFY_REG(hi2c->Instance->CR2, \
 8015c14:	6822      	ldr	r2, [r4, #0]
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8015c16:	b29b      	uxth	r3, r3
 8015c18:	2bff      	cmp	r3, #255	@ 0xff
 8015c1a:	d966      	bls.n	8015cea <HAL_I2C_Mem_Read+0x196>
  MODIFY_REG(hi2c->Instance->CR2, \
 8015c1c:	6853      	ldr	r3, [r2, #4]
 8015c1e:	4947      	ldr	r1, [pc, #284]	@ (8015d3c <HAL_I2C_Mem_Read+0x1e8>)
 8015c20:	400b      	ands	r3, r1
 8015c22:	4947      	ldr	r1, [pc, #284]	@ (8015d40 <HAL_I2C_Mem_Read+0x1ec>)
 8015c24:	432b      	orrs	r3, r5
 8015c26:	4319      	orrs	r1, r3
      hi2c->XferSize = 1U;
 8015c28:	2301      	movs	r3, #1
 8015c2a:	8523      	strh	r3, [r4, #40]	@ 0x28
  MODIFY_REG(hi2c->Instance->CR2, \
 8015c2c:	6051      	str	r1, [r2, #4]
}
 8015c2e:	e003      	b.n	8015c38 <HAL_I2C_Mem_Read+0xe4>
    } while (hi2c->XferCount > 0U);
 8015c30:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
 8015c32:	b29b      	uxth	r3, r3
 8015c34:	2b00      	cmp	r3, #0
 8015c36:	d06b      	beq.n	8015d10 <HAL_I2C_Mem_Read+0x1bc>
      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout, tickstart) != HAL_OK)
 8015c38:	463b      	mov	r3, r7
 8015c3a:	2200      	movs	r2, #0
 8015c3c:	2104      	movs	r1, #4
 8015c3e:	4620      	mov	r0, r4
 8015c40:	9600      	str	r6, [sp, #0]
 8015c42:	f7ff fcb5 	bl	80155b0 <I2C_WaitOnFlagUntilTimeout>
 8015c46:	2800      	cmp	r0, #0
 8015c48:	d1a6      	bne.n	8015b98 <HAL_I2C_Mem_Read+0x44>
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 8015c4a:	6821      	ldr	r1, [r4, #0]
 8015c4c:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 8015c4e:	6a49      	ldr	r1, [r1, #36]	@ 0x24
 8015c50:	7019      	strb	r1, [r3, #0]
      hi2c->XferCount--;
 8015c52:	f8b4 c02a 	ldrh.w	ip, [r4, #42]	@ 0x2a
      hi2c->XferSize--;
 8015c56:	8d23      	ldrh	r3, [r4, #40]	@ 0x28
      hi2c->pBuffPtr++;
 8015c58:	6a61      	ldr	r1, [r4, #36]	@ 0x24
      hi2c->XferCount--;
 8015c5a:	f10c 3cff 	add.w	ip, ip, #4294967295
      hi2c->XferSize--;
 8015c5e:	3b01      	subs	r3, #1
      hi2c->pBuffPtr++;
 8015c60:	3101      	adds	r1, #1
      hi2c->XferCount--;
 8015c62:	fa1f fc8c 	uxth.w	ip, ip
      hi2c->XferSize--;
 8015c66:	b29b      	uxth	r3, r3
      hi2c->pBuffPtr++;
 8015c68:	6261      	str	r1, [r4, #36]	@ 0x24
      hi2c->XferCount--;
 8015c6a:	f8a4 c02a 	strh.w	ip, [r4, #42]	@ 0x2a
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 8015c6e:	8d61      	ldrh	r1, [r4, #42]	@ 0x2a
      hi2c->XferSize--;
 8015c70:	8523      	strh	r3, [r4, #40]	@ 0x28
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 8015c72:	b289      	uxth	r1, r1
 8015c74:	2b00      	cmp	r3, #0
 8015c76:	d1db      	bne.n	8015c30 <HAL_I2C_Mem_Read+0xdc>
 8015c78:	2900      	cmp	r1, #0
 8015c7a:	d0d9      	beq.n	8015c30 <HAL_I2C_Mem_Read+0xdc>
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 8015c7c:	4602      	mov	r2, r0
 8015c7e:	463b      	mov	r3, r7
 8015c80:	2180      	movs	r1, #128	@ 0x80
 8015c82:	4620      	mov	r0, r4
 8015c84:	9600      	str	r6, [sp, #0]
 8015c86:	f7ff fc93 	bl	80155b0 <I2C_WaitOnFlagUntilTimeout>
          hi2c->XferSize = 1U;
 8015c8a:	f04f 0c01 	mov.w	ip, #1
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 8015c8e:	2800      	cmp	r0, #0
 8015c90:	d182      	bne.n	8015b98 <HAL_I2C_Mem_Read+0x44>
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8015c92:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
  MODIFY_REG(hi2c->Instance->CR2, \
 8015c94:	f8df e0b8 	ldr.w	lr, [pc, #184]	@ 8015d50 <HAL_I2C_Mem_Read+0x1fc>
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8015c98:	b29b      	uxth	r3, r3
  MODIFY_REG(hi2c->Instance->CR2, \
 8015c9a:	492a      	ldr	r1, [pc, #168]	@ (8015d44 <HAL_I2C_Mem_Read+0x1f0>)
 8015c9c:	4670      	mov	r0, lr
 8015c9e:	6822      	ldr	r2, [r4, #0]
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8015ca0:	2bff      	cmp	r3, #255	@ 0xff
 8015ca2:	d908      	bls.n	8015cb6 <HAL_I2C_Mem_Read+0x162>
  MODIFY_REG(hi2c->Instance->CR2, \
 8015ca4:	6853      	ldr	r3, [r2, #4]
          hi2c->XferSize = 1U;
 8015ca6:	f8a4 c028 	strh.w	ip, [r4, #40]	@ 0x28
  MODIFY_REG(hi2c->Instance->CR2, \
 8015caa:	ea03 030e 	and.w	r3, r3, lr
 8015cae:	432b      	orrs	r3, r5
 8015cb0:	4319      	orrs	r1, r3
 8015cb2:	6051      	str	r1, [r2, #4]
}
 8015cb4:	e7bc      	b.n	8015c30 <HAL_I2C_Mem_Read+0xdc>
          hi2c->XferSize = hi2c->XferCount;
 8015cb6:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
  MODIFY_REG(hi2c->Instance->CR2, \
 8015cb8:	6851      	ldr	r1, [r2, #4]
          hi2c->XferSize = hi2c->XferCount;
 8015cba:	b29b      	uxth	r3, r3
  MODIFY_REG(hi2c->Instance->CR2, \
 8015cbc:	4001      	ands	r1, r0
          hi2c->XferSize = hi2c->XferCount;
 8015cbe:	8523      	strh	r3, [r4, #40]	@ 0x28
                             (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
 8015cc0:	b2db      	uxtb	r3, r3
  MODIFY_REG(hi2c->Instance->CR2, \
 8015cc2:	ea45 4303 	orr.w	r3, r5, r3, lsl #16
 8015cc6:	430b      	orrs	r3, r1
 8015cc8:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
 8015ccc:	6053      	str	r3, [r2, #4]
}
 8015cce:	e7af      	b.n	8015c30 <HAL_I2C_Mem_Read+0xdc>
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
 8015cd0:	ea4f 2219 	mov.w	r2, r9, lsr #8
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8015cd4:	4639      	mov	r1, r7
 8015cd6:	4620      	mov	r0, r4
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
 8015cd8:	629a      	str	r2, [r3, #40]	@ 0x28
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8015cda:	4632      	mov	r2, r6
 8015cdc:	f7ff fbb2 	bl	8015444 <I2C_WaitOnTXISFlagUntilTimeout>
 8015ce0:	b188      	cbz	r0, 8015d06 <HAL_I2C_Mem_Read+0x1b2>
      __HAL_UNLOCK(hi2c);
 8015ce2:	2300      	movs	r3, #0
 8015ce4:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
      return HAL_ERROR;
 8015ce8:	e756      	b.n	8015b98 <HAL_I2C_Mem_Read+0x44>
      hi2c->XferSize = hi2c->XferCount;
 8015cea:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
  MODIFY_REG(hi2c->Instance->CR2, \
 8015cec:	4813      	ldr	r0, [pc, #76]	@ (8015d3c <HAL_I2C_Mem_Read+0x1e8>)
      hi2c->XferSize = hi2c->XferCount;
 8015cee:	b29b      	uxth	r3, r3
  MODIFY_REG(hi2c->Instance->CR2, \
 8015cf0:	6851      	ldr	r1, [r2, #4]
      hi2c->XferSize = hi2c->XferCount;
 8015cf2:	8523      	strh	r3, [r4, #40]	@ 0x28
                             (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
 8015cf4:	b2db      	uxtb	r3, r3
  MODIFY_REG(hi2c->Instance->CR2, \
 8015cf6:	4001      	ands	r1, r0
 8015cf8:	ea45 4303 	orr.w	r3, r5, r3, lsl #16
 8015cfc:	430b      	orrs	r3, r1
 8015cfe:	4912      	ldr	r1, [pc, #72]	@ (8015d48 <HAL_I2C_Mem_Read+0x1f4>)
 8015d00:	4319      	orrs	r1, r3
 8015d02:	6051      	str	r1, [r2, #4]
}
 8015d04:	e798      	b.n	8015c38 <HAL_I2C_Mem_Read+0xe4>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8015d06:	fa5f f289 	uxtb.w	r2, r9
 8015d0a:	6823      	ldr	r3, [r4, #0]
 8015d0c:	629a      	str	r2, [r3, #40]	@ 0x28
 8015d0e:	e777      	b.n	8015c00 <HAL_I2C_Mem_Read+0xac>
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8015d10:	4632      	mov	r2, r6
 8015d12:	4639      	mov	r1, r7
 8015d14:	4620      	mov	r0, r4
 8015d16:	f7ff fd11 	bl	801573c <I2C_WaitOnSTOPFlagUntilTimeout>
 8015d1a:	2800      	cmp	r0, #0
 8015d1c:	f47f af3c 	bne.w	8015b98 <HAL_I2C_Mem_Read+0x44>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8015d20:	6823      	ldr	r3, [r4, #0]
 8015d22:	2120      	movs	r1, #32
    I2C_RESET_CR2(hi2c);
 8015d24:	4d09      	ldr	r5, [pc, #36]	@ (8015d4c <HAL_I2C_Mem_Read+0x1f8>)
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8015d26:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
 8015d28:	685a      	ldr	r2, [r3, #4]
 8015d2a:	402a      	ands	r2, r5
 8015d2c:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 8015d2e:	f884 1041 	strb.w	r1, [r4, #65]	@ 0x41
    __HAL_UNLOCK(hi2c);
 8015d32:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 8015d36:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
    return HAL_OK;
 8015d3a:	e72e      	b.n	8015b9a <HAL_I2C_Mem_Read+0x46>
 8015d3c:	fc009800 	.word	0xfc009800
 8015d40:	01012400 	.word	0x01012400
 8015d44:	01010000 	.word	0x01010000
 8015d48:	02002400 	.word	0x02002400
 8015d4c:	fe00e800 	.word	0xfe00e800
 8015d50:	fc009c00 	.word	0xfc009c00

08015d54 <HAL_I2CEx_ConfigAnalogFilter>:
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 8015d54:	f890 2041 	ldrb.w	r2, [r0, #65]	@ 0x41
 8015d58:	2a20      	cmp	r2, #32
 8015d5a:	d123      	bne.n	8015da4 <HAL_I2CEx_ConfigAnalogFilter+0x50>
 8015d5c:	fa5f fc82 	uxtb.w	ip, r2
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 8015d60:	f890 2040 	ldrb.w	r2, [r0, #64]	@ 0x40
 8015d64:	4603      	mov	r3, r0
 8015d66:	2a01      	cmp	r2, #1
 8015d68:	d01c      	beq.n	8015da4 <HAL_I2CEx_ConfigAnalogFilter+0x50>

    hi2c->State = HAL_I2C_STATE_BUSY;

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 8015d6a:	6802      	ldr	r2, [r0, #0]
    hi2c->State = HAL_I2C_STATE_BUSY;
 8015d6c:	2024      	movs	r0, #36	@ 0x24
{
 8015d6e:	b500      	push	{lr}
    hi2c->State = HAL_I2C_STATE_BUSY;
 8015d70:	f883 0041 	strb.w	r0, [r3, #65]	@ 0x41
    __HAL_I2C_ENABLE(hi2c);

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8015d74:	f04f 0e00 	mov.w	lr, #0
    __HAL_I2C_DISABLE(hi2c);
 8015d78:	6810      	ldr	r0, [r2, #0]
 8015d7a:	f020 0001 	bic.w	r0, r0, #1
 8015d7e:	6010      	str	r0, [r2, #0]
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
 8015d80:	6810      	ldr	r0, [r2, #0]
 8015d82:	f420 5080 	bic.w	r0, r0, #4096	@ 0x1000
 8015d86:	6010      	str	r0, [r2, #0]
    hi2c->Instance->CR1 |= AnalogFilter;
 8015d88:	6810      	ldr	r0, [r2, #0]
 8015d8a:	4301      	orrs	r1, r0

    return HAL_OK;
 8015d8c:	4670      	mov	r0, lr
    hi2c->Instance->CR1 |= AnalogFilter;
 8015d8e:	6011      	str	r1, [r2, #0]
    __HAL_I2C_ENABLE(hi2c);
 8015d90:	6811      	ldr	r1, [r2, #0]
 8015d92:	f041 0101 	orr.w	r1, r1, #1
 8015d96:	6011      	str	r1, [r2, #0]
    hi2c->State = HAL_I2C_STATE_READY;
 8015d98:	f883 c041 	strb.w	ip, [r3, #65]	@ 0x41
    __HAL_UNLOCK(hi2c);
 8015d9c:	f883 e040 	strb.w	lr, [r3, #64]	@ 0x40
  }
  else
  {
    return HAL_BUSY;
  }
}
 8015da0:	f85d fb04 	ldr.w	pc, [sp], #4
    __HAL_LOCK(hi2c);
 8015da4:	2002      	movs	r0, #2
}
 8015da6:	4770      	bx	lr

08015da8 <HAL_I2CEx_ConfigDigitalFilter>:

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 8015da8:	f890 2041 	ldrb.w	r2, [r0, #65]	@ 0x41
 8015dac:	2a20      	cmp	r2, #32
 8015dae:	d122      	bne.n	8015df6 <HAL_I2CEx_ConfigDigitalFilter+0x4e>
 8015db0:	4603      	mov	r3, r0
{
 8015db2:	b500      	push	{lr}
 8015db4:	fa5f fe82 	uxtb.w	lr, r2
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 8015db8:	f890 2040 	ldrb.w	r2, [r0, #64]	@ 0x40
 8015dbc:	2a01      	cmp	r2, #1
 8015dbe:	d01c      	beq.n	8015dfa <HAL_I2CEx_ConfigDigitalFilter+0x52>

    hi2c->State = HAL_I2C_STATE_BUSY;

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 8015dc0:	6802      	ldr	r2, [r0, #0]
    hi2c->State = HAL_I2C_STATE_BUSY;
 8015dc2:	2024      	movs	r0, #36	@ 0x24
    __HAL_I2C_ENABLE(hi2c);

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8015dc4:	f04f 0c00 	mov.w	ip, #0
    hi2c->State = HAL_I2C_STATE_BUSY;
 8015dc8:	f883 0041 	strb.w	r0, [r3, #65]	@ 0x41
    __HAL_I2C_DISABLE(hi2c);
 8015dcc:	6810      	ldr	r0, [r2, #0]
 8015dce:	f020 0001 	bic.w	r0, r0, #1
 8015dd2:	6010      	str	r0, [r2, #0]
    tmpreg = hi2c->Instance->CR1;
 8015dd4:	6810      	ldr	r0, [r2, #0]
    tmpreg &= ~(I2C_CR1_DNF);
 8015dd6:	f420 6070 	bic.w	r0, r0, #3840	@ 0xf00
    tmpreg |= DigitalFilter << 8U;
 8015dda:	ea40 2101 	orr.w	r1, r0, r1, lsl #8

    return HAL_OK;
 8015dde:	4660      	mov	r0, ip
    hi2c->Instance->CR1 = tmpreg;
 8015de0:	6011      	str	r1, [r2, #0]
    __HAL_I2C_ENABLE(hi2c);
 8015de2:	6811      	ldr	r1, [r2, #0]
 8015de4:	f041 0101 	orr.w	r1, r1, #1
 8015de8:	6011      	str	r1, [r2, #0]
    hi2c->State = HAL_I2C_STATE_READY;
 8015dea:	f883 e041 	strb.w	lr, [r3, #65]	@ 0x41
    __HAL_UNLOCK(hi2c);
 8015dee:	f883 c040 	strb.w	ip, [r3, #64]	@ 0x40
  }
  else
  {
    return HAL_BUSY;
  }
}
 8015df2:	f85d fb04 	ldr.w	pc, [sp], #4
    __HAL_LOCK(hi2c);
 8015df6:	2002      	movs	r0, #2
}
 8015df8:	4770      	bx	lr
    __HAL_LOCK(hi2c);
 8015dfa:	2002      	movs	r0, #2
}
 8015dfc:	f85d fb04 	ldr.w	pc, [sp], #4

08015e00 <HAL_LTDC_Init>:
{
  uint32_t tmp;
  uint32_t tmp1;

  /* Check the LTDC peripheral state */
  if (hltdc == NULL)
 8015e00:	2800      	cmp	r0, #0
 8015e02:	d067      	beq.n	8015ed4 <HAL_LTDC_Init+0xd4>
{
 8015e04:	b538      	push	{r3, r4, r5, lr}
    }
    /* Init the low level hardware */
    hltdc->MspInitCallback(hltdc);
  }
#else
  if (hltdc->State == HAL_LTDC_STATE_RESET)
 8015e06:	f890 30a1 	ldrb.w	r3, [r0, #161]	@ 0xa1
 8015e0a:	4604      	mov	r4, r0
 8015e0c:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
 8015e10:	2b00      	cmp	r3, #0
 8015e12:	d05a      	beq.n	8015eca <HAL_LTDC_Init+0xca>
  /* Change LTDC peripheral state */
  hltdc->State = HAL_LTDC_STATE_BUSY;

  /* Configure the HS, VS, DE and PC polarity */
  hltdc->Instance->GCR &= ~(LTDC_GCR_HSPOL | LTDC_GCR_VSPOL | LTDC_GCR_DEPOL | LTDC_GCR_PCPOL);
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
 8015e14:	68a0      	ldr	r0, [r4, #8]
  hltdc->State = HAL_LTDC_STATE_BUSY;
 8015e16:	2102      	movs	r1, #2
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
 8015e18:	e9d4 3200 	ldrd	r3, r2, [r4]
  hltdc->State = HAL_LTDC_STATE_BUSY;
 8015e1c:	f884 10a1 	strb.w	r1, [r4, #161]	@ 0xa1
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
 8015e20:	4302      	orrs	r2, r0
 8015e22:	68e1      	ldr	r1, [r4, #12]
  hltdc->Instance->GCR &= ~(LTDC_GCR_HSPOL | LTDC_GCR_VSPOL | LTDC_GCR_DEPOL | LTDC_GCR_PCPOL);
 8015e24:	6998      	ldr	r0, [r3, #24]
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
 8015e26:	430a      	orrs	r2, r1
                                     hltdc->Init.DEPolarity | hltdc->Init.PCPolarity);
 8015e28:	6921      	ldr	r1, [r4, #16]
  hltdc->Instance->GCR &= ~(LTDC_GCR_HSPOL | LTDC_GCR_VSPOL | LTDC_GCR_DEPOL | LTDC_GCR_PCPOL);
 8015e2a:	f020 4070 	bic.w	r0, r0, #4026531840	@ 0xf0000000
                                     hltdc->Init.DEPolarity | hltdc->Init.PCPolarity);
 8015e2e:	430a      	orrs	r2, r1

  /* Set Synchronization size */
  hltdc->Instance->SSCR &= ~(LTDC_SSCR_VSH | LTDC_SSCR_HSW);
 8015e30:	4929      	ldr	r1, [pc, #164]	@ (8015ed8 <HAL_LTDC_Init+0xd8>)
  hltdc->Instance->GCR &= ~(LTDC_GCR_HSPOL | LTDC_GCR_VSPOL | LTDC_GCR_DEPOL | LTDC_GCR_PCPOL);
 8015e32:	6198      	str	r0, [r3, #24]
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
 8015e34:	6998      	ldr	r0, [r3, #24]
 8015e36:	4302      	orrs	r2, r0
  tmp = (hltdc->Init.HorizontalSync << 16U);
 8015e38:	6960      	ldr	r0, [r4, #20]
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
 8015e3a:	619a      	str	r2, [r3, #24]
  hltdc->Instance->SSCR &= ~(LTDC_SSCR_VSH | LTDC_SSCR_HSW);
 8015e3c:	689a      	ldr	r2, [r3, #8]
 8015e3e:	400a      	ands	r2, r1
 8015e40:	609a      	str	r2, [r3, #8]
  hltdc->Instance->SSCR |= (tmp | hltdc->Init.VerticalSync);
 8015e42:	689a      	ldr	r2, [r3, #8]
 8015e44:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 8015e48:	69a0      	ldr	r0, [r4, #24]
 8015e4a:	4302      	orrs	r2, r0

  /* Set Accumulated Back porch */
  hltdc->Instance->BPCR &= ~(LTDC_BPCR_AVBP | LTDC_BPCR_AHBP);
  tmp = (hltdc->Init.AccumulatedHBP << 16U);
 8015e4c:	69e0      	ldr	r0, [r4, #28]
  hltdc->Instance->SSCR |= (tmp | hltdc->Init.VerticalSync);
 8015e4e:	609a      	str	r2, [r3, #8]
  hltdc->Instance->BPCR &= ~(LTDC_BPCR_AVBP | LTDC_BPCR_AHBP);
 8015e50:	68da      	ldr	r2, [r3, #12]
 8015e52:	400a      	ands	r2, r1
 8015e54:	60da      	str	r2, [r3, #12]
  hltdc->Instance->BPCR |= (tmp | hltdc->Init.AccumulatedVBP);
 8015e56:	68da      	ldr	r2, [r3, #12]
 8015e58:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 8015e5c:	6a20      	ldr	r0, [r4, #32]
 8015e5e:	4302      	orrs	r2, r0

  /* Set Accumulated Active Width */
  hltdc->Instance->AWCR &= ~(LTDC_AWCR_AAH | LTDC_AWCR_AAW);
  tmp = (hltdc->Init.AccumulatedActiveW << 16U);
 8015e60:	6a60      	ldr	r0, [r4, #36]	@ 0x24
  hltdc->Instance->BPCR |= (tmp | hltdc->Init.AccumulatedVBP);
 8015e62:	60da      	str	r2, [r3, #12]
  hltdc->Instance->AWCR &= ~(LTDC_AWCR_AAH | LTDC_AWCR_AAW);
 8015e64:	691a      	ldr	r2, [r3, #16]
 8015e66:	400a      	ands	r2, r1
 8015e68:	611a      	str	r2, [r3, #16]
  hltdc->Instance->AWCR |= (tmp | hltdc->Init.AccumulatedActiveH);
 8015e6a:	691a      	ldr	r2, [r3, #16]
 8015e6c:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 8015e70:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
 8015e72:	4302      	orrs	r2, r0

  /* Set Total Width */
  hltdc->Instance->TWCR &= ~(LTDC_TWCR_TOTALH | LTDC_TWCR_TOTALW);
  tmp = (hltdc->Init.TotalWidth << 16U);
 8015e74:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
  hltdc->Instance->AWCR |= (tmp | hltdc->Init.AccumulatedActiveH);
 8015e76:	611a      	str	r2, [r3, #16]
  hltdc->Instance->TWCR &= ~(LTDC_TWCR_TOTALH | LTDC_TWCR_TOTALW);
 8015e78:	695a      	ldr	r2, [r3, #20]
 8015e7a:	400a      	ands	r2, r1
 8015e7c:	615a      	str	r2, [r3, #20]
  hltdc->Instance->TWCR |= (tmp | hltdc->Init.TotalHeigh);
 8015e7e:	695a      	ldr	r2, [r3, #20]
 8015e80:	6b21      	ldr	r1, [r4, #48]	@ 0x30
 8015e82:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 8015e86:	430a      	orrs	r2, r1
 8015e88:	615a      	str	r2, [r3, #20]

  /* Set the background color value */
  tmp = ((uint32_t)(hltdc->Init.Backcolor.Green) << 8U);
  tmp1 = ((uint32_t)(hltdc->Init.Backcolor.Red) << 16U);
  hltdc->Instance->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
 8015e8a:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
  tmp = ((uint32_t)(hltdc->Init.Backcolor.Green) << 8U);
 8015e8c:	f894 0035 	ldrb.w	r0, [r4, #53]	@ 0x35
  hltdc->Instance->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
 8015e90:	f002 427f 	and.w	r2, r2, #4278190080	@ 0xff000000
  tmp1 = ((uint32_t)(hltdc->Init.Backcolor.Red) << 16U);
 8015e94:	f894 1036 	ldrb.w	r1, [r4, #54]	@ 0x36
  hltdc->Instance->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
 8015e98:	62da      	str	r2, [r3, #44]	@ 0x2c
  hltdc->Instance->BCCR |= (tmp1 | tmp | hltdc->Init.Backcolor.Blue);
 8015e9a:	6add      	ldr	r5, [r3, #44]	@ 0x2c
 8015e9c:	f894 2034 	ldrb.w	r2, [r4, #52]	@ 0x34
 8015ea0:	432a      	orrs	r2, r5
 8015ea2:	ea42 2200 	orr.w	r2, r2, r0, lsl #8

  /* Enable LTDC by setting LTDCEN bit */
  __HAL_LTDC_ENABLE(hltdc);

  /* Initialize the error code */
  hltdc->ErrorCode = HAL_LTDC_ERROR_NONE;
 8015ea6:	2000      	movs	r0, #0
  hltdc->Instance->BCCR |= (tmp1 | tmp | hltdc->Init.Backcolor.Blue);
 8015ea8:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 8015eac:	62da      	str	r2, [r3, #44]	@ 0x2c
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_TE | LTDC_IT_FU);
 8015eae:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8015eb0:	f042 0206 	orr.w	r2, r2, #6
 8015eb4:	635a      	str	r2, [r3, #52]	@ 0x34
  __HAL_LTDC_ENABLE(hltdc);
 8015eb6:	699a      	ldr	r2, [r3, #24]
 8015eb8:	f042 0201 	orr.w	r2, r2, #1
 8015ebc:	619a      	str	r2, [r3, #24]

  /* Initialize the LTDC state*/
  hltdc->State = HAL_LTDC_STATE_READY;
 8015ebe:	2301      	movs	r3, #1
  hltdc->ErrorCode = HAL_LTDC_ERROR_NONE;
 8015ec0:	f8c4 00a4 	str.w	r0, [r4, #164]	@ 0xa4
  hltdc->State = HAL_LTDC_STATE_READY;
 8015ec4:	f884 30a1 	strb.w	r3, [r4, #161]	@ 0xa1

  return HAL_OK;
}
 8015ec8:	bd38      	pop	{r3, r4, r5, pc}
    hltdc->Lock = HAL_UNLOCKED;
 8015eca:	f880 20a0 	strb.w	r2, [r0, #160]	@ 0xa0
    HAL_LTDC_MspInit(hltdc);
 8015ece:	f7fc fa51 	bl	8012374 <HAL_LTDC_MspInit>
 8015ed2:	e79f      	b.n	8015e14 <HAL_LTDC_Init+0x14>
    return HAL_ERROR;
 8015ed4:	2001      	movs	r0, #1
}
 8015ed6:	4770      	bx	lr
 8015ed8:	f000f800 	.word	0xf000f800

08015edc <HAL_LTDC_ErrorCallback>:
  * @brief  Error LTDC callback.
  * @param  hltdc  pointer to a LTDC_HandleTypeDef structure that contains
  *                the configuration information for the LTDC.
  * @retval None
  */
__weak void HAL_LTDC_ErrorCallback(LTDC_HandleTypeDef *hltdc)
 8015edc:	4770      	bx	lr
 8015ede:	bf00      	nop

08015ee0 <HAL_LTDC_LineEventCallback>:
  * @brief  Line Event callback.
  * @param  hltdc  pointer to a LTDC_HandleTypeDef structure that contains
  *                the configuration information for the LTDC.
  * @retval None
  */
__weak void HAL_LTDC_LineEventCallback(LTDC_HandleTypeDef *hltdc)
 8015ee0:	4770      	bx	lr
 8015ee2:	bf00      	nop

08015ee4 <HAL_LTDC_ReloadEventCallback>:
  * @brief  Reload Event callback.
  * @param  hltdc  pointer to a LTDC_HandleTypeDef structure that contains
  *                the configuration information for the LTDC.
  * @retval None
  */
__weak void HAL_LTDC_ReloadEventCallback(LTDC_HandleTypeDef *hltdc)
 8015ee4:	4770      	bx	lr
 8015ee6:	bf00      	nop

08015ee8 <HAL_LTDC_IRQHandler>:
  uint32_t isrflags  = READ_REG(hltdc->Instance->ISR);
 8015ee8:	6803      	ldr	r3, [r0, #0]
{
 8015eea:	b570      	push	{r4, r5, r6, lr}
  uint32_t isrflags  = READ_REG(hltdc->Instance->ISR);
 8015eec:	6b9d      	ldr	r5, [r3, #56]	@ 0x38
{
 8015eee:	4604      	mov	r4, r0
  uint32_t itsources = READ_REG(hltdc->Instance->IER);
 8015ef0:	6b5e      	ldr	r6, [r3, #52]	@ 0x34
  if (((isrflags & LTDC_ISR_TERRIF) != 0U) && ((itsources & LTDC_IER_TERRIE) != 0U))
 8015ef2:	076a      	lsls	r2, r5, #29
 8015ef4:	d501      	bpl.n	8015efa <HAL_LTDC_IRQHandler+0x12>
 8015ef6:	0771      	lsls	r1, r6, #29
 8015ef8:	d41d      	bmi.n	8015f36 <HAL_LTDC_IRQHandler+0x4e>
  if (((isrflags & LTDC_ISR_FUIF) != 0U) && ((itsources & LTDC_IER_FUIE) != 0U))
 8015efa:	07aa      	lsls	r2, r5, #30
 8015efc:	d501      	bpl.n	8015f02 <HAL_LTDC_IRQHandler+0x1a>
 8015efe:	07b3      	lsls	r3, r6, #30
 8015f00:	d42d      	bmi.n	8015f5e <HAL_LTDC_IRQHandler+0x76>
  if (((isrflags & LTDC_ISR_LIF) != 0U) && ((itsources & LTDC_IER_LIE) != 0U))
 8015f02:	07e8      	lsls	r0, r5, #31
 8015f04:	d501      	bpl.n	8015f0a <HAL_LTDC_IRQHandler+0x22>
 8015f06:	07f1      	lsls	r1, r6, #31
 8015f08:	d440      	bmi.n	8015f8c <HAL_LTDC_IRQHandler+0xa4>
  if (((isrflags & LTDC_ISR_RRIF) != 0U) && ((itsources & LTDC_IER_RRIE) != 0U))
 8015f0a:	072a      	lsls	r2, r5, #28
 8015f0c:	d501      	bpl.n	8015f12 <HAL_LTDC_IRQHandler+0x2a>
 8015f0e:	0733      	lsls	r3, r6, #28
 8015f10:	d400      	bmi.n	8015f14 <HAL_LTDC_IRQHandler+0x2c>
}
 8015f12:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_LTDC_DISABLE_IT(hltdc, LTDC_IT_RR);
 8015f14:	6823      	ldr	r3, [r4, #0]
    __HAL_LTDC_CLEAR_FLAG(hltdc, LTDC_FLAG_RR);
 8015f16:	2008      	movs	r0, #8
    hltdc->State = HAL_LTDC_STATE_READY;
 8015f18:	2501      	movs	r5, #1
    __HAL_UNLOCK(hltdc);
 8015f1a:	2100      	movs	r1, #0
    __HAL_LTDC_DISABLE_IT(hltdc, LTDC_IT_RR);
 8015f1c:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8015f1e:	f022 0208 	bic.w	r2, r2, #8
 8015f22:	635a      	str	r2, [r3, #52]	@ 0x34
    __HAL_LTDC_CLEAR_FLAG(hltdc, LTDC_FLAG_RR);
 8015f24:	63d8      	str	r0, [r3, #60]	@ 0x3c
    HAL_LTDC_ReloadEventCallback(hltdc);
 8015f26:	4620      	mov	r0, r4
    hltdc->State = HAL_LTDC_STATE_READY;
 8015f28:	f884 50a1 	strb.w	r5, [r4, #161]	@ 0xa1
    __HAL_UNLOCK(hltdc);
 8015f2c:	f884 10a0 	strb.w	r1, [r4, #160]	@ 0xa0
    HAL_LTDC_ReloadEventCallback(hltdc);
 8015f30:	f7ff ffd8 	bl	8015ee4 <HAL_LTDC_ReloadEventCallback>
}
 8015f34:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_LTDC_DISABLE_IT(hltdc, LTDC_IT_TE);
 8015f36:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8015f38:	f022 0204 	bic.w	r2, r2, #4
 8015f3c:	635a      	str	r2, [r3, #52]	@ 0x34
    __HAL_LTDC_CLEAR_FLAG(hltdc, LTDC_FLAG_TE);
 8015f3e:	2204      	movs	r2, #4
 8015f40:	63da      	str	r2, [r3, #60]	@ 0x3c
    hltdc->ErrorCode |= HAL_LTDC_ERROR_TE;
 8015f42:	f8d0 30a4 	ldr.w	r3, [r0, #164]	@ 0xa4
 8015f46:	f043 0301 	orr.w	r3, r3, #1
 8015f4a:	f8c0 30a4 	str.w	r3, [r0, #164]	@ 0xa4
    __HAL_UNLOCK(hltdc);
 8015f4e:	2300      	movs	r3, #0
    hltdc->State = HAL_LTDC_STATE_ERROR;
 8015f50:	f880 20a1 	strb.w	r2, [r0, #161]	@ 0xa1
    __HAL_UNLOCK(hltdc);
 8015f54:	f880 30a0 	strb.w	r3, [r0, #160]	@ 0xa0
    HAL_LTDC_ErrorCallback(hltdc);
 8015f58:	f7ff ffc0 	bl	8015edc <HAL_LTDC_ErrorCallback>
 8015f5c:	e7cd      	b.n	8015efa <HAL_LTDC_IRQHandler+0x12>
    __HAL_LTDC_DISABLE_IT(hltdc, LTDC_IT_FU);
 8015f5e:	6823      	ldr	r3, [r4, #0]
    HAL_LTDC_ErrorCallback(hltdc);
 8015f60:	4620      	mov	r0, r4
    __HAL_LTDC_DISABLE_IT(hltdc, LTDC_IT_FU);
 8015f62:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8015f64:	f022 0202 	bic.w	r2, r2, #2
 8015f68:	635a      	str	r2, [r3, #52]	@ 0x34
    __HAL_LTDC_CLEAR_FLAG(hltdc, LTDC_FLAG_FU);
 8015f6a:	2202      	movs	r2, #2
 8015f6c:	63da      	str	r2, [r3, #60]	@ 0x3c
    hltdc->State = HAL_LTDC_STATE_ERROR;
 8015f6e:	2204      	movs	r2, #4
    hltdc->ErrorCode |= HAL_LTDC_ERROR_FU;
 8015f70:	f8d4 30a4 	ldr.w	r3, [r4, #164]	@ 0xa4
 8015f74:	f043 0302 	orr.w	r3, r3, #2
 8015f78:	f8c4 30a4 	str.w	r3, [r4, #164]	@ 0xa4
    __HAL_UNLOCK(hltdc);
 8015f7c:	2300      	movs	r3, #0
    hltdc->State = HAL_LTDC_STATE_ERROR;
 8015f7e:	f884 20a1 	strb.w	r2, [r4, #161]	@ 0xa1
    __HAL_UNLOCK(hltdc);
 8015f82:	f884 30a0 	strb.w	r3, [r4, #160]	@ 0xa0
    HAL_LTDC_ErrorCallback(hltdc);
 8015f86:	f7ff ffa9 	bl	8015edc <HAL_LTDC_ErrorCallback>
 8015f8a:	e7ba      	b.n	8015f02 <HAL_LTDC_IRQHandler+0x1a>
    __HAL_LTDC_DISABLE_IT(hltdc, LTDC_IT_LI);
 8015f8c:	6823      	ldr	r3, [r4, #0]
    HAL_LTDC_LineEventCallback(hltdc);
 8015f8e:	4620      	mov	r0, r4
    __HAL_LTDC_DISABLE_IT(hltdc, LTDC_IT_LI);
 8015f90:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8015f92:	f022 0201 	bic.w	r2, r2, #1
 8015f96:	635a      	str	r2, [r3, #52]	@ 0x34
    __HAL_LTDC_CLEAR_FLAG(hltdc, LTDC_FLAG_LI);
 8015f98:	2201      	movs	r2, #1
 8015f9a:	63da      	str	r2, [r3, #60]	@ 0x3c
    __HAL_UNLOCK(hltdc);
 8015f9c:	2300      	movs	r3, #0
    hltdc->State = HAL_LTDC_STATE_READY;
 8015f9e:	f884 20a1 	strb.w	r2, [r4, #161]	@ 0xa1
    __HAL_UNLOCK(hltdc);
 8015fa2:	f884 30a0 	strb.w	r3, [r4, #160]	@ 0xa0
    HAL_LTDC_LineEventCallback(hltdc);
 8015fa6:	f7ff ff9b 	bl	8015ee0 <HAL_LTDC_LineEventCallback>
 8015faa:	e7ae      	b.n	8015f0a <HAL_LTDC_IRQHandler+0x22>

08015fac <HAL_LTDC_ConfigLayer>:
  assert_param(IS_LTDC_BLENDING_FACTOR2(pLayerCfg->BlendingFactor2));
  assert_param(IS_LTDC_CFBLL(pLayerCfg->ImageWidth));
  assert_param(IS_LTDC_CFBLNBR(pLayerCfg->ImageHeight));

  /* Process locked */
  __HAL_LOCK(hltdc);
 8015fac:	f890 30a0 	ldrb.w	r3, [r0, #160]	@ 0xa0
 8015fb0:	2b01      	cmp	r3, #1
 8015fb2:	f000 80c6 	beq.w	8016142 <HAL_LTDC_ConfigLayer+0x196>

  /* Change LTDC peripheral state */
  hltdc->State = HAL_LTDC_STATE_BUSY;
 8015fb6:	2302      	movs	r3, #2
{
 8015fb8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

  /* Copy new layer configuration into handle structure */
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;
 8015fbc:	f04f 0e34 	mov.w	lr, #52	@ 0x34
  uint32_t tmp;
  uint32_t tmp1;
  uint32_t tmp2;

  /* Configure the horizontal start and stop position */
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
 8015fc0:	f8d0 9000 	ldr.w	r9, [r0]
  hltdc->State = HAL_LTDC_STATE_BUSY;
 8015fc4:	f880 30a1 	strb.w	r3, [r0, #161]	@ 0xa1
{
 8015fc8:	b083      	sub	sp, #12
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;
 8015fca:	fb0e 0e02 	mla	lr, lr, r2, r0
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 8015fce:	01d2      	lsls	r2, r2, #7
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
 8015fd0:	f8d9 300c 	ldr.w	r3, [r9, #12]
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;
 8015fd4:	460c      	mov	r4, r1
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 8015fd6:	f102 0684 	add.w	r6, r2, #132	@ 0x84
 8015fda:	460d      	mov	r5, r1
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
 8015fdc:	f3c3 4b0b 	ubfx	fp, r3, #16, #12
 8015fe0:	4680      	mov	r8, r0
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 8015fe2:	eb09 0c06 	add.w	ip, r9, r6
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;
 8015fe6:	f10e 0e38 	add.w	lr, lr, #56	@ 0x38
  /* Specifies the constant alpha value */
  LTDC_LAYER(hltdc, LayerIdx)->CACR &= ~(LTDC_LxCACR_CONSTA);
  LTDC_LAYER(hltdc, LayerIdx)->CACR = (pLayerCfg->Alpha);

  /* Specifies the blending factors */
  LTDC_LAYER(hltdc, LayerIdx)->BFCR &= ~(LTDC_LxBFCR_BF2 | LTDC_LxBFCR_BF1);
 8015fea:	f8df a164 	ldr.w	sl, [pc, #356]	@ 8016150 <HAL_LTDC_ConfigLayer+0x1a4>
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 8015fee:	f8dc 3004 	ldr.w	r3, [ip, #4]
 8015ff2:	f403 4370 	and.w	r3, r3, #61440	@ 0xf000
 8015ff6:	9301      	str	r3, [sp, #4]
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;
 8015ff8:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8015ffa:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
 8015ffe:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
 8016000:	686f      	ldr	r7, [r5, #4]
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;
 8016002:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
 8016006:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8016008:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
 801600c:	6823      	ldr	r3, [r4, #0]
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
 801600e:	44bb      	add	fp, r7
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;
 8016010:	f8ce 3000 	str.w	r3, [lr]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 8016014:	9b01      	ldr	r3, [sp, #4]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + \
 8016016:	682a      	ldr	r2, [r5, #0]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 8016018:	f8cc 3004 	str.w	r3, [ip, #4]
                                         ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
 801601c:	f8d9 300c 	ldr.w	r3, [r9, #12]
 8016020:	1c51      	adds	r1, r2, #1
  tmp = ((pLayerCfg->WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
 8016022:	68e8      	ldr	r0, [r5, #12]
                                         ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
 8016024:	f3c3 430b 	ubfx	r3, r3, #16, #12
  tmp2 = (pLayerCfg->Alpha0 << 24U);
 8016028:	f8d5 e018 	ldr.w	lr, [r5, #24]
                                         ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
 801602c:	440b      	add	r3, r1
 801602e:	ea43 430b 	orr.w	r3, r3, fp, lsl #16
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + \
 8016032:	f8cc 3004 	str.w	r3, [ip, #4]
  tmp = ((pLayerCfg->WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
 8016036:	f8d9 100c 	ldr.w	r1, [r9, #12]
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR &= ~(LTDC_LxWVPCR_WVSTPOS | LTDC_LxWVPCR_WVSPPOS);
 801603a:	f8dc 3008 	ldr.w	r3, [ip, #8]
  tmp = ((pLayerCfg->WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
 801603e:	f3c1 010a 	ubfx	r1, r1, #0, #11
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR &= ~(LTDC_LxWVPCR_WVSTPOS | LTDC_LxWVPCR_WVSPPOS);
 8016042:	f403 4370 	and.w	r3, r3, #61440	@ 0xf000
  tmp = ((pLayerCfg->WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
 8016046:	4401      	add	r1, r0
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR &= ~(LTDC_LxWVPCR_WVSTPOS | LTDC_LxWVPCR_WVSPPOS);
 8016048:	f8cc 3008 	str.w	r3, [ip, #8]
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR  = ((pLayerCfg->WindowY0 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
 801604c:	68ab      	ldr	r3, [r5, #8]
 801604e:	f8d9 000c 	ldr.w	r0, [r9, #12]
 8016052:	3301      	adds	r3, #1
 8016054:	f3c0 000a 	ubfx	r0, r0, #0, #11
 8016058:	4403      	add	r3, r0
 801605a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
  LTDC_LAYER(hltdc, LayerIdx)->PFCR = (pLayerCfg->PixelFormat);
 801605e:	6929      	ldr	r1, [r5, #16]
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR  = ((pLayerCfg->WindowY0 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
 8016060:	f8cc 3008 	str.w	r3, [ip, #8]
  LTDC_LAYER(hltdc, LayerIdx)->PFCR &= ~(LTDC_LxPFCR_PF);
 8016064:	f8dc 3010 	ldr.w	r3, [ip, #16]
 8016068:	f023 0307 	bic.w	r3, r3, #7
 801606c:	f8cc 3010 	str.w	r3, [ip, #16]
  LTDC_LAYER(hltdc, LayerIdx)->PFCR = (pLayerCfg->PixelFormat);
 8016070:	f8cc 1010 	str.w	r1, [ip, #16]
  LTDC_LAYER(hltdc, LayerIdx)->DCCR &= ~(LTDC_LxDCCR_DCBLUE | LTDC_LxDCCR_DCGREEN | LTDC_LxDCCR_DCRED |
 8016074:	f8dc 3018 	ldr.w	r3, [ip, #24]
 8016078:	2300      	movs	r3, #0
  tmp1 = ((uint32_t)(pLayerCfg->Backcolor.Red) << 16U);
 801607a:	f895 0032 	ldrb.w	r0, [r5, #50]	@ 0x32
  tmp = ((uint32_t)(pLayerCfg->Backcolor.Green) << 8U);
 801607e:	f895 4031 	ldrb.w	r4, [r5, #49]	@ 0x31
  LTDC_LAYER(hltdc, LayerIdx)->DCCR &= ~(LTDC_LxDCCR_DCBLUE | LTDC_LxDCCR_DCGREEN | LTDC_LxDCCR_DCRED |
 8016082:	f8cc 3018 	str.w	r3, [ip, #24]
  LTDC_LAYER(hltdc, LayerIdx)->DCCR = (pLayerCfg->Backcolor.Blue | tmp | tmp1 | tmp2);
 8016086:	f895 3030 	ldrb.w	r3, [r5, #48]	@ 0x30
 801608a:	ea43 630e 	orr.w	r3, r3, lr, lsl #24
 801608e:	ea43 2304 	orr.w	r3, r3, r4, lsl #8
 8016092:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
 8016096:	f8cc 3018 	str.w	r3, [ip, #24]
  LTDC_LAYER(hltdc, LayerIdx)->CACR &= ~(LTDC_LxCACR_CONSTA);
 801609a:	f8dc 3014 	ldr.w	r3, [ip, #20]
 801609e:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
 80160a2:	f8cc 3014 	str.w	r3, [ip, #20]
  LTDC_LAYER(hltdc, LayerIdx)->CACR = (pLayerCfg->Alpha);
 80160a6:	696b      	ldr	r3, [r5, #20]
 80160a8:	f8cc 3014 	str.w	r3, [ip, #20]
  LTDC_LAYER(hltdc, LayerIdx)->BFCR &= ~(LTDC_LxBFCR_BF2 | LTDC_LxBFCR_BF1);
 80160ac:	f8dc 001c 	ldr.w	r0, [ip, #28]
  LTDC_LAYER(hltdc, LayerIdx)->BFCR = (pLayerCfg->BlendingFactor1 | pLayerCfg->BlendingFactor2);
 80160b0:	69eb      	ldr	r3, [r5, #28]
  LTDC_LAYER(hltdc, LayerIdx)->BFCR &= ~(LTDC_LxBFCR_BF2 | LTDC_LxBFCR_BF1);
 80160b2:	ea00 0a0a 	and.w	sl, r0, sl
  LTDC_LAYER(hltdc, LayerIdx)->BFCR = (pLayerCfg->BlendingFactor1 | pLayerCfg->BlendingFactor2);
 80160b6:	6a28      	ldr	r0, [r5, #32]
 80160b8:	4303      	orrs	r3, r0
  LTDC_LAYER(hltdc, LayerIdx)->BFCR &= ~(LTDC_LxBFCR_BF2 | LTDC_LxBFCR_BF1);
 80160ba:	f8cc a01c 	str.w	sl, [ip, #28]
  LTDC_LAYER(hltdc, LayerIdx)->BFCR = (pLayerCfg->BlendingFactor1 | pLayerCfg->BlendingFactor2);
 80160be:	f8cc 301c 	str.w	r3, [ip, #28]

  /* Configure the color frame buffer start address */
  LTDC_LAYER(hltdc, LayerIdx)->CFBAR &= ~(LTDC_LxCFBAR_CFBADD);
 80160c2:	f8dc 3028 	ldr.w	r3, [ip, #40]	@ 0x28
 80160c6:	2300      	movs	r3, #0
 80160c8:	f8cc 3028 	str.w	r3, [ip, #40]	@ 0x28
  LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (pLayerCfg->FBStartAdress);
 80160cc:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
 80160ce:	f8cc 3028 	str.w	r3, [ip, #40]	@ 0x28

  if (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
 80160d2:	b3a1      	cbz	r1, 801613e <HAL_LTDC_ConfigLayer+0x192>
  {
    tmp = 4U;
  }
  else if (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_RGB888)
 80160d4:	2901      	cmp	r1, #1
 80160d6:	d036      	beq.n	8016146 <HAL_LTDC_ConfigLayer+0x19a>
  {
    tmp = 3U;
  }
  else if ((pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB4444) || \
 80160d8:	1e8b      	subs	r3, r1, #2
 80160da:	2907      	cmp	r1, #7
 80160dc:	bf18      	it	ne
 80160de:	2b02      	cmpne	r3, #2
 80160e0:	bf94      	ite	ls
 80160e2:	2301      	movls	r3, #1
 80160e4:	2300      	movhi	r3, #0
 80160e6:	3301      	adds	r3, #1
  }

  /* Configure the color frame buffer pitch in byte */
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  &= ~(LTDC_LxCFBLR_CFBLL | LTDC_LxCFBLR_CFBP);
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16U) | \
                                         (((pLayerCfg->WindowX1 - pLayerCfg->WindowX0) * tmp)  + 3U));
 80160e8:	1abf      	subs	r7, r7, r2
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16U) | \
 80160ea:	6aaa      	ldr	r2, [r5, #40]	@ 0x28
                                         (((pLayerCfg->WindowX1 - pLayerCfg->WindowX0) * tmp)  + 3U));
 80160ec:	fb03 f707 	mul.w	r7, r3, r7
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16U) | \
 80160f0:	fb02 f303 	mul.w	r3, r2, r3
  /* Configure the frame buffer line number */
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  &= ~(LTDC_LxCFBLNR_CFBLNBR);
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (pLayerCfg->ImageHeight);
 80160f4:	6aea      	ldr	r2, [r5, #44]	@ 0x2c
                                         (((pLayerCfg->WindowX1 - pLayerCfg->WindowX0) * tmp)  + 3U));
 80160f6:	3703      	adds	r7, #3
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16U) | \
 80160f8:	ea47 4703 	orr.w	r7, r7, r3, lsl #16
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  &= ~(LTDC_LxCFBLR_CFBLL | LTDC_LxCFBLR_CFBP);
 80160fc:	f8dc 302c 	ldr.w	r3, [ip, #44]	@ 0x2c
 8016100:	f003 23e0 	and.w	r3, r3, #3758153728	@ 0xe000e000
 8016104:	f8cc 302c 	str.w	r3, [ip, #44]	@ 0x2c
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16U) | \
 8016108:	f8cc 702c 	str.w	r7, [ip, #44]	@ 0x2c
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  &= ~(LTDC_LxCFBLNR_CFBLNBR);
 801610c:	4b0f      	ldr	r3, [pc, #60]	@ (801614c <HAL_LTDC_ConfigLayer+0x1a0>)
 801610e:	f8dc 1030 	ldr.w	r1, [ip, #48]	@ 0x30
 8016112:	400b      	ands	r3, r1
 8016114:	f8cc 3030 	str.w	r3, [ip, #48]	@ 0x30
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (pLayerCfg->ImageHeight);
 8016118:	f8cc 2030 	str.w	r2, [ip, #48]	@ 0x30
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
 801611c:	2201      	movs	r2, #1

  /* Enable LTDC_Layer by setting LEN bit */
  LTDC_LAYER(hltdc, LayerIdx)->CR |= (uint32_t)LTDC_LxCR_LEN;
 801611e:	f859 3006 	ldr.w	r3, [r9, r6]
 8016122:	4313      	orrs	r3, r2
 8016124:	f849 3006 	str.w	r3, [r9, r6]
  __HAL_UNLOCK(hltdc);
 8016128:	2300      	movs	r3, #0
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
 801612a:	f8c9 2024 	str.w	r2, [r9, #36]	@ 0x24
  return HAL_OK;
 801612e:	4618      	mov	r0, r3
  hltdc->State  = HAL_LTDC_STATE_READY;
 8016130:	f888 20a1 	strb.w	r2, [r8, #161]	@ 0xa1
  __HAL_UNLOCK(hltdc);
 8016134:	f888 30a0 	strb.w	r3, [r8, #160]	@ 0xa0
}
 8016138:	b003      	add	sp, #12
 801613a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    tmp = 4U;
 801613e:	2304      	movs	r3, #4
 8016140:	e7d2      	b.n	80160e8 <HAL_LTDC_ConfigLayer+0x13c>
  __HAL_LOCK(hltdc);
 8016142:	2002      	movs	r0, #2
}
 8016144:	4770      	bx	lr
    tmp = 3U;
 8016146:	2303      	movs	r3, #3
 8016148:	e7ce      	b.n	80160e8 <HAL_LTDC_ConfigLayer+0x13c>
 801614a:	bf00      	nop
 801614c:	fffff800 	.word	0xfffff800
 8016150:	fffff8f8 	.word	0xfffff8f8

08016154 <HAL_LTDC_SetAddress>:
  __HAL_LOCK(hltdc);
 8016154:	f890 30a0 	ldrb.w	r3, [r0, #160]	@ 0xa0
 8016158:	2b01      	cmp	r3, #1
 801615a:	f000 80a3 	beq.w	80162a4 <HAL_LTDC_SetAddress+0x150>
  hltdc->State = HAL_LTDC_STATE_BUSY;
 801615e:	2302      	movs	r3, #2
  pLayerCfg->FBStartAdress = Address;
 8016160:	f04f 0c34 	mov.w	ip, #52	@ 0x34
{
 8016164:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 8016168:	01d6      	lsls	r6, r2, #7
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
 801616a:	6804      	ldr	r4, [r0, #0]
  hltdc->State = HAL_LTDC_STATE_BUSY;
 801616c:	f880 30a1 	strb.w	r3, [r0, #161]	@ 0xa1
  pLayerCfg->FBStartAdress = Address;
 8016170:	4686      	mov	lr, r0
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 8016172:	3684      	adds	r6, #132	@ 0x84
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
 8016174:	68e5      	ldr	r5, [r4, #12]
  pLayerCfg->FBStartAdress = Address;
 8016176:	fb0c 0c02 	mla	ip, ip, r2, r0
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 801617a:	19a3      	adds	r3, r4, r6
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
 801617c:	f3c5 480b 	ubfx	r8, r5, #16, #12
  pLayerCfg->FBStartAdress = Address;
 8016180:	f8cc 105c 	str.w	r1, [ip, #92]	@ 0x5c
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 8016184:	685d      	ldr	r5, [r3, #4]
  LTDC_LAYER(hltdc, LayerIdx)->DCCR = (pLayerCfg->Backcolor.Blue | tmp | tmp1 | tmp2);
 8016186:	f8dc 0050 	ldr.w	r0, [ip, #80]	@ 0x50
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 801618a:	f405 4570 	and.w	r5, r5, #61440	@ 0xf000
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + \
 801618e:	e9dc 7b0e 	ldrd	r7, fp, [ip, #56]	@ 0x38
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 8016192:	605d      	str	r5, [r3, #4]
                                         ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
 8016194:	68e5      	ldr	r5, [r4, #12]
 8016196:	f107 0901 	add.w	r9, r7, #1
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
 801619a:	44d8      	add	r8, fp
                                         ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
 801619c:	f3c5 450b 	ubfx	r5, r5, #16, #12
 80161a0:	444d      	add	r5, r9
  tmp = ((pLayerCfg->WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
 80161a2:	f8dc 9044 	ldr.w	r9, [ip, #68]	@ 0x44
                                         ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
 80161a6:	ea45 4508 	orr.w	r5, r5, r8, lsl #16
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + \
 80161aa:	605d      	str	r5, [r3, #4]
  tmp = ((pLayerCfg->WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
 80161ac:	68e5      	ldr	r5, [r4, #12]
 80161ae:	f3c5 080a 	ubfx	r8, r5, #0, #11
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR &= ~(LTDC_LxWVPCR_WVSTPOS | LTDC_LxWVPCR_WVSPPOS);
 80161b2:	689d      	ldr	r5, [r3, #8]
 80161b4:	f405 4570 	and.w	r5, r5, #61440	@ 0xf000
  tmp = ((pLayerCfg->WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
 80161b8:	44c8      	add	r8, r9
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR &= ~(LTDC_LxWVPCR_WVSTPOS | LTDC_LxWVPCR_WVSPPOS);
 80161ba:	609d      	str	r5, [r3, #8]
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR  = ((pLayerCfg->WindowY0 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
 80161bc:	68e5      	ldr	r5, [r4, #12]
 80161be:	f3c5 090a 	ubfx	r9, r5, #0, #11
 80161c2:	f8dc 5040 	ldr.w	r5, [ip, #64]	@ 0x40
 80161c6:	3501      	adds	r5, #1
 80161c8:	444d      	add	r5, r9
 80161ca:	ea45 4508 	orr.w	r5, r5, r8, lsl #16
  tmp = ((uint32_t)(pLayerCfg->Backcolor.Green) << 8U);
 80161ce:	f89c 8069 	ldrb.w	r8, [ip, #105]	@ 0x69
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR  = ((pLayerCfg->WindowY0 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
 80161d2:	609d      	str	r5, [r3, #8]
  LTDC_LAYER(hltdc, LayerIdx)->DCCR = (pLayerCfg->Backcolor.Blue | tmp | tmp1 | tmp2);
 80161d4:	f89c 5068 	ldrb.w	r5, [ip, #104]	@ 0x68
 80161d8:	ea45 6500 	orr.w	r5, r5, r0, lsl #24
 80161dc:	ea45 2508 	orr.w	r5, r5, r8, lsl #8
  LTDC_LAYER(hltdc, LayerIdx)->PFCR &= ~(LTDC_LxPFCR_PF);
 80161e0:	f8d3 8010 	ldr.w	r8, [r3, #16]
 80161e4:	f028 0807 	bic.w	r8, r8, #7
 80161e8:	f8c3 8010 	str.w	r8, [r3, #16]
  tmp1 = ((uint32_t)(pLayerCfg->Backcolor.Red) << 16U);
 80161ec:	f89c 806a 	ldrb.w	r8, [ip, #106]	@ 0x6a
  LTDC_LAYER(hltdc, LayerIdx)->DCCR = (pLayerCfg->Backcolor.Blue | tmp | tmp1 | tmp2);
 80161f0:	ea45 4508 	orr.w	r5, r5, r8, lsl #16
  LTDC_LAYER(hltdc, LayerIdx)->PFCR = (pLayerCfg->PixelFormat);
 80161f4:	f8dc 8048 	ldr.w	r8, [ip, #72]	@ 0x48
 80161f8:	f8c3 8010 	str.w	r8, [r3, #16]
  LTDC_LAYER(hltdc, LayerIdx)->DCCR &= ~(LTDC_LxDCCR_DCBLUE | LTDC_LxDCCR_DCGREEN | LTDC_LxDCCR_DCRED |
 80161fc:	f8d3 9018 	ldr.w	r9, [r3, #24]
 8016200:	f04f 0900 	mov.w	r9, #0
 8016204:	f8c3 9018 	str.w	r9, [r3, #24]
  LTDC_LAYER(hltdc, LayerIdx)->DCCR = (pLayerCfg->Backcolor.Blue | tmp | tmp1 | tmp2);
 8016208:	619d      	str	r5, [r3, #24]
  LTDC_LAYER(hltdc, LayerIdx)->CACR &= ~(LTDC_LxCACR_CONSTA);
 801620a:	695d      	ldr	r5, [r3, #20]
 801620c:	f025 05ff 	bic.w	r5, r5, #255	@ 0xff
 8016210:	615d      	str	r5, [r3, #20]
  LTDC_LAYER(hltdc, LayerIdx)->CACR = (pLayerCfg->Alpha);
 8016212:	f8dc 504c 	ldr.w	r5, [ip, #76]	@ 0x4c
 8016216:	615d      	str	r5, [r3, #20]
  LTDC_LAYER(hltdc, LayerIdx)->BFCR &= ~(LTDC_LxBFCR_BF2 | LTDC_LxBFCR_BF1);
 8016218:	f8d3 a01c 	ldr.w	sl, [r3, #28]
 801621c:	4d23      	ldr	r5, [pc, #140]	@ (80162ac <HAL_LTDC_SetAddress+0x158>)
 801621e:	ea0a 0505 	and.w	r5, sl, r5
 8016222:	61dd      	str	r5, [r3, #28]
  LTDC_LAYER(hltdc, LayerIdx)->BFCR = (pLayerCfg->BlendingFactor1 | pLayerCfg->BlendingFactor2);
 8016224:	e9dc 5c15 	ldrd	r5, ip, [ip, #84]	@ 0x54
 8016228:	ea45 050c 	orr.w	r5, r5, ip
 801622c:	61dd      	str	r5, [r3, #28]
  LTDC_LAYER(hltdc, LayerIdx)->CFBAR &= ~(LTDC_LxCFBAR_CFBADD);
 801622e:	6a9d      	ldr	r5, [r3, #40]	@ 0x28
 8016230:	f8c3 9028 	str.w	r9, [r3, #40]	@ 0x28
  LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (pLayerCfg->FBStartAdress);
 8016234:	6299      	str	r1, [r3, #40]	@ 0x28
  if (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
 8016236:	f1b8 0f00 	cmp.w	r8, #0
 801623a:	d031      	beq.n	80162a0 <HAL_LTDC_SetAddress+0x14c>
  else if (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_RGB888)
 801623c:	f1b8 0f01 	cmp.w	r8, #1
 8016240:	d032      	beq.n	80162a8 <HAL_LTDC_SetAddress+0x154>
  else if ((pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB4444) || \
 8016242:	f1a8 0102 	sub.w	r1, r8, #2
 8016246:	f1b8 0f07 	cmp.w	r8, #7
 801624a:	bf18      	it	ne
 801624c:	2902      	cmpne	r1, #2
 801624e:	bf94      	ite	ls
 8016250:	2101      	movls	r1, #1
 8016252:	2100      	movhi	r1, #0
 8016254:	3101      	adds	r1, #1
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16U) | \
 8016256:	2534      	movs	r5, #52	@ 0x34
                                         (((pLayerCfg->WindowX1 - pLayerCfg->WindowX0) * tmp)  + 3U));
 8016258:	ebab 0007 	sub.w	r0, fp, r7
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16U) | \
 801625c:	fb05 e202 	mla	r2, r5, r2, lr
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  &= ~(LTDC_LxCFBLR_CFBLL | LTDC_LxCFBLR_CFBP);
 8016260:	6add      	ldr	r5, [r3, #44]	@ 0x2c
                                         (((pLayerCfg->WindowX1 - pLayerCfg->WindowX0) * tmp)  + 3U));
 8016262:	fb01 f000 	mul.w	r0, r1, r0
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  &= ~(LTDC_LxCFBLR_CFBLL | LTDC_LxCFBLR_CFBP);
 8016266:	f005 25e0 	and.w	r5, r5, #3758153728	@ 0xe000e000
                                         (((pLayerCfg->WindowX1 - pLayerCfg->WindowX0) * tmp)  + 3U));
 801626a:	3003      	adds	r0, #3
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  &= ~(LTDC_LxCFBLR_CFBLL | LTDC_LxCFBLR_CFBP);
 801626c:	62dd      	str	r5, [r3, #44]	@ 0x2c
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16U) | \
 801626e:	6e15      	ldr	r5, [r2, #96]	@ 0x60
 8016270:	fb05 f101 	mul.w	r1, r5, r1
 8016274:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (pLayerCfg->ImageHeight);
 8016278:	6e51      	ldr	r1, [r2, #100]	@ 0x64
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  &= ~(LTDC_LxCFBLNR_CFBLNBR);
 801627a:	4a0d      	ldr	r2, [pc, #52]	@ (80162b0 <HAL_LTDC_SetAddress+0x15c>)
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16U) | \
 801627c:	62d8      	str	r0, [r3, #44]	@ 0x2c
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  &= ~(LTDC_LxCFBLNR_CFBLNBR);
 801627e:	6b18      	ldr	r0, [r3, #48]	@ 0x30
 8016280:	4002      	ands	r2, r0
 8016282:	631a      	str	r2, [r3, #48]	@ 0x30
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
 8016284:	2201      	movs	r2, #1
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (pLayerCfg->ImageHeight);
 8016286:	6319      	str	r1, [r3, #48]	@ 0x30
  LTDC_LAYER(hltdc, LayerIdx)->CR |= (uint32_t)LTDC_LxCR_LEN;
 8016288:	59a3      	ldr	r3, [r4, r6]
 801628a:	4313      	orrs	r3, r2
 801628c:	51a3      	str	r3, [r4, r6]
  __HAL_UNLOCK(hltdc);
 801628e:	2300      	movs	r3, #0
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
 8016290:	6262      	str	r2, [r4, #36]	@ 0x24
  return HAL_OK;
 8016292:	4618      	mov	r0, r3
  hltdc->State = HAL_LTDC_STATE_READY;
 8016294:	f88e 20a1 	strb.w	r2, [lr, #161]	@ 0xa1
  __HAL_UNLOCK(hltdc);
 8016298:	f88e 30a0 	strb.w	r3, [lr, #160]	@ 0xa0
}
 801629c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    tmp = 4U;
 80162a0:	2104      	movs	r1, #4
 80162a2:	e7d8      	b.n	8016256 <HAL_LTDC_SetAddress+0x102>
  __HAL_LOCK(hltdc);
 80162a4:	2002      	movs	r0, #2
}
 80162a6:	4770      	bx	lr
    tmp = 3U;
 80162a8:	2103      	movs	r1, #3
 80162aa:	e7d4      	b.n	8016256 <HAL_LTDC_SetAddress+0x102>
 80162ac:	fffff8f8 	.word	0xfffff8f8
 80162b0:	fffff800 	.word	0xfffff800

080162b4 <HAL_LTDC_Reload>:
  __HAL_LOCK(hltdc);
 80162b4:	f890 20a0 	ldrb.w	r2, [r0, #160]	@ 0xa0
 80162b8:	2a01      	cmp	r2, #1
 80162ba:	d015      	beq.n	80162e8 <HAL_LTDC_Reload+0x34>
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_RR);
 80162bc:	6802      	ldr	r2, [r0, #0]
 80162be:	4603      	mov	r3, r0
  hltdc->State = HAL_LTDC_STATE_BUSY;
 80162c0:	2002      	movs	r0, #2
  __HAL_UNLOCK(hltdc);
 80162c2:	f04f 0c00 	mov.w	ip, #0
{
 80162c6:	b500      	push	{lr}
  hltdc->State = HAL_LTDC_STATE_BUSY;
 80162c8:	f883 00a1 	strb.w	r0, [r3, #161]	@ 0xa1
  hltdc->State = HAL_LTDC_STATE_READY;
 80162cc:	f04f 0e01 	mov.w	lr, #1
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_RR);
 80162d0:	6b50      	ldr	r0, [r2, #52]	@ 0x34
 80162d2:	f040 0008 	orr.w	r0, r0, #8
 80162d6:	6350      	str	r0, [r2, #52]	@ 0x34
  return HAL_OK;
 80162d8:	4660      	mov	r0, ip
  hltdc->Instance->SRCR = ReloadType;
 80162da:	6251      	str	r1, [r2, #36]	@ 0x24
  hltdc->State = HAL_LTDC_STATE_READY;
 80162dc:	f883 e0a1 	strb.w	lr, [r3, #161]	@ 0xa1
  __HAL_UNLOCK(hltdc);
 80162e0:	f883 c0a0 	strb.w	ip, [r3, #160]	@ 0xa0
}
 80162e4:	f85d fb04 	ldr.w	pc, [sp], #4
  __HAL_LOCK(hltdc);
 80162e8:	2002      	movs	r0, #2
}
 80162ea:	4770      	bx	lr

080162ec <HAL_PCD_Init>:
  *         parameters in the PCD_InitTypeDef and initialize the associated handle.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{
 80162ec:	b530      	push	{r4, r5, lr}
 80162ee:	b083      	sub	sp, #12
  const USB_OTG_GlobalTypeDef *USBx;
#endif /* defined (USB_OTG_FS) */
  uint8_t i;

  /* Check the PCD handle allocation */
  if (hpcd == NULL)
 80162f0:	b1f8      	cbz	r0, 8016332 <HAL_PCD_Init+0x46>

#if defined (USB_OTG_FS)
  USBx = hpcd->Instance;
#endif /* defined (USB_OTG_FS) */

  if (hpcd->State == HAL_PCD_STATE_RESET)
 80162f2:	f890 3495 	ldrb.w	r3, [r0, #1173]	@ 0x495
 80162f6:	4604      	mov	r4, r0
  USBx = hpcd->Instance;
 80162f8:	6805      	ldr	r5, [r0, #0]
  if (hpcd->State == HAL_PCD_STATE_RESET)
 80162fa:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
 80162fe:	2b00      	cmp	r3, #0
 8016300:	f000 81f1 	beq.w	80166e6 <HAL_PCD_Init+0x3fa>
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_PCD_MspInit(hpcd);
#endif /* (USE_HAL_PCD_REGISTER_CALLBACKS) */
  }

  hpcd->State = HAL_PCD_STATE_BUSY;
 8016304:	2303      	movs	r3, #3

#if defined (USB_OTG_FS)
  /* Disable DMA mode for FS instance */
  if (USBx == USB_OTG_FS)
 8016306:	f1b5 4fa0 	cmp.w	r5, #1342177280	@ 0x50000000
 801630a:	4628      	mov	r0, r5
  hpcd->State = HAL_PCD_STATE_BUSY;
 801630c:	f884 3495 	strb.w	r3, [r4, #1173]	@ 0x495
  if (USBx == USB_OTG_FS)
 8016310:	f000 81f5 	beq.w	80166fe <HAL_PCD_Init+0x412>
    hpcd->Init.dma_enable = 0U;
  }
#endif /* defined (USB_OTG_FS) */

  /* Disable the Interrupts */
  __HAL_PCD_DISABLE(hpcd);
 8016314:	f005 fc64 	bl	801bbe0 <USB_DisableGlobalInt>

  /*Init the Core (common init.) */
  if (USB_CoreInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 8016318:	1d25      	adds	r5, r4, #4
 801631a:	7c23      	ldrb	r3, [r4, #16]
 801631c:	f88d 3000 	strb.w	r3, [sp]
 8016320:	6820      	ldr	r0, [r4, #0]
 8016322:	e895 000e 	ldmia.w	r5, {r1, r2, r3}
 8016326:	f005 fb5d 	bl	801b9e4 <USB_CoreInit>
 801632a:	b130      	cbz	r0, 801633a <HAL_PCD_Init+0x4e>
  {
    hpcd->State = HAL_PCD_STATE_ERROR;
 801632c:	2302      	movs	r3, #2
 801632e:	f884 3495 	strb.w	r3, [r4, #1173]	@ 0x495
    return HAL_ERROR;
 8016332:	2501      	movs	r5, #1
  }

  (void)USB_DevDisconnect(hpcd->Instance);

  return HAL_OK;
}
 8016334:	4628      	mov	r0, r5
 8016336:	b003      	add	sp, #12
 8016338:	bd30      	pop	{r4, r5, pc}
  if (USB_SetCurrentMode(hpcd->Instance, USB_DEVICE_MODE) != HAL_OK)
 801633a:	4601      	mov	r1, r0
 801633c:	6820      	ldr	r0, [r4, #0]
 801633e:	f005 fc57 	bl	801bbf0 <USB_SetCurrentMode>
 8016342:	2800      	cmp	r0, #0
 8016344:	d1f2      	bne.n	801632c <HAL_PCD_Init+0x40>
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8016346:	7922      	ldrb	r2, [r4, #4]
 8016348:	2a00      	cmp	r2, #0
 801634a:	f000 81b3 	beq.w	80166b4 <HAL_PCD_Init+0x3c8>
    hpcd->IN_ep[i].num = i;
 801634e:	f44f 7380 	mov.w	r3, #256	@ 0x100
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8016352:	2a01      	cmp	r2, #1
    hpcd->IN_ep[i].tx_fifo_num = i;
 8016354:	85e0      	strh	r0, [r4, #46]	@ 0x2e
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 8016356:	7620      	strb	r0, [r4, #24]
    hpcd->IN_ep[i].maxpacket = 0U;
 8016358:	61e0      	str	r0, [r4, #28]
    hpcd->IN_ep[i].num = i;
 801635a:	82a3      	strh	r3, [r4, #20]
    hpcd->IN_ep[i].xfer_len = 0U;
 801635c:	e9c4 0008 	strd	r0, r0, [r4, #32]
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8016360:	f000 81d4 	beq.w	801670c <HAL_PCD_Init+0x420>
    hpcd->IN_ep[i].num = i;
 8016364:	f240 1301 	movw	r3, #257	@ 0x101
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8016368:	2a02      	cmp	r2, #2
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 801636a:	f884 003c 	strb.w	r0, [r4, #60]	@ 0x3c
    hpcd->IN_ep[i].num = i;
 801636e:	8723      	strh	r3, [r4, #56]	@ 0x38
    hpcd->IN_ep[i].tx_fifo_num = i;
 8016370:	f04f 0301 	mov.w	r3, #1
    hpcd->IN_ep[i].xfer_len = 0U;
 8016374:	64a0      	str	r0, [r4, #72]	@ 0x48
    hpcd->IN_ep[i].tx_fifo_num = i;
 8016376:	f8a4 3052 	strh.w	r3, [r4, #82]	@ 0x52
    hpcd->IN_ep[i].xfer_buff = 0U;
 801637a:	e9c4 0010 	strd	r0, r0, [r4, #64]	@ 0x40
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 801637e:	f000 80e2 	beq.w	8016546 <HAL_PCD_Init+0x25a>
    hpcd->IN_ep[i].num = i;
 8016382:	f44f 7381 	mov.w	r3, #258	@ 0x102
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8016386:	2a03      	cmp	r2, #3
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 8016388:	f884 0060 	strb.w	r0, [r4, #96]	@ 0x60
    hpcd->IN_ep[i].num = i;
 801638c:	f8a4 305c 	strh.w	r3, [r4, #92]	@ 0x5c
    hpcd->IN_ep[i].tx_fifo_num = i;
 8016390:	f04f 0302 	mov.w	r3, #2
    hpcd->IN_ep[i].xfer_len = 0U;
 8016394:	66e0      	str	r0, [r4, #108]	@ 0x6c
    hpcd->IN_ep[i].tx_fifo_num = i;
 8016396:	f8a4 3076 	strh.w	r3, [r4, #118]	@ 0x76
    hpcd->IN_ep[i].xfer_buff = 0U;
 801639a:	e9c4 0019 	strd	r0, r0, [r4, #100]	@ 0x64
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 801639e:	f000 80d2 	beq.w	8016546 <HAL_PCD_Init+0x25a>
    hpcd->IN_ep[i].num = i;
 80163a2:	f240 1303 	movw	r3, #259	@ 0x103
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80163a6:	2a04      	cmp	r2, #4
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 80163a8:	f884 0084 	strb.w	r0, [r4, #132]	@ 0x84
    hpcd->IN_ep[i].num = i;
 80163ac:	f8a4 3080 	strh.w	r3, [r4, #128]	@ 0x80
    hpcd->IN_ep[i].tx_fifo_num = i;
 80163b0:	f04f 0303 	mov.w	r3, #3
    hpcd->IN_ep[i].xfer_len = 0U;
 80163b4:	f8c4 0090 	str.w	r0, [r4, #144]	@ 0x90
    hpcd->IN_ep[i].tx_fifo_num = i;
 80163b8:	f8a4 309a 	strh.w	r3, [r4, #154]	@ 0x9a
    hpcd->IN_ep[i].xfer_buff = 0U;
 80163bc:	e9c4 0022 	strd	r0, r0, [r4, #136]	@ 0x88
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80163c0:	f000 80c1 	beq.w	8016546 <HAL_PCD_Init+0x25a>
    hpcd->IN_ep[i].num = i;
 80163c4:	f44f 7382 	mov.w	r3, #260	@ 0x104
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80163c8:	2a05      	cmp	r2, #5
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 80163ca:	f884 00a8 	strb.w	r0, [r4, #168]	@ 0xa8
    hpcd->IN_ep[i].num = i;
 80163ce:	f8a4 30a4 	strh.w	r3, [r4, #164]	@ 0xa4
    hpcd->IN_ep[i].tx_fifo_num = i;
 80163d2:	f04f 0304 	mov.w	r3, #4
    hpcd->IN_ep[i].xfer_len = 0U;
 80163d6:	f8c4 00b4 	str.w	r0, [r4, #180]	@ 0xb4
    hpcd->IN_ep[i].tx_fifo_num = i;
 80163da:	f8a4 30be 	strh.w	r3, [r4, #190]	@ 0xbe
    hpcd->IN_ep[i].xfer_buff = 0U;
 80163de:	e9c4 002b 	strd	r0, r0, [r4, #172]	@ 0xac
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80163e2:	f000 80b0 	beq.w	8016546 <HAL_PCD_Init+0x25a>
    hpcd->IN_ep[i].num = i;
 80163e6:	f240 1305 	movw	r3, #261	@ 0x105
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80163ea:	2a06      	cmp	r2, #6
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 80163ec:	f884 00cc 	strb.w	r0, [r4, #204]	@ 0xcc
    hpcd->IN_ep[i].num = i;
 80163f0:	f8a4 30c8 	strh.w	r3, [r4, #200]	@ 0xc8
    hpcd->IN_ep[i].tx_fifo_num = i;
 80163f4:	f04f 0305 	mov.w	r3, #5
    hpcd->IN_ep[i].xfer_len = 0U;
 80163f8:	f8c4 00d8 	str.w	r0, [r4, #216]	@ 0xd8
    hpcd->IN_ep[i].tx_fifo_num = i;
 80163fc:	f8a4 30e2 	strh.w	r3, [r4, #226]	@ 0xe2
    hpcd->IN_ep[i].xfer_buff = 0U;
 8016400:	e9c4 0034 	strd	r0, r0, [r4, #208]	@ 0xd0
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8016404:	f000 809f 	beq.w	8016546 <HAL_PCD_Init+0x25a>
    hpcd->IN_ep[i].num = i;
 8016408:	f44f 7383 	mov.w	r3, #262	@ 0x106
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 801640c:	2a07      	cmp	r2, #7
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 801640e:	f884 00f0 	strb.w	r0, [r4, #240]	@ 0xf0
    hpcd->IN_ep[i].num = i;
 8016412:	f8a4 30ec 	strh.w	r3, [r4, #236]	@ 0xec
    hpcd->IN_ep[i].tx_fifo_num = i;
 8016416:	f04f 0306 	mov.w	r3, #6
    hpcd->IN_ep[i].xfer_len = 0U;
 801641a:	f8c4 00fc 	str.w	r0, [r4, #252]	@ 0xfc
    hpcd->IN_ep[i].tx_fifo_num = i;
 801641e:	f8a4 3106 	strh.w	r3, [r4, #262]	@ 0x106
    hpcd->IN_ep[i].xfer_buff = 0U;
 8016422:	e9c4 003d 	strd	r0, r0, [r4, #244]	@ 0xf4
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8016426:	f000 808e 	beq.w	8016546 <HAL_PCD_Init+0x25a>
    hpcd->IN_ep[i].num = i;
 801642a:	f240 1107 	movw	r1, #263	@ 0x107
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 801642e:	2300      	movs	r3, #0
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8016430:	2a08      	cmp	r2, #8
    hpcd->IN_ep[i].num = i;
 8016432:	f8a4 1110 	strh.w	r1, [r4, #272]	@ 0x110
    hpcd->IN_ep[i].tx_fifo_num = i;
 8016436:	f04f 0107 	mov.w	r1, #7
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 801643a:	f884 3114 	strb.w	r3, [r4, #276]	@ 0x114
    hpcd->IN_ep[i].xfer_len = 0U;
 801643e:	f8c4 3120 	str.w	r3, [r4, #288]	@ 0x120
    hpcd->IN_ep[i].tx_fifo_num = i;
 8016442:	f8a4 112a 	strh.w	r1, [r4, #298]	@ 0x12a
    hpcd->IN_ep[i].xfer_buff = 0U;
 8016446:	e9c4 3346 	strd	r3, r3, [r4, #280]	@ 0x118
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 801644a:	d07c      	beq.n	8016546 <HAL_PCD_Init+0x25a>
    hpcd->IN_ep[i].num = i;
 801644c:	f44f 7184 	mov.w	r1, #264	@ 0x108
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8016450:	2a09      	cmp	r2, #9
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 8016452:	f884 3138 	strb.w	r3, [r4, #312]	@ 0x138
    hpcd->IN_ep[i].num = i;
 8016456:	f8a4 1134 	strh.w	r1, [r4, #308]	@ 0x134
    hpcd->IN_ep[i].tx_fifo_num = i;
 801645a:	f04f 0108 	mov.w	r1, #8
    hpcd->IN_ep[i].xfer_len = 0U;
 801645e:	f8c4 3144 	str.w	r3, [r4, #324]	@ 0x144
    hpcd->IN_ep[i].tx_fifo_num = i;
 8016462:	f8a4 114e 	strh.w	r1, [r4, #334]	@ 0x14e
    hpcd->IN_ep[i].xfer_buff = 0U;
 8016466:	e9c4 334f 	strd	r3, r3, [r4, #316]	@ 0x13c
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 801646a:	d06c      	beq.n	8016546 <HAL_PCD_Init+0x25a>
    hpcd->IN_ep[i].num = i;
 801646c:	f240 1109 	movw	r1, #265	@ 0x109
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8016470:	2a0a      	cmp	r2, #10
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 8016472:	f884 315c 	strb.w	r3, [r4, #348]	@ 0x15c
    hpcd->IN_ep[i].num = i;
 8016476:	f8a4 1158 	strh.w	r1, [r4, #344]	@ 0x158
    hpcd->IN_ep[i].tx_fifo_num = i;
 801647a:	f04f 0109 	mov.w	r1, #9
    hpcd->IN_ep[i].xfer_len = 0U;
 801647e:	f8c4 3168 	str.w	r3, [r4, #360]	@ 0x168
    hpcd->IN_ep[i].tx_fifo_num = i;
 8016482:	f8a4 1172 	strh.w	r1, [r4, #370]	@ 0x172
    hpcd->IN_ep[i].xfer_buff = 0U;
 8016486:	e9c4 3358 	strd	r3, r3, [r4, #352]	@ 0x160
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 801648a:	d05c      	beq.n	8016546 <HAL_PCD_Init+0x25a>
    hpcd->IN_ep[i].num = i;
 801648c:	f44f 7185 	mov.w	r1, #266	@ 0x10a
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8016490:	2a0b      	cmp	r2, #11
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 8016492:	f884 3180 	strb.w	r3, [r4, #384]	@ 0x180
    hpcd->IN_ep[i].num = i;
 8016496:	f8a4 117c 	strh.w	r1, [r4, #380]	@ 0x17c
    hpcd->IN_ep[i].tx_fifo_num = i;
 801649a:	f04f 010a 	mov.w	r1, #10
    hpcd->IN_ep[i].xfer_len = 0U;
 801649e:	f8c4 318c 	str.w	r3, [r4, #396]	@ 0x18c
    hpcd->IN_ep[i].tx_fifo_num = i;
 80164a2:	f8a4 1196 	strh.w	r1, [r4, #406]	@ 0x196
    hpcd->IN_ep[i].xfer_buff = 0U;
 80164a6:	e9c4 3361 	strd	r3, r3, [r4, #388]	@ 0x184
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80164aa:	d04c      	beq.n	8016546 <HAL_PCD_Init+0x25a>
    hpcd->IN_ep[i].num = i;
 80164ac:	f240 110b 	movw	r1, #267	@ 0x10b
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80164b0:	2a0c      	cmp	r2, #12
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 80164b2:	f884 31a4 	strb.w	r3, [r4, #420]	@ 0x1a4
    hpcd->IN_ep[i].num = i;
 80164b6:	f8a4 11a0 	strh.w	r1, [r4, #416]	@ 0x1a0
    hpcd->IN_ep[i].tx_fifo_num = i;
 80164ba:	f04f 010b 	mov.w	r1, #11
    hpcd->IN_ep[i].xfer_len = 0U;
 80164be:	f8c4 31b0 	str.w	r3, [r4, #432]	@ 0x1b0
    hpcd->IN_ep[i].tx_fifo_num = i;
 80164c2:	f8a4 11ba 	strh.w	r1, [r4, #442]	@ 0x1ba
    hpcd->IN_ep[i].xfer_buff = 0U;
 80164c6:	e9c4 336a 	strd	r3, r3, [r4, #424]	@ 0x1a8
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80164ca:	d03c      	beq.n	8016546 <HAL_PCD_Init+0x25a>
    hpcd->IN_ep[i].num = i;
 80164cc:	f44f 7186 	mov.w	r1, #268	@ 0x10c
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80164d0:	2a0d      	cmp	r2, #13
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 80164d2:	f884 31c8 	strb.w	r3, [r4, #456]	@ 0x1c8
    hpcd->IN_ep[i].num = i;
 80164d6:	f8a4 11c4 	strh.w	r1, [r4, #452]	@ 0x1c4
    hpcd->IN_ep[i].tx_fifo_num = i;
 80164da:	f04f 010c 	mov.w	r1, #12
    hpcd->IN_ep[i].xfer_len = 0U;
 80164de:	f8c4 31d4 	str.w	r3, [r4, #468]	@ 0x1d4
    hpcd->IN_ep[i].tx_fifo_num = i;
 80164e2:	f8a4 11de 	strh.w	r1, [r4, #478]	@ 0x1de
    hpcd->IN_ep[i].xfer_buff = 0U;
 80164e6:	e9c4 3373 	strd	r3, r3, [r4, #460]	@ 0x1cc
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80164ea:	d02c      	beq.n	8016546 <HAL_PCD_Init+0x25a>
    hpcd->IN_ep[i].num = i;
 80164ec:	f240 110d 	movw	r1, #269	@ 0x10d
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80164f0:	2a0e      	cmp	r2, #14
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 80164f2:	f884 31ec 	strb.w	r3, [r4, #492]	@ 0x1ec
    hpcd->IN_ep[i].num = i;
 80164f6:	f8a4 11e8 	strh.w	r1, [r4, #488]	@ 0x1e8
    hpcd->IN_ep[i].tx_fifo_num = i;
 80164fa:	f04f 010d 	mov.w	r1, #13
    hpcd->IN_ep[i].xfer_len = 0U;
 80164fe:	f8c4 31f8 	str.w	r3, [r4, #504]	@ 0x1f8
    hpcd->IN_ep[i].tx_fifo_num = i;
 8016502:	f8a4 1202 	strh.w	r1, [r4, #514]	@ 0x202
    hpcd->IN_ep[i].xfer_buff = 0U;
 8016506:	e9c4 337c 	strd	r3, r3, [r4, #496]	@ 0x1f0
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 801650a:	d01c      	beq.n	8016546 <HAL_PCD_Init+0x25a>
    hpcd->IN_ep[i].num = i;
 801650c:	f44f 7187 	mov.w	r1, #270	@ 0x10e
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8016510:	2a0f      	cmp	r2, #15
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 8016512:	f884 3210 	strb.w	r3, [r4, #528]	@ 0x210
    hpcd->IN_ep[i].num = i;
 8016516:	f8a4 120c 	strh.w	r1, [r4, #524]	@ 0x20c
    hpcd->IN_ep[i].tx_fifo_num = i;
 801651a:	f04f 010e 	mov.w	r1, #14
    hpcd->IN_ep[i].xfer_len = 0U;
 801651e:	f8c4 321c 	str.w	r3, [r4, #540]	@ 0x21c
    hpcd->IN_ep[i].tx_fifo_num = i;
 8016522:	f8a4 1226 	strh.w	r1, [r4, #550]	@ 0x226
    hpcd->IN_ep[i].xfer_buff = 0U;
 8016526:	e9c4 3385 	strd	r3, r3, [r4, #532]	@ 0x214
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 801652a:	d00c      	beq.n	8016546 <HAL_PCD_Init+0x25a>
    hpcd->IN_ep[i].num = i;
 801652c:	f240 110f 	movw	r1, #271	@ 0x10f
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 8016530:	f884 3234 	strb.w	r3, [r4, #564]	@ 0x234
    hpcd->IN_ep[i].xfer_len = 0U;
 8016534:	f8c4 3240 	str.w	r3, [r4, #576]	@ 0x240
    hpcd->IN_ep[i].num = i;
 8016538:	f8a4 1230 	strh.w	r1, [r4, #560]	@ 0x230
    hpcd->IN_ep[i].tx_fifo_num = i;
 801653c:	210f      	movs	r1, #15
    hpcd->IN_ep[i].xfer_buff = 0U;
 801653e:	e9c4 338e 	strd	r3, r3, [r4, #568]	@ 0x238
    hpcd->IN_ep[i].tx_fifo_num = i;
 8016542:	f8a4 124a 	strh.w	r1, [r4, #586]	@ 0x24a
    hpcd->OUT_ep[i].num = i;
 8016546:	2300      	movs	r3, #0
 8016548:	2101      	movs	r1, #1
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 801654a:	2a02      	cmp	r2, #2
    hpcd->OUT_ep[i].num = i;
 801654c:	f8a4 3254 	strh.w	r3, [r4, #596]	@ 0x254
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 8016550:	f884 3258 	strb.w	r3, [r4, #600]	@ 0x258
    hpcd->OUT_ep[i].xfer_len = 0U;
 8016554:	f8c4 3264 	str.w	r3, [r4, #612]	@ 0x264
    hpcd->OUT_ep[i].num = i;
 8016558:	f8a4 1278 	strh.w	r1, [r4, #632]	@ 0x278
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 801655c:	f884 327c 	strb.w	r3, [r4, #636]	@ 0x27c
    hpcd->OUT_ep[i].xfer_len = 0U;
 8016560:	f8c4 3288 	str.w	r3, [r4, #648]	@ 0x288
    hpcd->OUT_ep[i].xfer_buff = 0U;
 8016564:	e9c4 3397 	strd	r3, r3, [r4, #604]	@ 0x25c
 8016568:	e9c4 33a0 	strd	r3, r3, [r4, #640]	@ 0x280
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 801656c:	f000 80a2 	beq.w	80166b4 <HAL_PCD_Init+0x3c8>
    hpcd->OUT_ep[i].num = i;
 8016570:	2102      	movs	r1, #2
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8016572:	2a03      	cmp	r2, #3
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 8016574:	f884 32a0 	strb.w	r3, [r4, #672]	@ 0x2a0
    hpcd->OUT_ep[i].num = i;
 8016578:	f8a4 129c 	strh.w	r1, [r4, #668]	@ 0x29c
    hpcd->OUT_ep[i].xfer_len = 0U;
 801657c:	f8c4 32ac 	str.w	r3, [r4, #684]	@ 0x2ac
    hpcd->OUT_ep[i].xfer_buff = 0U;
 8016580:	e9c4 33a9 	strd	r3, r3, [r4, #676]	@ 0x2a4
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8016584:	f000 8096 	beq.w	80166b4 <HAL_PCD_Init+0x3c8>
    hpcd->OUT_ep[i].num = i;
 8016588:	2103      	movs	r1, #3
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 801658a:	2a04      	cmp	r2, #4
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 801658c:	f884 32c4 	strb.w	r3, [r4, #708]	@ 0x2c4
    hpcd->OUT_ep[i].num = i;
 8016590:	f8a4 12c0 	strh.w	r1, [r4, #704]	@ 0x2c0
    hpcd->OUT_ep[i].xfer_len = 0U;
 8016594:	f8c4 32d0 	str.w	r3, [r4, #720]	@ 0x2d0
    hpcd->OUT_ep[i].xfer_buff = 0U;
 8016598:	e9c4 33b2 	strd	r3, r3, [r4, #712]	@ 0x2c8
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 801659c:	f000 808a 	beq.w	80166b4 <HAL_PCD_Init+0x3c8>
    hpcd->OUT_ep[i].num = i;
 80165a0:	2104      	movs	r1, #4
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80165a2:	2a05      	cmp	r2, #5
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 80165a4:	f884 32e8 	strb.w	r3, [r4, #744]	@ 0x2e8
    hpcd->OUT_ep[i].num = i;
 80165a8:	f8a4 12e4 	strh.w	r1, [r4, #740]	@ 0x2e4
    hpcd->OUT_ep[i].xfer_len = 0U;
 80165ac:	f8c4 32f4 	str.w	r3, [r4, #756]	@ 0x2f4
    hpcd->OUT_ep[i].xfer_buff = 0U;
 80165b0:	e9c4 33bb 	strd	r3, r3, [r4, #748]	@ 0x2ec
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80165b4:	d07e      	beq.n	80166b4 <HAL_PCD_Init+0x3c8>
    hpcd->OUT_ep[i].num = i;
 80165b6:	2105      	movs	r1, #5
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80165b8:	2a06      	cmp	r2, #6
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 80165ba:	f884 330c 	strb.w	r3, [r4, #780]	@ 0x30c
    hpcd->OUT_ep[i].num = i;
 80165be:	f8a4 1308 	strh.w	r1, [r4, #776]	@ 0x308
    hpcd->OUT_ep[i].xfer_len = 0U;
 80165c2:	f8c4 3318 	str.w	r3, [r4, #792]	@ 0x318
    hpcd->OUT_ep[i].xfer_buff = 0U;
 80165c6:	e9c4 33c4 	strd	r3, r3, [r4, #784]	@ 0x310
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80165ca:	d073      	beq.n	80166b4 <HAL_PCD_Init+0x3c8>
    hpcd->OUT_ep[i].num = i;
 80165cc:	2106      	movs	r1, #6
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80165ce:	2a07      	cmp	r2, #7
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 80165d0:	f884 3330 	strb.w	r3, [r4, #816]	@ 0x330
    hpcd->OUT_ep[i].num = i;
 80165d4:	f8a4 132c 	strh.w	r1, [r4, #812]	@ 0x32c
    hpcd->OUT_ep[i].xfer_len = 0U;
 80165d8:	f8c4 333c 	str.w	r3, [r4, #828]	@ 0x33c
    hpcd->OUT_ep[i].xfer_buff = 0U;
 80165dc:	e9c4 33cd 	strd	r3, r3, [r4, #820]	@ 0x334
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80165e0:	d068      	beq.n	80166b4 <HAL_PCD_Init+0x3c8>
    hpcd->OUT_ep[i].num = i;
 80165e2:	2107      	movs	r1, #7
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80165e4:	2a08      	cmp	r2, #8
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 80165e6:	f884 3354 	strb.w	r3, [r4, #852]	@ 0x354
    hpcd->OUT_ep[i].num = i;
 80165ea:	f8a4 1350 	strh.w	r1, [r4, #848]	@ 0x350
    hpcd->OUT_ep[i].xfer_len = 0U;
 80165ee:	f8c4 3360 	str.w	r3, [r4, #864]	@ 0x360
    hpcd->OUT_ep[i].xfer_buff = 0U;
 80165f2:	e9c4 33d6 	strd	r3, r3, [r4, #856]	@ 0x358
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80165f6:	d05d      	beq.n	80166b4 <HAL_PCD_Init+0x3c8>
    hpcd->OUT_ep[i].num = i;
 80165f8:	2108      	movs	r1, #8
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80165fa:	2a09      	cmp	r2, #9
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 80165fc:	f884 3378 	strb.w	r3, [r4, #888]	@ 0x378
    hpcd->OUT_ep[i].num = i;
 8016600:	f8a4 1374 	strh.w	r1, [r4, #884]	@ 0x374
    hpcd->OUT_ep[i].xfer_len = 0U;
 8016604:	f8c4 3384 	str.w	r3, [r4, #900]	@ 0x384
    hpcd->OUT_ep[i].xfer_buff = 0U;
 8016608:	e9c4 33df 	strd	r3, r3, [r4, #892]	@ 0x37c
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 801660c:	d052      	beq.n	80166b4 <HAL_PCD_Init+0x3c8>
    hpcd->OUT_ep[i].num = i;
 801660e:	2109      	movs	r1, #9
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8016610:	2a0a      	cmp	r2, #10
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 8016612:	f884 339c 	strb.w	r3, [r4, #924]	@ 0x39c
    hpcd->OUT_ep[i].num = i;
 8016616:	f8a4 1398 	strh.w	r1, [r4, #920]	@ 0x398
    hpcd->OUT_ep[i].xfer_len = 0U;
 801661a:	f8c4 33a8 	str.w	r3, [r4, #936]	@ 0x3a8
    hpcd->OUT_ep[i].xfer_buff = 0U;
 801661e:	e9c4 33e8 	strd	r3, r3, [r4, #928]	@ 0x3a0
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8016622:	d047      	beq.n	80166b4 <HAL_PCD_Init+0x3c8>
    hpcd->OUT_ep[i].num = i;
 8016624:	210a      	movs	r1, #10
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8016626:	2a0b      	cmp	r2, #11
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 8016628:	f884 33c0 	strb.w	r3, [r4, #960]	@ 0x3c0
    hpcd->OUT_ep[i].num = i;
 801662c:	f8a4 13bc 	strh.w	r1, [r4, #956]	@ 0x3bc
    hpcd->OUT_ep[i].xfer_len = 0U;
 8016630:	f8c4 33cc 	str.w	r3, [r4, #972]	@ 0x3cc
    hpcd->OUT_ep[i].xfer_buff = 0U;
 8016634:	e9c4 33f1 	strd	r3, r3, [r4, #964]	@ 0x3c4
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8016638:	d03c      	beq.n	80166b4 <HAL_PCD_Init+0x3c8>
    hpcd->OUT_ep[i].num = i;
 801663a:	210b      	movs	r1, #11
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 801663c:	2a0c      	cmp	r2, #12
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 801663e:	f884 33e4 	strb.w	r3, [r4, #996]	@ 0x3e4
    hpcd->OUT_ep[i].num = i;
 8016642:	f8a4 13e0 	strh.w	r1, [r4, #992]	@ 0x3e0
    hpcd->OUT_ep[i].xfer_len = 0U;
 8016646:	f8c4 33f0 	str.w	r3, [r4, #1008]	@ 0x3f0
    hpcd->OUT_ep[i].xfer_buff = 0U;
 801664a:	e9c4 33fa 	strd	r3, r3, [r4, #1000]	@ 0x3e8
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 801664e:	d031      	beq.n	80166b4 <HAL_PCD_Init+0x3c8>
    hpcd->OUT_ep[i].num = i;
 8016650:	210c      	movs	r1, #12
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8016652:	2a0d      	cmp	r2, #13
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 8016654:	f884 3408 	strb.w	r3, [r4, #1032]	@ 0x408
    hpcd->OUT_ep[i].maxpacket = 0U;
 8016658:	f8c4 340c 	str.w	r3, [r4, #1036]	@ 0x40c
    hpcd->OUT_ep[i].xfer_buff = 0U;
 801665c:	f8c4 3410 	str.w	r3, [r4, #1040]	@ 0x410
    hpcd->OUT_ep[i].num = i;
 8016660:	f8a4 1404 	strh.w	r1, [r4, #1028]	@ 0x404
    hpcd->OUT_ep[i].xfer_len = 0U;
 8016664:	f8c4 3414 	str.w	r3, [r4, #1044]	@ 0x414
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8016668:	d024      	beq.n	80166b4 <HAL_PCD_Init+0x3c8>
    hpcd->OUT_ep[i].num = i;
 801666a:	210d      	movs	r1, #13
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 801666c:	2a0e      	cmp	r2, #14
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 801666e:	f884 342c 	strb.w	r3, [r4, #1068]	@ 0x42c
    hpcd->OUT_ep[i].maxpacket = 0U;
 8016672:	f8c4 3430 	str.w	r3, [r4, #1072]	@ 0x430
    hpcd->OUT_ep[i].xfer_buff = 0U;
 8016676:	f8c4 3434 	str.w	r3, [r4, #1076]	@ 0x434
    hpcd->OUT_ep[i].num = i;
 801667a:	f8a4 1428 	strh.w	r1, [r4, #1064]	@ 0x428
    hpcd->OUT_ep[i].xfer_len = 0U;
 801667e:	f8c4 3438 	str.w	r3, [r4, #1080]	@ 0x438
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8016682:	d017      	beq.n	80166b4 <HAL_PCD_Init+0x3c8>
    hpcd->OUT_ep[i].num = i;
 8016684:	210e      	movs	r1, #14
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8016686:	2a0f      	cmp	r2, #15
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 8016688:	f884 3450 	strb.w	r3, [r4, #1104]	@ 0x450
    hpcd->OUT_ep[i].maxpacket = 0U;
 801668c:	f8c4 3454 	str.w	r3, [r4, #1108]	@ 0x454
    hpcd->OUT_ep[i].xfer_buff = 0U;
 8016690:	f8c4 3458 	str.w	r3, [r4, #1112]	@ 0x458
    hpcd->OUT_ep[i].num = i;
 8016694:	f8a4 144c 	strh.w	r1, [r4, #1100]	@ 0x44c
    hpcd->OUT_ep[i].xfer_len = 0U;
 8016698:	f8c4 345c 	str.w	r3, [r4, #1116]	@ 0x45c
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 801669c:	d00a      	beq.n	80166b4 <HAL_PCD_Init+0x3c8>
    hpcd->OUT_ep[i].num = i;
 801669e:	220f      	movs	r2, #15
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 80166a0:	f884 3474 	strb.w	r3, [r4, #1140]	@ 0x474
    hpcd->OUT_ep[i].maxpacket = 0U;
 80166a4:	f8c4 3478 	str.w	r3, [r4, #1144]	@ 0x478
    hpcd->OUT_ep[i].xfer_buff = 0U;
 80166a8:	f8c4 347c 	str.w	r3, [r4, #1148]	@ 0x47c
    hpcd->OUT_ep[i].num = i;
 80166ac:	f8a4 2470 	strh.w	r2, [r4, #1136]	@ 0x470
    hpcd->OUT_ep[i].xfer_len = 0U;
 80166b0:	f8c4 3480 	str.w	r3, [r4, #1152]	@ 0x480
  if (USB_DevInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 80166b4:	7c20      	ldrb	r0, [r4, #16]
 80166b6:	e895 000e 	ldmia.w	r5, {r1, r2, r3}
 80166ba:	f88d 0000 	strb.w	r0, [sp]
 80166be:	6820      	ldr	r0, [r4, #0]
 80166c0:	f005 facc 	bl	801bc5c <USB_DevInit>
 80166c4:	4605      	mov	r5, r0
 80166c6:	2800      	cmp	r0, #0
 80166c8:	f47f ae30 	bne.w	801632c <HAL_PCD_Init+0x40>
  hpcd->State = HAL_PCD_STATE_READY;
 80166cc:	2201      	movs	r2, #1
  if (hpcd->Init.lpm_enable == 1U)
 80166ce:	7b23      	ldrb	r3, [r4, #12]
  hpcd->USB_Address = 0U;
 80166d0:	7460      	strb	r0, [r4, #17]
  if (hpcd->Init.lpm_enable == 1U)
 80166d2:	4293      	cmp	r3, r2
  hpcd->State = HAL_PCD_STATE_READY;
 80166d4:	f884 2495 	strb.w	r2, [r4, #1173]	@ 0x495
  if (hpcd->Init.lpm_enable == 1U)
 80166d8:	d014      	beq.n	8016704 <HAL_PCD_Init+0x418>
  (void)USB_DevDisconnect(hpcd->Instance);
 80166da:	6820      	ldr	r0, [r4, #0]
 80166dc:	f005 fefc 	bl	801c4d8 <USB_DevDisconnect>
}
 80166e0:	4628      	mov	r0, r5
 80166e2:	b003      	add	sp, #12
 80166e4:	bd30      	pop	{r4, r5, pc}
    hpcd->Lock = HAL_UNLOCKED;
 80166e6:	f880 2494 	strb.w	r2, [r0, #1172]	@ 0x494
    HAL_PCD_MspInit(hpcd);
 80166ea:	f009 fca3 	bl	8020034 <HAL_PCD_MspInit>
  hpcd->State = HAL_PCD_STATE_BUSY;
 80166ee:	2303      	movs	r3, #3
  if (USBx == USB_OTG_FS)
 80166f0:	f1b5 4fa0 	cmp.w	r5, #1342177280	@ 0x50000000
  __HAL_PCD_DISABLE(hpcd);
 80166f4:	6820      	ldr	r0, [r4, #0]
  hpcd->State = HAL_PCD_STATE_BUSY;
 80166f6:	f884 3495 	strb.w	r3, [r4, #1173]	@ 0x495
  if (USBx == USB_OTG_FS)
 80166fa:	f47f ae0b 	bne.w	8016314 <HAL_PCD_Init+0x28>
    hpcd->Init.dma_enable = 0U;
 80166fe:	2300      	movs	r3, #0
 8016700:	71a3      	strb	r3, [r4, #6]
 8016702:	e607      	b.n	8016314 <HAL_PCD_Init+0x28>
    (void)HAL_PCDEx_ActivateLPM(hpcd);
 8016704:	4620      	mov	r0, r4
 8016706:	f000 ffad 	bl	8017664 <HAL_PCDEx_ActivateLPM>
 801670a:	e7e6      	b.n	80166da <HAL_PCD_Init+0x3ee>
    hpcd->OUT_ep[i].num = i;
 801670c:	f8a4 0254 	strh.w	r0, [r4, #596]	@ 0x254
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 8016710:	f884 0258 	strb.w	r0, [r4, #600]	@ 0x258
    hpcd->OUT_ep[i].xfer_len = 0U;
 8016714:	f8c4 0264 	str.w	r0, [r4, #612]	@ 0x264
    hpcd->OUT_ep[i].xfer_buff = 0U;
 8016718:	e9c4 0097 	strd	r0, r0, [r4, #604]	@ 0x25c
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 801671c:	e7ca      	b.n	80166b4 <HAL_PCD_Init+0x3c8>
 801671e:	bf00      	nop

08016720 <HAL_PCD_Start>:
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{
  __HAL_LOCK(hpcd);
 8016720:	f890 3494 	ldrb.w	r3, [r0, #1172]	@ 0x494
 8016724:	2b01      	cmp	r3, #1
 8016726:	d00f      	beq.n	8016748 <HAL_PCD_Start+0x28>
 8016728:	2301      	movs	r3, #1
{
 801672a:	b510      	push	{r4, lr}
 801672c:	4604      	mov	r4, r0
  __HAL_PCD_ENABLE(hpcd);
 801672e:	6800      	ldr	r0, [r0, #0]
  __HAL_LOCK(hpcd);
 8016730:	f884 3494 	strb.w	r3, [r4, #1172]	@ 0x494
  __HAL_PCD_ENABLE(hpcd);
 8016734:	f005 fa4c 	bl	801bbd0 <USB_EnableGlobalInt>
  (void)USB_DevConnect(hpcd->Instance);
 8016738:	6820      	ldr	r0, [r4, #0]
 801673a:	f005 febd 	bl	801c4b8 <USB_DevConnect>
  __HAL_UNLOCK(hpcd);
 801673e:	2300      	movs	r3, #0

  return HAL_OK;
 8016740:	4618      	mov	r0, r3
  __HAL_UNLOCK(hpcd);
 8016742:	f884 3494 	strb.w	r3, [r4, #1172]	@ 0x494
}
 8016746:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hpcd);
 8016748:	2002      	movs	r0, #2
}
 801674a:	4770      	bx	lr

0801674c <HAL_PCD_IRQHandler>:
  * @brief  Handles PCD interrupt request.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
 801674c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8016750:	6806      	ldr	r6, [r0, #0]
{
 8016752:	b089      	sub	sp, #36	@ 0x24
 8016754:	4604      	mov	r4, r0
  uint32_t epnum;
  uint32_t fifoemptymsk;
  uint32_t RegVal;

  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
 8016756:	4630      	mov	r0, r6
 8016758:	f005 fefc 	bl	801c554 <USB_GetMode>
 801675c:	b110      	cbz	r0, 8016764 <HAL_PCD_IRQHandler+0x18>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
      hpcd->Instance->GOTGINT |= RegVal;
    }
  }
}
 801675e:	b009      	add	sp, #36	@ 0x24
 8016760:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (__HAL_PCD_IS_INVALID_INTERRUPT(hpcd))
 8016764:	4605      	mov	r5, r0
 8016766:	6820      	ldr	r0, [r4, #0]
 8016768:	f005 fec6 	bl	801c4f8 <USB_ReadInterrupts>
 801676c:	2800      	cmp	r0, #0
 801676e:	d0f6      	beq.n	801675e <HAL_PCD_IRQHandler+0x12>
    hpcd->FrameNumber = (USBx_DEVICE->DSTS & USB_OTG_DSTS_FNSOF_Msk) >> USB_OTG_DSTS_FNSOF_Pos;
 8016770:	f8d6 3808 	ldr.w	r3, [r6, #2056]	@ 0x808
 8016774:	f506 6200 	add.w	r2, r6, #2048	@ 0x800
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
 8016778:	6820      	ldr	r0, [r4, #0]
    hpcd->FrameNumber = (USBx_DEVICE->DSTS & USB_OTG_DSTS_FNSOF_Msk) >> USB_OTG_DSTS_FNSOF_Pos;
 801677a:	f3c3 230d 	ubfx	r3, r3, #8, #14
 801677e:	9203      	str	r2, [sp, #12]
 8016780:	f8c4 34d4 	str.w	r3, [r4, #1236]	@ 0x4d4
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
 8016784:	f005 feb8 	bl	801c4f8 <USB_ReadInterrupts>
 8016788:	f010 0f02 	tst.w	r0, #2
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
 801678c:	6820      	ldr	r0, [r4, #0]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
 801678e:	d003      	beq.n	8016798 <HAL_PCD_IRQHandler+0x4c>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
 8016790:	6943      	ldr	r3, [r0, #20]
 8016792:	f003 0302 	and.w	r3, r3, #2
 8016796:	6143      	str	r3, [r0, #20]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
 8016798:	f005 feae 	bl	801c4f8 <USB_ReadInterrupts>
 801679c:	f010 0f10 	tst.w	r0, #16
      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 80167a0:	6820      	ldr	r0, [r4, #0]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
 80167a2:	d012      	beq.n	80167ca <HAL_PCD_IRQHandler+0x7e>
      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 80167a4:	6983      	ldr	r3, [r0, #24]
 80167a6:	f023 0310 	bic.w	r3, r3, #16
 80167aa:	6183      	str	r3, [r0, #24]
      RegVal = USBx->GRXSTSP;
 80167ac:	6a37      	ldr	r7, [r6, #32]
      if (((RegVal & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_DATA_UPDT)
 80167ae:	f3c7 4343 	ubfx	r3, r7, #17, #4
      ep = &hpcd->OUT_ep[RegVal & USB_OTG_GRXSTSP_EPNUM];
 80167b2:	f007 080f 	and.w	r8, r7, #15
      if (((RegVal & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_DATA_UPDT)
 80167b6:	2b02      	cmp	r3, #2
 80167b8:	f000 83dc 	beq.w	8016f74 <HAL_PCD_IRQHandler+0x828>
      else if (((RegVal & USB_OTG_GRXSTSP_PKTSTS) >> 17) == STS_SETUP_UPDT)
 80167bc:	2b06      	cmp	r3, #6
 80167be:	f000 8379 	beq.w	8016eb4 <HAL_PCD_IRQHandler+0x768>
      USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 80167c2:	6983      	ldr	r3, [r0, #24]
 80167c4:	f043 0310 	orr.w	r3, r3, #16
 80167c8:	6183      	str	r3, [r0, #24]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
 80167ca:	f005 fe95 	bl	801c4f8 <USB_ReadInterrupts>
 80167ce:	f410 2f00 	tst.w	r0, #524288	@ 0x80000
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
 80167d2:	6820      	ldr	r0, [r4, #0]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
 80167d4:	f040 82d1 	bne.w	8016d7a <HAL_PCD_IRQHandler+0x62e>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IEPINT))
 80167d8:	f005 fe8e 	bl	801c4f8 <USB_ReadInterrupts>
 80167dc:	0347      	lsls	r7, r0, #13
 80167de:	f100 8228 	bmi.w	8016c32 <HAL_PCD_IRQHandler+0x4e6>
      ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);
 80167e2:	6820      	ldr	r0, [r4, #0]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 80167e4:	f005 fe88 	bl	801c4f8 <USB_ReadInterrupts>
 80167e8:	2800      	cmp	r0, #0
 80167ea:	f2c0 819a 	blt.w	8016b22 <HAL_PCD_IRQHandler+0x3d6>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP))
 80167ee:	6820      	ldr	r0, [r4, #0]
 80167f0:	f005 fe82 	bl	801c4f8 <USB_ReadInterrupts>
 80167f4:	0502      	lsls	r2, r0, #20
 80167f6:	f100 8157 	bmi.w	8016aa8 <HAL_PCD_IRQHandler+0x35c>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP);
 80167fa:	6820      	ldr	r0, [r4, #0]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_LPMINT))
 80167fc:	f005 fe7c 	bl	801c4f8 <USB_ReadInterrupts>
 8016800:	0107      	lsls	r7, r0, #4
 8016802:	d514      	bpl.n	801682e <HAL_PCD_IRQHandler+0xe2>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_LPMINT);
 8016804:	6822      	ldr	r2, [r4, #0]
 8016806:	6953      	ldr	r3, [r2, #20]
 8016808:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 801680c:	6153      	str	r3, [r2, #20]
      if (hpcd->LPM_State == LPM_L0)
 801680e:	f894 34cc 	ldrb.w	r3, [r4, #1228]	@ 0x4cc
 8016812:	2b00      	cmp	r3, #0
 8016814:	f040 8301 	bne.w	8016e1a <HAL_PCD_IRQHandler+0x6ce>
        hpcd->LPM_State = LPM_L1;
 8016818:	2101      	movs	r1, #1
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L1_ACTIVE);
 801681a:	4620      	mov	r0, r4
        hpcd->LPM_State = LPM_L1;
 801681c:	f884 14cc 	strb.w	r1, [r4, #1228]	@ 0x4cc
        hpcd->BESL = (hpcd->Instance->GLPMCFG & USB_OTG_GLPMCFG_BESL) >> 2U;
 8016820:	6d53      	ldr	r3, [r2, #84]	@ 0x54
 8016822:	f3c3 0383 	ubfx	r3, r3, #2, #4
 8016826:	f8c4 34d0 	str.w	r3, [r4, #1232]	@ 0x4d0
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L1_ACTIVE);
 801682a:	f009 fd55 	bl	80202d8 <HAL_PCDEx_LPM_Callback>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
 801682e:	6820      	ldr	r0, [r4, #0]
 8016830:	f005 fe62 	bl	801c4f8 <USB_ReadInterrupts>
 8016834:	04c0      	lsls	r0, r0, #19
 8016836:	f100 819e 	bmi.w	8016b76 <HAL_PCD_IRQHandler+0x42a>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
 801683a:	6820      	ldr	r0, [r4, #0]
 801683c:	f005 fe5c 	bl	801c4f8 <USB_ReadInterrupts>
 8016840:	f410 5f00 	tst.w	r0, #8192	@ 0x2000
      (void)USB_ActivateSetup(hpcd->Instance);
 8016844:	6820      	ldr	r0, [r4, #0]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
 8016846:	f040 817f 	bne.w	8016b48 <HAL_PCD_IRQHandler+0x3fc>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SOF))
 801684a:	f005 fe55 	bl	801c4f8 <USB_ReadInterrupts>
 801684e:	0701      	lsls	r1, r0, #28
 8016850:	f100 81e6 	bmi.w	8016c20 <HAL_PCD_IRQHandler+0x4d4>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_BOUTNAKEFF))
 8016854:	6820      	ldr	r0, [r4, #0]
 8016856:	f005 fe4f 	bl	801c4f8 <USB_ReadInterrupts>
 801685a:	0602      	lsls	r2, r0, #24
 801685c:	d571      	bpl.n	8016942 <HAL_PCD_IRQHandler+0x1f6>
      USBx->GINTMSK &= ~USB_OTG_GINTMSK_GONAKEFFM;
 801685e:	69b3      	ldr	r3, [r6, #24]
 8016860:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 8016864:	61b3      	str	r3, [r6, #24]
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8016866:	7923      	ldrb	r3, [r4, #4]
 8016868:	2b01      	cmp	r3, #1
 801686a:	d96a      	bls.n	8016942 <HAL_PCD_IRQHandler+0x1f6>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 801686c:	f894 227b 	ldrb.w	r2, [r4, #635]	@ 0x27b
 8016870:	2a01      	cmp	r2, #1
 8016872:	f000 83ed 	beq.w	8017050 <HAL_PCD_IRQHandler+0x904>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8016876:	2b02      	cmp	r3, #2
 8016878:	d963      	bls.n	8016942 <HAL_PCD_IRQHandler+0x1f6>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 801687a:	f894 229f 	ldrb.w	r2, [r4, #671]	@ 0x29f
 801687e:	2a01      	cmp	r2, #1
 8016880:	f000 8401 	beq.w	8017086 <HAL_PCD_IRQHandler+0x93a>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8016884:	2b03      	cmp	r3, #3
 8016886:	d95c      	bls.n	8016942 <HAL_PCD_IRQHandler+0x1f6>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 8016888:	f894 22c3 	ldrb.w	r2, [r4, #707]	@ 0x2c3
 801688c:	2a01      	cmp	r2, #1
 801688e:	f000 830a 	beq.w	8016ea6 <HAL_PCD_IRQHandler+0x75a>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8016892:	2b04      	cmp	r3, #4
 8016894:	d955      	bls.n	8016942 <HAL_PCD_IRQHandler+0x1f6>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 8016896:	f894 22e7 	ldrb.w	r2, [r4, #743]	@ 0x2e7
 801689a:	2a01      	cmp	r2, #1
 801689c:	f000 831d 	beq.w	8016eda <HAL_PCD_IRQHandler+0x78e>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 80168a0:	2b05      	cmp	r3, #5
 80168a2:	d94e      	bls.n	8016942 <HAL_PCD_IRQHandler+0x1f6>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 80168a4:	f894 230b 	ldrb.w	r2, [r4, #779]	@ 0x30b
 80168a8:	2a01      	cmp	r2, #1
 80168aa:	f000 842c 	beq.w	8017106 <HAL_PCD_IRQHandler+0x9ba>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 80168ae:	2b06      	cmp	r3, #6
 80168b0:	d947      	bls.n	8016942 <HAL_PCD_IRQHandler+0x1f6>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 80168b2:	f894 232f 	ldrb.w	r2, [r4, #815]	@ 0x32f
 80168b6:	2a01      	cmp	r2, #1
 80168b8:	f000 8439 	beq.w	801712e <HAL_PCD_IRQHandler+0x9e2>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 80168bc:	2b07      	cmp	r3, #7
 80168be:	d940      	bls.n	8016942 <HAL_PCD_IRQHandler+0x1f6>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 80168c0:	f894 2353 	ldrb.w	r2, [r4, #851]	@ 0x353
 80168c4:	2a01      	cmp	r2, #1
 80168c6:	f000 844b 	beq.w	8017160 <HAL_PCD_IRQHandler+0xa14>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 80168ca:	2b08      	cmp	r3, #8
 80168cc:	d939      	bls.n	8016942 <HAL_PCD_IRQHandler+0x1f6>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 80168ce:	f894 2377 	ldrb.w	r2, [r4, #887]	@ 0x377
 80168d2:	2a01      	cmp	r2, #1
 80168d4:	f000 8458 	beq.w	8017188 <HAL_PCD_IRQHandler+0xa3c>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 80168d8:	2b09      	cmp	r3, #9
 80168da:	d932      	bls.n	8016942 <HAL_PCD_IRQHandler+0x1f6>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 80168dc:	f894 239b 	ldrb.w	r2, [r4, #923]	@ 0x39b
 80168e0:	2a01      	cmp	r2, #1
 80168e2:	f000 8465 	beq.w	80171b0 <HAL_PCD_IRQHandler+0xa64>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 80168e6:	2b0a      	cmp	r3, #10
 80168e8:	d92b      	bls.n	8016942 <HAL_PCD_IRQHandler+0x1f6>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 80168ea:	f894 23bf 	ldrb.w	r2, [r4, #959]	@ 0x3bf
 80168ee:	2a01      	cmp	r2, #1
 80168f0:	f000 8472 	beq.w	80171d8 <HAL_PCD_IRQHandler+0xa8c>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 80168f4:	2b0b      	cmp	r3, #11
 80168f6:	d924      	bls.n	8016942 <HAL_PCD_IRQHandler+0x1f6>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 80168f8:	f894 23e3 	ldrb.w	r2, [r4, #995]	@ 0x3e3
 80168fc:	2a01      	cmp	r2, #1
 80168fe:	f000 847f 	beq.w	8017200 <HAL_PCD_IRQHandler+0xab4>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8016902:	2b0c      	cmp	r3, #12
 8016904:	d91d      	bls.n	8016942 <HAL_PCD_IRQHandler+0x1f6>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 8016906:	f894 2407 	ldrb.w	r2, [r4, #1031]	@ 0x407
 801690a:	2a01      	cmp	r2, #1
 801690c:	f000 8484 	beq.w	8017218 <HAL_PCD_IRQHandler+0xacc>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8016910:	2b0d      	cmp	r3, #13
 8016912:	d916      	bls.n	8016942 <HAL_PCD_IRQHandler+0x1f6>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 8016914:	f894 242b 	ldrb.w	r2, [r4, #1067]	@ 0x42b
 8016918:	2a01      	cmp	r2, #1
 801691a:	f000 84a4 	beq.w	8017266 <HAL_PCD_IRQHandler+0xb1a>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 801691e:	2b0e      	cmp	r3, #14
 8016920:	d90f      	bls.n	8016942 <HAL_PCD_IRQHandler+0x1f6>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 8016922:	f894 244f 	ldrb.w	r2, [r4, #1103]	@ 0x44f
 8016926:	2a01      	cmp	r2, #1
 8016928:	f000 84ab 	beq.w	8017282 <HAL_PCD_IRQHandler+0xb36>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 801692c:	2b0f      	cmp	r3, #15
 801692e:	d908      	bls.n	8016942 <HAL_PCD_IRQHandler+0x1f6>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 8016930:	f894 3473 	ldrb.w	r3, [r4, #1139]	@ 0x473
 8016934:	2b01      	cmp	r3, #1
 8016936:	d104      	bne.n	8016942 <HAL_PCD_IRQHandler+0x1f6>
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
  }

  /* Stop Xfer */
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 8016938:	f504 618e 	add.w	r1, r4, #1136	@ 0x470
 801693c:	6820      	ldr	r0, [r4, #0]
 801693e:	f005 fcc1 	bl	801c2c4 <USB_EPStopXfer>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR))
 8016942:	6820      	ldr	r0, [r4, #0]
 8016944:	f005 fdd8 	bl	801c4f8 <USB_ReadInterrupts>
 8016948:	02c3      	lsls	r3, r0, #11
 801694a:	f140 80ab 	bpl.w	8016aa4 <HAL_PCD_IRQHandler+0x358>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 801694e:	7923      	ldrb	r3, [r4, #4]
 8016950:	2b01      	cmp	r3, #1
 8016952:	f240 8089 	bls.w	8016a68 <HAL_PCD_IRQHandler+0x31c>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8016956:	f894 203c 	ldrb.w	r2, [r4, #60]	@ 0x3c
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 801695a:	f8d6 1920 	ldr.w	r1, [r6, #2336]	@ 0x920
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 801695e:	2a01      	cmp	r2, #1
 8016960:	f000 826a 	beq.w	8016e38 <HAL_PCD_IRQHandler+0x6ec>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8016964:	2b02      	cmp	r3, #2
 8016966:	d97f      	bls.n	8016a68 <HAL_PCD_IRQHandler+0x31c>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8016968:	f894 2060 	ldrb.w	r2, [r4, #96]	@ 0x60
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 801696c:	f8d6 1940 	ldr.w	r1, [r6, #2368]	@ 0x940
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8016970:	2a01      	cmp	r2, #1
 8016972:	f000 8274 	beq.w	8016e5e <HAL_PCD_IRQHandler+0x712>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8016976:	2b03      	cmp	r3, #3
 8016978:	d976      	bls.n	8016a68 <HAL_PCD_IRQHandler+0x31c>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 801697a:	f894 2084 	ldrb.w	r2, [r4, #132]	@ 0x84
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 801697e:	f8d6 1960 	ldr.w	r1, [r6, #2400]	@ 0x960
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8016982:	2a01      	cmp	r2, #1
 8016984:	f000 8277 	beq.w	8016e76 <HAL_PCD_IRQHandler+0x72a>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8016988:	2b04      	cmp	r3, #4
 801698a:	d96d      	bls.n	8016a68 <HAL_PCD_IRQHandler+0x31c>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 801698c:	f894 20a8 	ldrb.w	r2, [r4, #168]	@ 0xa8
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 8016990:	f8d6 1980 	ldr.w	r1, [r6, #2432]	@ 0x980
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8016994:	2a01      	cmp	r2, #1
 8016996:	f000 827a 	beq.w	8016e8e <HAL_PCD_IRQHandler+0x742>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 801699a:	2b05      	cmp	r3, #5
 801699c:	d964      	bls.n	8016a68 <HAL_PCD_IRQHandler+0x31c>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 801699e:	f894 20cc 	ldrb.w	r2, [r4, #204]	@ 0xcc
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 80169a2:	f8d6 19a0 	ldr.w	r1, [r6, #2464]	@ 0x9a0
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 80169a6:	2a01      	cmp	r2, #1
 80169a8:	f000 8346 	beq.w	8017038 <HAL_PCD_IRQHandler+0x8ec>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 80169ac:	2b06      	cmp	r3, #6
 80169ae:	d95b      	bls.n	8016a68 <HAL_PCD_IRQHandler+0x31c>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 80169b0:	f894 20f0 	ldrb.w	r2, [r4, #240]	@ 0xf0
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 80169b4:	f8d6 19c0 	ldr.w	r1, [r6, #2496]	@ 0x9c0
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 80169b8:	2a01      	cmp	r2, #1
 80169ba:	f000 8358 	beq.w	801706e <HAL_PCD_IRQHandler+0x922>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 80169be:	2b07      	cmp	r3, #7
 80169c0:	d952      	bls.n	8016a68 <HAL_PCD_IRQHandler+0x31c>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 80169c2:	f894 2114 	ldrb.w	r2, [r4, #276]	@ 0x114
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 80169c6:	f8d6 19e0 	ldr.w	r1, [r6, #2528]	@ 0x9e0
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 80169ca:	2a01      	cmp	r2, #1
 80169cc:	f000 8363 	beq.w	8017096 <HAL_PCD_IRQHandler+0x94a>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 80169d0:	2b08      	cmp	r3, #8
 80169d2:	d949      	bls.n	8016a68 <HAL_PCD_IRQHandler+0x31c>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 80169d4:	f894 2138 	ldrb.w	r2, [r4, #312]	@ 0x138
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 80169d8:	f8d6 1a00 	ldr.w	r1, [r6, #2560]	@ 0xa00
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 80169dc:	2a01      	cmp	r2, #1
 80169de:	f000 836a 	beq.w	80170b6 <HAL_PCD_IRQHandler+0x96a>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 80169e2:	2b09      	cmp	r3, #9
 80169e4:	d940      	bls.n	8016a68 <HAL_PCD_IRQHandler+0x31c>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 80169e6:	f894 215c 	ldrb.w	r2, [r4, #348]	@ 0x15c
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 80169ea:	f8d6 1a20 	ldr.w	r1, [r6, #2592]	@ 0xa20
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 80169ee:	2a01      	cmp	r2, #1
 80169f0:	f000 8375 	beq.w	80170de <HAL_PCD_IRQHandler+0x992>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 80169f4:	2b0a      	cmp	r3, #10
 80169f6:	d937      	bls.n	8016a68 <HAL_PCD_IRQHandler+0x31c>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 80169f8:	f894 2180 	ldrb.w	r2, [r4, #384]	@ 0x180
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 80169fc:	f8d6 1a40 	ldr.w	r1, [r6, #2624]	@ 0xa40
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8016a00:	2a01      	cmp	r2, #1
 8016a02:	f000 8388 	beq.w	8017116 <HAL_PCD_IRQHandler+0x9ca>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8016a06:	2b0b      	cmp	r3, #11
 8016a08:	d92e      	bls.n	8016a68 <HAL_PCD_IRQHandler+0x31c>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8016a0a:	f894 21a4 	ldrb.w	r2, [r4, #420]	@ 0x1a4
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 8016a0e:	f8d6 1a60 	ldr.w	r1, [r6, #2656]	@ 0xa60
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8016a12:	2a01      	cmp	r2, #1
 8016a14:	f000 8398 	beq.w	8017148 <HAL_PCD_IRQHandler+0x9fc>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8016a18:	2b0c      	cmp	r3, #12
 8016a1a:	d925      	bls.n	8016a68 <HAL_PCD_IRQHandler+0x31c>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8016a1c:	f894 21c8 	ldrb.w	r2, [r4, #456]	@ 0x1c8
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 8016a20:	f8d6 1a80 	ldr.w	r1, [r6, #2688]	@ 0xa80
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8016a24:	2a01      	cmp	r2, #1
 8016a26:	f000 83a3 	beq.w	8017170 <HAL_PCD_IRQHandler+0xa24>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8016a2a:	2b0d      	cmp	r3, #13
 8016a2c:	d91c      	bls.n	8016a68 <HAL_PCD_IRQHandler+0x31c>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8016a2e:	f894 21ec 	ldrb.w	r2, [r4, #492]	@ 0x1ec
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 8016a32:	f8d6 1aa0 	ldr.w	r1, [r6, #2720]	@ 0xaa0
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8016a36:	2a01      	cmp	r2, #1
 8016a38:	f000 83ae 	beq.w	8017198 <HAL_PCD_IRQHandler+0xa4c>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8016a3c:	2b0e      	cmp	r3, #14
 8016a3e:	d913      	bls.n	8016a68 <HAL_PCD_IRQHandler+0x31c>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8016a40:	f894 2210 	ldrb.w	r2, [r4, #528]	@ 0x210
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 8016a44:	f8d6 1ac0 	ldr.w	r1, [r6, #2752]	@ 0xac0
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8016a48:	2a01      	cmp	r2, #1
 8016a4a:	f000 83b9 	beq.w	80171c0 <HAL_PCD_IRQHandler+0xa74>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8016a4e:	2b0f      	cmp	r3, #15
 8016a50:	d90a      	bls.n	8016a68 <HAL_PCD_IRQHandler+0x31c>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8016a52:	f894 2234 	ldrb.w	r2, [r4, #564]	@ 0x234
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 8016a56:	f8d6 1ae0 	ldr.w	r1, [r6, #2784]	@ 0xae0
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8016a5a:	2a01      	cmp	r2, #1
 8016a5c:	f000 83c4 	beq.w	80171e8 <HAL_PCD_IRQHandler+0xa9c>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8016a60:	2b10      	cmp	r3, #16
 8016a62:	d901      	bls.n	8016a68 <HAL_PCD_IRQHandler+0x31c>
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 8016a64:	f8d6 3b00 	ldr.w	r3, [r6, #2816]	@ 0xb00
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR);
 8016a68:	6820      	ldr	r0, [r4, #0]
 8016a6a:	6943      	ldr	r3, [r0, #20]
 8016a6c:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
 8016a70:	6143      	str	r3, [r0, #20]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
 8016a72:	f005 fd41 	bl	801c4f8 <USB_ReadInterrupts>
 8016a76:	0287      	lsls	r7, r0, #10
 8016a78:	d421      	bmi.n	8016abe <HAL_PCD_IRQHandler+0x372>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT))
 8016a7a:	6820      	ldr	r0, [r4, #0]
 8016a7c:	f005 fd3c 	bl	801c4f8 <USB_ReadInterrupts>
 8016a80:	0040      	lsls	r0, r0, #1
 8016a82:	f100 80c4 	bmi.w	8016c0e <HAL_PCD_IRQHandler+0x4c2>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OTGINT))
 8016a86:	6820      	ldr	r0, [r4, #0]
 8016a88:	f005 fd36 	bl	801c4f8 <USB_ReadInterrupts>
 8016a8c:	0741      	lsls	r1, r0, #29
 8016a8e:	f57f ae66 	bpl.w	801675e <HAL_PCD_IRQHandler+0x12>
      RegVal = hpcd->Instance->GOTGINT;
 8016a92:	6823      	ldr	r3, [r4, #0]
 8016a94:	685d      	ldr	r5, [r3, #4]
      if ((RegVal & USB_OTG_GOTGINT_SEDET) == USB_OTG_GOTGINT_SEDET)
 8016a96:	076a      	lsls	r2, r5, #29
 8016a98:	f100 828d 	bmi.w	8016fb6 <HAL_PCD_IRQHandler+0x86a>
      hpcd->Instance->GOTGINT |= RegVal;
 8016a9c:	685a      	ldr	r2, [r3, #4]
 8016a9e:	432a      	orrs	r2, r5
 8016aa0:	605a      	str	r2, [r3, #4]
 8016aa2:	e65c      	b.n	801675e <HAL_PCD_IRQHandler+0x12>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR);
 8016aa4:	6820      	ldr	r0, [r4, #0]
 8016aa6:	e7e4      	b.n	8016a72 <HAL_PCD_IRQHandler+0x326>
      if ((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
 8016aa8:	9b03      	ldr	r3, [sp, #12]
 8016aaa:	689b      	ldr	r3, [r3, #8]
 8016aac:	07db      	lsls	r3, r3, #31
 8016aae:	f100 827e 	bmi.w	8016fae <HAL_PCD_IRQHandler+0x862>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP);
 8016ab2:	6820      	ldr	r0, [r4, #0]
 8016ab4:	6943      	ldr	r3, [r0, #20]
 8016ab6:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 8016aba:	6143      	str	r3, [r0, #20]
 8016abc:	e69e      	b.n	80167fc <HAL_PCD_IRQHandler+0xb0>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8016abe:	f894 c004 	ldrb.w	ip, [r4, #4]
 8016ac2:	f1bc 0f01 	cmp.w	ip, #1
 8016ac6:	d926      	bls.n	8016b16 <HAL_PCD_IRQHandler+0x3ca>
 8016ac8:	f506 6232 	add.w	r2, r6, #2848	@ 0xb20
 8016acc:	4623      	mov	r3, r4
 8016ace:	2101      	movs	r1, #1
 8016ad0:	e004      	b.n	8016adc <HAL_PCD_IRQHandler+0x390>
 8016ad2:	3101      	adds	r1, #1
 8016ad4:	3220      	adds	r2, #32
 8016ad6:	3324      	adds	r3, #36	@ 0x24
 8016ad8:	4561      	cmp	r1, ip
 8016ada:	d01c      	beq.n	8016b16 <HAL_PCD_IRQHandler+0x3ca>
        if ((hpcd->OUT_ep[epnum].type == EP_TYPE_ISOC) &&
 8016adc:	f893 027c 	ldrb.w	r0, [r3, #636]	@ 0x27c
        RegVal = USBx_OUTEP(epnum)->DOEPCTL;
 8016ae0:	6815      	ldr	r5, [r2, #0]
        if ((hpcd->OUT_ep[epnum].type == EP_TYPE_ISOC) &&
 8016ae2:	2801      	cmp	r0, #1
 8016ae4:	d1f5      	bne.n	8016ad2 <HAL_PCD_IRQHandler+0x386>
 8016ae6:	2d00      	cmp	r5, #0
 8016ae8:	daf3      	bge.n	8016ad2 <HAL_PCD_IRQHandler+0x386>
            ((RegVal & (0x1U << 16)) == (hpcd->FrameNumber & 0x1U)))
 8016aea:	f8d4 74d4 	ldr.w	r7, [r4, #1236]	@ 0x4d4
 8016aee:	f405 3580 	and.w	r5, r5, #65536	@ 0x10000
 8016af2:	f007 0701 	and.w	r7, r7, #1
            ((RegVal & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA) &&
 8016af6:	42bd      	cmp	r5, r7
 8016af8:	d1eb      	bne.n	8016ad2 <HAL_PCD_IRQHandler+0x386>
          hpcd->OUT_ep[epnum].is_iso_incomplete = 1U;
 8016afa:	f883 027b 	strb.w	r0, [r3, #635]	@ 0x27b
          USBx->GINTMSK |= USB_OTG_GINTMSK_GONAKEFFM;
 8016afe:	69b0      	ldr	r0, [r6, #24]
 8016b00:	f040 0080 	orr.w	r0, r0, #128	@ 0x80
 8016b04:	61b0      	str	r0, [r6, #24]
          if ((USBx->GINTSTS & USB_OTG_GINTSTS_BOUTNAKEFF) == 0U)
 8016b06:	6970      	ldr	r0, [r6, #20]
 8016b08:	0605      	lsls	r5, r0, #24
 8016b0a:	d4e2      	bmi.n	8016ad2 <HAL_PCD_IRQHandler+0x386>
            USBx_DEVICE->DCTL |= USB_OTG_DCTL_SGONAK;
 8016b0c:	9a03      	ldr	r2, [sp, #12]
 8016b0e:	6853      	ldr	r3, [r2, #4]
 8016b10:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 8016b14:	6053      	str	r3, [r2, #4]
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
 8016b16:	6820      	ldr	r0, [r4, #0]
 8016b18:	6943      	ldr	r3, [r0, #20]
 8016b1a:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 8016b1e:	6143      	str	r3, [r0, #20]
 8016b20:	e7ac      	b.n	8016a7c <HAL_PCD_IRQHandler+0x330>
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 8016b22:	9a03      	ldr	r2, [sp, #12]
 8016b24:	6853      	ldr	r3, [r2, #4]
 8016b26:	f023 0301 	bic.w	r3, r3, #1
 8016b2a:	6053      	str	r3, [r2, #4]
      if (hpcd->LPM_State == LPM_L1)
 8016b2c:	f894 34cc 	ldrb.w	r3, [r4, #1228]	@ 0x4cc
 8016b30:	2b01      	cmp	r3, #1
 8016b32:	f000 818d 	beq.w	8016e50 <HAL_PCD_IRQHandler+0x704>
        HAL_PCD_ResumeCallback(hpcd);
 8016b36:	4620      	mov	r0, r4
 8016b38:	f009 fb0e 	bl	8020158 <HAL_PCD_ResumeCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT);
 8016b3c:	6820      	ldr	r0, [r4, #0]
 8016b3e:	6943      	ldr	r3, [r0, #20]
 8016b40:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 8016b44:	6143      	str	r3, [r0, #20]
 8016b46:	e653      	b.n	80167f0 <HAL_PCD_IRQHandler+0xa4>
      (void)USB_ActivateSetup(hpcd->Instance);
 8016b48:	f005 fd08 	bl	801c55c <USB_ActivateSetup>
      hpcd->Init.speed = USB_GetDevSpeed(hpcd->Instance);
 8016b4c:	6820      	ldr	r0, [r4, #0]
 8016b4e:	f005 f9e3 	bl	801bf18 <USB_GetDevSpeed>
      (void)USB_SetTurnaroundTime(hpcd->Instance,
 8016b52:	6825      	ldr	r5, [r4, #0]
      hpcd->Init.speed = USB_GetDevSpeed(hpcd->Instance);
 8016b54:	71e0      	strb	r0, [r4, #7]
      (void)USB_SetTurnaroundTime(hpcd->Instance,
 8016b56:	f001 f937 	bl	8017dc8 <HAL_RCC_GetHCLKFreq>
 8016b5a:	79e2      	ldrb	r2, [r4, #7]
 8016b5c:	4601      	mov	r1, r0
 8016b5e:	4628      	mov	r0, r5
 8016b60:	f004 ffbc 	bl	801badc <USB_SetTurnaroundTime>
      HAL_PCD_ResetCallback(hpcd);
 8016b64:	4620      	mov	r0, r4
 8016b66:	f009 fac9 	bl	80200fc <HAL_PCD_ResetCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE);
 8016b6a:	6820      	ldr	r0, [r4, #0]
 8016b6c:	6943      	ldr	r3, [r0, #20]
 8016b6e:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 8016b72:	6143      	str	r3, [r0, #20]
 8016b74:	e669      	b.n	801684a <HAL_PCD_IRQHandler+0xfe>
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 8016b76:	9a03      	ldr	r2, [sp, #12]
      (void)USB_FlushTxFifo(hpcd->Instance, 0x10U);
 8016b78:	2110      	movs	r1, #16
 8016b7a:	6820      	ldr	r0, [r4, #0]
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 8016b7c:	6853      	ldr	r3, [r2, #4]
 8016b7e:	f023 0301 	bic.w	r3, r3, #1
 8016b82:	6053      	str	r3, [r2, #4]
      (void)USB_FlushTxFifo(hpcd->Instance, 0x10U);
 8016b84:	f005 f9a0 	bl	801bec8 <USB_FlushTxFifo>
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8016b88:	7920      	ldrb	r0, [r4, #4]
 8016b8a:	b1d8      	cbz	r0, 8016bc4 <HAL_PCD_IRQHandler+0x478>
 8016b8c:	f506 6310 	add.w	r3, r6, #2304	@ 0x900
        USBx_INEP(i)->DIEPINT = 0xFB7FU;
 8016b90:	f64f 317f 	movw	r1, #64383	@ 0xfb7f
 8016b94:	6099      	str	r1, [r3, #8]
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8016b96:	3501      	adds	r5, #1
        USBx_INEP(i)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 8016b98:	681a      	ldr	r2, [r3, #0]
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8016b9a:	3320      	adds	r3, #32
 8016b9c:	4285      	cmp	r5, r0
        USBx_INEP(i)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 8016b9e:	f422 1200 	bic.w	r2, r2, #2097152	@ 0x200000
 8016ba2:	f843 2c20 	str.w	r2, [r3, #-32]
        USBx_OUTEP(i)->DOEPINT = 0xFB7FU;
 8016ba6:	f8c3 11e8 	str.w	r1, [r3, #488]	@ 0x1e8
        USBx_OUTEP(i)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 8016baa:	f8d3 21e0 	ldr.w	r2, [r3, #480]	@ 0x1e0
 8016bae:	f422 1200 	bic.w	r2, r2, #2097152	@ 0x200000
 8016bb2:	f8c3 21e0 	str.w	r2, [r3, #480]	@ 0x1e0
        USBx_OUTEP(i)->DOEPCTL |= USB_OTG_DOEPCTL_SNAK;
 8016bb6:	f8d3 21e0 	ldr.w	r2, [r3, #480]	@ 0x1e0
 8016bba:	f042 6200 	orr.w	r2, r2, #134217728	@ 0x8000000
 8016bbe:	f8c3 21e0 	str.w	r2, [r3, #480]	@ 0x1e0
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8016bc2:	d1e7      	bne.n	8016b94 <HAL_PCD_IRQHandler+0x448>
      USBx_DEVICE->DAINTMSK |= 0x10001U;
 8016bc4:	9a03      	ldr	r2, [sp, #12]
 8016bc6:	69d3      	ldr	r3, [r2, #28]
 8016bc8:	f043 1301 	orr.w	r3, r3, #65537	@ 0x10001
 8016bcc:	61d3      	str	r3, [r2, #28]
      if (hpcd->Init.use_dedicated_ep1 != 0U)
 8016bce:	7be3      	ldrb	r3, [r4, #15]
 8016bd0:	2b00      	cmp	r3, #0
 8016bd2:	f000 8126 	beq.w	8016e22 <HAL_PCD_IRQHandler+0x6d6>
        USBx_DEVICE->DOUTEP1MSK |= USB_OTG_DOEPMSK_STUPM |
 8016bd6:	f8d2 3084 	ldr.w	r3, [r2, #132]	@ 0x84
 8016bda:	f043 030b 	orr.w	r3, r3, #11
 8016bde:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84
        USBx_DEVICE->DINEP1MSK |= USB_OTG_DIEPMSK_TOM |
 8016be2:	6c53      	ldr	r3, [r2, #68]	@ 0x44
 8016be4:	f043 030b 	orr.w	r3, r3, #11
 8016be8:	6453      	str	r3, [r2, #68]	@ 0x44
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 8016bea:	f8d6 3800 	ldr.w	r3, [r6, #2048]	@ 0x800
      (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable,
 8016bee:	f204 429c 	addw	r2, r4, #1180	@ 0x49c
 8016bf2:	6820      	ldr	r0, [r4, #0]
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 8016bf4:	f423 63fe 	bic.w	r3, r3, #2032	@ 0x7f0
 8016bf8:	f8c6 3800 	str.w	r3, [r6, #2048]	@ 0x800
      (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable,
 8016bfc:	79a1      	ldrb	r1, [r4, #6]
 8016bfe:	f005 fcc3 	bl	801c588 <USB_EP0_OutStart>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBRST);
 8016c02:	6820      	ldr	r0, [r4, #0]
 8016c04:	6943      	ldr	r3, [r0, #20]
 8016c06:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
 8016c0a:	6143      	str	r3, [r0, #20]
 8016c0c:	e616      	b.n	801683c <HAL_PCD_IRQHandler+0xf0>
      HAL_PCD_ConnectCallback(hpcd);
 8016c0e:	4620      	mov	r0, r4
 8016c10:	f009 faae 	bl	8020170 <HAL_PCD_ConnectCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT);
 8016c14:	6820      	ldr	r0, [r4, #0]
 8016c16:	6943      	ldr	r3, [r0, #20]
 8016c18:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
 8016c1c:	6143      	str	r3, [r0, #20]
 8016c1e:	e733      	b.n	8016a88 <HAL_PCD_IRQHandler+0x33c>
      HAL_PCD_SOFCallback(hpcd);
 8016c20:	4620      	mov	r0, r4
 8016c22:	f009 fa67 	bl	80200f4 <HAL_PCD_SOFCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SOF);
 8016c26:	6820      	ldr	r0, [r4, #0]
 8016c28:	6943      	ldr	r3, [r0, #20]
 8016c2a:	f003 0308 	and.w	r3, r3, #8
 8016c2e:	6143      	str	r3, [r0, #20]
 8016c30:	e611      	b.n	8016856 <HAL_PCD_IRQHandler+0x10a>
      ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);
 8016c32:	6820      	ldr	r0, [r4, #0]
 8016c34:	f005 fc6c 	bl	801c510 <USB_ReadDevAllInEpInterrupt>
      while (ep_intr != 0U)
 8016c38:	4681      	mov	r9, r0
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 8016c3a:	6820      	ldr	r0, [r4, #0]
      while (ep_intr != 0U)
 8016c3c:	f1b9 0f00 	cmp.w	r9, #0
 8016c40:	f43f add0 	beq.w	80167e4 <HAL_PCD_IRQHandler+0x98>
 8016c44:	f506 6710 	add.w	r7, r6, #2304	@ 0x900
 8016c48:	46a0      	mov	r8, r4
      epnum = 0U;
 8016c4a:	f04f 0a00 	mov.w	sl, #0
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_TOC);
 8016c4e:	46bb      	mov	fp, r7
 8016c50:	e9cd 6504 	strd	r6, r5, [sp, #16]
 8016c54:	4605      	mov	r5, r0
 8016c56:	e009      	b.n	8016c6c <HAL_PCD_IRQHandler+0x520>
      while (ep_intr != 0U)
 8016c58:	ea5f 0959 	movs.w	r9, r9, lsr #1
        epnum++;
 8016c5c:	f10a 0a01 	add.w	sl, sl, #1
      while (ep_intr != 0U)
 8016c60:	f108 0824 	add.w	r8, r8, #36	@ 0x24
 8016c64:	f10b 0b20 	add.w	fp, fp, #32
 8016c68:	f000 8140 	beq.w	8016eec <HAL_PCD_IRQHandler+0x7a0>
        if ((ep_intr & 0x1U) != 0U) /* In ITR */
 8016c6c:	f019 0f01 	tst.w	r9, #1
 8016c70:	d0f2      	beq.n	8016c58 <HAL_PCD_IRQHandler+0x50c>
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 8016c72:	fa5f f78a 	uxtb.w	r7, sl
 8016c76:	4628      	mov	r0, r5
 8016c78:	4639      	mov	r1, r7
 8016c7a:	f005 fc5b 	bl	801c534 <USB_ReadDevInEPInterrupt>
          if ((epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
 8016c7e:	07c1      	lsls	r1, r0, #31
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 8016c80:	4606      	mov	r6, r0
          if ((epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
 8016c82:	d513      	bpl.n	8016cac <HAL_PCD_IRQHandler+0x560>
            fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 8016c84:	2001      	movs	r0, #1
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8016c86:	9b03      	ldr	r3, [sp, #12]
            fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 8016c88:	f00a 010f 	and.w	r1, sl, #15
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8016c8c:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
            fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 8016c8e:	fa00 f101 	lsl.w	r1, r0, r1
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8016c92:	ea22 0201 	bic.w	r2, r2, r1
 8016c96:	635a      	str	r2, [r3, #52]	@ 0x34
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_XFRC);
 8016c98:	f8cb 0008 	str.w	r0, [fp, #8]
            if (hpcd->Init.dma_enable == 1U)
 8016c9c:	79a1      	ldrb	r1, [r4, #6]
 8016c9e:	4281      	cmp	r1, r0
 8016ca0:	f000 818e 	beq.w	8016fc0 <HAL_PCD_IRQHandler+0x874>
            HAL_PCD_DataInStageCallback(hpcd, (uint8_t)epnum);
 8016ca4:	4639      	mov	r1, r7
 8016ca6:	4620      	mov	r0, r4
 8016ca8:	f009 fa1a 	bl	80200e0 <HAL_PCD_DataInStageCallback>
          if ((epint & USB_OTG_DIEPINT_TOC) == USB_OTG_DIEPINT_TOC)
 8016cac:	0732      	lsls	r2, r6, #28
 8016cae:	d502      	bpl.n	8016cb6 <HAL_PCD_IRQHandler+0x56a>
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_TOC);
 8016cb0:	2308      	movs	r3, #8
 8016cb2:	f8cb 3008 	str.w	r3, [fp, #8]
          if ((epint & USB_OTG_DIEPINT_ITTXFE) == USB_OTG_DIEPINT_ITTXFE)
 8016cb6:	06f3      	lsls	r3, r6, #27
 8016cb8:	d502      	bpl.n	8016cc0 <HAL_PCD_IRQHandler+0x574>
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_ITTXFE);
 8016cba:	2310      	movs	r3, #16
 8016cbc:	f8cb 3008 	str.w	r3, [fp, #8]
          if ((epint & USB_OTG_DIEPINT_INEPNE) == USB_OTG_DIEPINT_INEPNE)
 8016cc0:	0675      	lsls	r5, r6, #25
 8016cc2:	d502      	bpl.n	8016cca <HAL_PCD_IRQHandler+0x57e>
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);
 8016cc4:	2340      	movs	r3, #64	@ 0x40
 8016cc6:	f8cb 3008 	str.w	r3, [fp, #8]
          if ((epint & USB_OTG_DIEPINT_EPDISD) == USB_OTG_DIEPINT_EPDISD)
 8016cca:	07b0      	lsls	r0, r6, #30
 8016ccc:	f100 8145 	bmi.w	8016f5a <HAL_PCD_IRQHandler+0x80e>
          if ((epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
 8016cd0:	0631      	lsls	r1, r6, #24
  * @param  epnum endpoint number
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_WriteEmptyTxFifo(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8016cd2:	6825      	ldr	r5, [r4, #0]
          if ((epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
 8016cd4:	d5c0      	bpl.n	8016c58 <HAL_PCD_IRQHandler+0x50c>
  uint32_t len32b;
  uint32_t fifoemptymsk;

  ep = &hpcd->IN_ep[epnum];

  if (ep->xfer_count > ep->xfer_len)
 8016cd6:	e9d8 2309 	ldrd	r2, r3, [r8, #36]	@ 0x24
 8016cda:	4293      	cmp	r3, r2
 8016cdc:	d8bc      	bhi.n	8016c58 <HAL_PCD_IRQHandler+0x50c>
  {
    return HAL_ERROR;
  }

  len = ep->xfer_len - ep->xfer_count;
 8016cde:	eba2 0e03 	sub.w	lr, r2, r3
  if (len > ep->maxpacket)
  {
    len = ep->maxpacket;
  }

  len32b = (len + 3U) / 4U;
 8016ce2:	f8d8 101c 	ldr.w	r1, [r8, #28]

  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 8016ce6:	f505 6c10 	add.w	ip, r5, #2304	@ 0x900
  uint32_t USBx_BASE = (uint32_t)USBx;
 8016cea:	9507      	str	r5, [sp, #28]
  len32b = (len + 3U) / 4U;
 8016cec:	458e      	cmp	lr, r1
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 8016cee:	eb0c 164a 	add.w	r6, ip, sl, lsl #5
  len32b = (len + 3U) / 4U;
 8016cf2:	bf28      	it	cs
 8016cf4:	468e      	movcs	lr, r1
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 8016cf6:	69b0      	ldr	r0, [r6, #24]
  len32b = (len + 3U) / 4U;
 8016cf8:	f10e 0103 	add.w	r1, lr, #3
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 8016cfc:	fa1f fe80 	uxth.w	lr, r0
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
 8016d00:	ebbe 0f91 	cmp.w	lr, r1, lsr #2
 8016d04:	f0c0 8194 	bcc.w	8017030 <HAL_PCD_IRQHandler+0x8e4>
 8016d08:	f8cd b018 	str.w	fp, [sp, #24]
 8016d0c:	e024      	b.n	8016d58 <HAL_PCD_IRQHandler+0x60c>
  {
    /* Write the FIFO */
    len = ep->xfer_len - ep->xfer_count;
 8016d0e:	eba2 0b03 	sub.w	fp, r2, r3
 8016d12:	f8d8 301c 	ldr.w	r3, [r8, #28]
    {
      len = ep->maxpacket;
    }
    len32b = (len + 3U) / 4U;

    (void)USB_WritePacket(USBx, ep->xfer_buff, (uint8_t)epnum, (uint16_t)len,
 8016d16:	f8d8 1020 	ldr.w	r1, [r8, #32]
 8016d1a:	463a      	mov	r2, r7
 8016d1c:	459b      	cmp	fp, r3
 8016d1e:	4628      	mov	r0, r5
 8016d20:	bf28      	it	cs
 8016d22:	469b      	movcs	fp, r3
 8016d24:	79a3      	ldrb	r3, [r4, #6]
 8016d26:	9300      	str	r3, [sp, #0]
 8016d28:	fa1f f38b 	uxth.w	r3, fp
 8016d2c:	f005 fb14 	bl	801c358 <USB_WritePacket>
                          (uint8_t)hpcd->Init.dma_enable);

    ep->xfer_buff  += len;
 8016d30:	f8d8 3020 	ldr.w	r3, [r8, #32]
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 8016d34:	69b2      	ldr	r2, [r6, #24]
    ep->xfer_buff  += len;
 8016d36:	445b      	add	r3, fp
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 8016d38:	b292      	uxth	r2, r2
    ep->xfer_buff  += len;
 8016d3a:	f8c8 3020 	str.w	r3, [r8, #32]
    ep->xfer_count += len;
 8016d3e:	f8d8 3028 	ldr.w	r3, [r8, #40]	@ 0x28
 8016d42:	445b      	add	r3, fp
    len32b = (len + 3U) / 4U;
 8016d44:	f10b 0b03 	add.w	fp, fp, #3
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
 8016d48:	ebb2 0f9b 	cmp.w	r2, fp, lsr #2
    ep->xfer_count += len;
 8016d4c:	f8c8 3028 	str.w	r3, [r8, #40]	@ 0x28
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
 8016d50:	f0c0 8169 	bcc.w	8017026 <HAL_PCD_IRQHandler+0x8da>
  }

  if (ep->xfer_len <= ep->xfer_count)
 8016d54:	f8d8 2024 	ldr.w	r2, [r8, #36]	@ 0x24
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 8016d58:	4293      	cmp	r3, r2
 8016d5a:	d3d8      	bcc.n	8016d0e <HAL_PCD_IRQHandler+0x5c2>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 8016d5c:	f8dd b018 	ldr.w	fp, [sp, #24]
 8016d60:	6825      	ldr	r5, [r4, #0]
  {
    fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8016d62:	9b07      	ldr	r3, [sp, #28]
    fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 8016d64:	2201      	movs	r2, #1
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8016d66:	f503 6100 	add.w	r1, r3, #2048	@ 0x800
    fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 8016d6a:	f00a 030f 	and.w	r3, sl, #15
 8016d6e:	409a      	lsls	r2, r3
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8016d70:	6b4b      	ldr	r3, [r1, #52]	@ 0x34
 8016d72:	ea23 0302 	bic.w	r3, r3, r2
 8016d76:	634b      	str	r3, [r1, #52]	@ 0x34
 8016d78:	e76e      	b.n	8016c58 <HAL_PCD_IRQHandler+0x50c>
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
 8016d7a:	f005 fbc1 	bl	801c500 <USB_ReadDevAllOutEpInterrupt>
      while (ep_intr != 0U)
 8016d7e:	4607      	mov	r7, r0
 8016d80:	2800      	cmp	r0, #0
 8016d82:	f000 80b1 	beq.w	8016ee8 <HAL_PCD_IRQHandler+0x79c>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_EPDISD);
 8016d86:	9504      	str	r5, [sp, #16]
 8016d88:	f506 6830 	add.w	r8, r6, #2816	@ 0xb00
 8016d8c:	46a3      	mov	fp, r4
      epnum = 0U;
 8016d8e:	f04f 0a00 	mov.w	sl, #0
 8016d92:	6820      	ldr	r0, [r4, #0]
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_EPDISD);
 8016d94:	4625      	mov	r5, r4
 8016d96:	e008      	b.n	8016daa <HAL_PCD_IRQHandler+0x65e>
      while (ep_intr != 0U)
 8016d98:	087f      	lsrs	r7, r7, #1
        epnum++;
 8016d9a:	f10a 0a01 	add.w	sl, sl, #1
      while (ep_intr != 0U)
 8016d9e:	f108 0820 	add.w	r8, r8, #32
 8016da2:	f10b 0b24 	add.w	fp, fp, #36	@ 0x24
 8016da6:	f000 80a5 	beq.w	8016ef4 <HAL_PCD_IRQHandler+0x7a8>
        if ((ep_intr & 0x1U) != 0U)
 8016daa:	07fc      	lsls	r4, r7, #31
 8016dac:	d5f4      	bpl.n	8016d98 <HAL_PCD_IRQHandler+0x64c>
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 8016dae:	fa5f f48a 	uxtb.w	r4, sl
 8016db2:	4621      	mov	r1, r4
 8016db4:	f005 fbb4 	bl	801c520 <USB_ReadDevOutEPInterrupt>
          if ((epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
 8016db8:	f010 0f01 	tst.w	r0, #1
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 8016dbc:	4681      	mov	r9, r0
          if ((epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
 8016dbe:	f040 809c 	bne.w	8016efa <HAL_PCD_IRQHandler+0x7ae>
          if ((epint & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP)
 8016dc2:	f019 0f08 	tst.w	r9, #8
 8016dc6:	f040 80b7 	bne.w	8016f38 <HAL_PCD_IRQHandler+0x7ec>
          if ((epint & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS)
 8016dca:	f019 0f10 	tst.w	r9, #16
 8016dce:	d002      	beq.n	8016dd6 <HAL_PCD_IRQHandler+0x68a>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPDIS);
 8016dd0:	2210      	movs	r2, #16
 8016dd2:	f8c8 2008 	str.w	r2, [r8, #8]
          if ((epint & USB_OTG_DOEPINT_EPDISD) == USB_OTG_DOEPINT_EPDISD)
 8016dd6:	f019 0f02 	tst.w	r9, #2
 8016dda:	d00f      	beq.n	8016dfc <HAL_PCD_IRQHandler+0x6b0>
            if ((USBx->GINTSTS & USB_OTG_GINTSTS_BOUTNAKEFF) == USB_OTG_GINTSTS_BOUTNAKEFF)
 8016ddc:	6972      	ldr	r2, [r6, #20]
 8016dde:	0610      	lsls	r0, r2, #24
 8016de0:	d504      	bpl.n	8016dec <HAL_PCD_IRQHandler+0x6a0>
              USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGONAK;
 8016de2:	9b03      	ldr	r3, [sp, #12]
 8016de4:	685a      	ldr	r2, [r3, #4]
 8016de6:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
 8016dea:	605a      	str	r2, [r3, #4]
            if (ep->is_iso_incomplete == 1U)
 8016dec:	f89b 2257 	ldrb.w	r2, [fp, #599]	@ 0x257
 8016df0:	2a01      	cmp	r2, #1
 8016df2:	f000 8134 	beq.w	801705e <HAL_PCD_IRQHandler+0x912>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_EPDISD);
 8016df6:	2302      	movs	r3, #2
 8016df8:	f8c8 3008 	str.w	r3, [r8, #8]
          if ((epint & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)
 8016dfc:	f019 0f20 	tst.w	r9, #32
 8016e00:	d002      	beq.n	8016e08 <HAL_PCD_IRQHandler+0x6bc>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 8016e02:	2320      	movs	r3, #32
 8016e04:	f8c8 3008 	str.w	r3, [r8, #8]
          if ((epint & USB_OTG_DOEPINT_NAK) == USB_OTG_DOEPINT_NAK)
 8016e08:	f419 5f00 	tst.w	r9, #8192	@ 0x2000
 8016e0c:	d003      	beq.n	8016e16 <HAL_PCD_IRQHandler+0x6ca>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_NAK);
 8016e0e:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
 8016e12:	f8c8 3008 	str.w	r3, [r8, #8]
 8016e16:	6828      	ldr	r0, [r5, #0]
 8016e18:	e7be      	b.n	8016d98 <HAL_PCD_IRQHandler+0x64c>
        HAL_PCD_SuspendCallback(hpcd);
 8016e1a:	4620      	mov	r0, r4
 8016e1c:	f009 f984 	bl	8020128 <HAL_PCD_SuspendCallback>
 8016e20:	e505      	b.n	801682e <HAL_PCD_IRQHandler+0xe2>
        USBx_DEVICE->DOEPMSK |= USB_OTG_DOEPMSK_STUPM |
 8016e22:	4611      	mov	r1, r2
 8016e24:	f242 032b 	movw	r3, #8235	@ 0x202b
 8016e28:	6952      	ldr	r2, [r2, #20]
 8016e2a:	4313      	orrs	r3, r2
 8016e2c:	614b      	str	r3, [r1, #20]
        USBx_DEVICE->DIEPMSK |= USB_OTG_DIEPMSK_TOM |
 8016e2e:	690b      	ldr	r3, [r1, #16]
 8016e30:	f043 030b 	orr.w	r3, r3, #11
 8016e34:	610b      	str	r3, [r1, #16]
 8016e36:	e6d8      	b.n	8016bea <HAL_PCD_IRQHandler+0x49e>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8016e38:	2900      	cmp	r1, #0
 8016e3a:	f6bf ad93 	bge.w	8016964 <HAL_PCD_IRQHandler+0x218>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 8016e3e:	f104 0138 	add.w	r1, r4, #56	@ 0x38
 8016e42:	6820      	ldr	r0, [r4, #0]
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 8016e44:	f884 203b 	strb.w	r2, [r4, #59]	@ 0x3b
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 8016e48:	f005 fa3c 	bl	801c2c4 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8016e4c:	7923      	ldrb	r3, [r4, #4]
 8016e4e:	e589      	b.n	8016964 <HAL_PCD_IRQHandler+0x218>
        hpcd->LPM_State = LPM_L0;
 8016e50:	2100      	movs	r1, #0
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L0_ACTIVE);
 8016e52:	4620      	mov	r0, r4
        hpcd->LPM_State = LPM_L0;
 8016e54:	f884 14cc 	strb.w	r1, [r4, #1228]	@ 0x4cc
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L0_ACTIVE);
 8016e58:	f009 fa3e 	bl	80202d8 <HAL_PCDEx_LPM_Callback>
 8016e5c:	e66e      	b.n	8016b3c <HAL_PCD_IRQHandler+0x3f0>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8016e5e:	2900      	cmp	r1, #0
 8016e60:	f6bf ad89 	bge.w	8016976 <HAL_PCD_IRQHandler+0x22a>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 8016e64:	f104 015c 	add.w	r1, r4, #92	@ 0x5c
 8016e68:	6820      	ldr	r0, [r4, #0]
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 8016e6a:	f884 205f 	strb.w	r2, [r4, #95]	@ 0x5f
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 8016e6e:	f005 fa29 	bl	801c2c4 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8016e72:	7923      	ldrb	r3, [r4, #4]
 8016e74:	e57f      	b.n	8016976 <HAL_PCD_IRQHandler+0x22a>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8016e76:	2900      	cmp	r1, #0
 8016e78:	f6bf ad86 	bge.w	8016988 <HAL_PCD_IRQHandler+0x23c>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 8016e7c:	f104 0180 	add.w	r1, r4, #128	@ 0x80
 8016e80:	6820      	ldr	r0, [r4, #0]
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 8016e82:	f884 2083 	strb.w	r2, [r4, #131]	@ 0x83
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 8016e86:	f005 fa1d 	bl	801c2c4 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8016e8a:	7923      	ldrb	r3, [r4, #4]
 8016e8c:	e57c      	b.n	8016988 <HAL_PCD_IRQHandler+0x23c>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8016e8e:	2900      	cmp	r1, #0
 8016e90:	f6bf ad83 	bge.w	801699a <HAL_PCD_IRQHandler+0x24e>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 8016e94:	f104 01a4 	add.w	r1, r4, #164	@ 0xa4
 8016e98:	6820      	ldr	r0, [r4, #0]
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 8016e9a:	f884 20a7 	strb.w	r2, [r4, #167]	@ 0xa7
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 8016e9e:	f005 fa11 	bl	801c2c4 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8016ea2:	7923      	ldrb	r3, [r4, #4]
 8016ea4:	e579      	b.n	801699a <HAL_PCD_IRQHandler+0x24e>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 8016ea6:	f504 7130 	add.w	r1, r4, #704	@ 0x2c0
 8016eaa:	6820      	ldr	r0, [r4, #0]
 8016eac:	f005 fa0a 	bl	801c2c4 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8016eb0:	7923      	ldrb	r3, [r4, #4]
 8016eb2:	e4ee      	b.n	8016892 <HAL_PCD_IRQHandler+0x146>
        ep->xfer_count += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 8016eb4:	eb08 08c8 	add.w	r8, r8, r8, lsl #3
        (void)USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8U);
 8016eb8:	2208      	movs	r2, #8
 8016eba:	f204 419c 	addw	r1, r4, #1180	@ 0x49c
 8016ebe:	4630      	mov	r0, r6
 8016ec0:	f005 fa60 	bl	801c384 <USB_ReadPacket>
        ep->xfer_count += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 8016ec4:	f3c7 130a 	ubfx	r3, r7, #4, #11
 8016ec8:	eb04 0288 	add.w	r2, r4, r8, lsl #2
      USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8016ecc:	6820      	ldr	r0, [r4, #0]
        ep->xfer_count += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 8016ece:	f8d2 1268 	ldr.w	r1, [r2, #616]	@ 0x268
 8016ed2:	440b      	add	r3, r1
 8016ed4:	f8c2 3268 	str.w	r3, [r2, #616]	@ 0x268
 8016ed8:	e473      	b.n	80167c2 <HAL_PCD_IRQHandler+0x76>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 8016eda:	f504 7139 	add.w	r1, r4, #740	@ 0x2e4
 8016ede:	6820      	ldr	r0, [r4, #0]
 8016ee0:	f005 f9f0 	bl	801c2c4 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8016ee4:	7923      	ldrb	r3, [r4, #4]
 8016ee6:	e4db      	b.n	80168a0 <HAL_PCD_IRQHandler+0x154>
 8016ee8:	6820      	ldr	r0, [r4, #0]
 8016eea:	e475      	b.n	80167d8 <HAL_PCD_IRQHandler+0x8c>
 8016eec:	4628      	mov	r0, r5
 8016eee:	9e04      	ldr	r6, [sp, #16]
 8016ef0:	9d05      	ldr	r5, [sp, #20]
 8016ef2:	e477      	b.n	80167e4 <HAL_PCD_IRQHandler+0x98>
 8016ef4:	462c      	mov	r4, r5
 8016ef6:	9d04      	ldr	r5, [sp, #16]
 8016ef8:	e46e      	b.n	80167d8 <HAL_PCD_IRQHandler+0x8c>
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_EP_OutXfrComplete_int(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
  USB_OTG_EPTypeDef *ep;
  const USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8016efa:	6828      	ldr	r0, [r5, #0]
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
 8016efc:	2201      	movs	r2, #1
 8016efe:	f8c8 2008 	str.w	r2, [r8, #8]
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t gSNPSiD = *(__IO const uint32_t *)(&USBx->CID + 0x1U);
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 8016f02:	f500 6230 	add.w	r2, r0, #2816	@ 0xb00

  if (hpcd->Init.dma_enable == 1U)
 8016f06:	79a9      	ldrb	r1, [r5, #6]
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 8016f08:	eb02 124a 	add.w	r2, r2, sl, lsl #5
  uint32_t gSNPSiD = *(__IO const uint32_t *)(&USBx->CID + 0x1U);
 8016f0c:	f8d0 e040 	ldr.w	lr, [r0, #64]	@ 0x40
  if (hpcd->Init.dma_enable == 1U)
 8016f10:	2901      	cmp	r1, #1
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 8016f12:	6893      	ldr	r3, [r2, #8]
  if (hpcd->Init.dma_enable == 1U)
 8016f14:	d079      	beq.n	801700a <HAL_PCD_IRQHandler+0x8be>
      /* ... */
    }
  }
  else
  {
    if (gSNPSiD == USB_OTG_CORE_ID_310A)
 8016f16:	49be      	ldr	r1, [pc, #760]	@ (8017210 <HAL_PCD_IRQHandler+0xac4>)
 8016f18:	458e      	cmp	lr, r1
 8016f1a:	f000 80d8 	beq.w	80170ce <HAL_PCD_IRQHandler+0x982>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
    }
    else
    {
      if ((epnum == 0U) && (hpcd->OUT_ep[epnum].xfer_len == 0U))
 8016f1e:	f1ba 0f00 	cmp.w	sl, #0
 8016f22:	d104      	bne.n	8016f2e <HAL_PCD_IRQHandler+0x7e2>
 8016f24:	f8d5 2264 	ldr.w	r2, [r5, #612]	@ 0x264
 8016f28:	2a00      	cmp	r2, #0
 8016f2a:	f000 81a4 	beq.w	8017276 <HAL_PCD_IRQHandler+0xb2a>
      }

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->DataOutStageCallback(hpcd, (uint8_t)epnum);
#else
      HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 8016f2e:	4621      	mov	r1, r4
 8016f30:	4628      	mov	r0, r5
 8016f32:	f009 f8cb 	bl	80200cc <HAL_PCD_DataOutStageCallback>
 8016f36:	e744      	b.n	8016dc2 <HAL_PCD_IRQHandler+0x676>
  * @param  epnum endpoint number
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_EP_OutSetupPacket_int(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
  const USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8016f38:	6829      	ldr	r1, [r5, #0]
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STUP);
 8016f3a:	2208      	movs	r2, #8
 8016f3c:	f8c8 2008 	str.w	r2, [r8, #8]
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t gSNPSiD = *(__IO const uint32_t *)(&USBx->CID + 0x1U);
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 8016f40:	f501 6230 	add.w	r2, r1, #2816	@ 0xb00
  uint32_t gSNPSiD = *(__IO const uint32_t *)(&USBx->CID + 0x1U);
 8016f44:	6c08      	ldr	r0, [r1, #64]	@ 0x40

  if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 8016f46:	49b3      	ldr	r1, [pc, #716]	@ (8017214 <HAL_PCD_IRQHandler+0xac8>)
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 8016f48:	eb02 124a 	add.w	r2, r2, sl, lsl #5
  if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 8016f4c:	4288      	cmp	r0, r1
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 8016f4e:	6893      	ldr	r3, [r2, #8]
  if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 8016f50:	d849      	bhi.n	8016fe6 <HAL_PCD_IRQHandler+0x89a>

  /* Inform the upper layer that a setup packet is available */
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
  hpcd->SetupStageCallback(hpcd);
#else
  HAL_PCD_SetupStageCallback(hpcd);
 8016f52:	4628      	mov	r0, r5
 8016f54:	f009 f8b4 	bl	80200c0 <HAL_PCD_SetupStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

  if ((gSNPSiD > USB_OTG_CORE_ID_300A) && (hpcd->Init.dma_enable == 1U))
 8016f58:	e737      	b.n	8016dca <HAL_PCD_IRQHandler+0x67e>
            (void)USB_FlushTxFifo(USBx, epnum);
 8016f5a:	4651      	mov	r1, sl
 8016f5c:	9804      	ldr	r0, [sp, #16]
 8016f5e:	f004 ffb3 	bl	801bec8 <USB_FlushTxFifo>
            if (ep->is_iso_incomplete == 1U)
 8016f62:	f898 2017 	ldrb.w	r2, [r8, #23]
 8016f66:	2a01      	cmp	r2, #1
 8016f68:	f000 80c5 	beq.w	80170f6 <HAL_PCD_IRQHandler+0x9aa>
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_EPDISD);
 8016f6c:	2202      	movs	r2, #2
 8016f6e:	f8cb 2008 	str.w	r2, [fp, #8]
 8016f72:	e6ad      	b.n	8016cd0 <HAL_PCD_IRQHandler+0x584>
        if ((RegVal & USB_OTG_GRXSTSP_BCNT) != 0U)
 8016f74:	f647 73f0 	movw	r3, #32752	@ 0x7ff0
 8016f78:	421f      	tst	r7, r3
 8016f7a:	f43f ac22 	beq.w	80167c2 <HAL_PCD_IRQHandler+0x76>
          (void)USB_ReadPacket(USBx, ep->xfer_buff,
 8016f7e:	eb08 08c8 	add.w	r8, r8, r8, lsl #3
 8016f82:	f3c7 120a 	ubfx	r2, r7, #4, #11
 8016f86:	4630      	mov	r0, r6
 8016f88:	eb04 0888 	add.w	r8, r4, r8, lsl #2
 8016f8c:	4617      	mov	r7, r2
 8016f8e:	f8d8 1260 	ldr.w	r1, [r8, #608]	@ 0x260
 8016f92:	f005 f9f7 	bl	801c384 <USB_ReadPacket>
          ep->xfer_buff += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 8016f96:	f8d8 3260 	ldr.w	r3, [r8, #608]	@ 0x260
      USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8016f9a:	6820      	ldr	r0, [r4, #0]
          ep->xfer_buff += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 8016f9c:	443b      	add	r3, r7
 8016f9e:	f8c8 3260 	str.w	r3, [r8, #608]	@ 0x260
          ep->xfer_count += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 8016fa2:	f8d8 3268 	ldr.w	r3, [r8, #616]	@ 0x268
 8016fa6:	443b      	add	r3, r7
 8016fa8:	f8c8 3268 	str.w	r3, [r8, #616]	@ 0x268
 8016fac:	e409      	b.n	80167c2 <HAL_PCD_IRQHandler+0x76>
        HAL_PCD_SuspendCallback(hpcd);
 8016fae:	4620      	mov	r0, r4
 8016fb0:	f009 f8ba 	bl	8020128 <HAL_PCD_SuspendCallback>
 8016fb4:	e57d      	b.n	8016ab2 <HAL_PCD_IRQHandler+0x366>
        HAL_PCD_DisconnectCallback(hpcd);
 8016fb6:	4620      	mov	r0, r4
 8016fb8:	f009 f8de 	bl	8020178 <HAL_PCD_DisconnectCallback>
      hpcd->Instance->GOTGINT |= RegVal;
 8016fbc:	6823      	ldr	r3, [r4, #0]
 8016fbe:	e56d      	b.n	8016a9c <HAL_PCD_IRQHandler+0x350>
              hpcd->IN_ep[epnum].xfer_buff += hpcd->IN_ep[epnum].maxpacket;
 8016fc0:	e9d8 0207 	ldrd	r0, r2, [r8, #28]
 8016fc4:	4402      	add	r2, r0
 8016fc6:	f8c8 2020 	str.w	r2, [r8, #32]
              if ((epnum == 0U) && (hpcd->IN_ep[epnum].xfer_len == 0U))
 8016fca:	f1ba 0f00 	cmp.w	sl, #0
 8016fce:	f47f ae69 	bne.w	8016ca4 <HAL_PCD_IRQHandler+0x558>
 8016fd2:	6a62      	ldr	r2, [r4, #36]	@ 0x24
 8016fd4:	2a00      	cmp	r2, #0
 8016fd6:	f47f ae65 	bne.w	8016ca4 <HAL_PCD_IRQHandler+0x558>
                (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 8016fda:	f204 429c 	addw	r2, r4, #1180	@ 0x49c
 8016fde:	6820      	ldr	r0, [r4, #0]
 8016fe0:	f005 fad2 	bl	801c588 <USB_EP0_OutStart>
 8016fe4:	e65e      	b.n	8016ca4 <HAL_PCD_IRQHandler+0x558>
  if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 8016fe6:	041b      	lsls	r3, r3, #16
 8016fe8:	d561      	bpl.n	80170ae <HAL_PCD_IRQHandler+0x962>
    CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 8016fea:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
  HAL_PCD_SetupStageCallback(hpcd);
 8016fee:	4628      	mov	r0, r5
    CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 8016ff0:	6091      	str	r1, [r2, #8]
  HAL_PCD_SetupStageCallback(hpcd);
 8016ff2:	f009 f865 	bl	80200c0 <HAL_PCD_SetupStageCallback>
  if ((gSNPSiD > USB_OTG_CORE_ID_300A) && (hpcd->Init.dma_enable == 1U))
 8016ff6:	79a9      	ldrb	r1, [r5, #6]
 8016ff8:	2901      	cmp	r1, #1
 8016ffa:	f47f aee6 	bne.w	8016dca <HAL_PCD_IRQHandler+0x67e>
  {
    (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 8016ffe:	f205 429c 	addw	r2, r5, #1180	@ 0x49c
 8017002:	6828      	ldr	r0, [r5, #0]
 8017004:	f005 fac0 	bl	801c588 <USB_EP0_OutStart>
 8017008:	e6df      	b.n	8016dca <HAL_PCD_IRQHandler+0x67e>
    if ((DoepintReg & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP) /* Class C */
 801700a:	0719      	lsls	r1, r3, #28
 801700c:	f140 8097 	bpl.w	801713e <HAL_PCD_IRQHandler+0x9f2>
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 8017010:	4980      	ldr	r1, [pc, #512]	@ (8017214 <HAL_PCD_IRQHandler+0xac8>)
 8017012:	458e      	cmp	lr, r1
 8017014:	f67f aed5 	bls.w	8016dc2 <HAL_PCD_IRQHandler+0x676>
 8017018:	0418      	lsls	r0, r3, #16
 801701a:	f57f aed2 	bpl.w	8016dc2 <HAL_PCD_IRQHandler+0x676>
        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 801701e:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
 8017022:	6091      	str	r1, [r2, #8]
 8017024:	e6cd      	b.n	8016dc2 <HAL_PCD_IRQHandler+0x676>
  if (ep->xfer_len <= ep->xfer_count)
 8017026:	f8dd b018 	ldr.w	fp, [sp, #24]
 801702a:	f8d8 2024 	ldr.w	r2, [r8, #36]	@ 0x24
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 801702e:	6825      	ldr	r5, [r4, #0]
  if (ep->xfer_len <= ep->xfer_count)
 8017030:	4293      	cmp	r3, r2
 8017032:	f4ff ae11 	bcc.w	8016c58 <HAL_PCD_IRQHandler+0x50c>
 8017036:	e694      	b.n	8016d62 <HAL_PCD_IRQHandler+0x616>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8017038:	2900      	cmp	r1, #0
 801703a:	f6bf acb7 	bge.w	80169ac <HAL_PCD_IRQHandler+0x260>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 801703e:	f104 01c8 	add.w	r1, r4, #200	@ 0xc8
 8017042:	6820      	ldr	r0, [r4, #0]
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 8017044:	f884 20cb 	strb.w	r2, [r4, #203]	@ 0xcb
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 8017048:	f005 f93c 	bl	801c2c4 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 801704c:	7923      	ldrb	r3, [r4, #4]
 801704e:	e4ad      	b.n	80169ac <HAL_PCD_IRQHandler+0x260>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 8017050:	f504 711e 	add.w	r1, r4, #632	@ 0x278
 8017054:	6820      	ldr	r0, [r4, #0]
 8017056:	f005 f935 	bl	801c2c4 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 801705a:	7923      	ldrb	r3, [r4, #4]
 801705c:	e40b      	b.n	8016876 <HAL_PCD_IRQHandler+0x12a>
              ep->is_iso_incomplete = 0U;
 801705e:	2200      	movs	r2, #0
              HAL_PCD_ISOOUTIncompleteCallback(hpcd, (uint8_t)epnum);
 8017060:	4621      	mov	r1, r4
 8017062:	4628      	mov	r0, r5
              ep->is_iso_incomplete = 0U;
 8017064:	f88b 2257 	strb.w	r2, [fp, #599]	@ 0x257
              HAL_PCD_ISOOUTIncompleteCallback(hpcd, (uint8_t)epnum);
 8017068:	f009 f87a 	bl	8020160 <HAL_PCD_ISOOUTIncompleteCallback>
 801706c:	e6c3      	b.n	8016df6 <HAL_PCD_IRQHandler+0x6aa>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 801706e:	2900      	cmp	r1, #0
 8017070:	f6bf aca5 	bge.w	80169be <HAL_PCD_IRQHandler+0x272>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 8017074:	f104 01ec 	add.w	r1, r4, #236	@ 0xec
 8017078:	6820      	ldr	r0, [r4, #0]
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 801707a:	f884 20ef 	strb.w	r2, [r4, #239]	@ 0xef
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 801707e:	f005 f921 	bl	801c2c4 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8017082:	7923      	ldrb	r3, [r4, #4]
 8017084:	e49b      	b.n	80169be <HAL_PCD_IRQHandler+0x272>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 8017086:	f504 7127 	add.w	r1, r4, #668	@ 0x29c
 801708a:	6820      	ldr	r0, [r4, #0]
 801708c:	f005 f91a 	bl	801c2c4 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8017090:	7923      	ldrb	r3, [r4, #4]
 8017092:	f7ff bbf7 	b.w	8016884 <HAL_PCD_IRQHandler+0x138>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8017096:	2900      	cmp	r1, #0
 8017098:	f6bf ac9a 	bge.w	80169d0 <HAL_PCD_IRQHandler+0x284>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 801709c:	f504 7188 	add.w	r1, r4, #272	@ 0x110
 80170a0:	6820      	ldr	r0, [r4, #0]
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 80170a2:	f884 2113 	strb.w	r2, [r4, #275]	@ 0x113
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 80170a6:	f005 f90d 	bl	801c2c4 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 80170aa:	7923      	ldrb	r3, [r4, #4]
 80170ac:	e490      	b.n	80169d0 <HAL_PCD_IRQHandler+0x284>
  HAL_PCD_SetupStageCallback(hpcd);
 80170ae:	4628      	mov	r0, r5
 80170b0:	f009 f806 	bl	80200c0 <HAL_PCD_SetupStageCallback>
  if ((gSNPSiD > USB_OTG_CORE_ID_300A) && (hpcd->Init.dma_enable == 1U))
 80170b4:	e79f      	b.n	8016ff6 <HAL_PCD_IRQHandler+0x8aa>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 80170b6:	2900      	cmp	r1, #0
 80170b8:	f6bf ac93 	bge.w	80169e2 <HAL_PCD_IRQHandler+0x296>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 80170bc:	f504 719a 	add.w	r1, r4, #308	@ 0x134
 80170c0:	6820      	ldr	r0, [r4, #0]
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 80170c2:	f884 2137 	strb.w	r2, [r4, #311]	@ 0x137
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 80170c6:	f005 f8fd 	bl	801c2c4 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 80170ca:	7923      	ldrb	r3, [r4, #4]
 80170cc:	e489      	b.n	80169e2 <HAL_PCD_IRQHandler+0x296>
      if ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX)
 80170ce:	0418      	lsls	r0, r3, #16
 80170d0:	d4a5      	bmi.n	801701e <HAL_PCD_IRQHandler+0x8d2>
        if ((DoepintReg & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)
 80170d2:	0699      	lsls	r1, r3, #26
 80170d4:	f57f af2b 	bpl.w	8016f2e <HAL_PCD_IRQHandler+0x7e2>
          CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 80170d8:	2120      	movs	r1, #32
 80170da:	6091      	str	r1, [r2, #8]
        HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 80170dc:	e727      	b.n	8016f2e <HAL_PCD_IRQHandler+0x7e2>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 80170de:	2900      	cmp	r1, #0
 80170e0:	f6bf ac88 	bge.w	80169f4 <HAL_PCD_IRQHandler+0x2a8>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 80170e4:	f504 71ac 	add.w	r1, r4, #344	@ 0x158
 80170e8:	6820      	ldr	r0, [r4, #0]
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 80170ea:	f884 215b 	strb.w	r2, [r4, #347]	@ 0x15b
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 80170ee:	f005 f8e9 	bl	801c2c4 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 80170f2:	7923      	ldrb	r3, [r4, #4]
 80170f4:	e47e      	b.n	80169f4 <HAL_PCD_IRQHandler+0x2a8>
              ep->is_iso_incomplete = 0U;
 80170f6:	2200      	movs	r2, #0
              HAL_PCD_ISOINIncompleteCallback(hpcd, (uint8_t)epnum);
 80170f8:	4639      	mov	r1, r7
 80170fa:	4620      	mov	r0, r4
              ep->is_iso_incomplete = 0U;
 80170fc:	f888 2017 	strb.w	r2, [r8, #23]
              HAL_PCD_ISOINIncompleteCallback(hpcd, (uint8_t)epnum);
 8017100:	f009 f832 	bl	8020168 <HAL_PCD_ISOINIncompleteCallback>
 8017104:	e732      	b.n	8016f6c <HAL_PCD_IRQHandler+0x820>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 8017106:	f504 7142 	add.w	r1, r4, #776	@ 0x308
 801710a:	6820      	ldr	r0, [r4, #0]
 801710c:	f005 f8da 	bl	801c2c4 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8017110:	7923      	ldrb	r3, [r4, #4]
 8017112:	f7ff bbcc 	b.w	80168ae <HAL_PCD_IRQHandler+0x162>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8017116:	2900      	cmp	r1, #0
 8017118:	f6bf ac75 	bge.w	8016a06 <HAL_PCD_IRQHandler+0x2ba>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 801711c:	f504 71be 	add.w	r1, r4, #380	@ 0x17c
 8017120:	6820      	ldr	r0, [r4, #0]
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 8017122:	f884 217f 	strb.w	r2, [r4, #383]	@ 0x17f
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 8017126:	f005 f8cd 	bl	801c2c4 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 801712a:	7923      	ldrb	r3, [r4, #4]
 801712c:	e46b      	b.n	8016a06 <HAL_PCD_IRQHandler+0x2ba>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 801712e:	f504 714b 	add.w	r1, r4, #812	@ 0x32c
 8017132:	6820      	ldr	r0, [r4, #0]
 8017134:	f005 f8c6 	bl	801c2c4 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8017138:	7923      	ldrb	r3, [r4, #4]
 801713a:	f7ff bbbf 	b.w	80168bc <HAL_PCD_IRQHandler+0x170>
    else if ((DoepintReg & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR) /* Class E */
 801713e:	0699      	lsls	r1, r3, #26
 8017140:	d572      	bpl.n	8017228 <HAL_PCD_IRQHandler+0xadc>
      CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 8017142:	2120      	movs	r1, #32
 8017144:	6091      	str	r1, [r2, #8]
 8017146:	e63c      	b.n	8016dc2 <HAL_PCD_IRQHandler+0x676>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8017148:	2900      	cmp	r1, #0
 801714a:	f6bf ac65 	bge.w	8016a18 <HAL_PCD_IRQHandler+0x2cc>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 801714e:	f504 71d0 	add.w	r1, r4, #416	@ 0x1a0
 8017152:	6820      	ldr	r0, [r4, #0]
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 8017154:	f884 21a3 	strb.w	r2, [r4, #419]	@ 0x1a3
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 8017158:	f005 f8b4 	bl	801c2c4 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 801715c:	7923      	ldrb	r3, [r4, #4]
 801715e:	e45b      	b.n	8016a18 <HAL_PCD_IRQHandler+0x2cc>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 8017160:	f504 7154 	add.w	r1, r4, #848	@ 0x350
 8017164:	6820      	ldr	r0, [r4, #0]
 8017166:	f005 f8ad 	bl	801c2c4 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 801716a:	7923      	ldrb	r3, [r4, #4]
 801716c:	f7ff bbad 	b.w	80168ca <HAL_PCD_IRQHandler+0x17e>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8017170:	2900      	cmp	r1, #0
 8017172:	f6bf ac5a 	bge.w	8016a2a <HAL_PCD_IRQHandler+0x2de>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 8017176:	f504 71e2 	add.w	r1, r4, #452	@ 0x1c4
 801717a:	6820      	ldr	r0, [r4, #0]
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 801717c:	f884 21c7 	strb.w	r2, [r4, #455]	@ 0x1c7
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 8017180:	f005 f8a0 	bl	801c2c4 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8017184:	7923      	ldrb	r3, [r4, #4]
 8017186:	e450      	b.n	8016a2a <HAL_PCD_IRQHandler+0x2de>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 8017188:	f504 715d 	add.w	r1, r4, #884	@ 0x374
 801718c:	6820      	ldr	r0, [r4, #0]
 801718e:	f005 f899 	bl	801c2c4 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8017192:	7923      	ldrb	r3, [r4, #4]
 8017194:	f7ff bba0 	b.w	80168d8 <HAL_PCD_IRQHandler+0x18c>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8017198:	2900      	cmp	r1, #0
 801719a:	f6bf ac4f 	bge.w	8016a3c <HAL_PCD_IRQHandler+0x2f0>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 801719e:	f504 71f4 	add.w	r1, r4, #488	@ 0x1e8
 80171a2:	6820      	ldr	r0, [r4, #0]
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 80171a4:	f884 21eb 	strb.w	r2, [r4, #491]	@ 0x1eb
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 80171a8:	f005 f88c 	bl	801c2c4 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 80171ac:	7923      	ldrb	r3, [r4, #4]
 80171ae:	e445      	b.n	8016a3c <HAL_PCD_IRQHandler+0x2f0>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 80171b0:	f504 7166 	add.w	r1, r4, #920	@ 0x398
 80171b4:	6820      	ldr	r0, [r4, #0]
 80171b6:	f005 f885 	bl	801c2c4 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 80171ba:	7923      	ldrb	r3, [r4, #4]
 80171bc:	f7ff bb93 	b.w	80168e6 <HAL_PCD_IRQHandler+0x19a>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 80171c0:	2900      	cmp	r1, #0
 80171c2:	f6bf ac44 	bge.w	8016a4e <HAL_PCD_IRQHandler+0x302>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 80171c6:	f504 7103 	add.w	r1, r4, #524	@ 0x20c
 80171ca:	6820      	ldr	r0, [r4, #0]
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 80171cc:	f884 220f 	strb.w	r2, [r4, #527]	@ 0x20f
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 80171d0:	f005 f878 	bl	801c2c4 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 80171d4:	7923      	ldrb	r3, [r4, #4]
 80171d6:	e43a      	b.n	8016a4e <HAL_PCD_IRQHandler+0x302>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 80171d8:	f504 716f 	add.w	r1, r4, #956	@ 0x3bc
 80171dc:	6820      	ldr	r0, [r4, #0]
 80171de:	f005 f871 	bl	801c2c4 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 80171e2:	7923      	ldrb	r3, [r4, #4]
 80171e4:	f7ff bb86 	b.w	80168f4 <HAL_PCD_IRQHandler+0x1a8>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 80171e8:	2900      	cmp	r1, #0
 80171ea:	f6bf ac39 	bge.w	8016a60 <HAL_PCD_IRQHandler+0x314>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 80171ee:	f504 710c 	add.w	r1, r4, #560	@ 0x230
 80171f2:	6820      	ldr	r0, [r4, #0]
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 80171f4:	f884 2233 	strb.w	r2, [r4, #563]	@ 0x233
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 80171f8:	f005 f864 	bl	801c2c4 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 80171fc:	7923      	ldrb	r3, [r4, #4]
 80171fe:	e42f      	b.n	8016a60 <HAL_PCD_IRQHandler+0x314>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 8017200:	f504 7178 	add.w	r1, r4, #992	@ 0x3e0
 8017204:	6820      	ldr	r0, [r4, #0]
 8017206:	f005 f85d 	bl	801c2c4 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 801720a:	7923      	ldrb	r3, [r4, #4]
 801720c:	f7ff bb79 	b.w	8016902 <HAL_PCD_IRQHandler+0x1b6>
 8017210:	4f54310a 	.word	0x4f54310a
 8017214:	4f54300a 	.word	0x4f54300a
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 8017218:	f204 4104 	addw	r1, r4, #1028	@ 0x404
 801721c:	6820      	ldr	r0, [r4, #0]
 801721e:	f005 f851 	bl	801c2c4 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8017222:	7923      	ldrb	r3, [r4, #4]
 8017224:	f7ff bb74 	b.w	8016910 <HAL_PCD_IRQHandler+0x1c4>
    else if ((DoepintReg & (USB_OTG_DOEPINT_STUP | USB_OTG_DOEPINT_OTEPSPR)) == 0U)
 8017228:	f013 0f28 	tst.w	r3, #40	@ 0x28
 801722c:	f47f adc9 	bne.w	8016dc2 <HAL_PCD_IRQHandler+0x676>
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 8017230:	491b      	ldr	r1, [pc, #108]	@ (80172a0 <HAL_PCD_IRQHandler+0xb54>)
 8017232:	458e      	cmp	lr, r1
 8017234:	d902      	bls.n	801723c <HAL_PCD_IRQHandler+0xaf0>
 8017236:	041b      	lsls	r3, r3, #16
 8017238:	f53f aef1 	bmi.w	801701e <HAL_PCD_IRQHandler+0x8d2>
        ep->xfer_count = ep->xfer_size - (USBx_OUTEP(epnum)->DOEPTSIZ & USB_OTG_DOEPTSIZ_XFRSIZ);
 801723c:	6911      	ldr	r1, [r2, #16]
 801723e:	f8db 2274 	ldr.w	r2, [fp, #628]	@ 0x274
 8017242:	f3c1 0112 	ubfx	r1, r1, #0, #19
 8017246:	1a52      	subs	r2, r2, r1
 8017248:	f8cb 2268 	str.w	r2, [fp, #616]	@ 0x268
        if (epnum == 0U)
 801724c:	f1ba 0f00 	cmp.w	sl, #0
 8017250:	f47f ae6d 	bne.w	8016f2e <HAL_PCD_IRQHandler+0x7e2>
          if (ep->xfer_len == 0U)
 8017254:	f8d5 1264 	ldr.w	r1, [r5, #612]	@ 0x264
 8017258:	b1d9      	cbz	r1, 8017292 <HAL_PCD_IRQHandler+0xb46>
            ep->xfer_buff += ep->xfer_count;
 801725a:	f8d5 1260 	ldr.w	r1, [r5, #608]	@ 0x260
 801725e:	4411      	add	r1, r2
 8017260:	f8c5 1260 	str.w	r1, [r5, #608]	@ 0x260
        HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 8017264:	e663      	b.n	8016f2e <HAL_PCD_IRQHandler+0x7e2>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 8017266:	f504 6185 	add.w	r1, r4, #1064	@ 0x428
 801726a:	6820      	ldr	r0, [r4, #0]
 801726c:	f005 f82a 	bl	801c2c4 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8017270:	7923      	ldrb	r3, [r4, #4]
 8017272:	f7ff bb54 	b.w	801691e <HAL_PCD_IRQHandler+0x1d2>
        (void)USB_EP0_OutStart(hpcd->Instance, 0U, (uint8_t *)hpcd->Setup);
 8017276:	f205 429c 	addw	r2, r5, #1180	@ 0x49c
 801727a:	4651      	mov	r1, sl
 801727c:	f005 f984 	bl	801c588 <USB_EP0_OutStart>
 8017280:	e655      	b.n	8016f2e <HAL_PCD_IRQHandler+0x7e2>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 8017282:	f204 414c 	addw	r1, r4, #1100	@ 0x44c
 8017286:	6820      	ldr	r0, [r4, #0]
 8017288:	f005 f81c 	bl	801c2c4 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 801728c:	7923      	ldrb	r3, [r4, #4]
 801728e:	f7ff bb4d 	b.w	801692c <HAL_PCD_IRQHandler+0x1e0>
            (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 8017292:	f205 429c 	addw	r2, r5, #1180	@ 0x49c
 8017296:	2101      	movs	r1, #1
 8017298:	f005 f976 	bl	801c588 <USB_EP0_OutStart>
 801729c:	e647      	b.n	8016f2e <HAL_PCD_IRQHandler+0x7e2>
 801729e:	bf00      	nop
 80172a0:	4f54300a 	.word	0x4f54300a

080172a4 <HAL_PCD_SetAddress>:
  __HAL_LOCK(hpcd);
 80172a4:	f890 2494 	ldrb.w	r2, [r0, #1172]	@ 0x494
 80172a8:	2a01      	cmp	r2, #1
 80172aa:	d00d      	beq.n	80172c8 <HAL_PCD_SetAddress+0x24>
 80172ac:	2201      	movs	r2, #1
{
 80172ae:	b510      	push	{r4, lr}
 80172b0:	4604      	mov	r4, r0
  (void)USB_SetDevAddress(hpcd->Instance, address);
 80172b2:	6800      	ldr	r0, [r0, #0]
  hpcd->USB_Address = address;
 80172b4:	7461      	strb	r1, [r4, #17]
  __HAL_LOCK(hpcd);
 80172b6:	f884 2494 	strb.w	r2, [r4, #1172]	@ 0x494
  (void)USB_SetDevAddress(hpcd->Instance, address);
 80172ba:	f005 f8eb 	bl	801c494 <USB_SetDevAddress>
  __HAL_UNLOCK(hpcd);
 80172be:	2300      	movs	r3, #0
  return HAL_OK;
 80172c0:	4618      	mov	r0, r3
  __HAL_UNLOCK(hpcd);
 80172c2:	f884 3494 	strb.w	r3, [r4, #1172]	@ 0x494
}
 80172c6:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hpcd);
 80172c8:	2002      	movs	r0, #2
}
 80172ca:	4770      	bx	lr

080172cc <HAL_PCD_EP_Open>:
{
 80172cc:	b510      	push	{r4, lr}
 80172ce:	f001 0e0f 	and.w	lr, r1, #15
  if ((ep_addr & 0x80U) == 0x80U)
 80172d2:	0609      	lsls	r1, r1, #24
{
 80172d4:	4604      	mov	r4, r0
 80172d6:	eb0e 0cce 	add.w	ip, lr, lr, lsl #3
 80172da:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
  if ((ep_addr & 0x80U) == 0x80U)
 80172de:	d425      	bmi.n	801732c <HAL_PCD_EP_Open+0x60>
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 80172e0:	f50c 7115 	add.w	r1, ip, #596	@ 0x254
    ep->is_in = 0U;
 80172e4:	f04f 0c00 	mov.w	ip, #0
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 80172e8:	4401      	add	r1, r0
    ep->is_in = 0U;
 80172ea:	eb0e 00ce 	add.w	r0, lr, lr, lsl #3
 80172ee:	eb04 0080 	add.w	r0, r4, r0, lsl #2
 80172f2:	f880 c255 	strb.w	ip, [r0, #597]	@ 0x255
  ep->maxpacket = ep_mps;
 80172f6:	608a      	str	r2, [r1, #8]
  if (ep->is_in != 0U)
 80172f8:	784a      	ldrb	r2, [r1, #1]
  ep->num = ep_addr & EP_ADDR_MSK;
 80172fa:	f881 e000 	strb.w	lr, [r1]
  ep->type = ep_type;
 80172fe:	710b      	strb	r3, [r1, #4]
  if (ep->is_in != 0U)
 8017300:	b10a      	cbz	r2, 8017306 <HAL_PCD_EP_Open+0x3a>
    ep->tx_fifo_num = ep->num;
 8017302:	f8a1 e01a 	strh.w	lr, [r1, #26]
  if (ep_type == EP_TYPE_BULK)
 8017306:	2b02      	cmp	r3, #2
 8017308:	d101      	bne.n	801730e <HAL_PCD_EP_Open+0x42>
    ep->data_pid_start = 0U;
 801730a:	2300      	movs	r3, #0
 801730c:	714b      	strb	r3, [r1, #5]
  __HAL_LOCK(hpcd);
 801730e:	f894 3494 	ldrb.w	r3, [r4, #1172]	@ 0x494
 8017312:	2b01      	cmp	r3, #1
 8017314:	d016      	beq.n	8017344 <HAL_PCD_EP_Open+0x78>
 8017316:	2301      	movs	r3, #1
  (void)USB_ActivateEndpoint(hpcd->Instance, ep);
 8017318:	6820      	ldr	r0, [r4, #0]
  __HAL_LOCK(hpcd);
 801731a:	f884 3494 	strb.w	r3, [r4, #1172]	@ 0x494
  (void)USB_ActivateEndpoint(hpcd->Instance, ep);
 801731e:	f004 fe07 	bl	801bf30 <USB_ActivateEndpoint>
  __HAL_UNLOCK(hpcd);
 8017322:	2300      	movs	r3, #0
  return ret;
 8017324:	4618      	mov	r0, r3
  __HAL_UNLOCK(hpcd);
 8017326:	f884 3494 	strb.w	r3, [r4, #1172]	@ 0x494
}
 801732a:	bd10      	pop	{r4, pc}
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 801732c:	f10c 0114 	add.w	r1, ip, #20
    ep->is_in = 1U;
 8017330:	f04f 0c01 	mov.w	ip, #1
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8017334:	4401      	add	r1, r0
    ep->is_in = 1U;
 8017336:	eb0e 00ce 	add.w	r0, lr, lr, lsl #3
 801733a:	eb04 0080 	add.w	r0, r4, r0, lsl #2
 801733e:	f880 c015 	strb.w	ip, [r0, #21]
 8017342:	e7d8      	b.n	80172f6 <HAL_PCD_EP_Open+0x2a>
  __HAL_LOCK(hpcd);
 8017344:	2002      	movs	r0, #2
}
 8017346:	bd10      	pop	{r4, pc}

08017348 <HAL_PCD_EP_Close>:
  if ((ep_addr & 0x80U) == 0x80U)
 8017348:	f001 030f 	and.w	r3, r1, #15
 801734c:	0609      	lsls	r1, r1, #24
 801734e:	461a      	mov	r2, r3
 8017350:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
{
 8017354:	b510      	push	{r4, lr}
 8017356:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801735a:	4604      	mov	r4, r0
  if ((ep_addr & 0x80U) == 0x80U)
 801735c:	d419      	bmi.n	8017392 <HAL_PCD_EP_Close+0x4a>
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 801735e:	f503 7115 	add.w	r1, r3, #596	@ 0x254
    ep->is_in = 0U;
 8017362:	eb02 03c2 	add.w	r3, r2, r2, lsl #3
 8017366:	2000      	movs	r0, #0
 8017368:	eb04 0383 	add.w	r3, r4, r3, lsl #2
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 801736c:	4421      	add	r1, r4
    ep->is_in = 0U;
 801736e:	f883 0255 	strb.w	r0, [r3, #597]	@ 0x255
  ep->num = ep_addr & EP_ADDR_MSK;
 8017372:	700a      	strb	r2, [r1, #0]
  __HAL_LOCK(hpcd);
 8017374:	f894 3494 	ldrb.w	r3, [r4, #1172]	@ 0x494
 8017378:	2b01      	cmp	r3, #1
 801737a:	d01a      	beq.n	80173b2 <HAL_PCD_EP_Close+0x6a>
 801737c:	2301      	movs	r3, #1
  (void)USB_DeactivateEndpoint(hpcd->Instance, ep);
 801737e:	6820      	ldr	r0, [r4, #0]
  __HAL_LOCK(hpcd);
 8017380:	f884 3494 	strb.w	r3, [r4, #1172]	@ 0x494
  (void)USB_DeactivateEndpoint(hpcd->Instance, ep);
 8017384:	f004 fe1a 	bl	801bfbc <USB_DeactivateEndpoint>
  __HAL_UNLOCK(hpcd);
 8017388:	2300      	movs	r3, #0
  return HAL_OK;
 801738a:	4618      	mov	r0, r3
  __HAL_UNLOCK(hpcd);
 801738c:	f884 3494 	strb.w	r3, [r4, #1172]	@ 0x494
}
 8017390:	bd10      	pop	{r4, pc}
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8017392:	f103 0114 	add.w	r1, r3, #20
    ep->is_in = 1U;
 8017396:	eb02 00c2 	add.w	r0, r2, r2, lsl #3
 801739a:	f04f 0c01 	mov.w	ip, #1
 801739e:	eb04 0380 	add.w	r3, r4, r0, lsl #2
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 80173a2:	4421      	add	r1, r4
    ep->is_in = 1U;
 80173a4:	f883 c015 	strb.w	ip, [r3, #21]
  ep->num = ep_addr & EP_ADDR_MSK;
 80173a8:	700a      	strb	r2, [r1, #0]
  __HAL_LOCK(hpcd);
 80173aa:	f894 3494 	ldrb.w	r3, [r4, #1172]	@ 0x494
 80173ae:	2b01      	cmp	r3, #1
 80173b0:	d1e4      	bne.n	801737c <HAL_PCD_EP_Close+0x34>
 80173b2:	2002      	movs	r0, #2
}
 80173b4:	bd10      	pop	{r4, pc}
 80173b6:	bf00      	nop

080173b8 <HAL_PCD_EP_Receive>:
{
 80173b8:	b510      	push	{r4, lr}
 80173ba:	f001 0e0f 	and.w	lr, r1, #15
 80173be:	4614      	mov	r4, r2
  ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 80173c0:	2124      	movs	r1, #36	@ 0x24
  ep->xfer_buff = pBuf;
 80173c2:	eb0e 0cce 	add.w	ip, lr, lr, lsl #3
  ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 80173c6:	fb01 010e 	mla	r1, r1, lr, r0
  ep->xfer_buff = pBuf;
 80173ca:	eb00 0c8c 	add.w	ip, r0, ip, lsl #2
  ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 80173ce:	f501 7115 	add.w	r1, r1, #596	@ 0x254
  ep->xfer_len = len;
 80173d2:	f8cc 3264 	str.w	r3, [ip, #612]	@ 0x264
  ep->xfer_count = 0U;
 80173d6:	2300      	movs	r3, #0
  ep->num = ep_addr & EP_ADDR_MSK;
 80173d8:	f88c e254 	strb.w	lr, [ip, #596]	@ 0x254
  ep->xfer_buff = pBuf;
 80173dc:	f8cc 2260 	str.w	r2, [ip, #608]	@ 0x260
  ep->xfer_count = 0U;
 80173e0:	f8cc 3268 	str.w	r3, [ip, #616]	@ 0x268
  ep->is_in = 0U;
 80173e4:	f88c 3255 	strb.w	r3, [ip, #597]	@ 0x255
  if (hpcd->Init.dma_enable == 1U)
 80173e8:	7982      	ldrb	r2, [r0, #6]
  (void)USB_EPStartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 80173ea:	6800      	ldr	r0, [r0, #0]
  if (hpcd->Init.dma_enable == 1U)
 80173ec:	2a01      	cmp	r2, #1
    ep->dma_addr = (uint32_t)pBuf;
 80173ee:	bf08      	it	eq
 80173f0:	f8cc 4270 	streq.w	r4, [ip, #624]	@ 0x270
  (void)USB_EPStartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 80173f4:	f004 fe40 	bl	801c078 <USB_EPStartXfer>
}
 80173f8:	2000      	movs	r0, #0
 80173fa:	bd10      	pop	{r4, pc}

080173fc <HAL_PCD_EP_GetRxCount>:
  return hpcd->OUT_ep[ep_addr & EP_ADDR_MSK].xfer_count;
 80173fc:	f001 010f 	and.w	r1, r1, #15
 8017400:	eb01 01c1 	add.w	r1, r1, r1, lsl #3
 8017404:	eb00 0081 	add.w	r0, r0, r1, lsl #2
}
 8017408:	f8d0 0268 	ldr.w	r0, [r0, #616]	@ 0x268
 801740c:	4770      	bx	lr
 801740e:	bf00      	nop

08017410 <HAL_PCD_EP_Transmit>:
{
 8017410:	b510      	push	{r4, lr}
 8017412:	f001 0e0f 	and.w	lr, r1, #15
 8017416:	4614      	mov	r4, r2
  ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8017418:	2124      	movs	r1, #36	@ 0x24
  ep->xfer_buff = pBuf;
 801741a:	eb0e 0cce 	add.w	ip, lr, lr, lsl #3
  ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 801741e:	fb01 010e 	mla	r1, r1, lr, r0
  ep->xfer_buff = pBuf;
 8017422:	eb00 0c8c 	add.w	ip, r0, ip, lsl #2
  ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8017426:	3114      	adds	r1, #20
  ep->xfer_len = len;
 8017428:	f8cc 3024 	str.w	r3, [ip, #36]	@ 0x24
  ep->xfer_count = 0U;
 801742c:	2300      	movs	r3, #0
  ep->num = ep_addr & EP_ADDR_MSK;
 801742e:	f88c e014 	strb.w	lr, [ip, #20]
  ep->xfer_count = 0U;
 8017432:	f8cc 3028 	str.w	r3, [ip, #40]	@ 0x28
  ep->is_in = 1U;
 8017436:	2301      	movs	r3, #1
  ep->xfer_buff = pBuf;
 8017438:	f8cc 2020 	str.w	r2, [ip, #32]
  ep->is_in = 1U;
 801743c:	f88c 3015 	strb.w	r3, [ip, #21]
  if (hpcd->Init.dma_enable == 1U)
 8017440:	7982      	ldrb	r2, [r0, #6]
  (void)USB_EPStartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 8017442:	6800      	ldr	r0, [r0, #0]
  if (hpcd->Init.dma_enable == 1U)
 8017444:	429a      	cmp	r2, r3
    ep->dma_addr = (uint32_t)pBuf;
 8017446:	bf08      	it	eq
 8017448:	f8cc 4030 	streq.w	r4, [ip, #48]	@ 0x30
  (void)USB_EPStartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 801744c:	f004 fe14 	bl	801c078 <USB_EPStartXfer>
}
 8017450:	2000      	movs	r0, #0
 8017452:	bd10      	pop	{r4, pc}

08017454 <HAL_PCD_EP_SetStall>:
{
 8017454:	b538      	push	{r3, r4, r5, lr}
 8017456:	f001 050f 	and.w	r5, r1, #15
  if (((uint32_t)ep_addr & EP_ADDR_MSK) > hpcd->Init.dev_endpoints)
 801745a:	7903      	ldrb	r3, [r0, #4]
 801745c:	42ab      	cmp	r3, r5
 801745e:	d333      	bcc.n	80174c8 <HAL_PCD_EP_SetStall+0x74>
  if ((0x80U & ep_addr) == 0x80U)
 8017460:	060b      	lsls	r3, r1, #24
 8017462:	4604      	mov	r4, r0
 8017464:	d41d      	bmi.n	80174a2 <HAL_PCD_EP_SetStall+0x4e>
    ep = &hpcd->OUT_ep[ep_addr];
 8017466:	2224      	movs	r2, #36	@ 0x24
    ep->is_in = 0U;
 8017468:	eb01 03c1 	add.w	r3, r1, r1, lsl #3
    ep = &hpcd->OUT_ep[ep_addr];
 801746c:	fb02 0101 	mla	r1, r2, r1, r0
    ep->is_in = 0U;
 8017470:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8017474:	2200      	movs	r2, #0
    ep = &hpcd->OUT_ep[ep_addr];
 8017476:	f501 7115 	add.w	r1, r1, #596	@ 0x254
    ep->is_in = 0U;
 801747a:	f883 2255 	strb.w	r2, [r3, #597]	@ 0x255
  ep->is_stall = 1U;
 801747e:	2301      	movs	r3, #1
  ep->num = ep_addr & EP_ADDR_MSK;
 8017480:	700d      	strb	r5, [r1, #0]
  ep->is_stall = 1U;
 8017482:	708b      	strb	r3, [r1, #2]
  __HAL_LOCK(hpcd);
 8017484:	f894 2494 	ldrb.w	r2, [r4, #1172]	@ 0x494
 8017488:	429a      	cmp	r2, r3
 801748a:	d01b      	beq.n	80174c4 <HAL_PCD_EP_SetStall+0x70>
  (void)USB_EPSetStall(hpcd->Instance, ep);
 801748c:	6820      	ldr	r0, [r4, #0]
  __HAL_LOCK(hpcd);
 801748e:	f884 3494 	strb.w	r3, [r4, #1172]	@ 0x494
  (void)USB_EPSetStall(hpcd->Instance, ep);
 8017492:	f004 ff9b 	bl	801c3cc <USB_EPSetStall>
  if ((ep_addr & EP_ADDR_MSK) == 0U)
 8017496:	b1cd      	cbz	r5, 80174cc <HAL_PCD_EP_SetStall+0x78>
  __HAL_UNLOCK(hpcd);
 8017498:	2300      	movs	r3, #0
  return HAL_OK;
 801749a:	4618      	mov	r0, r3
  __HAL_UNLOCK(hpcd);
 801749c:	f884 3494 	strb.w	r3, [r4, #1172]	@ 0x494
}
 80174a0:	bd38      	pop	{r3, r4, r5, pc}
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 80174a2:	2124      	movs	r1, #36	@ 0x24
    ep->is_in = 1U;
 80174a4:	eb05 03c5 	add.w	r3, r5, r5, lsl #3
 80174a8:	2201      	movs	r2, #1
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 80174aa:	fb01 0105 	mla	r1, r1, r5, r0
    ep->is_in = 1U;
 80174ae:	eb00 0383 	add.w	r3, r0, r3, lsl #2
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 80174b2:	3114      	adds	r1, #20
    ep->is_in = 1U;
 80174b4:	755a      	strb	r2, [r3, #21]
  ep->is_stall = 1U;
 80174b6:	2301      	movs	r3, #1
  ep->num = ep_addr & EP_ADDR_MSK;
 80174b8:	700d      	strb	r5, [r1, #0]
  ep->is_stall = 1U;
 80174ba:	708b      	strb	r3, [r1, #2]
  __HAL_LOCK(hpcd);
 80174bc:	f894 2494 	ldrb.w	r2, [r4, #1172]	@ 0x494
 80174c0:	429a      	cmp	r2, r3
 80174c2:	d1e3      	bne.n	801748c <HAL_PCD_EP_SetStall+0x38>
 80174c4:	2002      	movs	r0, #2
}
 80174c6:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 80174c8:	2001      	movs	r0, #1
}
 80174ca:	bd38      	pop	{r3, r4, r5, pc}
    (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
 80174cc:	f204 429c 	addw	r2, r4, #1180	@ 0x49c
 80174d0:	79a1      	ldrb	r1, [r4, #6]
 80174d2:	6820      	ldr	r0, [r4, #0]
 80174d4:	f005 f858 	bl	801c588 <USB_EP0_OutStart>
 80174d8:	e7de      	b.n	8017498 <HAL_PCD_EP_SetStall+0x44>
 80174da:	bf00      	nop

080174dc <HAL_PCD_EP_ClrStall>:
  if (((uint32_t)ep_addr & 0x0FU) > hpcd->Init.dev_endpoints)
 80174dc:	f001 020f 	and.w	r2, r1, #15
{
 80174e0:	b538      	push	{r3, r4, r5, lr}
  if (((uint32_t)ep_addr & 0x0FU) > hpcd->Init.dev_endpoints)
 80174e2:	7903      	ldrb	r3, [r0, #4]
 80174e4:	4293      	cmp	r3, r2
 80174e6:	d332      	bcc.n	801754e <HAL_PCD_EP_ClrStall+0x72>
  if ((0x80U & ep_addr) == 0x80U)
 80174e8:	eb02 03c2 	add.w	r3, r2, r2, lsl #3
 80174ec:	0609      	lsls	r1, r1, #24
 80174ee:	4604      	mov	r4, r0
 80174f0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80174f4:	d41a      	bmi.n	801752c <HAL_PCD_EP_ClrStall+0x50>
    ep->is_in = 0U;
 80174f6:	eb02 00c2 	add.w	r0, r2, r2, lsl #3
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 80174fa:	f503 7315 	add.w	r3, r3, #596	@ 0x254
    ep->is_in = 0U;
 80174fe:	2500      	movs	r5, #0
 8017500:	eb04 0080 	add.w	r0, r4, r0, lsl #2
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8017504:	18e1      	adds	r1, r4, r3
    ep->is_in = 0U;
 8017506:	f880 5255 	strb.w	r5, [r0, #597]	@ 0x255
  ep->is_stall = 0U;
 801750a:	2500      	movs	r5, #0
  ep->num = ep_addr & EP_ADDR_MSK;
 801750c:	700a      	strb	r2, [r1, #0]
  ep->is_stall = 0U;
 801750e:	708d      	strb	r5, [r1, #2]
  __HAL_LOCK(hpcd);
 8017510:	f894 3494 	ldrb.w	r3, [r4, #1172]	@ 0x494
 8017514:	2b01      	cmp	r3, #1
 8017516:	d018      	beq.n	801754a <HAL_PCD_EP_ClrStall+0x6e>
 8017518:	2301      	movs	r3, #1
  (void)USB_EPClearStall(hpcd->Instance, ep);
 801751a:	6820      	ldr	r0, [r4, #0]
  __HAL_LOCK(hpcd);
 801751c:	f884 3494 	strb.w	r3, [r4, #1172]	@ 0x494
  (void)USB_EPClearStall(hpcd->Instance, ep);
 8017520:	f004 ff8c 	bl	801c43c <USB_EPClearStall>
  return HAL_OK;
 8017524:	4628      	mov	r0, r5
  __HAL_UNLOCK(hpcd);
 8017526:	f884 5494 	strb.w	r5, [r4, #1172]	@ 0x494
}
 801752a:	bd38      	pop	{r3, r4, r5, pc}
    ep->is_in = 1U;
 801752c:	eb02 00c2 	add.w	r0, r2, r2, lsl #3
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8017530:	3314      	adds	r3, #20
    ep->is_in = 1U;
 8017532:	2501      	movs	r5, #1
 8017534:	eb04 0080 	add.w	r0, r4, r0, lsl #2
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8017538:	18e1      	adds	r1, r4, r3
    ep->is_in = 1U;
 801753a:	7545      	strb	r5, [r0, #21]
  ep->is_stall = 0U;
 801753c:	2500      	movs	r5, #0
  ep->num = ep_addr & EP_ADDR_MSK;
 801753e:	700a      	strb	r2, [r1, #0]
  ep->is_stall = 0U;
 8017540:	708d      	strb	r5, [r1, #2]
  __HAL_LOCK(hpcd);
 8017542:	f894 3494 	ldrb.w	r3, [r4, #1172]	@ 0x494
 8017546:	2b01      	cmp	r3, #1
 8017548:	d1e6      	bne.n	8017518 <HAL_PCD_EP_ClrStall+0x3c>
 801754a:	2002      	movs	r0, #2
}
 801754c:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 801754e:	2001      	movs	r0, #1
}
 8017550:	bd38      	pop	{r3, r4, r5, pc}
 8017552:	bf00      	nop

08017554 <HAL_PCDEx_SetTxFiFo>:
         --> Txn should be configured with the minimum space of 16 words
     The FIFO is used optimally when used TxFIFOs are allocated in the top
         of the FIFO.Ex: use EP1 and EP2 as IN instead of EP1 and EP3 as IN ones.
     When DMA is used 3n * FIFO locations should be reserved for internal DMA registers */

  Tx_Offset = hpcd->Instance->GRXFSIZ;
 8017554:	6800      	ldr	r0, [r0, #0]

  if (fifo == 0U)
  {
    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = ((uint32_t)size << 16) | Tx_Offset;
 8017556:	0412      	lsls	r2, r2, #16
  Tx_Offset = hpcd->Instance->GRXFSIZ;
 8017558:	6a43      	ldr	r3, [r0, #36]	@ 0x24
  if (fifo == 0U)
 801755a:	b919      	cbnz	r1, 8017564 <HAL_PCDEx_SetTxFiFo+0x10>
    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = ((uint32_t)size << 16) | Tx_Offset;
 801755c:	4313      	orrs	r3, r2
 801755e:	6283      	str	r3, [r0, #40]	@ 0x28
    /* Multiply Tx_Size by 2 to get higher performance */
    hpcd->Instance->DIEPTXF[fifo - 1U] = ((uint32_t)size << 16) | Tx_Offset;
  }

  return HAL_OK;
}
 8017560:	2000      	movs	r0, #0
 8017562:	4770      	bx	lr
{
 8017564:	b430      	push	{r4, r5}
    for (i = 0U; i < (fifo - 1U); i++)
 8017566:	3901      	subs	r1, #1
    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16;
 8017568:	6a84      	ldr	r4, [r0, #40]	@ 0x28
 801756a:	eb03 4314 	add.w	r3, r3, r4, lsr #16
    for (i = 0U; i < (fifo - 1U); i++)
 801756e:	d06b      	beq.n	8017648 <HAL_PCDEx_SetTxFiFo+0xf4>
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 8017570:	f8d0 4104 	ldr.w	r4, [r0, #260]	@ 0x104
    for (i = 0U; i < (fifo - 1U); i++)
 8017574:	2901      	cmp	r1, #1
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 8017576:	eb03 4314 	add.w	r3, r3, r4, lsr #16
    for (i = 0U; i < (fifo - 1U); i++)
 801757a:	d065      	beq.n	8017648 <HAL_PCDEx_SetTxFiFo+0xf4>
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 801757c:	f8d0 4108 	ldr.w	r4, [r0, #264]	@ 0x108
    for (i = 0U; i < (fifo - 1U); i++)
 8017580:	2902      	cmp	r1, #2
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 8017582:	eb03 4314 	add.w	r3, r3, r4, lsr #16
    for (i = 0U; i < (fifo - 1U); i++)
 8017586:	d05f      	beq.n	8017648 <HAL_PCDEx_SetTxFiFo+0xf4>
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 8017588:	f8d0 410c 	ldr.w	r4, [r0, #268]	@ 0x10c
    for (i = 0U; i < (fifo - 1U); i++)
 801758c:	2903      	cmp	r1, #3
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 801758e:	eb03 4314 	add.w	r3, r3, r4, lsr #16
    for (i = 0U; i < (fifo - 1U); i++)
 8017592:	d059      	beq.n	8017648 <HAL_PCDEx_SetTxFiFo+0xf4>
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 8017594:	f8d0 4110 	ldr.w	r4, [r0, #272]	@ 0x110
    for (i = 0U; i < (fifo - 1U); i++)
 8017598:	2904      	cmp	r1, #4
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 801759a:	eb03 4314 	add.w	r3, r3, r4, lsr #16
    for (i = 0U; i < (fifo - 1U); i++)
 801759e:	d053      	beq.n	8017648 <HAL_PCDEx_SetTxFiFo+0xf4>
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 80175a0:	f8d0 4114 	ldr.w	r4, [r0, #276]	@ 0x114
    for (i = 0U; i < (fifo - 1U); i++)
 80175a4:	2905      	cmp	r1, #5
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 80175a6:	eb03 4314 	add.w	r3, r3, r4, lsr #16
    for (i = 0U; i < (fifo - 1U); i++)
 80175aa:	d04d      	beq.n	8017648 <HAL_PCDEx_SetTxFiFo+0xf4>
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 80175ac:	f8d0 4118 	ldr.w	r4, [r0, #280]	@ 0x118
    for (i = 0U; i < (fifo - 1U); i++)
 80175b0:	2906      	cmp	r1, #6
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 80175b2:	eb03 4314 	add.w	r3, r3, r4, lsr #16
    for (i = 0U; i < (fifo - 1U); i++)
 80175b6:	d047      	beq.n	8017648 <HAL_PCDEx_SetTxFiFo+0xf4>
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 80175b8:	f8d0 411c 	ldr.w	r4, [r0, #284]	@ 0x11c
    for (i = 0U; i < (fifo - 1U); i++)
 80175bc:	2907      	cmp	r1, #7
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 80175be:	eb03 4314 	add.w	r3, r3, r4, lsr #16
    for (i = 0U; i < (fifo - 1U); i++)
 80175c2:	d041      	beq.n	8017648 <HAL_PCDEx_SetTxFiFo+0xf4>
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 80175c4:	f8d0 4120 	ldr.w	r4, [r0, #288]	@ 0x120
    for (i = 0U; i < (fifo - 1U); i++)
 80175c8:	2908      	cmp	r1, #8
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 80175ca:	eb03 4314 	add.w	r3, r3, r4, lsr #16
    for (i = 0U; i < (fifo - 1U); i++)
 80175ce:	d03b      	beq.n	8017648 <HAL_PCDEx_SetTxFiFo+0xf4>
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 80175d0:	f8d0 4124 	ldr.w	r4, [r0, #292]	@ 0x124
    for (i = 0U; i < (fifo - 1U); i++)
 80175d4:	2909      	cmp	r1, #9
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 80175d6:	eb03 4314 	add.w	r3, r3, r4, lsr #16
    for (i = 0U; i < (fifo - 1U); i++)
 80175da:	d035      	beq.n	8017648 <HAL_PCDEx_SetTxFiFo+0xf4>
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 80175dc:	f8d0 4128 	ldr.w	r4, [r0, #296]	@ 0x128
    for (i = 0U; i < (fifo - 1U); i++)
 80175e0:	290a      	cmp	r1, #10
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 80175e2:	eb03 4314 	add.w	r3, r3, r4, lsr #16
    for (i = 0U; i < (fifo - 1U); i++)
 80175e6:	d02f      	beq.n	8017648 <HAL_PCDEx_SetTxFiFo+0xf4>
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 80175e8:	f8d0 412c 	ldr.w	r4, [r0, #300]	@ 0x12c
    for (i = 0U; i < (fifo - 1U); i++)
 80175ec:	290b      	cmp	r1, #11
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 80175ee:	eb03 4314 	add.w	r3, r3, r4, lsr #16
    for (i = 0U; i < (fifo - 1U); i++)
 80175f2:	d029      	beq.n	8017648 <HAL_PCDEx_SetTxFiFo+0xf4>
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 80175f4:	f8d0 4130 	ldr.w	r4, [r0, #304]	@ 0x130
    for (i = 0U; i < (fifo - 1U); i++)
 80175f8:	290c      	cmp	r1, #12
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 80175fa:	eb03 4314 	add.w	r3, r3, r4, lsr #16
    for (i = 0U; i < (fifo - 1U); i++)
 80175fe:	d023      	beq.n	8017648 <HAL_PCDEx_SetTxFiFo+0xf4>
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 8017600:	f8d0 4134 	ldr.w	r4, [r0, #308]	@ 0x134
    for (i = 0U; i < (fifo - 1U); i++)
 8017604:	290d      	cmp	r1, #13
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 8017606:	eb03 4314 	add.w	r3, r3, r4, lsr #16
    for (i = 0U; i < (fifo - 1U); i++)
 801760a:	d01d      	beq.n	8017648 <HAL_PCDEx_SetTxFiFo+0xf4>
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 801760c:	f8d0 4138 	ldr.w	r4, [r0, #312]	@ 0x138
    for (i = 0U; i < (fifo - 1U); i++)
 8017610:	290e      	cmp	r1, #14
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 8017612:	eb03 4314 	add.w	r3, r3, r4, lsr #16
    for (i = 0U; i < (fifo - 1U); i++)
 8017616:	d017      	beq.n	8017648 <HAL_PCDEx_SetTxFiFo+0xf4>
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 8017618:	f8d0 413c 	ldr.w	r4, [r0, #316]	@ 0x13c
    for (i = 0U; i < (fifo - 1U); i++)
 801761c:	290f      	cmp	r1, #15
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 801761e:	eb03 4314 	add.w	r3, r3, r4, lsr #16
    for (i = 0U; i < (fifo - 1U); i++)
 8017622:	d011      	beq.n	8017648 <HAL_PCDEx_SetTxFiFo+0xf4>
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 8017624:	f8d0 4140 	ldr.w	r4, [r0, #320]	@ 0x140
    for (i = 0U; i < (fifo - 1U); i++)
 8017628:	2910      	cmp	r1, #16
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 801762a:	eb03 4314 	add.w	r3, r3, r4, lsr #16
    for (i = 0U; i < (fifo - 1U); i++)
 801762e:	d00b      	beq.n	8017648 <HAL_PCDEx_SetTxFiFo+0xf4>
 8017630:	2410      	movs	r4, #16
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 8017632:	f104 0c40 	add.w	ip, r4, #64	@ 0x40
    for (i = 0U; i < (fifo - 1U); i++)
 8017636:	3401      	adds	r4, #1
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 8017638:	eb00 0c8c 	add.w	ip, r0, ip, lsl #2
    for (i = 0U; i < (fifo - 1U); i++)
 801763c:	428c      	cmp	r4, r1
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 801763e:	f8dc 5004 	ldr.w	r5, [ip, #4]
 8017642:	eb03 4315 	add.w	r3, r3, r5, lsr #16
    for (i = 0U; i < (fifo - 1U); i++)
 8017646:	d3f4      	bcc.n	8017632 <HAL_PCDEx_SetTxFiFo+0xde>
    hpcd->Instance->DIEPTXF[fifo - 1U] = ((uint32_t)size << 16) | Tx_Offset;
 8017648:	3140      	adds	r1, #64	@ 0x40
 801764a:	431a      	orrs	r2, r3
 801764c:	eb00 0381 	add.w	r3, r0, r1, lsl #2
}
 8017650:	2000      	movs	r0, #0
 8017652:	bc30      	pop	{r4, r5}
    hpcd->Instance->DIEPTXF[fifo - 1U] = ((uint32_t)size << 16) | Tx_Offset;
 8017654:	605a      	str	r2, [r3, #4]
}
 8017656:	4770      	bx	lr

08017658 <HAL_PCDEx_SetRxFiFo>:
  * @param  hpcd PCD handle
  * @param  size Size of Rx fifo
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetRxFiFo(PCD_HandleTypeDef *hpcd, uint16_t size)
{
 8017658:	4603      	mov	r3, r0
  hpcd->Instance->GRXFSIZ = size;

  return HAL_OK;
}
 801765a:	2000      	movs	r0, #0
  hpcd->Instance->GRXFSIZ = size;
 801765c:	681b      	ldr	r3, [r3, #0]
 801765e:	6259      	str	r1, [r3, #36]	@ 0x24
}
 8017660:	4770      	bx	lr
 8017662:	bf00      	nop

08017664 <HAL_PCDEx_ActivateLPM>:
  * @brief  Activate LPM feature.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_ActivateLPM(PCD_HandleTypeDef *hpcd)
{
 8017664:	4603      	mov	r3, r0
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;

  hpcd->lpm_active = 1U;
  hpcd->LPM_State = LPM_L0;
 8017666:	f04f 0c00 	mov.w	ip, #0
  USBx->GINTMSK |= USB_OTG_GINTMSK_LPMINTM;
  USBx->GLPMCFG |= (USB_OTG_GLPMCFG_LPMEN | USB_OTG_GLPMCFG_LPMACK | USB_OTG_GLPMCFG_ENBESL);
 801766a:	4909      	ldr	r1, [pc, #36]	@ (8017690 <HAL_PCDEx_ActivateLPM+0x2c>)
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 801766c:	681a      	ldr	r2, [r3, #0]

  return HAL_OK;
}
 801766e:	4660      	mov	r0, ip
{
 8017670:	b410      	push	{r4}
  hpcd->lpm_active = 1U;
 8017672:	2401      	movs	r4, #1
  hpcd->LPM_State = LPM_L0;
 8017674:	f883 c4cc 	strb.w	ip, [r3, #1228]	@ 0x4cc
  hpcd->lpm_active = 1U;
 8017678:	f8c3 44d8 	str.w	r4, [r3, #1240]	@ 0x4d8
  USBx->GINTMSK |= USB_OTG_GINTMSK_LPMINTM;
 801767c:	6993      	ldr	r3, [r2, #24]
}
 801767e:	f85d 4b04 	ldr.w	r4, [sp], #4
  USBx->GINTMSK |= USB_OTG_GINTMSK_LPMINTM;
 8017682:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
 8017686:	6193      	str	r3, [r2, #24]
  USBx->GLPMCFG |= (USB_OTG_GLPMCFG_LPMEN | USB_OTG_GLPMCFG_LPMACK | USB_OTG_GLPMCFG_ENBESL);
 8017688:	6d53      	ldr	r3, [r2, #84]	@ 0x54
 801768a:	4319      	orrs	r1, r3
 801768c:	6551      	str	r1, [r2, #84]	@ 0x54
}
 801768e:	4770      	bx	lr
 8017690:	10000003 	.word	0x10000003

08017694 <HAL_PWR_EnableBkUpAccess>:
  * @retval None
  */
void HAL_PWR_EnableBkUpAccess(void)
{
  /* Enable access to RTC and backup registers */
  SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8017694:	4a02      	ldr	r2, [pc, #8]	@ (80176a0 <HAL_PWR_EnableBkUpAccess+0xc>)
 8017696:	6813      	ldr	r3, [r2, #0]
 8017698:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 801769c:	6013      	str	r3, [r2, #0]
}
 801769e:	4770      	bx	lr
 80176a0:	40007000 	.word	0x40007000

080176a4 <HAL_PWREx_EnableOverDrive>:
  */
HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)
{
  uint32_t tickstart = 0;

  __HAL_RCC_PWR_CLK_ENABLE();
 80176a4:	4b1a      	ldr	r3, [pc, #104]	@ (8017710 <HAL_PWREx_EnableOverDrive+0x6c>)
 80176a6:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 80176a8:	f042 5280 	orr.w	r2, r2, #268435456	@ 0x10000000
{
 80176ac:	b530      	push	{r4, r5, lr}
  __HAL_RCC_PWR_CLK_ENABLE();
 80176ae:	641a      	str	r2, [r3, #64]	@ 0x40
{
 80176b0:	b083      	sub	sp, #12
  __HAL_RCC_PWR_CLK_ENABLE();
 80176b2:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
  
  /* Enable the Over-drive to extend the clock frequency to 216 MHz */
  __HAL_PWR_OVERDRIVE_ENABLE();
 80176b4:	4c17      	ldr	r4, [pc, #92]	@ (8017714 <HAL_PWREx_EnableOverDrive+0x70>)
  __HAL_RCC_PWR_CLK_ENABLE();
 80176b6:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 80176ba:	9301      	str	r3, [sp, #4]
 80176bc:	9b01      	ldr	r3, [sp, #4]
  __HAL_PWR_OVERDRIVE_ENABLE();
 80176be:	6823      	ldr	r3, [r4, #0]
 80176c0:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 80176c4:	6023      	str	r3, [r4, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 80176c6:	f7fb fbd1 	bl	8012e6c <HAL_GetTick>
 80176ca:	4605      	mov	r5, r0

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 80176cc:	e005      	b.n	80176da <HAL_PWREx_EnableOverDrive+0x36>
  {
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 80176ce:	f7fb fbcd 	bl	8012e6c <HAL_GetTick>
 80176d2:	1b40      	subs	r0, r0, r5
 80176d4:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
 80176d8:	d817      	bhi.n	801770a <HAL_PWREx_EnableOverDrive+0x66>
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 80176da:	6863      	ldr	r3, [r4, #4]
 80176dc:	03da      	lsls	r2, r3, #15
 80176de:	d5f6      	bpl.n	80176ce <HAL_PWREx_EnableOverDrive+0x2a>
      return HAL_TIMEOUT;
    }
  }
  
  /* Enable the Over-drive switch */
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
 80176e0:	6823      	ldr	r3, [r4, #0]

  /* Get tick */
  tickstart = HAL_GetTick();

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 80176e2:	4d0c      	ldr	r5, [pc, #48]	@ (8017714 <HAL_PWREx_EnableOverDrive+0x70>)
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
 80176e4:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 80176e8:	6023      	str	r3, [r4, #0]
  tickstart = HAL_GetTick();
 80176ea:	f7fb fbbf 	bl	8012e6c <HAL_GetTick>
 80176ee:	4604      	mov	r4, r0
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 80176f0:	e005      	b.n	80176fe <HAL_PWREx_EnableOverDrive+0x5a>
  {
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 80176f2:	f7fb fbbb 	bl	8012e6c <HAL_GetTick>
 80176f6:	1b00      	subs	r0, r0, r4
 80176f8:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
 80176fc:	d805      	bhi.n	801770a <HAL_PWREx_EnableOverDrive+0x66>
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 80176fe:	686b      	ldr	r3, [r5, #4]
 8017700:	039b      	lsls	r3, r3, #14
 8017702:	d5f6      	bpl.n	80176f2 <HAL_PWREx_EnableOverDrive+0x4e>
    {
      return HAL_TIMEOUT;
    }
  } 
  return HAL_OK;
 8017704:	2000      	movs	r0, #0
}
 8017706:	b003      	add	sp, #12
 8017708:	bd30      	pop	{r4, r5, pc}
      return HAL_TIMEOUT;
 801770a:	2003      	movs	r0, #3
}
 801770c:	b003      	add	sp, #12
 801770e:	bd30      	pop	{r4, r5, pc}
 8017710:	40023800 	.word	0x40023800
 8017714:	40007000 	.word	0x40007000

08017718 <HAL_QSPI_Init>:
  *        in the QSPI_InitTypeDef and initialize the associated handle.
  * @param hqspi QSPI handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Init(QSPI_HandleTypeDef *hqspi)
{
 8017718:	b570      	push	{r4, r5, r6, lr}
 801771a:	4604      	mov	r4, r0
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
 801771c:	f7fb fba6 	bl	8012e6c <HAL_GetTick>

  /* Check the QSPI handle allocation */
  if(hqspi == NULL)
 8017720:	2c00      	cmp	r4, #0
 8017722:	d04d      	beq.n	80177c0 <HAL_QSPI_Init+0xa8>
  if (hqspi->Init.DualFlash != QSPI_DUALFLASH_ENABLE )
  {
    assert_param(IS_QSPI_FLASH_ID(hqspi->Init.FlashID));
  }

  if(hqspi->State == HAL_QSPI_STATE_RESET)
 8017724:	f894 3041 	ldrb.w	r3, [r4, #65]	@ 0x41
 8017728:	4606      	mov	r6, r0
 801772a:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
 801772e:	2b00      	cmp	r3, #0
 8017730:	d03c      	beq.n	80177ac <HAL_QSPI_Init+0x94>
  /* Configure QSPI FIFO Threshold */
  MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FTHRES,
             ((hqspi->Init.FifoThreshold - 1U) << QUADSPI_CR_FTHRES_Pos));

  /* Wait till BUSY flag reset */
  status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
 8017732:	6ca5      	ldr	r5, [r4, #72]	@ 0x48
  MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FTHRES,
 8017734:	6822      	ldr	r2, [r4, #0]
 8017736:	68a1      	ldr	r1, [r4, #8]
 8017738:	6813      	ldr	r3, [r2, #0]
 801773a:	3901      	subs	r1, #1
 801773c:	f423 53f8 	bic.w	r3, r3, #7936	@ 0x1f00
 8017740:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8017744:	6013      	str	r3, [r2, #0]
  */
static HAL_StatusTypeDef QSPI_WaitFlagStateUntilTimeout(QSPI_HandleTypeDef *hqspi, uint32_t Flag,
                                                        FlagStatus State, uint32_t Tickstart, uint32_t Timeout)
{
  /* Wait until flag is in expected state */
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
 8017746:	e001      	b.n	801774c <HAL_QSPI_Init+0x34>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 8017748:	1c6b      	adds	r3, r5, #1
 801774a:	d127      	bne.n	801779c <HAL_QSPI_Init+0x84>
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
 801774c:	6893      	ldr	r3, [r2, #8]
 801774e:	f013 0320 	ands.w	r3, r3, #32
 8017752:	d1f9      	bne.n	8017748 <HAL_QSPI_Init+0x30>
    MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PRESCALER | QUADSPI_CR_SSHIFT | QUADSPI_CR_FSEL | QUADSPI_CR_DFM),
 8017754:	69e0      	ldr	r0, [r4, #28]
 8017756:	68e1      	ldr	r1, [r4, #12]
 8017758:	6815      	ldr	r5, [r2, #0]
 801775a:	4301      	orrs	r1, r0
 801775c:	6a20      	ldr	r0, [r4, #32]
 801775e:	4301      	orrs	r1, r0
 8017760:	6860      	ldr	r0, [r4, #4]
 8017762:	ea41 6100 	orr.w	r1, r1, r0, lsl #24
 8017766:	481b      	ldr	r0, [pc, #108]	@ (80177d4 <HAL_QSPI_Init+0xbc>)
 8017768:	4028      	ands	r0, r5
 801776a:	4301      	orrs	r1, r0
    MODIFY_REG(hqspi->Instance->DCR, (QUADSPI_DCR_FSIZE | QUADSPI_DCR_CSHT | QUADSPI_DCR_CKMODE),
 801776c:	6960      	ldr	r0, [r4, #20]
    MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PRESCALER | QUADSPI_CR_SSHIFT | QUADSPI_CR_FSEL | QUADSPI_CR_DFM),
 801776e:	6011      	str	r1, [r2, #0]
    MODIFY_REG(hqspi->Instance->DCR, (QUADSPI_DCR_FSIZE | QUADSPI_DCR_CSHT | QUADSPI_DCR_CKMODE),
 8017770:	69a1      	ldr	r1, [r4, #24]
 8017772:	6855      	ldr	r5, [r2, #4]
 8017774:	4301      	orrs	r1, r0
 8017776:	6920      	ldr	r0, [r4, #16]
 8017778:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
 801777c:	4816      	ldr	r0, [pc, #88]	@ (80177d8 <HAL_QSPI_Init+0xc0>)
 801777e:	4028      	ands	r0, r5
    hqspi->State = HAL_QSPI_STATE_READY;
 8017780:	2501      	movs	r5, #1
    MODIFY_REG(hqspi->Instance->DCR, (QUADSPI_DCR_FSIZE | QUADSPI_DCR_CSHT | QUADSPI_DCR_CKMODE),
 8017782:	4301      	orrs	r1, r0
    hqspi->State = HAL_QSPI_STATE_READY;
 8017784:	4618      	mov	r0, r3
    MODIFY_REG(hqspi->Instance->DCR, (QUADSPI_DCR_FSIZE | QUADSPI_DCR_CSHT | QUADSPI_DCR_CKMODE),
 8017786:	6051      	str	r1, [r2, #4]
    __HAL_QSPI_ENABLE(hqspi);
 8017788:	6811      	ldr	r1, [r2, #0]
 801778a:	4329      	orrs	r1, r5
 801778c:	6011      	str	r1, [r2, #0]
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
 801778e:	6463      	str	r3, [r4, #68]	@ 0x44
    hqspi->State = HAL_QSPI_STATE_READY;
 8017790:	f884 5041 	strb.w	r5, [r4, #65]	@ 0x41
  __HAL_UNLOCK(hqspi);
 8017794:	2300      	movs	r3, #0
 8017796:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
}
 801779a:	bd70      	pop	{r4, r5, r6, pc}
    {
      if(((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 801779c:	f7fb fb66 	bl	8012e6c <HAL_GetTick>
 80177a0:	1b80      	subs	r0, r0, r6
 80177a2:	42a8      	cmp	r0, r5
 80177a4:	d80e      	bhi.n	80177c4 <HAL_QSPI_Init+0xac>
 80177a6:	b16d      	cbz	r5, 80177c4 <HAL_QSPI_Init+0xac>
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
 80177a8:	6822      	ldr	r2, [r4, #0]
 80177aa:	e7cf      	b.n	801774c <HAL_QSPI_Init+0x34>
    HAL_QSPI_MspInit(hqspi);
 80177ac:	4620      	mov	r0, r4
    hqspi->Lock = HAL_UNLOCKED;
 80177ae:	f884 2040 	strb.w	r2, [r4, #64]	@ 0x40
    HAL_QSPI_MspInit(hqspi);
 80177b2:	f7fa fe75 	bl	80124a0 <HAL_QSPI_MspInit>
  hqspi->Timeout = Timeout;
 80177b6:	f241 3388 	movw	r3, #5000	@ 0x1388
}
 80177ba:	461d      	mov	r5, r3
  hqspi->Timeout = Timeout;
 80177bc:	64a3      	str	r3, [r4, #72]	@ 0x48
}
 80177be:	e7b9      	b.n	8017734 <HAL_QSPI_Init+0x1c>
    return HAL_ERROR;
 80177c0:	2001      	movs	r0, #1
}
 80177c2:	bd70      	pop	{r4, r5, r6, pc}
      {
        hqspi->State     = HAL_QSPI_STATE_ERROR;
 80177c4:	2304      	movs	r3, #4
        hqspi->ErrorCode |= HAL_QSPI_ERROR_TIMEOUT;
 80177c6:	2001      	movs	r0, #1
        hqspi->State     = HAL_QSPI_STATE_ERROR;
 80177c8:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
        hqspi->ErrorCode |= HAL_QSPI_ERROR_TIMEOUT;
 80177cc:	6c63      	ldr	r3, [r4, #68]	@ 0x44
 80177ce:	4303      	orrs	r3, r0
 80177d0:	6463      	str	r3, [r4, #68]	@ 0x44
  if(status == HAL_OK)
 80177d2:	e7df      	b.n	8017794 <HAL_QSPI_Init+0x7c>
 80177d4:	00ffff2f 	.word	0x00ffff2f
 80177d8:	ffe0f8fe 	.word	0xffe0f8fe

080177dc <HAL_RCC_OscConfig>:
  uint32_t tickstart;
  uint32_t pll_config;
  FlagStatus pwrclkchanged = RESET;

  /* Check Null pointer */
  if (RCC_OscInitStruct == NULL)
 80177dc:	2800      	cmp	r0, #0
 80177de:	f000 81e7 	beq.w	8017bb0 <HAL_RCC_OscConfig+0x3d4>

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSE Configuration ------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80177e2:	6803      	ldr	r3, [r0, #0]
{
 80177e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80177e8:	07dd      	lsls	r5, r3, #31
{
 80177ea:	b082      	sub	sp, #8
 80177ec:	4604      	mov	r4, r0
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80177ee:	d535      	bpl.n	801785c <HAL_RCC_OscConfig+0x80>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL, It can not be disabled */
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE)
 80177f0:	499a      	ldr	r1, [pc, #616]	@ (8017a5c <HAL_RCC_OscConfig+0x280>)
 80177f2:	688a      	ldr	r2, [r1, #8]
 80177f4:	f002 020c 	and.w	r2, r2, #12
 80177f8:	2a04      	cmp	r2, #4
 80177fa:	f000 80e0 	beq.w	80179be <HAL_RCC_OscConfig+0x1e2>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 80177fe:	688a      	ldr	r2, [r1, #8]
 8017800:	f002 020c 	and.w	r2, r2, #12
 8017804:	2a08      	cmp	r2, #8
 8017806:	f000 80d6 	beq.w	80179b6 <HAL_RCC_OscConfig+0x1da>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 801780a:	6863      	ldr	r3, [r4, #4]
 801780c:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8017810:	d010      	beq.n	8017834 <HAL_RCC_OscConfig+0x58>
 8017812:	2b00      	cmp	r3, #0
 8017814:	f000 80fd 	beq.w	8017a12 <HAL_RCC_OscConfig+0x236>
 8017818:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 801781c:	4b8f      	ldr	r3, [pc, #572]	@ (8017a5c <HAL_RCC_OscConfig+0x280>)
 801781e:	681a      	ldr	r2, [r3, #0]
 8017820:	f000 8185 	beq.w	8017b2e <HAL_RCC_OscConfig+0x352>
 8017824:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
 8017828:	601a      	str	r2, [r3, #0]
 801782a:	681a      	ldr	r2, [r3, #0]
 801782c:	f422 2280 	bic.w	r2, r2, #262144	@ 0x40000
 8017830:	601a      	str	r2, [r3, #0]

      /* Check the HSE State */
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8017832:	e004      	b.n	801783e <HAL_RCC_OscConfig+0x62>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8017834:	4a89      	ldr	r2, [pc, #548]	@ (8017a5c <HAL_RCC_OscConfig+0x280>)
 8017836:	6813      	ldr	r3, [r2, #0]
 8017838:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 801783c:	6013      	str	r3, [r2, #0]
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 801783e:	f7fb fb15 	bl	8012e6c <HAL_GetTick>

        /* Wait till HSE is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8017842:	4e86      	ldr	r6, [pc, #536]	@ (8017a5c <HAL_RCC_OscConfig+0x280>)
        tickstart = HAL_GetTick();
 8017844:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8017846:	e005      	b.n	8017854 <HAL_RCC_OscConfig+0x78>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8017848:	f7fb fb10 	bl	8012e6c <HAL_GetTick>
 801784c:	1b40      	subs	r0, r0, r5
 801784e:	2864      	cmp	r0, #100	@ 0x64
 8017850:	f200 80db 	bhi.w	8017a0a <HAL_RCC_OscConfig+0x22e>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8017854:	6833      	ldr	r3, [r6, #0]
 8017856:	039b      	lsls	r3, r3, #14
 8017858:	d5f6      	bpl.n	8017848 <HAL_RCC_OscConfig+0x6c>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 801785a:	6823      	ldr	r3, [r4, #0]
 801785c:	079d      	lsls	r5, r3, #30
 801785e:	d528      	bpl.n	80178b2 <HAL_RCC_OscConfig+0xd6>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI)
 8017860:	4a7e      	ldr	r2, [pc, #504]	@ (8017a5c <HAL_RCC_OscConfig+0x280>)
 8017862:	6891      	ldr	r1, [r2, #8]
 8017864:	f011 0f0c 	tst.w	r1, #12
 8017868:	f000 8089 	beq.w	801797e <HAL_RCC_OscConfig+0x1a2>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 801786c:	6891      	ldr	r1, [r2, #8]
 801786e:	f001 010c 	and.w	r1, r1, #12
 8017872:	2908      	cmp	r1, #8
 8017874:	d07f      	beq.n	8017976 <HAL_RCC_OscConfig+0x19a>
      }
    }
    else
    {
      /* Check the HSI State */
      if ((RCC_OscInitStruct->HSIState) != RCC_HSI_OFF)
 8017876:	68e3      	ldr	r3, [r4, #12]
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 8017878:	4d78      	ldr	r5, [pc, #480]	@ (8017a5c <HAL_RCC_OscConfig+0x280>)
      if ((RCC_OscInitStruct->HSIState) != RCC_HSI_OFF)
 801787a:	2b00      	cmp	r3, #0
 801787c:	f000 8103 	beq.w	8017a86 <HAL_RCC_OscConfig+0x2aa>
        __HAL_RCC_HSI_ENABLE();
 8017880:	682b      	ldr	r3, [r5, #0]
 8017882:	f043 0301 	orr.w	r3, r3, #1
 8017886:	602b      	str	r3, [r5, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8017888:	f7fb faf0 	bl	8012e6c <HAL_GetTick>
 801788c:	4606      	mov	r6, r0

        /* Wait till HSI is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 801788e:	e005      	b.n	801789c <HAL_RCC_OscConfig+0xc0>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8017890:	f7fb faec 	bl	8012e6c <HAL_GetTick>
 8017894:	1b80      	subs	r0, r0, r6
 8017896:	2802      	cmp	r0, #2
 8017898:	f200 80b7 	bhi.w	8017a0a <HAL_RCC_OscConfig+0x22e>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 801789c:	682b      	ldr	r3, [r5, #0]
 801789e:	079f      	lsls	r7, r3, #30
 80178a0:	d5f6      	bpl.n	8017890 <HAL_RCC_OscConfig+0xb4>
            return HAL_TIMEOUT;
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80178a2:	682b      	ldr	r3, [r5, #0]
 80178a4:	6922      	ldr	r2, [r4, #16]
 80178a6:	f023 03f8 	bic.w	r3, r3, #248	@ 0xf8
 80178aa:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 80178ae:	602b      	str	r3, [r5, #0]
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 80178b0:	6823      	ldr	r3, [r4, #0]
 80178b2:	071a      	lsls	r2, r3, #28
 80178b4:	d428      	bmi.n	8017908 <HAL_RCC_OscConfig+0x12c>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 80178b6:	075e      	lsls	r6, r3, #29
 80178b8:	d53d      	bpl.n	8017936 <HAL_RCC_OscConfig+0x15a>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 80178ba:	4b68      	ldr	r3, [pc, #416]	@ (8017a5c <HAL_RCC_OscConfig+0x280>)
 80178bc:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 80178be:	00d5      	lsls	r5, r2, #3
 80178c0:	d477      	bmi.n	80179b2 <HAL_RCC_OscConfig+0x1d6>
    {
      /* Enable Power Clock*/
      __HAL_RCC_PWR_CLK_ENABLE();
 80178c2:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
      pwrclkchanged = SET;
 80178c4:	2501      	movs	r5, #1
      __HAL_RCC_PWR_CLK_ENABLE();
 80178c6:	f042 5280 	orr.w	r2, r2, #268435456	@ 0x10000000
 80178ca:	641a      	str	r2, [r3, #64]	@ 0x40
 80178cc:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80178ce:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 80178d2:	9301      	str	r3, [sp, #4]
 80178d4:	9b01      	ldr	r3, [sp, #4]
    }

    if (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 80178d6:	4e62      	ldr	r6, [pc, #392]	@ (8017a60 <HAL_RCC_OscConfig+0x284>)
 80178d8:	6833      	ldr	r3, [r6, #0]
 80178da:	05d8      	lsls	r0, r3, #23
 80178dc:	f140 8085 	bpl.w	80179ea <HAL_RCC_OscConfig+0x20e>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80178e0:	68a3      	ldr	r3, [r4, #8]
 80178e2:	2b01      	cmp	r3, #1
 80178e4:	f000 80e1 	beq.w	8017aaa <HAL_RCC_OscConfig+0x2ce>
 80178e8:	2b00      	cmp	r3, #0
 80178ea:	f000 80a8 	beq.w	8017a3e <HAL_RCC_OscConfig+0x262>
 80178ee:	2b05      	cmp	r3, #5
 80178f0:	4b5a      	ldr	r3, [pc, #360]	@ (8017a5c <HAL_RCC_OscConfig+0x280>)
 80178f2:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
 80178f4:	f000 8123 	beq.w	8017b3e <HAL_RCC_OscConfig+0x362>
 80178f8:	f022 0201 	bic.w	r2, r2, #1
 80178fc:	671a      	str	r2, [r3, #112]	@ 0x70
 80178fe:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
 8017900:	f022 0204 	bic.w	r2, r2, #4
 8017904:	671a      	str	r2, [r3, #112]	@ 0x70
    /* Check the LSE State */
    if ((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 8017906:	e0d5      	b.n	8017ab4 <HAL_RCC_OscConfig+0x2d8>
    if ((RCC_OscInitStruct->LSIState) != RCC_LSI_OFF)
 8017908:	6963      	ldr	r3, [r4, #20]
      __HAL_RCC_LSI_ENABLE();
 801790a:	4d54      	ldr	r5, [pc, #336]	@ (8017a5c <HAL_RCC_OscConfig+0x280>)
    if ((RCC_OscInitStruct->LSIState) != RCC_LSI_OFF)
 801790c:	2b00      	cmp	r3, #0
 801790e:	d03f      	beq.n	8017990 <HAL_RCC_OscConfig+0x1b4>
      __HAL_RCC_LSI_ENABLE();
 8017910:	6f6b      	ldr	r3, [r5, #116]	@ 0x74
 8017912:	f043 0301 	orr.w	r3, r3, #1
 8017916:	676b      	str	r3, [r5, #116]	@ 0x74
      tickstart = HAL_GetTick();
 8017918:	f7fb faa8 	bl	8012e6c <HAL_GetTick>
 801791c:	4606      	mov	r6, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 801791e:	e004      	b.n	801792a <HAL_RCC_OscConfig+0x14e>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8017920:	f7fb faa4 	bl	8012e6c <HAL_GetTick>
 8017924:	1b80      	subs	r0, r0, r6
 8017926:	2802      	cmp	r0, #2
 8017928:	d86f      	bhi.n	8017a0a <HAL_RCC_OscConfig+0x22e>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 801792a:	6f6b      	ldr	r3, [r5, #116]	@ 0x74
 801792c:	079b      	lsls	r3, r3, #30
 801792e:	d5f7      	bpl.n	8017920 <HAL_RCC_OscConfig+0x144>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8017930:	6823      	ldr	r3, [r4, #0]
 8017932:	075e      	lsls	r6, r3, #29
 8017934:	d4c1      	bmi.n	80178ba <HAL_RCC_OscConfig+0xde>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8017936:	69a3      	ldr	r3, [r4, #24]
 8017938:	b1cb      	cbz	r3, 801796e <HAL_RCC_OscConfig+0x192>
  {
    /* Check if the PLL is used as system clock or not */
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 801793a:	4d48      	ldr	r5, [pc, #288]	@ (8017a5c <HAL_RCC_OscConfig+0x280>)
 801793c:	68aa      	ldr	r2, [r5, #8]
 801793e:	f002 020c 	and.w	r2, r2, #12
 8017942:	2a08      	cmp	r2, #8
 8017944:	f000 80c9 	beq.w	8017ada <HAL_RCC_OscConfig+0x2fe>
    {
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8017948:	2b02      	cmp	r3, #2
#if defined (RCC_PLLCFGR_PLLR)
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));
#endif

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 801794a:	682b      	ldr	r3, [r5, #0]
 801794c:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
 8017950:	602b      	str	r3, [r5, #0]
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8017952:	f000 80fc 	beq.w	8017b4e <HAL_RCC_OscConfig+0x372>
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8017956:	f7fb fa89 	bl	8012e6c <HAL_GetTick>
 801795a:	4604      	mov	r4, r0

        /* Wait till PLL is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 801795c:	e004      	b.n	8017968 <HAL_RCC_OscConfig+0x18c>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 801795e:	f7fb fa85 	bl	8012e6c <HAL_GetTick>
 8017962:	1b00      	subs	r0, r0, r4
 8017964:	2802      	cmp	r0, #2
 8017966:	d850      	bhi.n	8017a0a <HAL_RCC_OscConfig+0x22e>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8017968:	682b      	ldr	r3, [r5, #0]
 801796a:	019b      	lsls	r3, r3, #6
 801796c:	d4f7      	bmi.n	801795e <HAL_RCC_OscConfig+0x182>
      {
        return HAL_ERROR;
      }
    }
  }
  return HAL_OK;
 801796e:	2000      	movs	r0, #0
}
 8017970:	b002      	add	sp, #8
 8017972:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8017976:	6852      	ldr	r2, [r2, #4]
 8017978:	0251      	lsls	r1, r2, #9
 801797a:	f53f af7c 	bmi.w	8017876 <HAL_RCC_OscConfig+0x9a>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 801797e:	4a37      	ldr	r2, [pc, #220]	@ (8017a5c <HAL_RCC_OscConfig+0x280>)
 8017980:	6812      	ldr	r2, [r2, #0]
 8017982:	0792      	lsls	r2, r2, #30
 8017984:	d525      	bpl.n	80179d2 <HAL_RCC_OscConfig+0x1f6>
 8017986:	68e2      	ldr	r2, [r4, #12]
 8017988:	2a01      	cmp	r2, #1
 801798a:	d022      	beq.n	80179d2 <HAL_RCC_OscConfig+0x1f6>
    return HAL_ERROR;
 801798c:	2001      	movs	r0, #1
 801798e:	e7ef      	b.n	8017970 <HAL_RCC_OscConfig+0x194>
      __HAL_RCC_LSI_DISABLE();
 8017990:	6f6b      	ldr	r3, [r5, #116]	@ 0x74
 8017992:	f023 0301 	bic.w	r3, r3, #1
 8017996:	676b      	str	r3, [r5, #116]	@ 0x74
      tickstart = HAL_GetTick();
 8017998:	f7fb fa68 	bl	8012e6c <HAL_GetTick>
 801799c:	4606      	mov	r6, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 801799e:	e004      	b.n	80179aa <HAL_RCC_OscConfig+0x1ce>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 80179a0:	f7fb fa64 	bl	8012e6c <HAL_GetTick>
 80179a4:	1b80      	subs	r0, r0, r6
 80179a6:	2802      	cmp	r0, #2
 80179a8:	d82f      	bhi.n	8017a0a <HAL_RCC_OscConfig+0x22e>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80179aa:	6f6b      	ldr	r3, [r5, #116]	@ 0x74
 80179ac:	079f      	lsls	r7, r3, #30
 80179ae:	d4f7      	bmi.n	80179a0 <HAL_RCC_OscConfig+0x1c4>
 80179b0:	e7be      	b.n	8017930 <HAL_RCC_OscConfig+0x154>
  FlagStatus pwrclkchanged = RESET;
 80179b2:	2500      	movs	r5, #0
 80179b4:	e78f      	b.n	80178d6 <HAL_RCC_OscConfig+0xfa>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 80179b6:	684a      	ldr	r2, [r1, #4]
 80179b8:	0251      	lsls	r1, r2, #9
 80179ba:	f57f af26 	bpl.w	801780a <HAL_RCC_OscConfig+0x2e>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 80179be:	4a27      	ldr	r2, [pc, #156]	@ (8017a5c <HAL_RCC_OscConfig+0x280>)
 80179c0:	6812      	ldr	r2, [r2, #0]
 80179c2:	0392      	lsls	r2, r2, #14
 80179c4:	f57f af4a 	bpl.w	801785c <HAL_RCC_OscConfig+0x80>
 80179c8:	6862      	ldr	r2, [r4, #4]
 80179ca:	2a00      	cmp	r2, #0
 80179cc:	f47f af46 	bne.w	801785c <HAL_RCC_OscConfig+0x80>
 80179d0:	e7dc      	b.n	801798c <HAL_RCC_OscConfig+0x1b0>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80179d2:	4922      	ldr	r1, [pc, #136]	@ (8017a5c <HAL_RCC_OscConfig+0x280>)
 80179d4:	6920      	ldr	r0, [r4, #16]
 80179d6:	680a      	ldr	r2, [r1, #0]
 80179d8:	f022 02f8 	bic.w	r2, r2, #248	@ 0xf8
 80179dc:	ea42 02c0 	orr.w	r2, r2, r0, lsl #3
 80179e0:	600a      	str	r2, [r1, #0]
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 80179e2:	071a      	lsls	r2, r3, #28
 80179e4:	f57f af67 	bpl.w	80178b6 <HAL_RCC_OscConfig+0xda>
 80179e8:	e78e      	b.n	8017908 <HAL_RCC_OscConfig+0x12c>
      PWR->CR1 |= PWR_CR1_DBP;
 80179ea:	6833      	ldr	r3, [r6, #0]
 80179ec:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 80179f0:	6033      	str	r3, [r6, #0]
      tickstart = HAL_GetTick();
 80179f2:	f7fb fa3b 	bl	8012e6c <HAL_GetTick>
 80179f6:	4607      	mov	r7, r0
      while (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 80179f8:	6833      	ldr	r3, [r6, #0]
 80179fa:	05d9      	lsls	r1, r3, #23
 80179fc:	f53f af70 	bmi.w	80178e0 <HAL_RCC_OscConfig+0x104>
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8017a00:	f7fb fa34 	bl	8012e6c <HAL_GetTick>
 8017a04:	1bc0      	subs	r0, r0, r7
 8017a06:	2864      	cmp	r0, #100	@ 0x64
 8017a08:	d9f6      	bls.n	80179f8 <HAL_RCC_OscConfig+0x21c>
            return HAL_TIMEOUT;
 8017a0a:	2003      	movs	r0, #3
}
 8017a0c:	b002      	add	sp, #8
 8017a0e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8017a12:	4d12      	ldr	r5, [pc, #72]	@ (8017a5c <HAL_RCC_OscConfig+0x280>)
 8017a14:	682b      	ldr	r3, [r5, #0]
 8017a16:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 8017a1a:	602b      	str	r3, [r5, #0]
 8017a1c:	682b      	ldr	r3, [r5, #0]
 8017a1e:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
 8017a22:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 8017a24:	f7fb fa22 	bl	8012e6c <HAL_GetTick>
 8017a28:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8017a2a:	e004      	b.n	8017a36 <HAL_RCC_OscConfig+0x25a>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8017a2c:	f7fb fa1e 	bl	8012e6c <HAL_GetTick>
 8017a30:	1b80      	subs	r0, r0, r6
 8017a32:	2864      	cmp	r0, #100	@ 0x64
 8017a34:	d8e9      	bhi.n	8017a0a <HAL_RCC_OscConfig+0x22e>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8017a36:	682b      	ldr	r3, [r5, #0]
 8017a38:	039f      	lsls	r7, r3, #14
 8017a3a:	d4f7      	bmi.n	8017a2c <HAL_RCC_OscConfig+0x250>
 8017a3c:	e70d      	b.n	801785a <HAL_RCC_OscConfig+0x7e>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8017a3e:	4e07      	ldr	r6, [pc, #28]	@ (8017a5c <HAL_RCC_OscConfig+0x280>)
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8017a40:	f241 3888 	movw	r8, #5000	@ 0x1388
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8017a44:	6f33      	ldr	r3, [r6, #112]	@ 0x70
 8017a46:	f023 0301 	bic.w	r3, r3, #1
 8017a4a:	6733      	str	r3, [r6, #112]	@ 0x70
 8017a4c:	6f33      	ldr	r3, [r6, #112]	@ 0x70
 8017a4e:	f023 0304 	bic.w	r3, r3, #4
 8017a52:	6733      	str	r3, [r6, #112]	@ 0x70
      tickstart = HAL_GetTick();
 8017a54:	f7fb fa0a 	bl	8012e6c <HAL_GetTick>
 8017a58:	4607      	mov	r7, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8017a5a:	e008      	b.n	8017a6e <HAL_RCC_OscConfig+0x292>
 8017a5c:	40023800 	.word	0x40023800
 8017a60:	40007000 	.word	0x40007000
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8017a64:	f7fb fa02 	bl	8012e6c <HAL_GetTick>
 8017a68:	1bc0      	subs	r0, r0, r7
 8017a6a:	4540      	cmp	r0, r8
 8017a6c:	d8cd      	bhi.n	8017a0a <HAL_RCC_OscConfig+0x22e>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8017a6e:	6f33      	ldr	r3, [r6, #112]	@ 0x70
 8017a70:	079b      	lsls	r3, r3, #30
 8017a72:	d4f7      	bmi.n	8017a64 <HAL_RCC_OscConfig+0x288>
    if (pwrclkchanged == SET)
 8017a74:	2d00      	cmp	r5, #0
 8017a76:	f43f af5e 	beq.w	8017936 <HAL_RCC_OscConfig+0x15a>
      __HAL_RCC_PWR_CLK_DISABLE();
 8017a7a:	4a4e      	ldr	r2, [pc, #312]	@ (8017bb4 <HAL_RCC_OscConfig+0x3d8>)
 8017a7c:	6c13      	ldr	r3, [r2, #64]	@ 0x40
 8017a7e:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
 8017a82:	6413      	str	r3, [r2, #64]	@ 0x40
 8017a84:	e757      	b.n	8017936 <HAL_RCC_OscConfig+0x15a>
        __HAL_RCC_HSI_DISABLE();
 8017a86:	682b      	ldr	r3, [r5, #0]
 8017a88:	f023 0301 	bic.w	r3, r3, #1
 8017a8c:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 8017a8e:	f7fb f9ed 	bl	8012e6c <HAL_GetTick>
 8017a92:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8017a94:	e004      	b.n	8017aa0 <HAL_RCC_OscConfig+0x2c4>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8017a96:	f7fb f9e9 	bl	8012e6c <HAL_GetTick>
 8017a9a:	1b80      	subs	r0, r0, r6
 8017a9c:	2802      	cmp	r0, #2
 8017a9e:	d8b4      	bhi.n	8017a0a <HAL_RCC_OscConfig+0x22e>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8017aa0:	682b      	ldr	r3, [r5, #0]
 8017aa2:	0799      	lsls	r1, r3, #30
 8017aa4:	d4f7      	bmi.n	8017a96 <HAL_RCC_OscConfig+0x2ba>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8017aa6:	6823      	ldr	r3, [r4, #0]
 8017aa8:	e703      	b.n	80178b2 <HAL_RCC_OscConfig+0xd6>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8017aaa:	4a42      	ldr	r2, [pc, #264]	@ (8017bb4 <HAL_RCC_OscConfig+0x3d8>)
 8017aac:	6f13      	ldr	r3, [r2, #112]	@ 0x70
 8017aae:	f043 0301 	orr.w	r3, r3, #1
 8017ab2:	6713      	str	r3, [r2, #112]	@ 0x70
      tickstart = HAL_GetTick();
 8017ab4:	f7fb f9da 	bl	8012e6c <HAL_GetTick>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8017ab8:	4f3e      	ldr	r7, [pc, #248]	@ (8017bb4 <HAL_RCC_OscConfig+0x3d8>)
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8017aba:	f241 3888 	movw	r8, #5000	@ 0x1388
      tickstart = HAL_GetTick();
 8017abe:	4606      	mov	r6, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8017ac0:	e004      	b.n	8017acc <HAL_RCC_OscConfig+0x2f0>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8017ac2:	f7fb f9d3 	bl	8012e6c <HAL_GetTick>
 8017ac6:	1b80      	subs	r0, r0, r6
 8017ac8:	4540      	cmp	r0, r8
 8017aca:	d89e      	bhi.n	8017a0a <HAL_RCC_OscConfig+0x22e>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8017acc:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8017ace:	079a      	lsls	r2, r3, #30
 8017ad0:	d5f7      	bpl.n	8017ac2 <HAL_RCC_OscConfig+0x2e6>
    if (pwrclkchanged == SET)
 8017ad2:	2d00      	cmp	r5, #0
 8017ad4:	f43f af2f 	beq.w	8017936 <HAL_RCC_OscConfig+0x15a>
 8017ad8:	e7cf      	b.n	8017a7a <HAL_RCC_OscConfig+0x29e>
      if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 8017ada:	2b01      	cmp	r3, #1
      pll_config = RCC->PLLCFGR;
 8017adc:	686a      	ldr	r2, [r5, #4]
      if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 8017ade:	f43f af55 	beq.w	801798c <HAL_RCC_OscConfig+0x1b0>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8017ae2:	f402 0380 	and.w	r3, r2, #4194304	@ 0x400000
      if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 8017ae6:	69e1      	ldr	r1, [r4, #28]
 8017ae8:	428b      	cmp	r3, r1
 8017aea:	f47f af4f 	bne.w	801798c <HAL_RCC_OscConfig+0x1b0>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
 8017aee:	f002 033f 	and.w	r3, r2, #63	@ 0x3f
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8017af2:	6a21      	ldr	r1, [r4, #32]
 8017af4:	428b      	cmp	r3, r1
 8017af6:	f47f af49 	bne.w	801798c <HAL_RCC_OscConfig+0x1b0>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
 8017afa:	f647 73c0 	movw	r3, #32704	@ 0x7fc0
 8017afe:	6a61      	ldr	r1, [r4, #36]	@ 0x24
 8017b00:	4013      	ands	r3, r2
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
 8017b02:	ebb3 1f81 	cmp.w	r3, r1, lsl #6
 8017b06:	f47f af41 	bne.w	801798c <HAL_RCC_OscConfig+0x1b0>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != ((((RCC_OscInitStruct->PLL.PLLP) >> 1U) - 1U) << RCC_PLLCFGR_PLLP_Pos)) ||
 8017b0a:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 8017b0c:	f402 3140 	and.w	r1, r2, #196608	@ 0x30000
 8017b10:	085b      	lsrs	r3, r3, #1
 8017b12:	3b01      	subs	r3, #1
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
 8017b14:	ebb1 4f03 	cmp.w	r1, r3, lsl #16
 8017b18:	f47f af38 	bne.w	801798c <HAL_RCC_OscConfig+0x1b0>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)))
 8017b1c:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
 8017b1e:	f002 6270 	and.w	r2, r2, #251658240	@ 0xf000000
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != ((((RCC_OscInitStruct->PLL.PLLP) >> 1U) - 1U) << RCC_PLLCFGR_PLLP_Pos)) ||
 8017b22:	ebb2 6f03 	cmp.w	r2, r3, lsl #24
 8017b26:	bf14      	ite	ne
 8017b28:	2001      	movne	r0, #1
 8017b2a:	2000      	moveq	r0, #0
 8017b2c:	e720      	b.n	8017970 <HAL_RCC_OscConfig+0x194>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8017b2e:	f442 2280 	orr.w	r2, r2, #262144	@ 0x40000
 8017b32:	601a      	str	r2, [r3, #0]
 8017b34:	681a      	ldr	r2, [r3, #0]
 8017b36:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
 8017b3a:	601a      	str	r2, [r3, #0]
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8017b3c:	e67f      	b.n	801783e <HAL_RCC_OscConfig+0x62>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8017b3e:	f042 0204 	orr.w	r2, r2, #4
 8017b42:	671a      	str	r2, [r3, #112]	@ 0x70
 8017b44:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
 8017b46:	f042 0201 	orr.w	r2, r2, #1
 8017b4a:	671a      	str	r2, [r3, #112]	@ 0x70
    if ((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 8017b4c:	e7b2      	b.n	8017ab4 <HAL_RCC_OscConfig+0x2d8>
        tickstart = HAL_GetTick();
 8017b4e:	f7fb f98d 	bl	8012e6c <HAL_GetTick>
 8017b52:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8017b54:	e005      	b.n	8017b62 <HAL_RCC_OscConfig+0x386>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8017b56:	f7fb f989 	bl	8012e6c <HAL_GetTick>
 8017b5a:	1b80      	subs	r0, r0, r6
 8017b5c:	2802      	cmp	r0, #2
 8017b5e:	f63f af54 	bhi.w	8017a0a <HAL_RCC_OscConfig+0x22e>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8017b62:	682b      	ldr	r3, [r5, #0]
 8017b64:	0199      	lsls	r1, r3, #6
 8017b66:	d4f6      	bmi.n	8017b56 <HAL_RCC_OscConfig+0x37a>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8017b68:	6aa2      	ldr	r2, [r4, #40]	@ 0x28
 8017b6a:	6a60      	ldr	r0, [r4, #36]	@ 0x24
 8017b6c:	0852      	lsrs	r2, r2, #1
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8017b6e:	4e11      	ldr	r6, [pc, #68]	@ (8017bb4 <HAL_RCC_OscConfig+0x3d8>)
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8017b70:	e9d4 3107 	ldrd	r3, r1, [r4, #28]
 8017b74:	3a01      	subs	r2, #1
 8017b76:	430b      	orrs	r3, r1
 8017b78:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
 8017b7a:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8017b7e:	ea43 1380 	orr.w	r3, r3, r0, lsl #6
 8017b82:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 8017b86:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
 8017b8a:	606b      	str	r3, [r5, #4]
        __HAL_RCC_PLL_ENABLE();
 8017b8c:	682b      	ldr	r3, [r5, #0]
 8017b8e:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 8017b92:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 8017b94:	f7fb f96a 	bl	8012e6c <HAL_GetTick>
 8017b98:	4604      	mov	r4, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8017b9a:	e005      	b.n	8017ba8 <HAL_RCC_OscConfig+0x3cc>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8017b9c:	f7fb f966 	bl	8012e6c <HAL_GetTick>
 8017ba0:	1b00      	subs	r0, r0, r4
 8017ba2:	2802      	cmp	r0, #2
 8017ba4:	f63f af31 	bhi.w	8017a0a <HAL_RCC_OscConfig+0x22e>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8017ba8:	6833      	ldr	r3, [r6, #0]
 8017baa:	019a      	lsls	r2, r3, #6
 8017bac:	d5f6      	bpl.n	8017b9c <HAL_RCC_OscConfig+0x3c0>
 8017bae:	e6de      	b.n	801796e <HAL_RCC_OscConfig+0x192>
    return HAL_ERROR;
 8017bb0:	2001      	movs	r0, #1
}
 8017bb2:	4770      	bx	lr
 8017bb4:	40023800 	.word	0x40023800

08017bb8 <HAL_RCC_ClockConfig>:
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
  uint32_t tickstart = 0;

  /* Check Null pointer */
  if (RCC_ClkInitStruct == NULL)
 8017bb8:	2800      	cmp	r0, #0
 8017bba:	f000 80b3 	beq.w	8017d24 <HAL_RCC_ClockConfig+0x16c>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
     must be correctly programmed according to the frequency of the CPU clock
     (HCLK) and the supply voltage of the device. */

  /* Increasing the CPU frequency */
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 8017bbe:	4a61      	ldr	r2, [pc, #388]	@ (8017d44 <HAL_RCC_ClockConfig+0x18c>)
 8017bc0:	6813      	ldr	r3, [r2, #0]
 8017bc2:	f003 030f 	and.w	r3, r3, #15
 8017bc6:	428b      	cmp	r3, r1
{
 8017bc8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8017bcc:	4604      	mov	r4, r0
 8017bce:	460d      	mov	r5, r1
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 8017bd0:	d20c      	bcs.n	8017bec <HAL_RCC_ClockConfig+0x34>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8017bd2:	6813      	ldr	r3, [r2, #0]
 8017bd4:	f023 030f 	bic.w	r3, r3, #15
 8017bd8:	430b      	orrs	r3, r1
 8017bda:	6013      	str	r3, [r2, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 8017bdc:	6813      	ldr	r3, [r2, #0]
 8017bde:	f003 030f 	and.w	r3, r3, #15
 8017be2:	428b      	cmp	r3, r1
 8017be4:	d002      	beq.n	8017bec <HAL_RCC_ClockConfig+0x34>
    return HAL_ERROR;
 8017be6:	2001      	movs	r0, #1

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick(uwTickPrio);

  return HAL_OK;
}
 8017be8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8017bec:	6823      	ldr	r3, [r4, #0]
 8017bee:	0798      	lsls	r0, r3, #30
 8017bf0:	d514      	bpl.n	8017c1c <HAL_RCC_ClockConfig+0x64>
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8017bf2:	0759      	lsls	r1, r3, #29
 8017bf4:	d504      	bpl.n	8017c00 <HAL_RCC_ClockConfig+0x48>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 8017bf6:	4954      	ldr	r1, [pc, #336]	@ (8017d48 <HAL_RCC_ClockConfig+0x190>)
 8017bf8:	688a      	ldr	r2, [r1, #8]
 8017bfa:	f442 52e0 	orr.w	r2, r2, #7168	@ 0x1c00
 8017bfe:	608a      	str	r2, [r1, #8]
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8017c00:	071a      	lsls	r2, r3, #28
 8017c02:	d504      	bpl.n	8017c0e <HAL_RCC_ClockConfig+0x56>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 8017c04:	4950      	ldr	r1, [pc, #320]	@ (8017d48 <HAL_RCC_ClockConfig+0x190>)
 8017c06:	688a      	ldr	r2, [r1, #8]
 8017c08:	f442 4260 	orr.w	r2, r2, #57344	@ 0xe000
 8017c0c:	608a      	str	r2, [r1, #8]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8017c0e:	494e      	ldr	r1, [pc, #312]	@ (8017d48 <HAL_RCC_ClockConfig+0x190>)
 8017c10:	68a0      	ldr	r0, [r4, #8]
 8017c12:	688a      	ldr	r2, [r1, #8]
 8017c14:	f022 02f0 	bic.w	r2, r2, #240	@ 0xf0
 8017c18:	4302      	orrs	r2, r0
 8017c1a:	608a      	str	r2, [r1, #8]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8017c1c:	07df      	lsls	r7, r3, #31
 8017c1e:	d520      	bpl.n	8017c62 <HAL_RCC_ClockConfig+0xaa>
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8017c20:	6862      	ldr	r2, [r4, #4]
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8017c22:	4b49      	ldr	r3, [pc, #292]	@ (8017d48 <HAL_RCC_ClockConfig+0x190>)
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8017c24:	2a01      	cmp	r2, #1
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8017c26:	681b      	ldr	r3, [r3, #0]
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8017c28:	d07e      	beq.n	8017d28 <HAL_RCC_ClockConfig+0x170>
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8017c2a:	2a02      	cmp	r2, #2
 8017c2c:	d077      	beq.n	8017d1e <HAL_RCC_ClockConfig+0x166>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8017c2e:	0799      	lsls	r1, r3, #30
 8017c30:	d5d9      	bpl.n	8017be6 <HAL_RCC_ClockConfig+0x2e>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8017c32:	4e45      	ldr	r6, [pc, #276]	@ (8017d48 <HAL_RCC_ClockConfig+0x190>)
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8017c34:	f241 3888 	movw	r8, #5000	@ 0x1388
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8017c38:	68b3      	ldr	r3, [r6, #8]
 8017c3a:	f023 0303 	bic.w	r3, r3, #3
 8017c3e:	4313      	orrs	r3, r2
 8017c40:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 8017c42:	f7fb f913 	bl	8012e6c <HAL_GetTick>
 8017c46:	4607      	mov	r7, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8017c48:	e004      	b.n	8017c54 <HAL_RCC_ClockConfig+0x9c>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8017c4a:	f7fb f90f 	bl	8012e6c <HAL_GetTick>
 8017c4e:	1bc0      	subs	r0, r0, r7
 8017c50:	4540      	cmp	r0, r8
 8017c52:	d86c      	bhi.n	8017d2e <HAL_RCC_ClockConfig+0x176>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8017c54:	68b3      	ldr	r3, [r6, #8]
 8017c56:	6862      	ldr	r2, [r4, #4]
 8017c58:	f003 030c 	and.w	r3, r3, #12
 8017c5c:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 8017c60:	d1f3      	bne.n	8017c4a <HAL_RCC_ClockConfig+0x92>
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 8017c62:	4a38      	ldr	r2, [pc, #224]	@ (8017d44 <HAL_RCC_ClockConfig+0x18c>)
 8017c64:	6813      	ldr	r3, [r2, #0]
 8017c66:	f003 030f 	and.w	r3, r3, #15
 8017c6a:	42ab      	cmp	r3, r5
 8017c6c:	d909      	bls.n	8017c82 <HAL_RCC_ClockConfig+0xca>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8017c6e:	6813      	ldr	r3, [r2, #0]
 8017c70:	f023 030f 	bic.w	r3, r3, #15
 8017c74:	432b      	orrs	r3, r5
 8017c76:	6013      	str	r3, [r2, #0]
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 8017c78:	6813      	ldr	r3, [r2, #0]
 8017c7a:	f003 030f 	and.w	r3, r3, #15
 8017c7e:	42ab      	cmp	r3, r5
 8017c80:	d1b1      	bne.n	8017be6 <HAL_RCC_ClockConfig+0x2e>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8017c82:	6823      	ldr	r3, [r4, #0]
 8017c84:	075a      	lsls	r2, r3, #29
 8017c86:	d506      	bpl.n	8017c96 <HAL_RCC_ClockConfig+0xde>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8017c88:	492f      	ldr	r1, [pc, #188]	@ (8017d48 <HAL_RCC_ClockConfig+0x190>)
 8017c8a:	68e0      	ldr	r0, [r4, #12]
 8017c8c:	688a      	ldr	r2, [r1, #8]
 8017c8e:	f422 52e0 	bic.w	r2, r2, #7168	@ 0x1c00
 8017c92:	4302      	orrs	r2, r0
 8017c94:	608a      	str	r2, [r1, #8]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8017c96:	071b      	lsls	r3, r3, #28
 8017c98:	d431      	bmi.n	8017cfe <HAL_RCC_ClockConfig+0x146>
{
  uint32_t pllm = 0, pllvco = 0, pllp = 0;
  uint32_t sysclockfreq = 0;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8017c9a:	492b      	ldr	r1, [pc, #172]	@ (8017d48 <HAL_RCC_ClockConfig+0x190>)
 8017c9c:	688b      	ldr	r3, [r1, #8]
 8017c9e:	f003 030c 	and.w	r3, r3, #12
 8017ca2:	2b04      	cmp	r3, #4
 8017ca4:	d039      	beq.n	8017d1a <HAL_RCC_ClockConfig+0x162>
 8017ca6:	2b08      	cmp	r3, #8
 8017ca8:	d118      	bne.n	8017cdc <HAL_RCC_ClockConfig+0x124>
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8017caa:	684a      	ldr	r2, [r1, #4]
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
 8017cac:	684b      	ldr	r3, [r1, #4]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8017cae:	f002 023f 	and.w	r2, r2, #63	@ 0x3f
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t)((((uint64_t) HSE_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8017cb2:	6849      	ldr	r1, [r1, #4]
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
 8017cb4:	f413 0380 	ands.w	r3, r3, #4194304	@ 0x400000
 8017cb8:	d03b      	beq.n	8017d32 <HAL_RCC_ClockConfig+0x17a>
        pllvco = (uint32_t)((((uint64_t) HSE_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8017cba:	4824      	ldr	r0, [pc, #144]	@ (8017d4c <HAL_RCC_ClockConfig+0x194>)
 8017cbc:	f3c1 1188 	ubfx	r1, r1, #6, #9
 8017cc0:	2300      	movs	r3, #0
 8017cc2:	fba1 0100 	umull	r0, r1, r1, r0
 8017cc6:	f7f8 fea7 	bl	8010a18 <__aeabi_uldivmod>
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (uint32_t)((((uint64_t) HSI_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1) * 2);
 8017cca:	4b1f      	ldr	r3, [pc, #124]	@ (8017d48 <HAL_RCC_ClockConfig+0x190>)
 8017ccc:	685b      	ldr	r3, [r3, #4]
 8017cce:	f3c3 4301 	ubfx	r3, r3, #16, #2
 8017cd2:	3301      	adds	r3, #1
 8017cd4:	005b      	lsls	r3, r3, #1

      sysclockfreq = pllvco / pllp;
 8017cd6:	fbb0 f3f3 	udiv	r3, r0, r3
    {
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
 8017cda:	e000      	b.n	8017cde <HAL_RCC_ClockConfig+0x126>
      sysclockfreq = HSI_VALUE;
 8017cdc:	4b1c      	ldr	r3, [pc, #112]	@ (8017d50 <HAL_RCC_ClockConfig+0x198>)
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 8017cde:	4a1a      	ldr	r2, [pc, #104]	@ (8017d48 <HAL_RCC_ClockConfig+0x190>)
 8017ce0:	4c1c      	ldr	r4, [pc, #112]	@ (8017d54 <HAL_RCC_ClockConfig+0x19c>)
 8017ce2:	6892      	ldr	r2, [r2, #8]
  HAL_InitTick(uwTickPrio);
 8017ce4:	481c      	ldr	r0, [pc, #112]	@ (8017d58 <HAL_RCC_ClockConfig+0x1a0>)
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 8017ce6:	f3c2 1203 	ubfx	r2, r2, #4, #4
 8017cea:	491c      	ldr	r1, [pc, #112]	@ (8017d5c <HAL_RCC_ClockConfig+0x1a4>)
  HAL_InitTick(uwTickPrio);
 8017cec:	6800      	ldr	r0, [r0, #0]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 8017cee:	5ca2      	ldrb	r2, [r4, r2]
 8017cf0:	40d3      	lsrs	r3, r2
 8017cf2:	600b      	str	r3, [r1, #0]
  HAL_InitTick(uwTickPrio);
 8017cf4:	f7fa ffc8 	bl	8012c88 <HAL_InitTick>
  return HAL_OK;
 8017cf8:	2000      	movs	r0, #0
}
 8017cfa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 8017cfe:	4a12      	ldr	r2, [pc, #72]	@ (8017d48 <HAL_RCC_ClockConfig+0x190>)
 8017d00:	6921      	ldr	r1, [r4, #16]
 8017d02:	6893      	ldr	r3, [r2, #8]
 8017d04:	f423 4360 	bic.w	r3, r3, #57344	@ 0xe000
 8017d08:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8017d0c:	490e      	ldr	r1, [pc, #56]	@ (8017d48 <HAL_RCC_ClockConfig+0x190>)
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 8017d0e:	6093      	str	r3, [r2, #8]
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8017d10:	688b      	ldr	r3, [r1, #8]
 8017d12:	f003 030c 	and.w	r3, r3, #12
 8017d16:	2b04      	cmp	r3, #4
 8017d18:	d1c5      	bne.n	8017ca6 <HAL_RCC_ClockConfig+0xee>
 8017d1a:	4b0c      	ldr	r3, [pc, #48]	@ (8017d4c <HAL_RCC_ClockConfig+0x194>)
 8017d1c:	e7df      	b.n	8017cde <HAL_RCC_ClockConfig+0x126>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8017d1e:	0198      	lsls	r0, r3, #6
 8017d20:	d487      	bmi.n	8017c32 <HAL_RCC_ClockConfig+0x7a>
 8017d22:	e760      	b.n	8017be6 <HAL_RCC_ClockConfig+0x2e>
    return HAL_ERROR;
 8017d24:	2001      	movs	r0, #1
}
 8017d26:	4770      	bx	lr
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8017d28:	039e      	lsls	r6, r3, #14
 8017d2a:	d482      	bmi.n	8017c32 <HAL_RCC_ClockConfig+0x7a>
 8017d2c:	e75b      	b.n	8017be6 <HAL_RCC_ClockConfig+0x2e>
        return HAL_TIMEOUT;
 8017d2e:	2003      	movs	r0, #3
 8017d30:	e75a      	b.n	8017be8 <HAL_RCC_ClockConfig+0x30>
        pllvco = (uint32_t)((((uint64_t) HSI_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8017d32:	4807      	ldr	r0, [pc, #28]	@ (8017d50 <HAL_RCC_ClockConfig+0x198>)
 8017d34:	f3c1 1188 	ubfx	r1, r1, #6, #9
 8017d38:	fba1 0100 	umull	r0, r1, r1, r0
 8017d3c:	f7f8 fe6c 	bl	8010a18 <__aeabi_uldivmod>
 8017d40:	e7c3      	b.n	8017cca <HAL_RCC_ClockConfig+0x112>
 8017d42:	bf00      	nop
 8017d44:	40023c00 	.word	0x40023c00
 8017d48:	40023800 	.word	0x40023800
 8017d4c:	017d7840 	.word	0x017d7840
 8017d50:	00f42400 	.word	0x00f42400
 8017d54:	08034c18 	.word	0x08034c18
 8017d58:	20000014 	.word	0x20000014
 8017d5c:	2000000c 	.word	0x2000000c

08017d60 <HAL_RCC_GetSysClockFreq>:
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8017d60:	4916      	ldr	r1, [pc, #88]	@ (8017dbc <HAL_RCC_GetSysClockFreq+0x5c>)
{
 8017d62:	b508      	push	{r3, lr}
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8017d64:	688b      	ldr	r3, [r1, #8]
 8017d66:	f003 030c 	and.w	r3, r3, #12
 8017d6a:	2b04      	cmp	r3, #4
 8017d6c:	d01b      	beq.n	8017da6 <HAL_RCC_GetSysClockFreq+0x46>
 8017d6e:	2b08      	cmp	r3, #8
 8017d70:	d117      	bne.n	8017da2 <HAL_RCC_GetSysClockFreq+0x42>
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8017d72:	684a      	ldr	r2, [r1, #4]
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
 8017d74:	684b      	ldr	r3, [r1, #4]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8017d76:	f002 023f 	and.w	r2, r2, #63	@ 0x3f
        pllvco = (uint32_t)((((uint64_t) HSE_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8017d7a:	6849      	ldr	r1, [r1, #4]
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
 8017d7c:	f413 0380 	ands.w	r3, r3, #4194304	@ 0x400000
 8017d80:	d113      	bne.n	8017daa <HAL_RCC_GetSysClockFreq+0x4a>
        pllvco = (uint32_t)((((uint64_t) HSI_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8017d82:	480f      	ldr	r0, [pc, #60]	@ (8017dc0 <HAL_RCC_GetSysClockFreq+0x60>)
 8017d84:	f3c1 1188 	ubfx	r1, r1, #6, #9
 8017d88:	fba1 0100 	umull	r0, r1, r1, r0
 8017d8c:	f7f8 fe44 	bl	8010a18 <__aeabi_uldivmod>
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1) * 2);
 8017d90:	4b0a      	ldr	r3, [pc, #40]	@ (8017dbc <HAL_RCC_GetSysClockFreq+0x5c>)
 8017d92:	685b      	ldr	r3, [r3, #4]
 8017d94:	f3c3 4301 	ubfx	r3, r3, #16, #2
 8017d98:	3301      	adds	r3, #1
 8017d9a:	005b      	lsls	r3, r3, #1
      sysclockfreq = pllvco / pllp;
 8017d9c:	fbb0 f0f3 	udiv	r0, r0, r3
}
 8017da0:	bd08      	pop	{r3, pc}
      sysclockfreq = HSI_VALUE;
 8017da2:	4807      	ldr	r0, [pc, #28]	@ (8017dc0 <HAL_RCC_GetSysClockFreq+0x60>)
}
 8017da4:	bd08      	pop	{r3, pc}
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8017da6:	4807      	ldr	r0, [pc, #28]	@ (8017dc4 <HAL_RCC_GetSysClockFreq+0x64>)
}
 8017da8:	bd08      	pop	{r3, pc}
        pllvco = (uint32_t)((((uint64_t) HSE_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8017daa:	4806      	ldr	r0, [pc, #24]	@ (8017dc4 <HAL_RCC_GetSysClockFreq+0x64>)
 8017dac:	f3c1 1188 	ubfx	r1, r1, #6, #9
 8017db0:	2300      	movs	r3, #0
 8017db2:	fba1 0100 	umull	r0, r1, r1, r0
 8017db6:	f7f8 fe2f 	bl	8010a18 <__aeabi_uldivmod>
 8017dba:	e7e9      	b.n	8017d90 <HAL_RCC_GetSysClockFreq+0x30>
 8017dbc:	40023800 	.word	0x40023800
 8017dc0:	00f42400 	.word	0x00f42400
 8017dc4:	017d7840 	.word	0x017d7840

08017dc8 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency.
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
  return SystemCoreClock;
 8017dc8:	4b01      	ldr	r3, [pc, #4]	@ (8017dd0 <HAL_RCC_GetHCLKFreq+0x8>)
}
 8017dca:	6818      	ldr	r0, [r3, #0]
 8017dcc:	4770      	bx	lr
 8017dce:	bf00      	nop
 8017dd0:	2000000c 	.word	0x2000000c

08017dd4 <HAL_RCC_GetPCLK1Freq>:
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos]);
 8017dd4:	4b04      	ldr	r3, [pc, #16]	@ (8017de8 <HAL_RCC_GetPCLK1Freq+0x14>)
  return SystemCoreClock;
 8017dd6:	4905      	ldr	r1, [pc, #20]	@ (8017dec <HAL_RCC_GetPCLK1Freq+0x18>)
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos]);
 8017dd8:	689b      	ldr	r3, [r3, #8]
 8017dda:	4a05      	ldr	r2, [pc, #20]	@ (8017df0 <HAL_RCC_GetPCLK1Freq+0x1c>)
 8017ddc:	f3c3 2382 	ubfx	r3, r3, #10, #3
 8017de0:	6808      	ldr	r0, [r1, #0]
 8017de2:	5cd3      	ldrb	r3, [r2, r3]
}
 8017de4:	40d8      	lsrs	r0, r3
 8017de6:	4770      	bx	lr
 8017de8:	40023800 	.word	0x40023800
 8017dec:	2000000c 	.word	0x2000000c
 8017df0:	08034c10 	.word	0x08034c10

08017df4 <HAL_RCC_GetPCLK2Freq>:
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);
 8017df4:	4b04      	ldr	r3, [pc, #16]	@ (8017e08 <HAL_RCC_GetPCLK2Freq+0x14>)
  return SystemCoreClock;
 8017df6:	4905      	ldr	r1, [pc, #20]	@ (8017e0c <HAL_RCC_GetPCLK2Freq+0x18>)
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);
 8017df8:	689b      	ldr	r3, [r3, #8]
 8017dfa:	4a05      	ldr	r2, [pc, #20]	@ (8017e10 <HAL_RCC_GetPCLK2Freq+0x1c>)
 8017dfc:	f3c3 3342 	ubfx	r3, r3, #13, #3
 8017e00:	6808      	ldr	r0, [r1, #0]
 8017e02:	5cd3      	ldrb	r3, [r2, r3]
}
 8017e04:	40d8      	lsrs	r0, r3
 8017e06:	4770      	bx	lr
 8017e08:	40023800 	.word	0x40023800
 8017e0c:	2000000c 	.word	0x2000000c
 8017e10:	08034c10 	.word	0x08034c10

08017e14 <HAL_RCC_GetClockConfig>:
{
  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;

  /* Get the SYSCLK configuration --------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 8017e14:	4b0e      	ldr	r3, [pc, #56]	@ (8017e50 <HAL_RCC_GetClockConfig+0x3c>)
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
 8017e16:	220f      	movs	r2, #15
 8017e18:	6002      	str	r2, [r0, #0]
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 8017e1a:	689a      	ldr	r2, [r3, #8]
 8017e1c:	f002 0203 	and.w	r2, r2, #3
 8017e20:	6042      	str	r2, [r0, #4]

  /* Get the HCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE);
 8017e22:	689a      	ldr	r2, [r3, #8]
 8017e24:	f002 02f0 	and.w	r2, r2, #240	@ 0xf0
 8017e28:	6082      	str	r2, [r0, #8]

  /* Get the APB1 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);
 8017e2a:	689a      	ldr	r2, [r3, #8]
 8017e2c:	f402 52e0 	and.w	r2, r2, #7168	@ 0x1c00
 8017e30:	60c2      	str	r2, [r0, #12]

  /* Get the APB2 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);
 8017e32:	689b      	ldr	r3, [r3, #8]
 8017e34:	08db      	lsrs	r3, r3, #3
{
 8017e36:	b410      	push	{r4}
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);
 8017e38:	f403 53e0 	and.w	r3, r3, #7168	@ 0x1c00

  /* Get the Flash Wait State (Latency) configuration ------------------------*/
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 8017e3c:	4c05      	ldr	r4, [pc, #20]	@ (8017e54 <HAL_RCC_GetClockConfig+0x40>)
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);
 8017e3e:	6103      	str	r3, [r0, #16]
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 8017e40:	6823      	ldr	r3, [r4, #0]
}
 8017e42:	f85d 4b04 	ldr.w	r4, [sp], #4
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 8017e46:	f003 030f 	and.w	r3, r3, #15
 8017e4a:	600b      	str	r3, [r1, #0]
}
 8017e4c:	4770      	bx	lr
 8017e4e:	bf00      	nop
 8017e50:	40023800 	.word	0x40023800
 8017e54:	40023c00 	.word	0x40023c00

08017e58 <HAL_RCCEx_PeriphCLKConfig>:

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*----------------------------------- I2S configuration ----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
 8017e58:	6803      	ldr	r3, [r0, #0]
{
 8017e5a:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
 8017e5e:	f013 0601 	ands.w	r6, r3, #1
{
 8017e62:	b083      	sub	sp, #12
 8017e64:	4604      	mov	r4, r0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
 8017e66:	d00b      	beq.n	8017e80 <HAL_RCCEx_PeriphCLKConfig+0x28>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2SCLKSOURCE(PeriphClkInit->I2sClockSelection));

    /* Configure I2S Clock source */
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
 8017e68:	4aa8      	ldr	r2, [pc, #672]	@ (801810c <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 8017e6a:	6891      	ldr	r1, [r2, #8]
 8017e6c:	f421 0100 	bic.w	r1, r1, #8388608	@ 0x800000
 8017e70:	6091      	str	r1, [r2, #8]
 8017e72:	6b46      	ldr	r6, [r0, #52]	@ 0x34
 8017e74:	6891      	ldr	r1, [r2, #8]
 8017e76:	4331      	orrs	r1, r6

    /* Enable the PLLI2S when it's used as clock source for I2S */
    if(PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)
 8017e78:	fab6 f686 	clz	r6, r6
 8017e7c:	0976      	lsrs	r6, r6, #5
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
 8017e7e:	6091      	str	r1, [r2, #8]
      plli2sused = 1;
    }
  }

  /*------------------------------------ SAI1 configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == (RCC_PERIPHCLK_SAI1))
 8017e80:	f413 2500 	ands.w	r5, r3, #524288	@ 0x80000
 8017e84:	d010      	beq.n	8017ea8 <HAL_RCCEx_PeriphCLKConfig+0x50>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));

    /* Configure SAI1 Clock source */
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8017e86:	49a1      	ldr	r1, [pc, #644]	@ (801810c <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 8017e88:	6be5      	ldr	r5, [r4, #60]	@ 0x3c
 8017e8a:	f8d1 208c 	ldr.w	r2, [r1, #140]	@ 0x8c
    /* Enable the PLLI2S when it's used as clock source for SAI */
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)
 8017e8e:	f5b5 1f80 	cmp.w	r5, #1048576	@ 0x100000
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8017e92:	f422 1240 	bic.w	r2, r2, #3145728	@ 0x300000
 8017e96:	ea42 0205 	orr.w	r2, r2, r5
 8017e9a:	f8c1 208c 	str.w	r2, [r1, #140]	@ 0x8c
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)
 8017e9e:	f000 8214 	beq.w	80182ca <HAL_RCCEx_PeriphCLKConfig+0x472>
    {
      plli2sused = 1;
    }
    /* Enable the PLLSAI when it's used as clock source for SAI */
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)
 8017ea2:	fab5 f585 	clz	r5, r5
 8017ea6:	096d      	lsrs	r5, r5, #5
      pllsaiused = 1;
    }
  }

  /*------------------------------------ SAI2 configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == (RCC_PERIPHCLK_SAI2))
 8017ea8:	02df      	lsls	r7, r3, #11
 8017eaa:	d510      	bpl.n	8017ece <HAL_RCCEx_PeriphCLKConfig+0x76>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLKSOURCE(PeriphClkInit->Sai2ClockSelection));

    /* Configure SAI2 Clock source */
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
 8017eac:	4897      	ldr	r0, [pc, #604]	@ (801810c <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 8017eae:	6c21      	ldr	r1, [r4, #64]	@ 0x40
 8017eb0:	f8d0 208c 	ldr.w	r2, [r0, #140]	@ 0x8c

    /* Enable the PLLI2S when it's used as clock source for SAI */
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)
 8017eb4:	f5b1 0f80 	cmp.w	r1, #4194304	@ 0x400000
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
 8017eb8:	f422 0240 	bic.w	r2, r2, #12582912	@ 0xc00000
 8017ebc:	ea42 0201 	orr.w	r2, r2, r1
 8017ec0:	f8c0 208c 	str.w	r2, [r0, #140]	@ 0x8c
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)
 8017ec4:	f000 8204 	beq.w	80182d0 <HAL_RCCEx_PeriphCLKConfig+0x478>
      plli2sused = 1;
    }
    /* Enable the PLLSAI when it's used as clock source for SAI */
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)
    {
      pllsaiused = 1;
 8017ec8:	2900      	cmp	r1, #0
 8017eca:	bf08      	it	eq
 8017ecc:	2501      	moveq	r5, #1
  }

  /*-------------------------------------- SPDIF-RX Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
  {
      plli2sused = 1;
 8017ece:	f013 7f80 	tst.w	r3, #16777216	@ 0x1000000
 8017ed2:	bf18      	it	ne
 8017ed4:	2601      	movne	r6, #1
  }

  /*------------------------------------ RTC configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 8017ed6:	0698      	lsls	r0, r3, #26
 8017ed8:	f100 81b2 	bmi.w	8018240 <HAL_RCCEx_PeriphCLKConfig+0x3e8>
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
  }

  /*------------------------------------ TIM configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))
 8017edc:	06d9      	lsls	r1, r3, #27
 8017ede:	d50c      	bpl.n	8017efa <HAL_RCCEx_PeriphCLKConfig+0xa2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));

    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
 8017ee0:	4a8a      	ldr	r2, [pc, #552]	@ (801810c <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 8017ee2:	f8d2 108c 	ldr.w	r1, [r2, #140]	@ 0x8c
 8017ee6:	f021 7180 	bic.w	r1, r1, #16777216	@ 0x1000000
 8017eea:	f8c2 108c 	str.w	r1, [r2, #140]	@ 0x8c
 8017eee:	f8d2 108c 	ldr.w	r1, [r2, #140]	@ 0x8c
 8017ef2:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
 8017ef4:	4301      	orrs	r1, r0
 8017ef6:	f8c2 108c 	str.w	r1, [r2, #140]	@ 0x8c
  }

  /*-------------------------------------- I2C1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 8017efa:	045a      	lsls	r2, r3, #17
 8017efc:	d508      	bpl.n	8017f10 <HAL_RCCEx_PeriphCLKConfig+0xb8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 8017efe:	4983      	ldr	r1, [pc, #524]	@ (801810c <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 8017f00:	6e60      	ldr	r0, [r4, #100]	@ 0x64
 8017f02:	f8d1 2090 	ldr.w	r2, [r1, #144]	@ 0x90
 8017f06:	f422 3240 	bic.w	r2, r2, #196608	@ 0x30000
 8017f0a:	4302      	orrs	r2, r0
 8017f0c:	f8c1 2090 	str.w	r2, [r1, #144]	@ 0x90
  }

  /*-------------------------------------- I2C2 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 8017f10:	041f      	lsls	r7, r3, #16
 8017f12:	d508      	bpl.n	8017f26 <HAL_RCCEx_PeriphCLKConfig+0xce>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));

    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 8017f14:	497d      	ldr	r1, [pc, #500]	@ (801810c <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 8017f16:	6ea0      	ldr	r0, [r4, #104]	@ 0x68
 8017f18:	f8d1 2090 	ldr.w	r2, [r1, #144]	@ 0x90
 8017f1c:	f422 2240 	bic.w	r2, r2, #786432	@ 0xc0000
 8017f20:	4302      	orrs	r2, r0
 8017f22:	f8c1 2090 	str.w	r2, [r1, #144]	@ 0x90
  }

  /*-------------------------------------- I2C3 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 8017f26:	03d8      	lsls	r0, r3, #15
 8017f28:	d508      	bpl.n	8017f3c <HAL_RCCEx_PeriphCLKConfig+0xe4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 8017f2a:	4978      	ldr	r1, [pc, #480]	@ (801810c <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 8017f2c:	6ee0      	ldr	r0, [r4, #108]	@ 0x6c
 8017f2e:	f8d1 2090 	ldr.w	r2, [r1, #144]	@ 0x90
 8017f32:	f422 1240 	bic.w	r2, r2, #3145728	@ 0x300000
 8017f36:	4302      	orrs	r2, r0
 8017f38:	f8c1 2090 	str.w	r2, [r1, #144]	@ 0x90
  }

  /*-------------------------------------- I2C4 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 8017f3c:	0399      	lsls	r1, r3, #14
 8017f3e:	d508      	bpl.n	8017f52 <HAL_RCCEx_PeriphCLKConfig+0xfa>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));

    /* Configure the I2C4 clock source */
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
 8017f40:	4972      	ldr	r1, [pc, #456]	@ (801810c <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 8017f42:	6f20      	ldr	r0, [r4, #112]	@ 0x70
 8017f44:	f8d1 2090 	ldr.w	r2, [r1, #144]	@ 0x90
 8017f48:	f422 0240 	bic.w	r2, r2, #12582912	@ 0xc00000
 8017f4c:	4302      	orrs	r2, r0
 8017f4e:	f8c1 2090 	str.w	r2, [r1, #144]	@ 0x90
  }

  /*-------------------------------------- USART1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8017f52:	065a      	lsls	r2, r3, #25
 8017f54:	d508      	bpl.n	8017f68 <HAL_RCCEx_PeriphCLKConfig+0x110>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 8017f56:	496d      	ldr	r1, [pc, #436]	@ (801810c <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 8017f58:	6c60      	ldr	r0, [r4, #68]	@ 0x44
 8017f5a:	f8d1 2090 	ldr.w	r2, [r1, #144]	@ 0x90
 8017f5e:	f022 0203 	bic.w	r2, r2, #3
 8017f62:	4302      	orrs	r2, r0
 8017f64:	f8c1 2090 	str.w	r2, [r1, #144]	@ 0x90
  }

  /*-------------------------------------- USART2 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 8017f68:	061f      	lsls	r7, r3, #24
 8017f6a:	d508      	bpl.n	8017f7e <HAL_RCCEx_PeriphCLKConfig+0x126>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 8017f6c:	4967      	ldr	r1, [pc, #412]	@ (801810c <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 8017f6e:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
 8017f70:	f8d1 2090 	ldr.w	r2, [r1, #144]	@ 0x90
 8017f74:	f022 020c 	bic.w	r2, r2, #12
 8017f78:	4302      	orrs	r2, r0
 8017f7a:	f8c1 2090 	str.w	r2, [r1, #144]	@ 0x90
  }

  /*-------------------------------------- USART3 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 8017f7e:	05d8      	lsls	r0, r3, #23
 8017f80:	d508      	bpl.n	8017f94 <HAL_RCCEx_PeriphCLKConfig+0x13c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));

    /* Configure the USART3 clock source */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
 8017f82:	4962      	ldr	r1, [pc, #392]	@ (801810c <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 8017f84:	6ce0      	ldr	r0, [r4, #76]	@ 0x4c
 8017f86:	f8d1 2090 	ldr.w	r2, [r1, #144]	@ 0x90
 8017f8a:	f022 0230 	bic.w	r2, r2, #48	@ 0x30
 8017f8e:	4302      	orrs	r2, r0
 8017f90:	f8c1 2090 	str.w	r2, [r1, #144]	@ 0x90
  }

  /*-------------------------------------- UART4 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 8017f94:	0599      	lsls	r1, r3, #22
 8017f96:	d508      	bpl.n	8017faa <HAL_RCCEx_PeriphCLKConfig+0x152>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));

    /* Configure the UART4 clock source */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
 8017f98:	495c      	ldr	r1, [pc, #368]	@ (801810c <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 8017f9a:	6d20      	ldr	r0, [r4, #80]	@ 0x50
 8017f9c:	f8d1 2090 	ldr.w	r2, [r1, #144]	@ 0x90
 8017fa0:	f022 02c0 	bic.w	r2, r2, #192	@ 0xc0
 8017fa4:	4302      	orrs	r2, r0
 8017fa6:	f8c1 2090 	str.w	r2, [r1, #144]	@ 0x90
  }

  /*-------------------------------------- UART5 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
 8017faa:	055a      	lsls	r2, r3, #21
 8017fac:	d508      	bpl.n	8017fc0 <HAL_RCCEx_PeriphCLKConfig+0x168>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));

    /* Configure the UART5 clock source */
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
 8017fae:	4957      	ldr	r1, [pc, #348]	@ (801810c <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 8017fb0:	6d60      	ldr	r0, [r4, #84]	@ 0x54
 8017fb2:	f8d1 2090 	ldr.w	r2, [r1, #144]	@ 0x90
 8017fb6:	f422 7240 	bic.w	r2, r2, #768	@ 0x300
 8017fba:	4302      	orrs	r2, r0
 8017fbc:	f8c1 2090 	str.w	r2, [r1, #144]	@ 0x90
  }

  /*-------------------------------------- USART6 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART6) == RCC_PERIPHCLK_USART6)
 8017fc0:	051f      	lsls	r7, r3, #20
 8017fc2:	d508      	bpl.n	8017fd6 <HAL_RCCEx_PeriphCLKConfig+0x17e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART6CLKSOURCE(PeriphClkInit->Usart6ClockSelection));

    /* Configure the USART6 clock source */
    __HAL_RCC_USART6_CONFIG(PeriphClkInit->Usart6ClockSelection);
 8017fc4:	4951      	ldr	r1, [pc, #324]	@ (801810c <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 8017fc6:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 8017fc8:	f8d1 2090 	ldr.w	r2, [r1, #144]	@ 0x90
 8017fcc:	f422 6240 	bic.w	r2, r2, #3072	@ 0xc00
 8017fd0:	4302      	orrs	r2, r0
 8017fd2:	f8c1 2090 	str.w	r2, [r1, #144]	@ 0x90
  }

  /*-------------------------------------- UART7 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART7) == RCC_PERIPHCLK_UART7)
 8017fd6:	04d8      	lsls	r0, r3, #19
 8017fd8:	d508      	bpl.n	8017fec <HAL_RCCEx_PeriphCLKConfig+0x194>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART7CLKSOURCE(PeriphClkInit->Uart7ClockSelection));

    /* Configure the UART7 clock source */
    __HAL_RCC_UART7_CONFIG(PeriphClkInit->Uart7ClockSelection);
 8017fda:	494c      	ldr	r1, [pc, #304]	@ (801810c <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 8017fdc:	6de0      	ldr	r0, [r4, #92]	@ 0x5c
 8017fde:	f8d1 2090 	ldr.w	r2, [r1, #144]	@ 0x90
 8017fe2:	f422 5240 	bic.w	r2, r2, #12288	@ 0x3000
 8017fe6:	4302      	orrs	r2, r0
 8017fe8:	f8c1 2090 	str.w	r2, [r1, #144]	@ 0x90
  }

  /*-------------------------------------- UART8 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART8) == RCC_PERIPHCLK_UART8)
 8017fec:	0499      	lsls	r1, r3, #18
 8017fee:	d508      	bpl.n	8018002 <HAL_RCCEx_PeriphCLKConfig+0x1aa>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART8CLKSOURCE(PeriphClkInit->Uart8ClockSelection));

    /* Configure the UART8 clock source */
    __HAL_RCC_UART8_CONFIG(PeriphClkInit->Uart8ClockSelection);
 8017ff0:	4946      	ldr	r1, [pc, #280]	@ (801810c <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 8017ff2:	6e20      	ldr	r0, [r4, #96]	@ 0x60
 8017ff4:	f8d1 2090 	ldr.w	r2, [r1, #144]	@ 0x90
 8017ff8:	f422 4240 	bic.w	r2, r2, #49152	@ 0xc000
 8017ffc:	4302      	orrs	r2, r0
 8017ffe:	f8c1 2090 	str.w	r2, [r1, #144]	@ 0x90
  }

  /*--------------------------------------- CEC Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
 8018002:	025a      	lsls	r2, r3, #9
 8018004:	d508      	bpl.n	8018018 <HAL_RCCEx_PeriphCLKConfig+0x1c0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));

    /* Configure the CEC clock source */
    __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
 8018006:	4941      	ldr	r1, [pc, #260]	@ (801810c <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 8018008:	6fa0      	ldr	r0, [r4, #120]	@ 0x78
 801800a:	f8d1 2090 	ldr.w	r2, [r1, #144]	@ 0x90
 801800e:	f022 6280 	bic.w	r2, r2, #67108864	@ 0x4000000
 8018012:	4302      	orrs	r2, r0
 8018014:	f8c1 2090 	str.w	r2, [r1, #144]	@ 0x90
  }

  /*-------------------------------------- CK48 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48)
 8018018:	029f      	lsls	r7, r3, #10
 801801a:	d50c      	bpl.n	8018036 <HAL_RCCEx_PeriphCLKConfig+0x1de>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CLK48SOURCE(PeriphClkInit->Clk48ClockSelection));

    /* Configure the CLK48 source */
    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
 801801c:	493b      	ldr	r1, [pc, #236]	@ (801810c <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 801801e:	6fe0      	ldr	r0, [r4, #124]	@ 0x7c
 8018020:	f8d1 2090 	ldr.w	r2, [r1, #144]	@ 0x90

    /* Enable the PLLSAI when it's used as clock source for CK48 */
    if(PeriphClkInit->Clk48ClockSelection == RCC_CLK48SOURCE_PLLSAIP)
    {
      pllsaiused = 1;
 8018024:	f1b0 6f00 	cmp.w	r0, #134217728	@ 0x8000000
    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
 8018028:	f022 6200 	bic.w	r2, r2, #134217728	@ 0x8000000
      pllsaiused = 1;
 801802c:	bf08      	it	eq
 801802e:	2501      	moveq	r5, #1
    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
 8018030:	4302      	orrs	r2, r0
 8018032:	f8c1 2090 	str.w	r2, [r1, #144]	@ 0x90

  /*-------------------------------------- LTDC Configuration -----------------------------------*/
#if defined(STM32F746xx) || defined(STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx) || defined (STM32F750xx)
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
  {
    pllsaiused = 1;
 8018036:	f013 0f08 	tst.w	r3, #8
 801803a:	bf18      	it	ne
 801803c:	2501      	movne	r5, #1
  }
#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx || STM32F750xx */

  /*-------------------------------------- LPTIM1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
 801803e:	0358      	lsls	r0, r3, #13
 8018040:	d508      	bpl.n	8018054 <HAL_RCCEx_PeriphCLKConfig+0x1fc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLK(PeriphClkInit->Lptim1ClockSelection));

    /* Configure the LTPIM1 clock source */
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 8018042:	4932      	ldr	r1, [pc, #200]	@ (801810c <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 8018044:	6f60      	ldr	r0, [r4, #116]	@ 0x74
 8018046:	f8d1 2090 	ldr.w	r2, [r1, #144]	@ 0x90
 801804a:	f022 7240 	bic.w	r2, r2, #50331648	@ 0x3000000
 801804e:	4302      	orrs	r2, r0
 8018050:	f8c1 2090 	str.w	r2, [r1, #144]	@ 0x90
   }

  /*------------------------------------- SDMMC1 Configuration ------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == RCC_PERIPHCLK_SDMMC1)
 8018054:	0219      	lsls	r1, r3, #8
 8018056:	d46a      	bmi.n	801812e <HAL_RCCEx_PeriphCLKConfig+0x2d6>
  }
#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */

  /*-------------------------------------- PLLI2S Configuration ---------------------------------*/
  /* PLLI2S is configured when a peripheral will use it as source clock : SAI1, SAI2, I2S or SPDIF-RX */
  if((plli2sused == 1) || ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S))
 8018058:	2e01      	cmp	r6, #1
 801805a:	d001      	beq.n	8018060 <HAL_RCCEx_PeriphCLKConfig+0x208>
 801805c:	019a      	lsls	r2, r3, #6
 801805e:	d560      	bpl.n	8018122 <HAL_RCCEx_PeriphCLKConfig+0x2ca>
  {
    /* Disable the PLLI2S */
    __HAL_RCC_PLLI2S_DISABLE();
 8018060:	4e2a      	ldr	r6, [pc, #168]	@ (801810c <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 8018062:	6833      	ldr	r3, [r6, #0]
 8018064:	f023 6380 	bic.w	r3, r3, #67108864	@ 0x4000000
 8018068:	6033      	str	r3, [r6, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 801806a:	f7fa feff 	bl	8012e6c <HAL_GetTick>
 801806e:	4607      	mov	r7, r0

    /* Wait till PLLI2S is disabled */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 8018070:	e005      	b.n	801807e <HAL_RCCEx_PeriphCLKConfig+0x226>
    {
      if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
 8018072:	f7fa fefb 	bl	8012e6c <HAL_GetTick>
 8018076:	1bc3      	subs	r3, r0, r7
 8018078:	2b64      	cmp	r3, #100	@ 0x64
 801807a:	f200 80dd 	bhi.w	8018238 <HAL_RCCEx_PeriphCLKConfig+0x3e0>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 801807e:	6833      	ldr	r3, [r6, #0]
 8018080:	011b      	lsls	r3, r3, #4
 8018082:	d4f6      	bmi.n	8018072 <HAL_RCCEx_PeriphCLKConfig+0x21a>

    /* check for common PLLI2S Parameters */
    assert_param(IS_RCC_PLLI2SN_VALUE(PeriphClkInit->PLLI2S.PLLI2SN));

    /*----------------- In Case of PLLI2S is selected as source clock for I2S -------------------*/
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) && (PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)))
 8018084:	6823      	ldr	r3, [r4, #0]
 8018086:	07df      	lsls	r7, r3, #31
 8018088:	d512      	bpl.n	80180b0 <HAL_RCCEx_PeriphCLKConfig+0x258>
 801808a:	6b62      	ldr	r2, [r4, #52]	@ 0x34
 801808c:	b982      	cbnz	r2, 80180b0 <HAL_RCCEx_PeriphCLKConfig+0x258>
    {
      /* check for Parameters */
      assert_param(IS_RCC_PLLI2SR_VALUE(PeriphClkInit->PLLI2S.PLLI2SR));

      /* Read PLLI2SP and PLLI2SQ value from PLLI2SCFGR register (this value is not needed for I2S configuration) */
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);
 801808e:	f8d6 2084 	ldr.w	r2, [r6, #132]	@ 0x84
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
 8018092:	f8d6 1084 	ldr.w	r1, [r6, #132]	@ 0x84
      /* Configure the PLLI2S division factors */
      /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) x (PLLI2SN/PLLM) */
      /* I2SCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SR */
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , tmpreg0, tmpreg1, PeriphClkInit->PLLI2S.PLLI2SR);
 8018096:	f402 3240 	and.w	r2, r2, #196608	@ 0x30000
 801809a:	f001 6170 	and.w	r1, r1, #251658240	@ 0xf000000
 801809e:	430a      	orrs	r2, r1
 80180a0:	6861      	ldr	r1, [r4, #4]
 80180a2:	ea42 1281 	orr.w	r2, r2, r1, lsl #6
 80180a6:	68a1      	ldr	r1, [r4, #8]
 80180a8:	ea42 7201 	orr.w	r2, r2, r1, lsl #28
 80180ac:	f8c6 2084 	str.w	r2, [r6, #132]	@ 0x84
    }

    /*----------------- In Case of PLLI2S is selected as source clock for SAI -------------------*/
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)) ||
 80180b0:	031e      	lsls	r6, r3, #12
 80180b2:	d504      	bpl.n	80180be <HAL_RCCEx_PeriphCLKConfig+0x266>
 80180b4:	6be2      	ldr	r2, [r4, #60]	@ 0x3c
 80180b6:	f5b2 1f80 	cmp.w	r2, #1048576	@ 0x100000
 80180ba:	f000 811a 	beq.w	80182f2 <HAL_RCCEx_PeriphCLKConfig+0x49a>
 80180be:	02d8      	lsls	r0, r3, #11
 80180c0:	d504      	bpl.n	80180cc <HAL_RCCEx_PeriphCLKConfig+0x274>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)))
 80180c2:	6c22      	ldr	r2, [r4, #64]	@ 0x40
 80180c4:	f5b2 0f80 	cmp.w	r2, #4194304	@ 0x400000
 80180c8:	f000 8113 	beq.w	80182f2 <HAL_RCCEx_PeriphCLKConfig+0x49a>
      /* SAI_CLK_x = SAI_CLK(first level)/PLLI2SDIVQ */
      __HAL_RCC_PLLI2S_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLI2SDivQ);
    }

    /*----------------- In Case of PLLI2S is selected as source clock for SPDIF-RX -------------------*/
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
 80180cc:	01d9      	lsls	r1, r3, #7
 80180ce:	d511      	bpl.n	80180f4 <HAL_RCCEx_PeriphCLKConfig+0x29c>
    {
      /* check for Parameters */
      assert_param(IS_RCC_PLLI2SP_VALUE(PeriphClkInit->PLLI2S.PLLI2SP));

     /* Read PLLI2SR value from PLLI2SCFGR register (this value is not needed for SPDIF-RX configuration) */
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
 80180d0:	490e      	ldr	r1, [pc, #56]	@ (801810c <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 80180d2:	f8d1 2084 	ldr.w	r2, [r1, #132]	@ 0x84
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
 80180d6:	f8d1 0084 	ldr.w	r0, [r1, #132]	@ 0x84
      /* Configure the PLLI2S division factors */
      /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) x (PLLI2SN/PLLM) */
      /* SPDIFCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SP */
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, tmpreg0, tmpreg1);
 80180da:	f002 6270 	and.w	r2, r2, #251658240	@ 0xf000000
 80180de:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
 80180e2:	4302      	orrs	r2, r0
 80180e4:	6860      	ldr	r0, [r4, #4]
 80180e6:	ea42 1280 	orr.w	r2, r2, r0, lsl #6
 80180ea:	6920      	ldr	r0, [r4, #16]
 80180ec:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 80180f0:	f8c1 2084 	str.w	r2, [r1, #132]	@ 0x84
    }

    /*----------------- In Case of PLLI2S is just selected  -----------------*/
    if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S)
 80180f4:	019a      	lsls	r2, r3, #6
 80180f6:	f100 80ed 	bmi.w	80182d4 <HAL_RCCEx_PeriphCLKConfig+0x47c>
      /* SPDIFRXCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SP */
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, PeriphClkInit->PLLI2S.PLLI2SQ, PeriphClkInit->PLLI2S.PLLI2SR);
    }

    /* Enable the PLLI2S */
    __HAL_RCC_PLLI2S_ENABLE();
 80180fa:	4e04      	ldr	r6, [pc, #16]	@ (801810c <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 80180fc:	6833      	ldr	r3, [r6, #0]
 80180fe:	f043 6380 	orr.w	r3, r3, #67108864	@ 0x4000000
 8018102:	6033      	str	r3, [r6, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8018104:	f7fa feb2 	bl	8012e6c <HAL_GetTick>
 8018108:	4607      	mov	r7, r0

    /* Wait till PLLI2S is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 801810a:	e007      	b.n	801811c <HAL_RCCEx_PeriphCLKConfig+0x2c4>
 801810c:	40023800 	.word	0x40023800
    {
      if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
 8018110:	f7fa feac 	bl	8012e6c <HAL_GetTick>
 8018114:	1bc0      	subs	r0, r0, r7
 8018116:	2864      	cmp	r0, #100	@ 0x64
 8018118:	f200 808e 	bhi.w	8018238 <HAL_RCCEx_PeriphCLKConfig+0x3e0>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 801811c:	6833      	ldr	r3, [r6, #0]
 801811e:	011b      	lsls	r3, r3, #4
 8018120:	d5f6      	bpl.n	8018110 <HAL_RCCEx_PeriphCLKConfig+0x2b8>
    }
  }

  /*-------------------------------------- PLLSAI Configuration ---------------------------------*/
  /* PLLSAI is configured when a peripheral will use it as source clock : SAI1, SAI2, LTDC or CK48 */
  if(pllsaiused == 1)
 8018122:	2d01      	cmp	r5, #1
 8018124:	d00e      	beq.n	8018144 <HAL_RCCEx_PeriphCLKConfig+0x2ec>
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
      }
    }
  }
  return HAL_OK;
 8018126:	2000      	movs	r0, #0
}
 8018128:	b003      	add	sp, #12
 801812a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 801812e:	4991      	ldr	r1, [pc, #580]	@ (8018374 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 8018130:	f8d4 0080 	ldr.w	r0, [r4, #128]	@ 0x80
 8018134:	f8d1 2090 	ldr.w	r2, [r1, #144]	@ 0x90
 8018138:	f022 5280 	bic.w	r2, r2, #268435456	@ 0x10000000
 801813c:	4302      	orrs	r2, r0
 801813e:	f8c1 2090 	str.w	r2, [r1, #144]	@ 0x90
 8018142:	e789      	b.n	8018058 <HAL_RCCEx_PeriphCLKConfig+0x200>
    __HAL_RCC_PLLSAI_DISABLE();
 8018144:	4d8b      	ldr	r5, [pc, #556]	@ (8018374 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 8018146:	682b      	ldr	r3, [r5, #0]
 8018148:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
 801814c:	602b      	str	r3, [r5, #0]
    tickstart = HAL_GetTick();
 801814e:	f7fa fe8d 	bl	8012e6c <HAL_GetTick>
 8018152:	4606      	mov	r6, r0
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
 8018154:	e004      	b.n	8018160 <HAL_RCCEx_PeriphCLKConfig+0x308>
      if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
 8018156:	f7fa fe89 	bl	8012e6c <HAL_GetTick>
 801815a:	1b80      	subs	r0, r0, r6
 801815c:	2864      	cmp	r0, #100	@ 0x64
 801815e:	d86b      	bhi.n	8018238 <HAL_RCCEx_PeriphCLKConfig+0x3e0>
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
 8018160:	682b      	ldr	r3, [r5, #0]
 8018162:	009f      	lsls	r7, r3, #2
 8018164:	d4f7      	bmi.n	8018156 <HAL_RCCEx_PeriphCLKConfig+0x2fe>
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)) ||\
 8018166:	6823      	ldr	r3, [r4, #0]
 8018168:	031d      	lsls	r5, r3, #12
 801816a:	f140 80fb 	bpl.w	8018364 <HAL_RCCEx_PeriphCLKConfig+0x50c>
 801816e:	6be2      	ldr	r2, [r4, #60]	@ 0x3c
 8018170:	2a00      	cmp	r2, #0
 8018172:	f040 80f7 	bne.w	8018364 <HAL_RCCEx_PeriphCLKConfig+0x50c>
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);
 8018176:	497f      	ldr	r1, [pc, #508]	@ (8018374 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 8018178:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);
 801817c:	f8d1 0088 	ldr.w	r0, [r1, #136]	@ 0x88
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg0, PeriphClkInit->PLLSAI.PLLSAIQ, tmpreg1);
 8018180:	f402 3240 	and.w	r2, r2, #196608	@ 0x30000
 8018184:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
 8018188:	4302      	orrs	r2, r0
 801818a:	6960      	ldr	r0, [r4, #20]
 801818c:	ea42 1280 	orr.w	r2, r2, r0, lsl #6
 8018190:	69a0      	ldr	r0, [r4, #24]
 8018192:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
 8018196:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
      __HAL_RCC_PLLSAI_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLSAIDivQ);
 801819a:	f8d1 208c 	ldr.w	r2, [r1, #140]	@ 0x8c
 801819e:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
 80181a0:	f422 52f8 	bic.w	r2, r2, #7936	@ 0x1f00
 80181a4:	3801      	subs	r0, #1
 80181a6:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 80181aa:	f8c1 208c 	str.w	r2, [r1, #140]	@ 0x8c
    if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48) && (PeriphClkInit->Clk48ClockSelection == RCC_CLK48SOURCE_PLLSAIP))
 80181ae:	0299      	lsls	r1, r3, #10
 80181b0:	d515      	bpl.n	80181de <HAL_RCCEx_PeriphCLKConfig+0x386>
 80181b2:	6fe2      	ldr	r2, [r4, #124]	@ 0x7c
 80181b4:	f1b2 6f00 	cmp.w	r2, #134217728	@ 0x8000000
 80181b8:	d111      	bne.n	80181de <HAL_RCCEx_PeriphCLKConfig+0x386>
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
 80181ba:	496e      	ldr	r1, [pc, #440]	@ (8018374 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 80181bc:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);
 80181c0:	f8d1 0088 	ldr.w	r0, [r1, #136]	@ 0x88
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , PeriphClkInit->PLLSAI.PLLSAIP, tmpreg0, tmpreg1);
 80181c4:	f002 6270 	and.w	r2, r2, #251658240	@ 0xf000000
 80181c8:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
 80181cc:	4302      	orrs	r2, r0
 80181ce:	6960      	ldr	r0, [r4, #20]
 80181d0:	ea42 1280 	orr.w	r2, r2, r0, lsl #6
 80181d4:	6a20      	ldr	r0, [r4, #32]
 80181d6:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 80181da:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == (RCC_PERIPHCLK_LTDC))
 80181de:	071a      	lsls	r2, r3, #28
 80181e0:	d519      	bpl.n	8018216 <HAL_RCCEx_PeriphCLKConfig+0x3be>
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
 80181e2:	4a64      	ldr	r2, [pc, #400]	@ (8018374 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg1, tmpreg0, PeriphClkInit->PLLSAI.PLLSAIR);
 80181e4:	6965      	ldr	r5, [r4, #20]
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
 80181e6:	f8d2 1088 	ldr.w	r1, [r2, #136]	@ 0x88
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);
 80181ea:	f8d2 3088 	ldr.w	r3, [r2, #136]	@ 0x88
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg1, tmpreg0, PeriphClkInit->PLLSAI.PLLSAIR);
 80181ee:	f001 6170 	and.w	r1, r1, #251658240	@ 0xf000000
 80181f2:	69e0      	ldr	r0, [r4, #28]
 80181f4:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
 80181f8:	430b      	orrs	r3, r1
 80181fa:	ea43 1385 	orr.w	r3, r3, r5, lsl #6
 80181fe:	ea43 7300 	orr.w	r3, r3, r0, lsl #28
 8018202:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88
      __HAL_RCC_PLLSAI_PLLSAICLKDIVR_CONFIG(PeriphClkInit->PLLSAIDivR);
 8018206:	f8d2 308c 	ldr.w	r3, [r2, #140]	@ 0x8c
 801820a:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
 801820c:	f423 3340 	bic.w	r3, r3, #196608	@ 0x30000
 8018210:	430b      	orrs	r3, r1
 8018212:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
    __HAL_RCC_PLLSAI_ENABLE();
 8018216:	4c57      	ldr	r4, [pc, #348]	@ (8018374 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 8018218:	6823      	ldr	r3, [r4, #0]
 801821a:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 801821e:	6023      	str	r3, [r4, #0]
    tickstart = HAL_GetTick();
 8018220:	f7fa fe24 	bl	8012e6c <HAL_GetTick>
 8018224:	4605      	mov	r5, r0
    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
 8018226:	6823      	ldr	r3, [r4, #0]
 8018228:	009b      	lsls	r3, r3, #2
 801822a:	f53f af7c 	bmi.w	8018126 <HAL_RCCEx_PeriphCLKConfig+0x2ce>
      if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
 801822e:	f7fa fe1d 	bl	8012e6c <HAL_GetTick>
 8018232:	1b40      	subs	r0, r0, r5
 8018234:	2864      	cmp	r0, #100	@ 0x64
 8018236:	d9f6      	bls.n	8018226 <HAL_RCCEx_PeriphCLKConfig+0x3ce>
        return HAL_TIMEOUT;
 8018238:	2003      	movs	r0, #3
}
 801823a:	b003      	add	sp, #12
 801823c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    __HAL_RCC_PWR_CLK_ENABLE();
 8018240:	4b4c      	ldr	r3, [pc, #304]	@ (8018374 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
    PWR->CR1 |= PWR_CR1_DBP;
 8018242:	4f4d      	ldr	r7, [pc, #308]	@ (8018378 <HAL_RCCEx_PeriphCLKConfig+0x520>)
    __HAL_RCC_PWR_CLK_ENABLE();
 8018244:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 8018246:	f042 5280 	orr.w	r2, r2, #268435456	@ 0x10000000
 801824a:	641a      	str	r2, [r3, #64]	@ 0x40
 801824c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 801824e:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8018252:	9301      	str	r3, [sp, #4]
 8018254:	9b01      	ldr	r3, [sp, #4]
    PWR->CR1 |= PWR_CR1_DBP;
 8018256:	683b      	ldr	r3, [r7, #0]
 8018258:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 801825c:	603b      	str	r3, [r7, #0]
    tickstart = HAL_GetTick();
 801825e:	f7fa fe05 	bl	8012e6c <HAL_GetTick>
 8018262:	4680      	mov	r8, r0
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
 8018264:	e005      	b.n	8018272 <HAL_RCCEx_PeriphCLKConfig+0x41a>
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8018266:	f7fa fe01 	bl	8012e6c <HAL_GetTick>
 801826a:	eba0 0008 	sub.w	r0, r0, r8
 801826e:	2864      	cmp	r0, #100	@ 0x64
 8018270:	d8e2      	bhi.n	8018238 <HAL_RCCEx_PeriphCLKConfig+0x3e0>
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
 8018272:	683b      	ldr	r3, [r7, #0]
 8018274:	05d9      	lsls	r1, r3, #23
 8018276:	d5f6      	bpl.n	8018266 <HAL_RCCEx_PeriphCLKConfig+0x40e>
    tmpreg0 = (RCC->BDCR & RCC_BDCR_RTCSEL);
 8018278:	4f3e      	ldr	r7, [pc, #248]	@ (8018374 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
    if((tmpreg0 != 0x00000000U) && (tmpreg0 != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 801827a:	6b23      	ldr	r3, [r4, #48]	@ 0x30
    tmpreg0 = (RCC->BDCR & RCC_BDCR_RTCSEL);
 801827c:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
    if((tmpreg0 != 0x00000000U) && (tmpreg0 != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 801827e:	f403 7140 	and.w	r1, r3, #768	@ 0x300
 8018282:	f412 7240 	ands.w	r2, r2, #768	@ 0x300
 8018286:	d010      	beq.n	80182aa <HAL_RCCEx_PeriphCLKConfig+0x452>
 8018288:	428a      	cmp	r2, r1
 801828a:	d00e      	beq.n	80182aa <HAL_RCCEx_PeriphCLKConfig+0x452>
      tmpreg0 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 801828c:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
      __HAL_RCC_BACKUPRESET_FORCE();
 801828e:	6f38      	ldr	r0, [r7, #112]	@ 0x70
      tmpreg0 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8018290:	f422 7240 	bic.w	r2, r2, #768	@ 0x300
      __HAL_RCC_BACKUPRESET_FORCE();
 8018294:	f440 3080 	orr.w	r0, r0, #65536	@ 0x10000
 8018298:	6738      	str	r0, [r7, #112]	@ 0x70
      __HAL_RCC_BACKUPRESET_RELEASE();
 801829a:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801829c:	f420 3080 	bic.w	r0, r0, #65536	@ 0x10000
 80182a0:	6738      	str	r0, [r7, #112]	@ 0x70
      RCC->BDCR = tmpreg0;
 80182a2:	673a      	str	r2, [r7, #112]	@ 0x70
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))
 80182a4:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 80182a6:	07d2      	lsls	r2, r2, #31
 80182a8:	d448      	bmi.n	801833c <HAL_RCCEx_PeriphCLKConfig+0x4e4>
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 80182aa:	f5b1 7f40 	cmp.w	r1, #768	@ 0x300
 80182ae:	d03c      	beq.n	801832a <HAL_RCCEx_PeriphCLKConfig+0x4d2>
 80182b0:	4930      	ldr	r1, [pc, #192]	@ (8018374 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 80182b2:	688a      	ldr	r2, [r1, #8]
 80182b4:	f422 12f8 	bic.w	r2, r2, #2031616	@ 0x1f0000
 80182b8:	608a      	str	r2, [r1, #8]
 80182ba:	4a2e      	ldr	r2, [pc, #184]	@ (8018374 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 80182bc:	f3c3 030b 	ubfx	r3, r3, #0, #12
 80182c0:	6f11      	ldr	r1, [r2, #112]	@ 0x70
 80182c2:	430b      	orrs	r3, r1
 80182c4:	6713      	str	r3, [r2, #112]	@ 0x70
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))
 80182c6:	6823      	ldr	r3, [r4, #0]
 80182c8:	e608      	b.n	8017edc <HAL_RCCEx_PeriphCLKConfig+0x84>
  uint32_t pllsaiused = 0;
 80182ca:	2500      	movs	r5, #0
      plli2sused = 1;
 80182cc:	2601      	movs	r6, #1
 80182ce:	e5eb      	b.n	8017ea8 <HAL_RCCEx_PeriphCLKConfig+0x50>
      plli2sused = 1;
 80182d0:	2601      	movs	r6, #1
 80182d2:	e5fc      	b.n	8017ece <HAL_RCCEx_PeriphCLKConfig+0x76>
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, PeriphClkInit->PLLI2S.PLLI2SQ, PeriphClkInit->PLLI2S.PLLI2SR);
 80182d4:	6923      	ldr	r3, [r4, #16]
 80182d6:	6861      	ldr	r1, [r4, #4]
 80182d8:	041b      	lsls	r3, r3, #16
 80182da:	68e2      	ldr	r2, [r4, #12]
 80182dc:	ea43 1381 	orr.w	r3, r3, r1, lsl #6
 80182e0:	68a1      	ldr	r1, [r4, #8]
 80182e2:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 80182e6:	4a23      	ldr	r2, [pc, #140]	@ (8018374 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 80182e8:	ea43 7301 	orr.w	r3, r3, r1, lsl #28
 80182ec:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84
 80182f0:	e703      	b.n	80180fa <HAL_RCCEx_PeriphCLKConfig+0x2a2>
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);
 80182f2:	4920      	ldr	r1, [pc, #128]	@ (8018374 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 80182f4:	f8d1 2084 	ldr.w	r2, [r1, #132]	@ 0x84
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
 80182f8:	f8d1 0084 	ldr.w	r0, [r1, #132]	@ 0x84
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN, tmpreg0, PeriphClkInit->PLLI2S.PLLI2SQ, tmpreg1);
 80182fc:	f402 3240 	and.w	r2, r2, #196608	@ 0x30000
 8018300:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
 8018304:	4302      	orrs	r2, r0
 8018306:	6860      	ldr	r0, [r4, #4]
 8018308:	ea42 1280 	orr.w	r2, r2, r0, lsl #6
 801830c:	68e0      	ldr	r0, [r4, #12]
 801830e:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
 8018312:	f8c1 2084 	str.w	r2, [r1, #132]	@ 0x84
      __HAL_RCC_PLLI2S_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLI2SDivQ);
 8018316:	f8d1 008c 	ldr.w	r0, [r1, #140]	@ 0x8c
 801831a:	6a62      	ldr	r2, [r4, #36]	@ 0x24
 801831c:	f020 001f 	bic.w	r0, r0, #31
 8018320:	3a01      	subs	r2, #1
 8018322:	4302      	orrs	r2, r0
 8018324:	f8c1 208c 	str.w	r2, [r1, #140]	@ 0x8c
 8018328:	e6d0      	b.n	80180cc <HAL_RCCEx_PeriphCLKConfig+0x274>
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 801832a:	4812      	ldr	r0, [pc, #72]	@ (8018374 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 801832c:	4913      	ldr	r1, [pc, #76]	@ (801837c <HAL_RCCEx_PeriphCLKConfig+0x524>)
 801832e:	6882      	ldr	r2, [r0, #8]
 8018330:	4019      	ands	r1, r3
 8018332:	f422 12f8 	bic.w	r2, r2, #2031616	@ 0x1f0000
 8018336:	430a      	orrs	r2, r1
 8018338:	6082      	str	r2, [r0, #8]
 801833a:	e7be      	b.n	80182ba <HAL_RCCEx_PeriphCLKConfig+0x462>
        tickstart = HAL_GetTick();
 801833c:	f7fa fd96 	bl	8012e6c <HAL_GetTick>
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8018340:	f241 3988 	movw	r9, #5000	@ 0x1388
        tickstart = HAL_GetTick();
 8018344:	4680      	mov	r8, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8018346:	e006      	b.n	8018356 <HAL_RCCEx_PeriphCLKConfig+0x4fe>
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8018348:	f7fa fd90 	bl	8012e6c <HAL_GetTick>
 801834c:	eba0 0008 	sub.w	r0, r0, r8
 8018350:	4548      	cmp	r0, r9
 8018352:	f63f af71 	bhi.w	8018238 <HAL_RCCEx_PeriphCLKConfig+0x3e0>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8018356:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8018358:	0798      	lsls	r0, r3, #30
 801835a:	d5f5      	bpl.n	8018348 <HAL_RCCEx_PeriphCLKConfig+0x4f0>
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 801835c:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 801835e:	f403 7140 	and.w	r1, r3, #768	@ 0x300
 8018362:	e7a2      	b.n	80182aa <HAL_RCCEx_PeriphCLKConfig+0x452>
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)) ||\
 8018364:	02d8      	lsls	r0, r3, #11
 8018366:	f57f af22 	bpl.w	80181ae <HAL_RCCEx_PeriphCLKConfig+0x356>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)))
 801836a:	6c22      	ldr	r2, [r4, #64]	@ 0x40
 801836c:	2a00      	cmp	r2, #0
 801836e:	f47f af1e 	bne.w	80181ae <HAL_RCCEx_PeriphCLKConfig+0x356>
 8018372:	e700      	b.n	8018176 <HAL_RCCEx_PeriphCLKConfig+0x31e>
 8018374:	40023800 	.word	0x40023800
 8018378:	40007000 	.word	0x40007000
 801837c:	0ffffcff 	.word	0x0ffffcff

08018380 <HAL_RCCEx_GetPeriphCLKFreq>:
  /* This variable is used to store the VCO Input (value in Hz) */
  uint32_t vcoinput = 0;
  /* This variable is used to store the SAI clock source */
  uint32_t saiclocksource = 0;

  if (PeriphClk == RCC_PERIPHCLK_SAI1)
 8018380:	f5b0 2f00 	cmp.w	r0, #524288	@ 0x80000
 8018384:	d031      	beq.n	80183ea <HAL_RCCEx_GetPeriphCLKFreq+0x6a>
        break;
      }
    }
  }

  if (PeriphClk == RCC_PERIPHCLK_SAI2)
 8018386:	f5b0 1f80 	cmp.w	r0, #1048576	@ 0x100000
 801838a:	d12c      	bne.n	80183e6 <HAL_RCCEx_GetPeriphCLKFreq+0x66>
  {
    saiclocksource = RCC->DCKCFGR1;
 801838c:	4a2e      	ldr	r2, [pc, #184]	@ (8018448 <HAL_RCCEx_GetPeriphCLKFreq+0xc8>)
 801838e:	f8d2 308c 	ldr.w	r3, [r2, #140]	@ 0x8c
    saiclocksource &= RCC_DCKCFGR1_SAI2SEL;
 8018392:	f403 0340 	and.w	r3, r3, #12582912	@ 0xc00000
    switch (saiclocksource)
 8018396:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
 801839a:	d033      	beq.n	8018404 <HAL_RCCEx_GetPeriphCLKFreq+0x84>
 801839c:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
 80183a0:	d02e      	beq.n	8018400 <HAL_RCCEx_GetPeriphCLKFreq+0x80>
 80183a2:	bb03      	cbnz	r3, 80183e6 <HAL_RCCEx_GetPeriphCLKFreq+0x66>
    {
    case 0: /* PLLSAI is the clock source for SAI*/
      {
        /* Configure the PLLSAI division factor */
        /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */
        if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSI)
 80183a4:	6853      	ldr	r3, [r2, #4]
 80183a6:	f413 0f80 	tst.w	r3, #4194304	@ 0x400000
        {
          /* In Case the PLL Source is HSI (Internal Clock) */
          vcoinput = (HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
 80183aa:	6853      	ldr	r3, [r2, #4]
 80183ac:	bf08      	it	eq
 80183ae:	4927      	ldreq	r1, [pc, #156]	@ (801844c <HAL_RCCEx_GetPeriphCLKFreq+0xcc>)
        }
        else
        {
          /* In Case the PLL Source is HSE (External Clock) */
          vcoinput = ((HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM)));
 80183b0:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 80183b4:	bf18      	it	ne
 80183b6:	4926      	ldrne	r1, [pc, #152]	@ (8018450 <HAL_RCCEx_GetPeriphCLKFreq+0xd0>)
 80183b8:	fbb1 f1f3 	udiv	r1, r1, r3
        }
        /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */
        /* SAI_CLK(first level) = PLLSAI_VCO Output/PLLSAIQ */
        tmpreg = (RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> 24;
 80183bc:	4b22      	ldr	r3, [pc, #136]	@ (8018448 <HAL_RCCEx_GetPeriphCLKFreq+0xc8>)
 80183be:	f8d3 2088 	ldr.w	r2, [r3, #136]	@ 0x88
        frequency = (vcoinput * ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIN) >> 6))/(tmpreg);
 80183c2:	f8d3 0088 	ldr.w	r0, [r3, #136]	@ 0x88
        tmpreg = (RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> 24;
 80183c6:	f3c2 6203 	ubfx	r2, r2, #24, #4

        /* SAI_CLK_x = SAI_CLK(first level)/PLLSAIDIVQ */
        tmpreg = (((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLSAIDIVQ) >> 8) + 1);
 80183ca:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
        frequency = (vcoinput * ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIN) >> 6))/(tmpreg);
 80183ce:	f3c0 1088 	ubfx	r0, r0, #6, #9
        tmpreg = (((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLSAIDIVQ) >> 8) + 1);
 80183d2:	f3c3 2304 	ubfx	r3, r3, #8, #5
        frequency = (vcoinput * ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIN) >> 6))/(tmpreg);
 80183d6:	fb01 f000 	mul.w	r0, r1, r0
        tmpreg = (((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLSAIDIVQ) >> 8) + 1);
 80183da:	3301      	adds	r3, #1
        frequency = (vcoinput * ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIN) >> 6))/(tmpreg);
 80183dc:	fbb0 f0f2 	udiv	r0, r0, r2
        frequency = frequency/(tmpreg);
 80183e0:	fbb0 f0f3 	udiv	r0, r0, r3
        break;
 80183e4:	4770      	bx	lr
    switch (saiclocksource)
 80183e6:	2000      	movs	r0, #0
      }
    }
  }

  return frequency;
}
 80183e8:	4770      	bx	lr
    saiclocksource = RCC->DCKCFGR1;
 80183ea:	4a17      	ldr	r2, [pc, #92]	@ (8018448 <HAL_RCCEx_GetPeriphCLKFreq+0xc8>)
 80183ec:	f8d2 308c 	ldr.w	r3, [r2, #140]	@ 0x8c
    saiclocksource &= RCC_DCKCFGR1_SAI1SEL;
 80183f0:	f403 1340 	and.w	r3, r3, #3145728	@ 0x300000
    switch (saiclocksource)
 80183f4:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 80183f8:	d004      	beq.n	8018404 <HAL_RCCEx_GetPeriphCLKFreq+0x84>
 80183fa:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 80183fe:	d1d0      	bne.n	80183a2 <HAL_RCCEx_GetPeriphCLKFreq+0x22>
        frequency = EXTERNAL_CLOCK_VALUE;
 8018400:	4814      	ldr	r0, [pc, #80]	@ (8018454 <HAL_RCCEx_GetPeriphCLKFreq+0xd4>)
 8018402:	4770      	bx	lr
        if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSI)
 8018404:	6853      	ldr	r3, [r2, #4]
 8018406:	f413 0f80 	tst.w	r3, #4194304	@ 0x400000
          vcoinput = (HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
 801840a:	6853      	ldr	r3, [r2, #4]
 801840c:	bf08      	it	eq
 801840e:	490f      	ldreq	r1, [pc, #60]	@ (801844c <HAL_RCCEx_GetPeriphCLKFreq+0xcc>)
          vcoinput = ((HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM)));
 8018410:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 8018414:	bf18      	it	ne
 8018416:	490e      	ldrne	r1, [pc, #56]	@ (8018450 <HAL_RCCEx_GetPeriphCLKFreq+0xd0>)
 8018418:	fbb1 f1f3 	udiv	r1, r1, r3
        tmpreg = (RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> 24;
 801841c:	4b0a      	ldr	r3, [pc, #40]	@ (8018448 <HAL_RCCEx_GetPeriphCLKFreq+0xc8>)
 801841e:	f8d3 2084 	ldr.w	r2, [r3, #132]	@ 0x84
        frequency = (vcoinput * ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6))/(tmpreg);
 8018422:	f8d3 0084 	ldr.w	r0, [r3, #132]	@ 0x84
        tmpreg = (RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> 24;
 8018426:	f3c2 6203 	ubfx	r2, r2, #24, #4
        tmpreg = ((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLI2SDIVQ) + 1);
 801842a:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
        frequency = (vcoinput * ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6))/(tmpreg);
 801842e:	f3c0 1088 	ubfx	r0, r0, #6, #9
        tmpreg = ((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLI2SDIVQ) + 1);
 8018432:	f003 031f 	and.w	r3, r3, #31
        frequency = (vcoinput * ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6))/(tmpreg);
 8018436:	fb01 f000 	mul.w	r0, r1, r0
        tmpreg = ((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLI2SDIVQ) + 1);
 801843a:	3301      	adds	r3, #1
        frequency = (vcoinput * ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6))/(tmpreg);
 801843c:	fbb0 f0f2 	udiv	r0, r0, r2
        frequency = frequency/(tmpreg);
 8018440:	fbb0 f0f3 	udiv	r0, r0, r3
        break;
 8018444:	4770      	bx	lr
 8018446:	bf00      	nop
 8018448:	40023800 	.word	0x40023800
 801844c:	00f42400 	.word	0x00f42400
 8018450:	017d7840 	.word	0x017d7840
 8018454:	00bb8000 	.word	0x00bb8000

08018458 <HAL_RTC_Init>:
HAL_StatusTypeDef HAL_RTC_Init(RTC_HandleTypeDef *hrtc)
{
  HAL_StatusTypeDef status = HAL_ERROR;

  /* Check RTC handler validity */
  if (hrtc == NULL)
 8018458:	2800      	cmp	r0, #0
 801845a:	d05d      	beq.n	8018518 <HAL_RTC_Init+0xc0>
{
 801845c:	b570      	push	{r4, r5, r6, lr}
    {
      hrtc->MspDeInitCallback = HAL_RTC_MspDeInit;
    }
  }
#else /* USE_HAL_RTC_REGISTER_CALLBACKS */
  if (hrtc->State == HAL_RTC_STATE_RESET)
 801845e:	7f43      	ldrb	r3, [r0, #29]
 8018460:	4604      	mov	r4, r0
 8018462:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
 8018466:	b14b      	cbz	r3, 801847c <HAL_RTC_Init+0x24>
    HAL_RTC_MspInit(hrtc);
  }
#endif /* USE_HAL_RTC_REGISTER_CALLBACKS */

  /* Set RTC state */
  hrtc->State = HAL_RTC_STATE_BUSY;
 8018468:	2202      	movs	r2, #2

  /* Check whether the calendar needs to be initialized */
  if (__HAL_RTC_IS_CALENDAR_INITIALIZED(hrtc) == 0U)
 801846a:	6823      	ldr	r3, [r4, #0]
  hrtc->State = HAL_RTC_STATE_BUSY;
 801846c:	7762      	strb	r2, [r4, #29]
  if (__HAL_RTC_IS_CALENDAR_INITIALIZED(hrtc) == 0U)
 801846e:	68da      	ldr	r2, [r3, #12]
 8018470:	06d5      	lsls	r5, r2, #27
 8018472:	d507      	bpl.n	8018484 <HAL_RTC_Init+0x2c>
    status = HAL_OK;
  }

  if (status == HAL_OK)
  {
    hrtc->State = HAL_RTC_STATE_READY;
 8018474:	2301      	movs	r3, #1
 8018476:	2000      	movs	r0, #0
 8018478:	7763      	strb	r3, [r4, #29]
  }

  return status;
}
 801847a:	bd70      	pop	{r4, r5, r6, pc}
    hrtc->Lock = HAL_UNLOCKED;
 801847c:	7702      	strb	r2, [r0, #28]
    HAL_RTC_MspInit(hrtc);
 801847e:	f7fa f87d 	bl	801257c <HAL_RTC_MspInit>
 8018482:	e7f1      	b.n	8018468 <HAL_RTC_Init+0x10>
    __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8018484:	21ca      	movs	r1, #202	@ 0xca
 8018486:	2253      	movs	r2, #83	@ 0x53
 8018488:	6259      	str	r1, [r3, #36]	@ 0x24
 801848a:	625a      	str	r2, [r3, #36]	@ 0x24
{
  uint32_t tickstart = 0U;
  HAL_StatusTypeDef status = HAL_OK;

  /* Check that Initialization mode is not already set */
  if (READ_BIT(hrtc->Instance->ISR, RTC_ISR_INITF) == 0U)
 801848c:	68dd      	ldr	r5, [r3, #12]
 801848e:	f015 0540 	ands.w	r5, r5, #64	@ 0x40
 8018492:	d024      	beq.n	80184de <HAL_RTC_Init+0x86>
      hrtc->Instance->CR &= ((uint32_t)~(RTC_CR_FMT | RTC_CR_OSEL | RTC_CR_POL));
 8018494:	6898      	ldr	r0, [r3, #8]
      hrtc->Instance->CR |= (uint32_t)(hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
 8018496:	6862      	ldr	r2, [r4, #4]
 8018498:	6925      	ldr	r5, [r4, #16]
      hrtc->Instance->CR &= ((uint32_t)~(RTC_CR_FMT | RTC_CR_OSEL | RTC_CR_POL));
 801849a:	492b      	ldr	r1, [pc, #172]	@ (8018548 <HAL_RTC_Init+0xf0>)
      hrtc->Instance->CR |= (uint32_t)(hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
 801849c:	432a      	orrs	r2, r5
      hrtc->Instance->CR &= ((uint32_t)~(RTC_CR_FMT | RTC_CR_OSEL | RTC_CR_POL));
 801849e:	4001      	ands	r1, r0
      hrtc->Instance->CR |= (uint32_t)(hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
 80184a0:	6960      	ldr	r0, [r4, #20]
      hrtc->Instance->CR &= ((uint32_t)~(RTC_CR_FMT | RTC_CR_OSEL | RTC_CR_POL));
 80184a2:	6099      	str	r1, [r3, #8]
      hrtc->Instance->CR |= (uint32_t)(hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
 80184a4:	4302      	orrs	r2, r0
 80184a6:	6899      	ldr	r1, [r3, #8]
      hrtc->Instance->PRER = (uint32_t)(hrtc->Init.SynchPrediv);
 80184a8:	68e0      	ldr	r0, [r4, #12]
      hrtc->Instance->CR |= (uint32_t)(hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
 80184aa:	430a      	orrs	r2, r1
      hrtc->Instance->PRER |= (uint32_t)(hrtc->Init.AsynchPrediv << RTC_PRER_PREDIV_A_Pos);
 80184ac:	68a1      	ldr	r1, [r4, #8]
      hrtc->Instance->CR |= (uint32_t)(hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
 80184ae:	609a      	str	r2, [r3, #8]
      hrtc->Instance->PRER = (uint32_t)(hrtc->Init.SynchPrediv);
 80184b0:	6118      	str	r0, [r3, #16]
      hrtc->Instance->PRER |= (uint32_t)(hrtc->Init.AsynchPrediv << RTC_PRER_PREDIV_A_Pos);
 80184b2:	691a      	ldr	r2, [r3, #16]
 80184b4:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 80184b8:	611a      	str	r2, [r3, #16]
HAL_StatusTypeDef RTC_ExitInitMode(RTC_HandleTypeDef *hrtc)
{
  HAL_StatusTypeDef status = HAL_OK;

  /* Clear INIT bit to exit Initialization mode */
  CLEAR_BIT(hrtc->Instance->ISR, RTC_ISR_INIT);
 80184ba:	68da      	ldr	r2, [r3, #12]
 80184bc:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
 80184c0:	60da      	str	r2, [r3, #12]

  /* If CR_BYPSHAD bit = 0, wait for synchro */
  if (READ_BIT(hrtc->Instance->CR, RTC_CR_BYPSHAD) == 0U)
 80184c2:	689a      	ldr	r2, [r3, #8]
 80184c4:	0691      	lsls	r1, r2, #26
 80184c6:	d529      	bpl.n	801851c <HAL_RTC_Init+0xc4>
      hrtc->Instance->OR &= (uint32_t)~RTC_OUTPUT_TYPE_PUSHPULL;
 80184c8:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80184ca:	21ff      	movs	r1, #255	@ 0xff
      hrtc->Instance->OR |= (uint32_t)(hrtc->Init.OutPutType);
 80184cc:	69a0      	ldr	r0, [r4, #24]
      hrtc->Instance->OR &= (uint32_t)~RTC_OUTPUT_TYPE_PUSHPULL;
 80184ce:	f022 0208 	bic.w	r2, r2, #8
 80184d2:	64da      	str	r2, [r3, #76]	@ 0x4c
      hrtc->Instance->OR |= (uint32_t)(hrtc->Init.OutPutType);
 80184d4:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 80184d6:	4302      	orrs	r2, r0
 80184d8:	64da      	str	r2, [r3, #76]	@ 0x4c
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80184da:	6259      	str	r1, [r3, #36]	@ 0x24
  if (status == HAL_OK)
 80184dc:	e7ca      	b.n	8018474 <HAL_RTC_Init+0x1c>
    SET_BIT(hrtc->Instance->ISR, RTC_ISR_INIT);
 80184de:	68da      	ldr	r2, [r3, #12]
 80184e0:	f042 0280 	orr.w	r2, r2, #128	@ 0x80
 80184e4:	60da      	str	r2, [r3, #12]
    tickstart = HAL_GetTick();
 80184e6:	f7fa fcc1 	bl	8012e6c <HAL_GetTick>
 80184ea:	4606      	mov	r6, r0
    while ((READ_BIT(hrtc->Instance->ISR, RTC_ISR_INITF) == 0U) && (status != HAL_ERROR))
 80184ec:	e006      	b.n	80184fc <HAL_RTC_Init+0xa4>
 80184ee:	b95d      	cbnz	r5, 8018508 <HAL_RTC_Init+0xb0>
      if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
 80184f0:	f7fa fcbc 	bl	8012e6c <HAL_GetTick>
 80184f4:	1b80      	subs	r0, r0, r6
 80184f6:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
 80184fa:	d809      	bhi.n	8018510 <HAL_RTC_Init+0xb8>
    while ((READ_BIT(hrtc->Instance->ISR, RTC_ISR_INITF) == 0U) && (status != HAL_ERROR))
 80184fc:	6823      	ldr	r3, [r4, #0]
 80184fe:	68da      	ldr	r2, [r3, #12]
 8018500:	0650      	lsls	r0, r2, #25
 8018502:	d5f4      	bpl.n	80184ee <HAL_RTC_Init+0x96>
    if (status == HAL_OK)
 8018504:	2d00      	cmp	r5, #0
 8018506:	d0c5      	beq.n	8018494 <HAL_RTC_Init+0x3c>
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8018508:	22ff      	movs	r2, #255	@ 0xff
 801850a:	625a      	str	r2, [r3, #36]	@ 0x24
    return HAL_ERROR;
 801850c:	2001      	movs	r0, #1
}
 801850e:	bd70      	pop	{r4, r5, r6, pc}
        hrtc->State = HAL_RTC_STATE_ERROR;
 8018510:	2304      	movs	r3, #4
        status = HAL_ERROR;
 8018512:	2501      	movs	r5, #1
        hrtc->State = HAL_RTC_STATE_ERROR;
 8018514:	7763      	strb	r3, [r4, #29]
        status = HAL_ERROR;
 8018516:	e7f1      	b.n	80184fc <HAL_RTC_Init+0xa4>
    return HAL_ERROR;
 8018518:	2001      	movs	r0, #1
}
 801851a:	4770      	bx	lr
  hrtc->Instance->ISR = ((uint32_t)(RTC_RSF_MASK & RTC_ISR_RESERVED_MASK));
 801851c:	4a0b      	ldr	r2, [pc, #44]	@ (801854c <HAL_RTC_Init+0xf4>)
 801851e:	60da      	str	r2, [r3, #12]
  tickstart = HAL_GetTick();
 8018520:	f7fa fca4 	bl	8012e6c <HAL_GetTick>
 8018524:	4605      	mov	r5, r0
  while ((hrtc->Instance->ISR & RTC_ISR_RSF) == 0U)
 8018526:	6823      	ldr	r3, [r4, #0]
 8018528:	68da      	ldr	r2, [r3, #12]
 801852a:	0692      	lsls	r2, r2, #26
 801852c:	d4cc      	bmi.n	80184c8 <HAL_RTC_Init+0x70>
    if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
 801852e:	f7fa fc9d 	bl	8012e6c <HAL_GetTick>
 8018532:	1b40      	subs	r0, r0, r5
 8018534:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
 8018538:	d9f5      	bls.n	8018526 <HAL_RTC_Init+0xce>
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 801853a:	6823      	ldr	r3, [r4, #0]
  {
    if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
    {
      /* Set RTC state */
      hrtc->State = HAL_RTC_STATE_ERROR;
 801853c:	2104      	movs	r1, #4
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 801853e:	22ff      	movs	r2, #255	@ 0xff
      hrtc->State = HAL_RTC_STATE_ERROR;
 8018540:	7761      	strb	r1, [r4, #29]
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8018542:	625a      	str	r2, [r3, #36]	@ 0x24
  if (status == HAL_OK)
 8018544:	e7e2      	b.n	801850c <HAL_RTC_Init+0xb4>
 8018546:	bf00      	nop
 8018548:	ff8fffbf 	.word	0xff8fffbf
 801854c:	0001ff5f 	.word	0x0001ff5f

08018550 <HAL_RTC_SetTime>:
{
 8018550:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  __HAL_LOCK(hrtc);
 8018554:	7f03      	ldrb	r3, [r0, #28]
 8018556:	2b01      	cmp	r3, #1
 8018558:	f000 809f 	beq.w	801869a <HAL_RTC_SetTime+0x14a>
 801855c:	460d      	mov	r5, r1
 801855e:	2101      	movs	r1, #1
  hrtc->State = HAL_RTC_STATE_BUSY;
 8018560:	2302      	movs	r3, #2
 8018562:	4606      	mov	r6, r0
  __HAL_LOCK(hrtc);
 8018564:	7701      	strb	r1, [r0, #28]
    if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
 8018566:	6801      	ldr	r1, [r0, #0]
  hrtc->State = HAL_RTC_STATE_BUSY;
 8018568:	7743      	strb	r3, [r0, #29]
    if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
 801856a:	688b      	ldr	r3, [r1, #8]
  if (Format == RTC_FORMAT_BIN)
 801856c:	bb82      	cbnz	r2, 80185d0 <HAL_RTC_SetTime+0x80>
    if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
 801856e:	f013 0c40 	ands.w	ip, r3, #64	@ 0x40
 8018572:	d07a      	beq.n	801866a <HAL_RTC_SetTime+0x11a>
              ((uint32_t)(sTime->TimeFormat) << RTC_TR_PM_Pos));
 8018574:	f895 c003 	ldrb.w	ip, [r5, #3]
 8018578:	ea4f 5c8c 	mov.w	ip, ip, lsl #22
    tmpreg = (uint32_t)(( (uint32_t)RTC_ByteToBcd2(sTime->Hours)   << RTC_TR_HU_Pos)  | \
 801857c:	782b      	ldrb	r3, [r5, #0]
  */
uint8_t RTC_ByteToBcd2(uint8_t number)
{
  uint32_t bcdhigh = 0U;

  while (number >= 10U)
 801857e:	2b09      	cmp	r3, #9
 8018580:	d908      	bls.n	8018594 <HAL_RTC_SetTime+0x44>
  uint32_t bcdhigh = 0U;
 8018582:	2000      	movs	r0, #0
  {
    bcdhigh++;
    number -= 10U;
 8018584:	3b0a      	subs	r3, #10
    bcdhigh++;
 8018586:	3001      	adds	r0, #1
    number -= 10U;
 8018588:	b2db      	uxtb	r3, r3
  while (number >= 10U)
 801858a:	2b09      	cmp	r3, #9
 801858c:	d8fa      	bhi.n	8018584 <HAL_RTC_SetTime+0x34>
  }

  return ((uint8_t)(bcdhigh << 4U) | number);
 801858e:	ea43 1300 	orr.w	r3, r3, r0, lsl #4
 8018592:	b2db      	uxtb	r3, r3
    tmpreg = (uint32_t)(( (uint32_t)RTC_ByteToBcd2(sTime->Hours)   << RTC_TR_HU_Pos)  | \
 8018594:	041c      	lsls	r4, r3, #16
                        ( (uint32_t)RTC_ByteToBcd2(sTime->Minutes) << RTC_TR_MNU_Pos) | \
 8018596:	786b      	ldrb	r3, [r5, #1]
  while (number >= 10U)
 8018598:	2b09      	cmp	r3, #9
 801859a:	d908      	bls.n	80185ae <HAL_RTC_SetTime+0x5e>
  uint32_t bcdhigh = 0U;
 801859c:	2000      	movs	r0, #0
    number -= 10U;
 801859e:	3b0a      	subs	r3, #10
    bcdhigh++;
 80185a0:	3001      	adds	r0, #1
    number -= 10U;
 80185a2:	b2db      	uxtb	r3, r3
  while (number >= 10U)
 80185a4:	2b09      	cmp	r3, #9
 80185a6:	d8fa      	bhi.n	801859e <HAL_RTC_SetTime+0x4e>
  return ((uint8_t)(bcdhigh << 4U) | number);
 80185a8:	ea43 1300 	orr.w	r3, r3, r0, lsl #4
 80185ac:	b2db      	uxtb	r3, r3
                        ( (uint32_t)RTC_ByteToBcd2(sTime->Seconds))                   | \
 80185ae:	78a8      	ldrb	r0, [r5, #2]
                        ( (uint32_t)RTC_ByteToBcd2(sTime->Minutes) << RTC_TR_MNU_Pos) | \
 80185b0:	021b      	lsls	r3, r3, #8
  while (number >= 10U)
 80185b2:	2809      	cmp	r0, #9
 80185b4:	d907      	bls.n	80185c6 <HAL_RTC_SetTime+0x76>
    number -= 10U;
 80185b6:	380a      	subs	r0, #10
    bcdhigh++;
 80185b8:	3201      	adds	r2, #1
    number -= 10U;
 80185ba:	b2c0      	uxtb	r0, r0
  while (number >= 10U)
 80185bc:	2809      	cmp	r0, #9
 80185be:	d8fa      	bhi.n	80185b6 <HAL_RTC_SetTime+0x66>
  return ((uint8_t)(bcdhigh << 4U) | number);
 80185c0:	ea40 1002 	orr.w	r0, r0, r2, lsl #4
 80185c4:	b2c0      	uxtb	r0, r0
    tmpreg = (uint32_t)(( (uint32_t)RTC_ByteToBcd2(sTime->Hours)   << RTC_TR_HU_Pos)  | \
 80185c6:	ea44 040c 	orr.w	r4, r4, ip
 80185ca:	431c      	orrs	r4, r3
 80185cc:	4304      	orrs	r4, r0
 80185ce:	e00c      	b.n	80185ea <HAL_RTC_SetTime+0x9a>
    if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
 80185d0:	f013 0340 	ands.w	r3, r3, #64	@ 0x40
 80185d4:	d047      	beq.n	8018666 <HAL_RTC_SetTime+0x116>
              ((uint32_t)(sTime->TimeFormat) << RTC_TR_PM_Pos));
 80185d6:	78eb      	ldrb	r3, [r5, #3]
 80185d8:	059b      	lsls	r3, r3, #22
              ((uint32_t)(sTime->Minutes)    << RTC_TR_MNU_Pos) | \
 80185da:	786c      	ldrb	r4, [r5, #1]
    tmpreg = (((uint32_t)(sTime->Hours)      << RTC_TR_HU_Pos)  | \
 80185dc:	782a      	ldrb	r2, [r5, #0]
              ((uint32_t)(sTime->Minutes)    << RTC_TR_MNU_Pos) | \
 80185de:	0224      	lsls	r4, r4, #8
    tmpreg = (((uint32_t)(sTime->Hours)      << RTC_TR_HU_Pos)  | \
 80185e0:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
              ((uint32_t) sTime->Seconds)                       | \
 80185e4:	78aa      	ldrb	r2, [r5, #2]
              ((uint32_t)(sTime->Minutes)    << RTC_TR_MNU_Pos) | \
 80185e6:	4314      	orrs	r4, r2
    tmpreg = (((uint32_t)(sTime->Hours)      << RTC_TR_HU_Pos)  | \
 80185e8:	431c      	orrs	r4, r3
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 80185ea:	23ca      	movs	r3, #202	@ 0xca
 80185ec:	624b      	str	r3, [r1, #36]	@ 0x24
 80185ee:	2353      	movs	r3, #83	@ 0x53
 80185f0:	624b      	str	r3, [r1, #36]	@ 0x24
  if (READ_BIT(hrtc->Instance->ISR, RTC_ISR_INITF) == 0U)
 80185f2:	68cf      	ldr	r7, [r1, #12]
 80185f4:	f017 0740 	ands.w	r7, r7, #64	@ 0x40
 80185f8:	d01d      	beq.n	8018636 <HAL_RTC_SetTime+0xe6>
    hrtc->Instance->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
 80185fa:	4a2c      	ldr	r2, [pc, #176]	@ (80186ac <HAL_RTC_SetTime+0x15c>)
 80185fc:	4022      	ands	r2, r4
    hrtc->Instance->CR |= (uint32_t)(sTime->DayLightSaving | sTime->StoreOperation);
 80185fe:	e9d5 3003 	ldrd	r3, r0, [r5, #12]
    hrtc->Instance->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
 8018602:	600a      	str	r2, [r1, #0]
    hrtc->Instance->CR &= (uint32_t)~RTC_CR_BKP;
 8018604:	688a      	ldr	r2, [r1, #8]
    hrtc->Instance->CR |= (uint32_t)(sTime->DayLightSaving | sTime->StoreOperation);
 8018606:	4303      	orrs	r3, r0
    hrtc->Instance->CR &= (uint32_t)~RTC_CR_BKP;
 8018608:	f422 2280 	bic.w	r2, r2, #262144	@ 0x40000
 801860c:	608a      	str	r2, [r1, #8]
    hrtc->Instance->CR |= (uint32_t)(sTime->DayLightSaving | sTime->StoreOperation);
 801860e:	688a      	ldr	r2, [r1, #8]
 8018610:	4313      	orrs	r3, r2
 8018612:	608b      	str	r3, [r1, #8]
  CLEAR_BIT(hrtc->Instance->ISR, RTC_ISR_INIT);
 8018614:	68cb      	ldr	r3, [r1, #12]
 8018616:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 801861a:	60cb      	str	r3, [r1, #12]
  if (READ_BIT(hrtc->Instance->CR, RTC_CR_BYPSHAD) == 0U)
 801861c:	688b      	ldr	r3, [r1, #8]
 801861e:	069a      	lsls	r2, r3, #26
 8018620:	d526      	bpl.n	8018670 <HAL_RTC_SetTime+0x120>
    hrtc->State = HAL_RTC_STATE_READY;
 8018622:	2301      	movs	r3, #1
    status = RTC_ExitInitMode(hrtc);
 8018624:	2700      	movs	r7, #0
    hrtc->State = HAL_RTC_STATE_READY;
 8018626:	7773      	strb	r3, [r6, #29]
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8018628:	22ff      	movs	r2, #255	@ 0xff
  __HAL_UNLOCK(hrtc);
 801862a:	2300      	movs	r3, #0
}
 801862c:	4638      	mov	r0, r7
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 801862e:	624a      	str	r2, [r1, #36]	@ 0x24
  __HAL_UNLOCK(hrtc);
 8018630:	7733      	strb	r3, [r6, #28]
}
 8018632:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    SET_BIT(hrtc->Instance->ISR, RTC_ISR_INIT);
 8018636:	68cb      	ldr	r3, [r1, #12]
 8018638:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 801863c:	60cb      	str	r3, [r1, #12]
    tickstart = HAL_GetTick();
 801863e:	f7fa fc15 	bl	8012e6c <HAL_GetTick>
 8018642:	4680      	mov	r8, r0
    while ((READ_BIT(hrtc->Instance->ISR, RTC_ISR_INITF) == 0U) && (status != HAL_ERROR))
 8018644:	e008      	b.n	8018658 <HAL_RTC_SetTime+0x108>
 8018646:	2f01      	cmp	r7, #1
 8018648:	d0ee      	beq.n	8018628 <HAL_RTC_SetTime+0xd8>
      if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
 801864a:	f7fa fc0f 	bl	8012e6c <HAL_GetTick>
 801864e:	eba0 0008 	sub.w	r0, r0, r8
 8018652:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
 8018656:	d81c      	bhi.n	8018692 <HAL_RTC_SetTime+0x142>
    while ((READ_BIT(hrtc->Instance->ISR, RTC_ISR_INITF) == 0U) && (status != HAL_ERROR))
 8018658:	6831      	ldr	r1, [r6, #0]
 801865a:	68cb      	ldr	r3, [r1, #12]
 801865c:	0658      	lsls	r0, r3, #25
 801865e:	d5f2      	bpl.n	8018646 <HAL_RTC_SetTime+0xf6>
  if (status == HAL_OK)
 8018660:	2f00      	cmp	r7, #0
 8018662:	d1e1      	bne.n	8018628 <HAL_RTC_SetTime+0xd8>
 8018664:	e7c9      	b.n	80185fa <HAL_RTC_SetTime+0xaa>
      sTime->TimeFormat = 0x00U;
 8018666:	70eb      	strb	r3, [r5, #3]
 8018668:	e7b7      	b.n	80185da <HAL_RTC_SetTime+0x8a>
      sTime->TimeFormat = 0x00U;
 801866a:	f885 c003 	strb.w	ip, [r5, #3]
 801866e:	e785      	b.n	801857c <HAL_RTC_SetTime+0x2c>
  hrtc->Instance->ISR = ((uint32_t)(RTC_RSF_MASK & RTC_ISR_RESERVED_MASK));
 8018670:	4b0f      	ldr	r3, [pc, #60]	@ (80186b0 <HAL_RTC_SetTime+0x160>)
 8018672:	60cb      	str	r3, [r1, #12]
  tickstart = HAL_GetTick();
 8018674:	f7fa fbfa 	bl	8012e6c <HAL_GetTick>
 8018678:	4604      	mov	r4, r0
  while ((hrtc->Instance->ISR & RTC_ISR_RSF) == 0U)
 801867a:	e005      	b.n	8018688 <HAL_RTC_SetTime+0x138>
    if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
 801867c:	f7fa fbf6 	bl	8012e6c <HAL_GetTick>
 8018680:	1b00      	subs	r0, r0, r4
 8018682:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
 8018686:	d80c      	bhi.n	80186a2 <HAL_RTC_SetTime+0x152>
  while ((hrtc->Instance->ISR & RTC_ISR_RSF) == 0U)
 8018688:	6831      	ldr	r1, [r6, #0]
 801868a:	68cb      	ldr	r3, [r1, #12]
 801868c:	069b      	lsls	r3, r3, #26
 801868e:	d5f5      	bpl.n	801867c <HAL_RTC_SetTime+0x12c>
 8018690:	e7c7      	b.n	8018622 <HAL_RTC_SetTime+0xd2>
        hrtc->State = HAL_RTC_STATE_ERROR;
 8018692:	2304      	movs	r3, #4
        status = HAL_ERROR;
 8018694:	2701      	movs	r7, #1
        hrtc->State = HAL_RTC_STATE_ERROR;
 8018696:	7773      	strb	r3, [r6, #29]
        status = HAL_ERROR;
 8018698:	e7de      	b.n	8018658 <HAL_RTC_SetTime+0x108>
  __HAL_LOCK(hrtc);
 801869a:	2702      	movs	r7, #2
}
 801869c:	4638      	mov	r0, r7
 801869e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      hrtc->State = HAL_RTC_STATE_ERROR;
 80186a2:	2304      	movs	r3, #4
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80186a4:	6831      	ldr	r1, [r6, #0]
      status = HAL_ERROR;
 80186a6:	2701      	movs	r7, #1
      hrtc->State = HAL_RTC_STATE_ERROR;
 80186a8:	7773      	strb	r3, [r6, #29]
  if (status == HAL_OK)
 80186aa:	e7bd      	b.n	8018628 <HAL_RTC_SetTime+0xd8>
 80186ac:	007f7f7f 	.word	0x007f7f7f
 80186b0:	0001ff5f 	.word	0x0001ff5f

080186b4 <HAL_RTC_SetDate>:
{
 80186b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(hrtc);
 80186b6:	7f03      	ldrb	r3, [r0, #28]
 80186b8:	2b01      	cmp	r3, #1
 80186ba:	f000 8098 	beq.w	80187ee <HAL_RTC_SetDate+0x13a>
 80186be:	4605      	mov	r5, r0
  hrtc->State = HAL_RTC_STATE_BUSY;
 80186c0:	2302      	movs	r3, #2
  __HAL_LOCK(hrtc);
 80186c2:	2001      	movs	r0, #1
  hrtc->State = HAL_RTC_STATE_BUSY;
 80186c4:	776b      	strb	r3, [r5, #29]
  __HAL_LOCK(hrtc);
 80186c6:	7728      	strb	r0, [r5, #28]
                  (((uint32_t)sDate->WeekDay) << RTC_DR_WDU_Pos));
 80186c8:	f891 e000 	ldrb.w	lr, [r1]
    datetmpreg = ((((uint32_t)sDate->Year)    << RTC_DR_YU_Pos) | \
 80186cc:	78cb      	ldrb	r3, [r1, #3]
                  (((uint32_t)sDate->Month)   << RTC_DR_MU_Pos) | \
 80186ce:	f891 c001 	ldrb.w	ip, [r1, #1]
                  (((uint32_t)sDate->WeekDay) << RTC_DR_WDU_Pos));
 80186d2:	ea4f 3e4e 	mov.w	lr, lr, lsl #13
                  ((uint32_t) sDate->Date)                      | \
 80186d6:	7888      	ldrb	r0, [r1, #2]
  if ((Format == RTC_FORMAT_BIN) && ((sDate->Month & 0x10U) == 0x10U))
 80186d8:	b302      	cbz	r2, 801871c <HAL_RTC_SetDate+0x68>
    datetmpreg = ((((uint32_t)sDate->Year)    << RTC_DR_YU_Pos) | \
 80186da:	ea4e 4403 	orr.w	r4, lr, r3, lsl #16
 80186de:	4304      	orrs	r4, r0
 80186e0:	ea44 240c 	orr.w	r4, r4, ip, lsl #8
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 80186e4:	682b      	ldr	r3, [r5, #0]
 80186e6:	21ca      	movs	r1, #202	@ 0xca
 80186e8:	2253      	movs	r2, #83	@ 0x53
 80186ea:	6259      	str	r1, [r3, #36]	@ 0x24
 80186ec:	625a      	str	r2, [r3, #36]	@ 0x24
  if (READ_BIT(hrtc->Instance->ISR, RTC_ISR_INITF) == 0U)
 80186ee:	68de      	ldr	r6, [r3, #12]
 80186f0:	f016 0640 	ands.w	r6, r6, #64	@ 0x40
 80186f4:	d04c      	beq.n	8018790 <HAL_RTC_SetDate+0xdc>
    hrtc->Instance->DR = (uint32_t)(datetmpreg & RTC_DR_RESERVED_MASK);
 80186f6:	4a43      	ldr	r2, [pc, #268]	@ (8018804 <HAL_RTC_SetDate+0x150>)
 80186f8:	4022      	ands	r2, r4
 80186fa:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(hrtc->Instance->ISR, RTC_ISR_INIT);
 80186fc:	68da      	ldr	r2, [r3, #12]
 80186fe:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
 8018702:	60da      	str	r2, [r3, #12]
  if (READ_BIT(hrtc->Instance->CR, RTC_CR_BYPSHAD) == 0U)
 8018704:	689a      	ldr	r2, [r3, #8]
 8018706:	0691      	lsls	r1, r2, #26
 8018708:	d55c      	bpl.n	80187c4 <HAL_RTC_SetDate+0x110>
    hrtc->State = HAL_RTC_STATE_READY;
 801870a:	2201      	movs	r2, #1
    status = RTC_ExitInitMode(hrtc);
 801870c:	2600      	movs	r6, #0
    hrtc->State = HAL_RTC_STATE_READY;
 801870e:	776a      	strb	r2, [r5, #29]
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8018710:	21ff      	movs	r1, #255	@ 0xff
  __HAL_UNLOCK(hrtc);
 8018712:	2200      	movs	r2, #0
}
 8018714:	4630      	mov	r0, r6
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8018716:	6259      	str	r1, [r3, #36]	@ 0x24
  __HAL_UNLOCK(hrtc);
 8018718:	772a      	strb	r2, [r5, #28]
}
 801871a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if ((Format == RTC_FORMAT_BIN) && ((sDate->Month & 0x10U) == 0x10U))
 801871c:	f01c 0f10 	tst.w	ip, #16
 8018720:	d04d      	beq.n	80187be <HAL_RTC_SetDate+0x10a>
    sDate->Month = (uint8_t)((sDate->Month & (uint8_t)~(0x10U)) + (uint8_t)0x0AU);
 8018722:	f02c 0c10 	bic.w	ip, ip, #16
  while (number >= 10U)
 8018726:	2b09      	cmp	r3, #9
    sDate->Month = (uint8_t)((sDate->Month & (uint8_t)~(0x10U)) + (uint8_t)0x0AU);
 8018728:	f10c 0c0a 	add.w	ip, ip, #10
 801872c:	fa5f fc8c 	uxtb.w	ip, ip
 8018730:	f881 c001 	strb.w	ip, [r1, #1]
  while (number >= 10U)
 8018734:	d95e      	bls.n	80187f4 <HAL_RTC_SetDate+0x140>
  uint32_t bcdhigh = 0U;
 8018736:	2100      	movs	r1, #0
    number -= 10U;
 8018738:	3b0a      	subs	r3, #10
    bcdhigh++;
 801873a:	3101      	adds	r1, #1
    number -= 10U;
 801873c:	b2db      	uxtb	r3, r3
  while (number >= 10U)
 801873e:	2b09      	cmp	r3, #9
 8018740:	d8fa      	bhi.n	8018738 <HAL_RTC_SetDate+0x84>
  return ((uint8_t)(bcdhigh << 4U) | number);
 8018742:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
 8018746:	b2db      	uxtb	r3, r3
  while (number >= 10U)
 8018748:	f1bc 0f09 	cmp.w	ip, #9
    datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year)  << RTC_DR_YU_Pos) | \
 801874c:	ea4f 4403 	mov.w	r4, r3, lsl #16
  while (number >= 10U)
 8018750:	d90c      	bls.n	801876c <HAL_RTC_SetDate+0xb8>
  uint32_t bcdhigh = 0U;
 8018752:	2300      	movs	r3, #0
    number -= 10U;
 8018754:	f1ac 0c0a 	sub.w	ip, ip, #10
    bcdhigh++;
 8018758:	3301      	adds	r3, #1
    number -= 10U;
 801875a:	fa5f fc8c 	uxtb.w	ip, ip
  while (number >= 10U)
 801875e:	f1bc 0f09 	cmp.w	ip, #9
 8018762:	d8f7      	bhi.n	8018754 <HAL_RTC_SetDate+0xa0>
  return ((uint8_t)(bcdhigh << 4U) | number);
 8018764:	ea4c 1303 	orr.w	r3, ip, r3, lsl #4
 8018768:	fa5f fc83 	uxtb.w	ip, r3
  while (number >= 10U)
 801876c:	2809      	cmp	r0, #9
                  ((uint32_t)RTC_ByteToBcd2(sDate->Month) << RTC_DR_MU_Pos) | \
 801876e:	ea4f 2c0c 	mov.w	ip, ip, lsl #8
  while (number >= 10U)
 8018772:	d907      	bls.n	8018784 <HAL_RTC_SetDate+0xd0>
    number -= 10U;
 8018774:	380a      	subs	r0, #10
    bcdhigh++;
 8018776:	3201      	adds	r2, #1
    number -= 10U;
 8018778:	b2c0      	uxtb	r0, r0
  while (number >= 10U)
 801877a:	2809      	cmp	r0, #9
 801877c:	d8fa      	bhi.n	8018774 <HAL_RTC_SetDate+0xc0>
  return ((uint8_t)(bcdhigh << 4U) | number);
 801877e:	ea40 1202 	orr.w	r2, r0, r2, lsl #4
 8018782:	b2d0      	uxtb	r0, r2
    datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year)  << RTC_DR_YU_Pos) | \
 8018784:	ea44 040e 	orr.w	r4, r4, lr
 8018788:	ea44 040c 	orr.w	r4, r4, ip
 801878c:	4304      	orrs	r4, r0
 801878e:	e7a9      	b.n	80186e4 <HAL_RTC_SetDate+0x30>
    SET_BIT(hrtc->Instance->ISR, RTC_ISR_INIT);
 8018790:	68da      	ldr	r2, [r3, #12]
 8018792:	f042 0280 	orr.w	r2, r2, #128	@ 0x80
 8018796:	60da      	str	r2, [r3, #12]
    tickstart = HAL_GetTick();
 8018798:	f7fa fb68 	bl	8012e6c <HAL_GetTick>
 801879c:	4607      	mov	r7, r0
    while ((READ_BIT(hrtc->Instance->ISR, RTC_ISR_INITF) == 0U) && (status != HAL_ERROR))
 801879e:	e007      	b.n	80187b0 <HAL_RTC_SetDate+0xfc>
 80187a0:	2e01      	cmp	r6, #1
 80187a2:	d0b5      	beq.n	8018710 <HAL_RTC_SetDate+0x5c>
      if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
 80187a4:	f7fa fb62 	bl	8012e6c <HAL_GetTick>
 80187a8:	1bc0      	subs	r0, r0, r7
 80187aa:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
 80187ae:	d81a      	bhi.n	80187e6 <HAL_RTC_SetDate+0x132>
    while ((READ_BIT(hrtc->Instance->ISR, RTC_ISR_INITF) == 0U) && (status != HAL_ERROR))
 80187b0:	682b      	ldr	r3, [r5, #0]
 80187b2:	68da      	ldr	r2, [r3, #12]
 80187b4:	0650      	lsls	r0, r2, #25
 80187b6:	d5f3      	bpl.n	80187a0 <HAL_RTC_SetDate+0xec>
  if (status == HAL_OK)
 80187b8:	2e00      	cmp	r6, #0
 80187ba:	d1a9      	bne.n	8018710 <HAL_RTC_SetDate+0x5c>
 80187bc:	e79b      	b.n	80186f6 <HAL_RTC_SetDate+0x42>
  while (number >= 10U)
 80187be:	2b09      	cmp	r3, #9
 80187c0:	d8b9      	bhi.n	8018736 <HAL_RTC_SetDate+0x82>
 80187c2:	e7c1      	b.n	8018748 <HAL_RTC_SetDate+0x94>
  hrtc->Instance->ISR = ((uint32_t)(RTC_RSF_MASK & RTC_ISR_RESERVED_MASK));
 80187c4:	4a10      	ldr	r2, [pc, #64]	@ (8018808 <HAL_RTC_SetDate+0x154>)
 80187c6:	60da      	str	r2, [r3, #12]
  tickstart = HAL_GetTick();
 80187c8:	f7fa fb50 	bl	8012e6c <HAL_GetTick>
 80187cc:	4604      	mov	r4, r0
  while ((hrtc->Instance->ISR & RTC_ISR_RSF) == 0U)
 80187ce:	e005      	b.n	80187dc <HAL_RTC_SetDate+0x128>
    if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
 80187d0:	f7fa fb4c 	bl	8012e6c <HAL_GetTick>
 80187d4:	1b00      	subs	r0, r0, r4
 80187d6:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
 80187da:	d80d      	bhi.n	80187f8 <HAL_RTC_SetDate+0x144>
  while ((hrtc->Instance->ISR & RTC_ISR_RSF) == 0U)
 80187dc:	682b      	ldr	r3, [r5, #0]
 80187de:	68da      	ldr	r2, [r3, #12]
 80187e0:	0692      	lsls	r2, r2, #26
 80187e2:	d5f5      	bpl.n	80187d0 <HAL_RTC_SetDate+0x11c>
 80187e4:	e791      	b.n	801870a <HAL_RTC_SetDate+0x56>
        hrtc->State = HAL_RTC_STATE_ERROR;
 80187e6:	2304      	movs	r3, #4
        status = HAL_ERROR;
 80187e8:	2601      	movs	r6, #1
        hrtc->State = HAL_RTC_STATE_ERROR;
 80187ea:	776b      	strb	r3, [r5, #29]
        status = HAL_ERROR;
 80187ec:	e7e0      	b.n	80187b0 <HAL_RTC_SetDate+0xfc>
  __HAL_LOCK(hrtc);
 80187ee:	2602      	movs	r6, #2
}
 80187f0:	4630      	mov	r0, r6
 80187f2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year)  << RTC_DR_YU_Pos) | \
 80187f4:	041c      	lsls	r4, r3, #16
  while (number >= 10U)
 80187f6:	e7ac      	b.n	8018752 <HAL_RTC_SetDate+0x9e>
      hrtc->State = HAL_RTC_STATE_ERROR;
 80187f8:	2204      	movs	r2, #4
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80187fa:	682b      	ldr	r3, [r5, #0]
      status = HAL_ERROR;
 80187fc:	2601      	movs	r6, #1
      hrtc->State = HAL_RTC_STATE_ERROR;
 80187fe:	776a      	strb	r2, [r5, #29]
  if (status == HAL_OK)
 8018800:	e786      	b.n	8018710 <HAL_RTC_SetDate+0x5c>
 8018802:	bf00      	nop
 8018804:	00ffff3f 	.word	0x00ffff3f
 8018808:	0001ff5f 	.word	0x0001ff5f

0801880c <HAL_RTC_SetAlarm>:
{
 801880c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(hrtc);
 801880e:	7f03      	ldrb	r3, [r0, #28]
 8018810:	2b01      	cmp	r3, #1
 8018812:	f000 80ca 	beq.w	80189aa <HAL_RTC_SetAlarm+0x19e>
 8018816:	4604      	mov	r4, r0
  hrtc->State = HAL_RTC_STATE_BUSY;
 8018818:	2302      	movs	r3, #2
  __HAL_LOCK(hrtc);
 801881a:	2001      	movs	r0, #1
    if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
 801881c:	6825      	ldr	r5, [r4, #0]
  __HAL_LOCK(hrtc);
 801881e:	7720      	strb	r0, [r4, #28]
  hrtc->State = HAL_RTC_STATE_BUSY;
 8018820:	7763      	strb	r3, [r4, #29]
  if (Format == RTC_FORMAT_BIN)
 8018822:	2a00      	cmp	r2, #0
 8018824:	d04b      	beq.n	80188be <HAL_RTC_SetAlarm+0xb2>
    if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
 8018826:	68aa      	ldr	r2, [r5, #8]
 8018828:	f012 0240 	ands.w	r2, r2, #64	@ 0x40
 801882c:	f000 80b8 	beq.w	80189a0 <HAL_RTC_SetAlarm+0x194>
              ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << RTC_TR_PM_Pos)      | \
 8018830:	78cb      	ldrb	r3, [r1, #3]
 8018832:	059a      	lsls	r2, r3, #22
    tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours)      << RTC_ALRMAR_HU_Pos)  | \
 8018834:	69cb      	ldr	r3, [r1, #28]
 8018836:	6948      	ldr	r0, [r1, #20]
 8018838:	ea43 0600 	orr.w	r6, r3, r0
              ((uint32_t) sAlarm->AlarmTime.Seconds)                           | \
 801883c:	788b      	ldrb	r3, [r1, #2]
    tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours)      << RTC_ALRMAR_HU_Pos)  | \
 801883e:	431e      	orrs	r6, r3
 8018840:	780b      	ldrb	r3, [r1, #0]
 8018842:	ea46 4603 	orr.w	r6, r6, r3, lsl #16
              ((uint32_t)(sAlarm->AlarmTime.Minutes)    << RTC_ALRMAR_MNU_Pos) | \
 8018846:	784b      	ldrb	r3, [r1, #1]
    tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours)      << RTC_ALRMAR_HU_Pos)  | \
 8018848:	ea46 2603 	orr.w	r6, r6, r3, lsl #8
              ((uint32_t)(sAlarm->AlarmDateWeekDay)     << RTC_ALRMAR_DU_Pos)  | \
 801884c:	f891 3020 	ldrb.w	r3, [r1, #32]
    tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours)      << RTC_ALRMAR_HU_Pos)  | \
 8018850:	ea46 6603 	orr.w	r6, r6, r3, lsl #24
 8018854:	4316      	orrs	r6, r2
  subsecondtmpreg = (uint32_t)((uint32_t)(sAlarm->AlarmTime.SubSeconds) | \
 8018856:	698b      	ldr	r3, [r1, #24]
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8018858:	22ca      	movs	r2, #202	@ 0xca
  subsecondtmpreg = (uint32_t)((uint32_t)(sAlarm->AlarmTime.SubSeconds) | \
 801885a:	684f      	ldr	r7, [r1, #4]
 801885c:	431f      	orrs	r7, r3
  if (sAlarm->Alarm == RTC_ALARM_A)
 801885e:	6a4b      	ldr	r3, [r1, #36]	@ 0x24
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8018860:	626a      	str	r2, [r5, #36]	@ 0x24
 8018862:	2253      	movs	r2, #83	@ 0x53
  if (sAlarm->Alarm == RTC_ALARM_A)
 8018864:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8018868:	626a      	str	r2, [r5, #36]	@ 0x24
    __HAL_RTC_ALARMA_DISABLE(hrtc);
 801886a:	68ab      	ldr	r3, [r5, #8]
  if (sAlarm->Alarm == RTC_ALARM_A)
 801886c:	d077      	beq.n	801895e <HAL_RTC_SetAlarm+0x152>
    __HAL_RTC_ALARMB_DISABLE(hrtc);
 801886e:	f423 7300 	bic.w	r3, r3, #512	@ 0x200
 8018872:	60ab      	str	r3, [r5, #8]
    __HAL_RTC_ALARM_DISABLE_IT(hrtc, RTC_IT_ALRB);
 8018874:	68ab      	ldr	r3, [r5, #8]
 8018876:	f423 5300 	bic.w	r3, r3, #8192	@ 0x2000
 801887a:	60ab      	str	r3, [r5, #8]
    __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRBF);
 801887c:	68eb      	ldr	r3, [r5, #12]
 801887e:	b2db      	uxtb	r3, r3
 8018880:	f463 7320 	orn	r3, r3, #640	@ 0x280
 8018884:	60eb      	str	r3, [r5, #12]
    tickstart = HAL_GetTick();
 8018886:	f7fa faf1 	bl	8012e6c <HAL_GetTick>
 801888a:	4605      	mov	r5, r0
    while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBWF) == 0U)
 801888c:	e005      	b.n	801889a <HAL_RTC_SetAlarm+0x8e>
      if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
 801888e:	f7fa faed 	bl	8012e6c <HAL_GetTick>
 8018892:	1b40      	subs	r0, r0, r5
 8018894:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
 8018898:	d858      	bhi.n	801894c <HAL_RTC_SetAlarm+0x140>
    while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBWF) == 0U)
 801889a:	6823      	ldr	r3, [r4, #0]
 801889c:	68da      	ldr	r2, [r3, #12]
 801889e:	0792      	lsls	r2, r2, #30
 80188a0:	d5f5      	bpl.n	801888e <HAL_RTC_SetAlarm+0x82>
    hrtc->Instance->ALRMBR = (uint32_t)tmpreg;
 80188a2:	621e      	str	r6, [r3, #32]
    hrtc->Instance->ALRMBSSR = subsecondtmpreg;
 80188a4:	649f      	str	r7, [r3, #72]	@ 0x48
    __HAL_RTC_ALARMB_ENABLE(hrtc);
 80188a6:	689a      	ldr	r2, [r3, #8]
 80188a8:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 80188ac:	609a      	str	r2, [r3, #8]
  __HAL_UNLOCK(hrtc);
 80188ae:	2200      	movs	r2, #0
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80188b0:	20ff      	movs	r0, #255	@ 0xff
  hrtc->State = HAL_RTC_STATE_READY;
 80188b2:	2101      	movs	r1, #1
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80188b4:	6258      	str	r0, [r3, #36]	@ 0x24
  return HAL_OK;
 80188b6:	4610      	mov	r0, r2
  hrtc->State = HAL_RTC_STATE_READY;
 80188b8:	7761      	strb	r1, [r4, #29]
  __HAL_UNLOCK(hrtc);
 80188ba:	7722      	strb	r2, [r4, #28]
}
 80188bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
 80188be:	68ab      	ldr	r3, [r5, #8]
 80188c0:	f013 0e40 	ands.w	lr, r3, #64	@ 0x40
 80188c4:	d06e      	beq.n	80189a4 <HAL_RTC_SetAlarm+0x198>
              ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << RTC_TR_PM_Pos)      | \
 80188c6:	f891 e003 	ldrb.w	lr, [r1, #3]
 80188ca:	ea4f 5e8e 	mov.w	lr, lr, lsl #22
    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours)   << RTC_ALRMAR_HU_Pos)  | \
 80188ce:	780b      	ldrb	r3, [r1, #0]
    if (sAlarm->AlarmDateWeekDaySel == RTC_ALARMDATEWEEKDAYSEL_DATE)
 80188d0:	69c8      	ldr	r0, [r1, #28]
  while (number >= 10U)
 80188d2:	2b09      	cmp	r3, #9
 80188d4:	d908      	bls.n	80188e8 <HAL_RTC_SetAlarm+0xdc>
  uint32_t bcdhigh = 0U;
 80188d6:	2600      	movs	r6, #0
    number -= 10U;
 80188d8:	3b0a      	subs	r3, #10
    bcdhigh++;
 80188da:	3601      	adds	r6, #1
    number -= 10U;
 80188dc:	b2db      	uxtb	r3, r3
  while (number >= 10U)
 80188de:	2b09      	cmp	r3, #9
 80188e0:	d8fa      	bhi.n	80188d8 <HAL_RTC_SetAlarm+0xcc>
  return ((uint8_t)(bcdhigh << 4U) | number);
 80188e2:	ea43 1306 	orr.w	r3, r3, r6, lsl #4
 80188e6:	b2db      	uxtb	r3, r3
    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours)   << RTC_ALRMAR_HU_Pos)  | \
 80188e8:	ea4f 4c03 	mov.w	ip, r3, lsl #16
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << RTC_ALRMAR_MNU_Pos) | \
 80188ec:	784b      	ldrb	r3, [r1, #1]
  while (number >= 10U)
 80188ee:	2b09      	cmp	r3, #9
 80188f0:	d908      	bls.n	8018904 <HAL_RTC_SetAlarm+0xf8>
  uint32_t bcdhigh = 0U;
 80188f2:	2600      	movs	r6, #0
    number -= 10U;
 80188f4:	3b0a      	subs	r3, #10
    bcdhigh++;
 80188f6:	3601      	adds	r6, #1
    number -= 10U;
 80188f8:	b2db      	uxtb	r3, r3
  while (number >= 10U)
 80188fa:	2b09      	cmp	r3, #9
 80188fc:	d8fa      	bhi.n	80188f4 <HAL_RTC_SetAlarm+0xe8>
  return ((uint8_t)(bcdhigh << 4U) | number);
 80188fe:	ea43 1306 	orr.w	r3, r3, r6, lsl #4
 8018902:	b2db      	uxtb	r3, r3
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds))                       | \
 8018904:	788f      	ldrb	r7, [r1, #2]
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << RTC_ALRMAR_MNU_Pos) | \
 8018906:	021b      	lsls	r3, r3, #8
  while (number >= 10U)
 8018908:	2f09      	cmp	r7, #9
 801890a:	d908      	bls.n	801891e <HAL_RTC_SetAlarm+0x112>
  uint32_t bcdhigh = 0U;
 801890c:	2600      	movs	r6, #0
    number -= 10U;
 801890e:	3f0a      	subs	r7, #10
    bcdhigh++;
 8018910:	3601      	adds	r6, #1
    number -= 10U;
 8018912:	b2ff      	uxtb	r7, r7
  while (number >= 10U)
 8018914:	2f09      	cmp	r7, #9
 8018916:	d8fa      	bhi.n	801890e <HAL_RTC_SetAlarm+0x102>
  return ((uint8_t)(bcdhigh << 4U) | number);
 8018918:	ea47 1606 	orr.w	r6, r7, r6, lsl #4
 801891c:	b2f7      	uxtb	r7, r6
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmDateWeekDay)  << RTC_ALRMAR_DU_Pos)  | \
 801891e:	f891 6020 	ldrb.w	r6, [r1, #32]
  while (number >= 10U)
 8018922:	2e09      	cmp	r6, #9
 8018924:	d907      	bls.n	8018936 <HAL_RTC_SetAlarm+0x12a>
    number -= 10U;
 8018926:	3e0a      	subs	r6, #10
    bcdhigh++;
 8018928:	3201      	adds	r2, #1
    number -= 10U;
 801892a:	b2f6      	uxtb	r6, r6
  while (number >= 10U)
 801892c:	2e09      	cmp	r6, #9
 801892e:	d8fa      	bhi.n	8018926 <HAL_RTC_SetAlarm+0x11a>
  return ((uint8_t)(bcdhigh << 4U) | number);
 8018930:	ea46 1202 	orr.w	r2, r6, r2, lsl #4
 8018934:	b2d6      	uxtb	r6, r2
    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours)   << RTC_ALRMAR_HU_Pos)  | \
 8018936:	694a      	ldr	r2, [r1, #20]
 8018938:	4310      	orrs	r0, r2
 801893a:	ea40 000e 	orr.w	r0, r0, lr
 801893e:	ea40 000c 	orr.w	r0, r0, ip
 8018942:	4303      	orrs	r3, r0
 8018944:	433b      	orrs	r3, r7
 8018946:	ea43 6606 	orr.w	r6, r3, r6, lsl #24
 801894a:	e784      	b.n	8018856 <HAL_RTC_SetAlarm+0x4a>
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 801894c:	6822      	ldr	r2, [r4, #0]
 801894e:	21ff      	movs	r1, #255	@ 0xff
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8018950:	2303      	movs	r3, #3
        return HAL_TIMEOUT;
 8018952:	2003      	movs	r0, #3
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8018954:	6251      	str	r1, [r2, #36]	@ 0x24
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8018956:	7763      	strb	r3, [r4, #29]
        __HAL_UNLOCK(hrtc);
 8018958:	2300      	movs	r3, #0
 801895a:	7723      	strb	r3, [r4, #28]
}
 801895c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    __HAL_RTC_ALARMA_DISABLE(hrtc);
 801895e:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 8018962:	60ab      	str	r3, [r5, #8]
    __HAL_RTC_ALARM_DISABLE_IT(hrtc, RTC_IT_ALRA);
 8018964:	68ab      	ldr	r3, [r5, #8]
 8018966:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 801896a:	60ab      	str	r3, [r5, #8]
    __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRAF);
 801896c:	68eb      	ldr	r3, [r5, #12]
 801896e:	b2db      	uxtb	r3, r3
 8018970:	f463 73c0 	orn	r3, r3, #384	@ 0x180
 8018974:	60eb      	str	r3, [r5, #12]
    tickstart = HAL_GetTick();
 8018976:	f7fa fa79 	bl	8012e6c <HAL_GetTick>
 801897a:	4605      	mov	r5, r0
    while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAWF) == 0U)
 801897c:	e005      	b.n	801898a <HAL_RTC_SetAlarm+0x17e>
      if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
 801897e:	f7fa fa75 	bl	8012e6c <HAL_GetTick>
 8018982:	1b40      	subs	r0, r0, r5
 8018984:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
 8018988:	d8e0      	bhi.n	801894c <HAL_RTC_SetAlarm+0x140>
    while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAWF) == 0U)
 801898a:	6823      	ldr	r3, [r4, #0]
 801898c:	68da      	ldr	r2, [r3, #12]
 801898e:	07d1      	lsls	r1, r2, #31
 8018990:	d5f5      	bpl.n	801897e <HAL_RTC_SetAlarm+0x172>
    hrtc->Instance->ALRMAR = (uint32_t)tmpreg;
 8018992:	61de      	str	r6, [r3, #28]
    hrtc->Instance->ALRMASSR = subsecondtmpreg;
 8018994:	645f      	str	r7, [r3, #68]	@ 0x44
    __HAL_RTC_ALARMA_ENABLE(hrtc);
 8018996:	689a      	ldr	r2, [r3, #8]
 8018998:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 801899c:	609a      	str	r2, [r3, #8]
 801899e:	e786      	b.n	80188ae <HAL_RTC_SetAlarm+0xa2>
      sAlarm->AlarmTime.TimeFormat = 0x00U;
 80189a0:	70ca      	strb	r2, [r1, #3]
 80189a2:	e747      	b.n	8018834 <HAL_RTC_SetAlarm+0x28>
      sAlarm->AlarmTime.TimeFormat = 0x00U;
 80189a4:	f881 e003 	strb.w	lr, [r1, #3]
 80189a8:	e791      	b.n	80188ce <HAL_RTC_SetAlarm+0xc2>
  __HAL_LOCK(hrtc);
 80189aa:	2002      	movs	r0, #2
}
 80189ac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80189ae:	bf00      	nop

080189b0 <HAL_RTCEx_SetTimeStamp>:
  /* Check the parameters */
  assert_param(IS_TIMESTAMP_EDGE(RTC_TimeStampEdge));
  assert_param(IS_RTC_TIMESTAMP_PIN(RTC_TimeStampPin));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 80189b0:	7f03      	ldrb	r3, [r0, #28]
 80189b2:	2b01      	cmp	r3, #1
 80189b4:	d02f      	beq.n	8018a16 <HAL_RTCEx_SetTimeStamp+0x66>

  /* Change RTC state to BUSY */
  hrtc->State = HAL_RTC_STATE_BUSY;

  hrtc->Instance->OR &= (uint32_t)~RTC_OR_TSINSEL;
 80189b6:	6803      	ldr	r3, [r0, #0]
 80189b8:	4684      	mov	ip, r0
  hrtc->State = HAL_RTC_STATE_BUSY;
 80189ba:	2002      	movs	r0, #2
{
 80189bc:	b410      	push	{r4}
  hrtc->State = HAL_RTC_STATE_BUSY;
 80189be:	f88c 001d 	strb.w	r0, [ip, #29]

  /* Enable the Timestamp saving */
  __HAL_RTC_TIMESTAMP_ENABLE(hrtc);

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80189c2:	24ff      	movs	r4, #255	@ 0xff
  hrtc->Instance->OR &= (uint32_t)~RTC_OR_TSINSEL;
 80189c4:	6cd8      	ldr	r0, [r3, #76]	@ 0x4c
 80189c6:	f020 0006 	bic.w	r0, r0, #6
 80189ca:	64d8      	str	r0, [r3, #76]	@ 0x4c
  hrtc->Instance->OR |= (uint32_t)(RTC_TimeStampPin);
 80189cc:	6cd8      	ldr	r0, [r3, #76]	@ 0x4c
 80189ce:	4302      	orrs	r2, r0
  tmpreg = (uint32_t)(hrtc->Instance->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
 80189d0:	4812      	ldr	r0, [pc, #72]	@ (8018a1c <HAL_RTCEx_SetTimeStamp+0x6c>)
  hrtc->Instance->OR |= (uint32_t)(RTC_TimeStampPin);
 80189d2:	64da      	str	r2, [r3, #76]	@ 0x4c
  tmpreg = (uint32_t)(hrtc->Instance->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
 80189d4:	689a      	ldr	r2, [r3, #8]
 80189d6:	4010      	ands	r0, r2
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 80189d8:	22ca      	movs	r2, #202	@ 0xca
  tmpreg |= RTC_TimeStampEdge;
 80189da:	4308      	orrs	r0, r1
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 80189dc:	625a      	str	r2, [r3, #36]	@ 0x24
 80189de:	2253      	movs	r2, #83	@ 0x53

  /* Change RTC state back to READY */
  hrtc->State = HAL_RTC_STATE_READY;

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 80189e0:	2100      	movs	r1, #0
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 80189e2:	625a      	str	r2, [r3, #36]	@ 0x24
  hrtc->Instance->CR = (uint32_t)tmpreg;
 80189e4:	6098      	str	r0, [r3, #8]

  return HAL_OK;
 80189e6:	4608      	mov	r0, r1
  __HAL_RTC_TIMESTAMP_CLEAR_FLAG(hrtc, RTC_FLAG_TSF);
 80189e8:	68da      	ldr	r2, [r3, #12]
 80189ea:	b2d2      	uxtb	r2, r2
 80189ec:	f462 6208 	orn	r2, r2, #2176	@ 0x880
 80189f0:	60da      	str	r2, [r3, #12]
  __HAL_RTC_TIMESTAMP_CLEAR_FLAG(hrtc, RTC_FLAG_TSOVF);
 80189f2:	68da      	ldr	r2, [r3, #12]
 80189f4:	b2d2      	uxtb	r2, r2
 80189f6:	f462 5284 	orn	r2, r2, #4224	@ 0x1080
 80189fa:	60da      	str	r2, [r3, #12]
  __HAL_RTC_TIMESTAMP_ENABLE(hrtc);
 80189fc:	689a      	ldr	r2, [r3, #8]
 80189fe:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
 8018a02:	609a      	str	r2, [r3, #8]
  hrtc->State = HAL_RTC_STATE_READY;
 8018a04:	2201      	movs	r2, #1
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8018a06:	625c      	str	r4, [r3, #36]	@ 0x24
  hrtc->State = HAL_RTC_STATE_READY;
 8018a08:	f88c 201d 	strb.w	r2, [ip, #29]
  __HAL_UNLOCK(hrtc);
 8018a0c:	f88c 101c 	strb.w	r1, [ip, #28]
}
 8018a10:	f85d 4b04 	ldr.w	r4, [sp], #4
 8018a14:	4770      	bx	lr
  __HAL_LOCK(hrtc);
 8018a16:	2002      	movs	r0, #2
}
 8018a18:	4770      	bx	lr
 8018a1a:	bf00      	nop
 8018a1c:	fffff7f7 	.word	0xfffff7f7

08018a20 <HAL_SAI_Init>:
  uint32_t tmpregisterGCR = 0;
  uint32_t ckstr_bits = 0;
  uint32_t syncen_bits = 0;

  /* Check the SAI handle allocation */
  if (hsai == NULL)
 8018a20:	2800      	cmp	r0, #0
 8018a22:	f000 80f7 	beq.w	8018c14 <HAL_SAI_Init+0x1f4>
{
 8018a26:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_SAI_BLOCK_FIRSTBIT_OFFSET(hsai->SlotInit.FirstBitOffset));
  assert_param(IS_SAI_BLOCK_SLOT_SIZE(hsai->SlotInit.SlotSize));
  assert_param(IS_SAI_BLOCK_SLOT_NUMBER(hsai->SlotInit.SlotNumber));
  assert_param(IS_SAI_SLOT_ACTIVE(hsai->SlotInit.SlotActive));

  if (hsai->State == HAL_SAI_STATE_RESET)
 8018a28:	f890 307d 	ldrb.w	r3, [r0, #125]	@ 0x7d
 8018a2c:	4604      	mov	r4, r0
 8018a2e:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
 8018a32:	2b00      	cmp	r3, #0
 8018a34:	f000 80e3 	beq.w	8018bfe <HAL_SAI_Init+0x1de>
  *                the configuration information for SAI module.
  * @retval None
  */
static HAL_StatusTypeDef SAI_Disable(SAI_HandleTypeDef *hsai)
{
  uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7 / 1000);
 8018a38:	4b77      	ldr	r3, [pc, #476]	@ (8018c18 <HAL_SAI_Init+0x1f8>)
  hsai->State = HAL_SAI_STATE_BUSY;
 8018a3a:	2002      	movs	r0, #2
  uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7 / 1000);
 8018a3c:	4977      	ldr	r1, [pc, #476]	@ (8018c1c <HAL_SAI_Init+0x1fc>)
  HAL_StatusTypeDef status = HAL_OK;

  /* Disable the SAI instance */
  __HAL_SAI_DISABLE(hsai);
 8018a3e:	6822      	ldr	r2, [r4, #0]
  uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7 / 1000);
 8018a40:	681b      	ldr	r3, [r3, #0]
  hsai->State = HAL_SAI_STATE_BUSY;
 8018a42:	f884 007d 	strb.w	r0, [r4, #125]	@ 0x7d
  uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7 / 1000);
 8018a46:	fba1 1303 	umull	r1, r3, r1, r3
  __HAL_SAI_DISABLE(hsai);
 8018a4a:	6811      	ldr	r1, [r2, #0]
  uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7 / 1000);
 8018a4c:	0b1b      	lsrs	r3, r3, #12
  __HAL_SAI_DISABLE(hsai);
 8018a4e:	f421 3180 	bic.w	r1, r1, #65536	@ 0x10000
  uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7 / 1000);
 8018a52:	4083      	lsls	r3, r0
  __HAL_SAI_DISABLE(hsai);
 8018a54:	6011      	str	r1, [r2, #0]
 8018a56:	e002      	b.n	8018a5e <HAL_SAI_Init+0x3e>
      hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
      status = HAL_TIMEOUT;
      break;
    }
  }
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != RESET);
 8018a58:	6811      	ldr	r1, [r2, #0]
 8018a5a:	03cd      	lsls	r5, r1, #15
 8018a5c:	d507      	bpl.n	8018a6e <HAL_SAI_Init+0x4e>
    if (count-- == 0)
 8018a5e:	3b01      	subs	r3, #1
 8018a60:	d2fa      	bcs.n	8018a58 <HAL_SAI_Init+0x38>
      hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
 8018a62:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
 8018a66:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8018a6a:	f8c4 3080 	str.w	r3, [r4, #128]	@ 0x80
  switch (hsai->Init.SynchroExt)
 8018a6e:	68e3      	ldr	r3, [r4, #12]
 8018a70:	2b01      	cmp	r3, #1
 8018a72:	f000 80c1 	beq.w	8018bf8 <HAL_SAI_Init+0x1d8>
 8018a76:	2b02      	cmp	r3, #2
 8018a78:	bf0b      	itete	eq
 8018a7a:	2021      	moveq	r0, #33	@ 0x21
 8018a7c:	2001      	movne	r0, #1
 8018a7e:	2120      	moveq	r1, #32
 8018a80:	2100      	movne	r1, #0
  switch (hsai->Init.Synchro)
 8018a82:	68a3      	ldr	r3, [r4, #8]
 8018a84:	2b02      	cmp	r3, #2
 8018a86:	d058      	beq.n	8018b3a <HAL_SAI_Init+0x11a>
 8018a88:	2b03      	cmp	r3, #3
 8018a8a:	d055      	beq.n	8018b38 <HAL_SAI_Init+0x118>
 8018a8c:	f1a3 0301 	sub.w	r3, r3, #1
 8018a90:	fab3 f383 	clz	r3, r3
 8018a94:	095b      	lsrs	r3, r3, #5
 8018a96:	029d      	lsls	r5, r3, #10
  if ((hsai->Instance == SAI1_Block_A) || (hsai->Instance == SAI1_Block_B))
 8018a98:	4b61      	ldr	r3, [pc, #388]	@ (8018c20 <HAL_SAI_Init+0x200>)
  if (hsai->Init.AudioFrequency != SAI_AUDIO_FREQUENCY_MCKDIV)
 8018a9a:	69e0      	ldr	r0, [r4, #28]
  if ((hsai->Instance == SAI1_Block_A) || (hsai->Instance == SAI1_Block_B))
 8018a9c:	429a      	cmp	r2, r3
 8018a9e:	d015      	beq.n	8018acc <HAL_SAI_Init+0xac>
 8018aa0:	3320      	adds	r3, #32
 8018aa2:	429a      	cmp	r2, r3
 8018aa4:	d012      	beq.n	8018acc <HAL_SAI_Init+0xac>
    SAI2->GCR = tmpregisterGCR;
 8018aa6:	4b5f      	ldr	r3, [pc, #380]	@ (8018c24 <HAL_SAI_Init+0x204>)
 8018aa8:	f8c3 1c00 	str.w	r1, [r3, #3072]	@ 0xc00
  if (hsai->Init.AudioFrequency != SAI_AUDIO_FREQUENCY_MCKDIV)
 8018aac:	2800      	cmp	r0, #0
 8018aae:	d047      	beq.n	8018b40 <HAL_SAI_Init+0x120>
    if ((hsai->Instance == SAI2_Block_A) || (hsai->Instance == SAI2_Block_B))
 8018ab0:	4b5d      	ldr	r3, [pc, #372]	@ (8018c28 <HAL_SAI_Init+0x208>)
 8018ab2:	429a      	cmp	r2, r3
 8018ab4:	f000 80a8 	beq.w	8018c08 <HAL_SAI_Init+0x1e8>
 8018ab8:	3320      	adds	r3, #32
 8018aba:	1ad3      	subs	r3, r2, r3
 8018abc:	fab3 f383 	clz	r3, r3
 8018ac0:	095b      	lsrs	r3, r3, #5
 8018ac2:	2b00      	cmp	r3, #0
 8018ac4:	f040 80a0 	bne.w	8018c08 <HAL_SAI_Init+0x1e8>
 8018ac8:	4619      	mov	r1, r3
 8018aca:	e023      	b.n	8018b14 <HAL_SAI_Init+0xf4>
    SAI1->GCR = tmpregisterGCR;
 8018acc:	4b55      	ldr	r3, [pc, #340]	@ (8018c24 <HAL_SAI_Init+0x204>)
 8018ace:	f8c3 1800 	str.w	r1, [r3, #2048]	@ 0x800
  if (hsai->Init.AudioFrequency != SAI_AUDIO_FREQUENCY_MCKDIV)
 8018ad2:	b3a8      	cbz	r0, 8018b40 <HAL_SAI_Init+0x120>
      freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI1);
 8018ad4:	f44f 2000 	mov.w	r0, #524288	@ 0x80000
 8018ad8:	f7ff fc52 	bl	8018380 <HAL_RCCEx_GetPeriphCLKFreq>
    if ((hsai->Instance == SAI2_Block_A) || (hsai->Instance == SAI2_Block_B))
 8018adc:	6822      	ldr	r2, [r4, #0]
 8018ade:	4b52      	ldr	r3, [pc, #328]	@ (8018c28 <HAL_SAI_Init+0x208>)
 8018ae0:	429a      	cmp	r2, r3
 8018ae2:	f000 8091 	beq.w	8018c08 <HAL_SAI_Init+0x1e8>
 8018ae6:	3320      	adds	r3, #32
 8018ae8:	429a      	cmp	r2, r3
 8018aea:	f000 808d 	beq.w	8018c08 <HAL_SAI_Init+0x1e8>
    tmpval = (freq * 10) / (hsai->Init.AudioFrequency * 2 * 256);
 8018aee:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8018af2:	69e1      	ldr	r1, [r4, #28]
 8018af4:	0043      	lsls	r3, r0, #1
 8018af6:	0249      	lsls	r1, r1, #9
 8018af8:	fbb3 f3f1 	udiv	r3, r3, r1
    hsai->Init.Mckdiv = tmpval / 10;
 8018afc:	494b      	ldr	r1, [pc, #300]	@ (8018c2c <HAL_SAI_Init+0x20c>)
 8018afe:	fba1 0103 	umull	r0, r1, r1, r3
 8018b02:	08c9      	lsrs	r1, r1, #3
    if ((tmpval % 10) > 8)
 8018b04:	eb01 0081 	add.w	r0, r1, r1, lsl #2
 8018b08:	eba3 0340 	sub.w	r3, r3, r0, lsl #1
 8018b0c:	2b09      	cmp	r3, #9
      hsai->Init.Mckdiv += 1;
 8018b0e:	bf08      	it	eq
 8018b10:	3101      	addeq	r1, #1
 8018b12:	460b      	mov	r3, r1
    if (hsai->Init.Protocol == SAI_SPDIF_PROTOCOL)
 8018b14:	6b26      	ldr	r6, [r4, #48]	@ 0x30
    hsai->Init.Mckdiv = tmpval / 10;
 8018b16:	6223      	str	r3, [r4, #32]
    if (hsai->Init.Protocol == SAI_SPDIF_PROTOCOL)
 8018b18:	2e04      	cmp	r6, #4
 8018b1a:	d113      	bne.n	8018b44 <HAL_SAI_Init+0x124>
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 8018b1c:	6863      	ldr	r3, [r4, #4]
      hsai->Init.Mckdiv = hsai->Init.Mckdiv >> 1;
 8018b1e:	0849      	lsrs	r1, r1, #1
    ckstr_bits = (hsai->Init.ClockStrobing == SAI_CLOCKSTROBING_RISINGEDGE) ? 0 : SAI_xCR1_CKSTR;
 8018b20:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 8018b22:	f033 0702 	bics.w	r7, r3, #2
      hsai->Init.Mckdiv = hsai->Init.Mckdiv >> 1;
 8018b26:	6221      	str	r1, [r4, #32]
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 8018b28:	d011      	beq.n	8018b4e <HAL_SAI_Init+0x12e>
    ckstr_bits = (hsai->Init.ClockStrobing == SAI_CLOCKSTROBING_RISINGEDGE) ? SAI_xCR1_CKSTR : 0;
 8018b2a:	f1a0 0001 	sub.w	r0, r0, #1
 8018b2e:	fab0 f080 	clz	r0, r0
 8018b32:	0940      	lsrs	r0, r0, #5
 8018b34:	0240      	lsls	r0, r0, #9
 8018b36:	e00e      	b.n	8018b56 <HAL_SAI_Init+0x136>
      tmpregisterGCR |= SAI_GCR_SYNCIN_0;
 8018b38:	4601      	mov	r1, r0
      syncen_bits = SAI_xCR1_SYNCEN_1;
 8018b3a:	f44f 6500 	mov.w	r5, #2048	@ 0x800
 8018b3e:	e7ab      	b.n	8018a98 <HAL_SAI_Init+0x78>
  hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
 8018b40:	6b26      	ldr	r6, [r4, #48]	@ 0x30
                          hsai->Init.NoDivider | (hsai->Init.Mckdiv << 20));
 8018b42:	6a21      	ldr	r1, [r4, #32]
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 8018b44:	6863      	ldr	r3, [r4, #4]
    ckstr_bits = (hsai->Init.ClockStrobing == SAI_CLOCKSTROBING_RISINGEDGE) ? 0 : SAI_xCR1_CKSTR;
 8018b46:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 8018b48:	f033 0702 	bics.w	r7, r3, #2
 8018b4c:	d1ed      	bne.n	8018b2a <HAL_SAI_Init+0x10a>
    ckstr_bits = (hsai->Init.ClockStrobing == SAI_CLOCKSTROBING_RISINGEDGE) ? 0 : SAI_xCR1_CKSTR;
 8018b4e:	3801      	subs	r0, #1
 8018b50:	bf18      	it	ne
 8018b52:	2001      	movne	r0, #1
 8018b54:	0240      	lsls	r0, r0, #9
  hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
 8018b56:	6b67      	ldr	r7, [r4, #52]	@ 0x34
 8018b58:	433b      	orrs	r3, r7
 8018b5a:	6ba7      	ldr	r7, [r4, #56]	@ 0x38
 8018b5c:	433b      	orrs	r3, r7
 8018b5e:	6a67      	ldr	r7, [r4, #36]	@ 0x24
 8018b60:	433b      	orrs	r3, r7
 8018b62:	6927      	ldr	r7, [r4, #16]
 8018b64:	433b      	orrs	r3, r7
 8018b66:	6967      	ldr	r7, [r4, #20]
 8018b68:	433b      	orrs	r3, r7
 8018b6a:	432b      	orrs	r3, r5
  hsai->Instance->CR1 &= ~(SAI_xCR1_MODE | SAI_xCR1_PRTCFG |  SAI_xCR1_DS |      \
 8018b6c:	4d30      	ldr	r5, [pc, #192]	@ (8018c30 <HAL_SAI_Init+0x210>)
  hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
 8018b6e:	4333      	orrs	r3, r6
  hsai->Instance->CR1 &= ~(SAI_xCR1_MODE | SAI_xCR1_PRTCFG |  SAI_xCR1_DS |      \
 8018b70:	6816      	ldr	r6, [r2, #0]
 8018b72:	4035      	ands	r5, r6
 8018b74:	6015      	str	r5, [r2, #0]
  hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
 8018b76:	6815      	ldr	r5, [r2, #0]
 8018b78:	432b      	orrs	r3, r5
  hsai->Instance->CR2 &= ~(SAI_xCR2_FTH | SAI_xCR2_FFLUSH | SAI_xCR2_COMP | SAI_xCR2_CPL);
 8018b7a:	4d2e      	ldr	r5, [pc, #184]	@ (8018c34 <HAL_SAI_Init+0x214>)
  hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
 8018b7c:	ea43 5301 	orr.w	r3, r3, r1, lsl #20
  hsai->Instance->CR2 |= (hsai->Init.FIFOThreshold | hsai->Init.CompandingMode | hsai->Init.TriState);
 8018b80:	69a1      	ldr	r1, [r4, #24]
  hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
 8018b82:	4303      	orrs	r3, r0
  hsai->Instance->FRCR &= (~(SAI_xFRCR_FRL | SAI_xFRCR_FSALL | SAI_xFRCR_FSDEF | \
 8018b84:	482c      	ldr	r0, [pc, #176]	@ (8018c38 <HAL_SAI_Init+0x218>)
  hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
 8018b86:	6013      	str	r3, [r2, #0]
  hsai->Instance->CR2 &= ~(SAI_xCR2_FTH | SAI_xCR2_FFLUSH | SAI_xCR2_COMP | SAI_xCR2_CPL);
 8018b88:	6853      	ldr	r3, [r2, #4]
 8018b8a:	401d      	ands	r5, r3
  hsai->Instance->CR2 |= (hsai->Init.FIFOThreshold | hsai->Init.CompandingMode | hsai->Init.TriState);
 8018b8c:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 8018b8e:	4319      	orrs	r1, r3
 8018b90:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
  hsai->Instance->CR2 &= ~(SAI_xCR2_FTH | SAI_xCR2_FFLUSH | SAI_xCR2_COMP | SAI_xCR2_CPL);
 8018b92:	6055      	str	r5, [r2, #4]
  hsai->Instance->CR2 |= (hsai->Init.FIFOThreshold | hsai->Init.CompandingMode | hsai->Init.TriState);
 8018b94:	4319      	orrs	r1, r3
 8018b96:	6855      	ldr	r5, [r2, #4]
  hsai->Instance->FRCR |= ((hsai->FrameInit.FrameLength - 1) |
 8018b98:	6d23      	ldr	r3, [r4, #80]	@ 0x50
  hsai->Instance->CR2 |= (hsai->Init.FIFOThreshold | hsai->Init.CompandingMode | hsai->Init.TriState);
 8018b9a:	4329      	orrs	r1, r5
  hsai->Instance->SLOTR &= (~(SAI_xSLOTR_FBOFF | SAI_xSLOTR_SLOTSZ |            \
 8018b9c:	f24f 0520 	movw	r5, #61472	@ 0xf020
  hsai->Instance->CR2 |= (hsai->Init.FIFOThreshold | hsai->Init.CompandingMode | hsai->Init.TriState);
 8018ba0:	6051      	str	r1, [r2, #4]
  hsai->Instance->FRCR &= (~(SAI_xFRCR_FRL | SAI_xFRCR_FSALL | SAI_xFRCR_FSDEF | \
 8018ba2:	6891      	ldr	r1, [r2, #8]
 8018ba4:	4008      	ands	r0, r1
  hsai->Instance->FRCR |= ((hsai->FrameInit.FrameLength - 1) |
 8018ba6:	6ca1      	ldr	r1, [r4, #72]	@ 0x48
 8018ba8:	430b      	orrs	r3, r1
 8018baa:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
  hsai->Instance->FRCR &= (~(SAI_xFRCR_FRL | SAI_xFRCR_FSALL | SAI_xFRCR_FSDEF | \
 8018bac:	6090      	str	r0, [r2, #8]
  hsai->Instance->FRCR |= ((hsai->FrameInit.FrameLength - 1) |
 8018bae:	430b      	orrs	r3, r1
 8018bb0:	6c21      	ldr	r1, [r4, #64]	@ 0x40
 8018bb2:	6890      	ldr	r0, [r2, #8]
 8018bb4:	3901      	subs	r1, #1
 8018bb6:	430b      	orrs	r3, r1
                           ((hsai->FrameInit.ActiveFrameLength - 1) << 8));
 8018bb8:	6c61      	ldr	r1, [r4, #68]	@ 0x44
 8018bba:	3901      	subs	r1, #1
  hsai->Instance->FRCR |= ((hsai->FrameInit.FrameLength - 1) |
 8018bbc:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
  hsai->Instance->SLOTR |=  hsai->SlotInit.FirstBitOffset |  hsai->SlotInit.SlotSize
 8018bc0:	6d61      	ldr	r1, [r4, #84]	@ 0x54
  hsai->Instance->FRCR |= ((hsai->FrameInit.FrameLength - 1) |
 8018bc2:	4303      	orrs	r3, r0
 8018bc4:	6093      	str	r3, [r2, #8]
  hsai->Instance->SLOTR |=  hsai->SlotInit.FirstBitOffset |  hsai->SlotInit.SlotSize
 8018bc6:	6da3      	ldr	r3, [r4, #88]	@ 0x58
  hsai->Instance->SLOTR &= (~(SAI_xSLOTR_FBOFF | SAI_xSLOTR_SLOTSZ |            \
 8018bc8:	68d0      	ldr	r0, [r2, #12]
  hsai->Instance->SLOTR |=  hsai->SlotInit.FirstBitOffset |  hsai->SlotInit.SlotSize
 8018bca:	430b      	orrs	r3, r1
                            | (hsai->SlotInit.SlotActive << 16) | ((hsai->SlotInit.SlotNumber - 1) <<  8);
 8018bcc:	6e21      	ldr	r1, [r4, #96]	@ 0x60
  hsai->Instance->SLOTR &= (~(SAI_xSLOTR_FBOFF | SAI_xSLOTR_SLOTSZ |            \
 8018bce:	4028      	ands	r0, r5
  hsai->Instance->SLOTR |=  hsai->SlotInit.FirstBitOffset |  hsai->SlotInit.SlotSize
 8018bd0:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
                            | (hsai->SlotInit.SlotActive << 16) | ((hsai->SlotInit.SlotNumber - 1) <<  8);
 8018bd4:	6de1      	ldr	r1, [r4, #92]	@ 0x5c
  hsai->Instance->SLOTR &= (~(SAI_xSLOTR_FBOFF | SAI_xSLOTR_SLOTSZ |            \
 8018bd6:	60d0      	str	r0, [r2, #12]
                            | (hsai->SlotInit.SlotActive << 16) | ((hsai->SlotInit.SlotNumber - 1) <<  8);
 8018bd8:	3901      	subs	r1, #1
  hsai->Instance->SLOTR |=  hsai->SlotInit.FirstBitOffset |  hsai->SlotInit.SlotSize
 8018bda:	68d0      	ldr	r0, [r2, #12]
 8018bdc:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
  hsai->ErrorCode = HAL_SAI_ERROR_NONE;
 8018be0:	2100      	movs	r1, #0
  hsai->Instance->SLOTR |=  hsai->SlotInit.FirstBitOffset |  hsai->SlotInit.SlotSize
 8018be2:	4303      	orrs	r3, r0
  return HAL_OK;
 8018be4:	4608      	mov	r0, r1
  hsai->Instance->SLOTR |=  hsai->SlotInit.FirstBitOffset |  hsai->SlotInit.SlotSize
 8018be6:	60d3      	str	r3, [r2, #12]
  hsai->State = HAL_SAI_STATE_READY;
 8018be8:	2301      	movs	r3, #1
  hsai->ErrorCode = HAL_SAI_ERROR_NONE;
 8018bea:	f8c4 1080 	str.w	r1, [r4, #128]	@ 0x80
  __HAL_UNLOCK(hsai);
 8018bee:	f884 107c 	strb.w	r1, [r4, #124]	@ 0x7c
  hsai->State = HAL_SAI_STATE_READY;
 8018bf2:	f884 307d 	strb.w	r3, [r4, #125]	@ 0x7d
}
 8018bf6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  switch (hsai->Init.SynchroExt)
 8018bf8:	2011      	movs	r0, #17
 8018bfa:	2110      	movs	r1, #16
 8018bfc:	e741      	b.n	8018a82 <HAL_SAI_Init+0x62>
    hsai->Lock = HAL_UNLOCKED;
 8018bfe:	f880 207c 	strb.w	r2, [r0, #124]	@ 0x7c
    HAL_SAI_MspInit(hsai);
 8018c02:	f7f9 ffe1 	bl	8012bc8 <HAL_SAI_MspInit>
 8018c06:	e717      	b.n	8018a38 <HAL_SAI_Init+0x18>
      freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI2);
 8018c08:	f44f 1080 	mov.w	r0, #1048576	@ 0x100000
 8018c0c:	f7ff fbb8 	bl	8018380 <HAL_RCCEx_GetPeriphCLKFreq>
 8018c10:	6822      	ldr	r2, [r4, #0]
 8018c12:	e76c      	b.n	8018aee <HAL_SAI_Init+0xce>
    return HAL_ERROR;
 8018c14:	2001      	movs	r0, #1
}
 8018c16:	4770      	bx	lr
 8018c18:	2000000c 	.word	0x2000000c
 8018c1c:	95cbec1b 	.word	0x95cbec1b
 8018c20:	40015804 	.word	0x40015804
 8018c24:	40015000 	.word	0x40015000
 8018c28:	40015c04 	.word	0x40015c04
 8018c2c:	cccccccd 	.word	0xcccccccd
 8018c30:	ff05c010 	.word	0xff05c010
 8018c34:	ffff1ff0 	.word	0xffff1ff0
 8018c38:	fff88000 	.word	0xfff88000

08018c3c <SD_DMATransmitCplt>:
static void SD_DMATransmitCplt(DMA_HandleTypeDef *hdma)
{
  SD_HandleTypeDef* hsd = (SD_HandleTypeDef* )(hdma->Parent);

  /* Enable DATAEND Interrupt */
  __HAL_SD_ENABLE_IT(hsd, (SDMMC_IT_DATAEND));
 8018c3c:	6b83      	ldr	r3, [r0, #56]	@ 0x38
 8018c3e:	681a      	ldr	r2, [r3, #0]
 8018c40:	6bd3      	ldr	r3, [r2, #60]	@ 0x3c
 8018c42:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8018c46:	63d3      	str	r3, [r2, #60]	@ 0x3c
}
 8018c48:	4770      	bx	lr
 8018c4a:	bf00      	nop

08018c4c <SD_FindSCR.constprop.0>:
  * @brief  Finds the SD card SCR register value.
  * @param  hsd: Pointer to SD handle
  * @param  pSCR: pointer to the buffer that will contain the SCR value
  * @retval error state
  */
static uint32_t SD_FindSCR(SD_HandleTypeDef *hsd, uint32_t *pSCR)
 8018c4c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8018c4e:	4605      	mov	r5, r0
 8018c50:	b089      	sub	sp, #36	@ 0x24
 8018c52:	460f      	mov	r7, r1
{
  SDMMC_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t tickstart = HAL_GetTick();
 8018c54:	f7fa f90a 	bl	8012e6c <HAL_GetTick>
  uint32_t index = 0U;
  uint32_t tempscr[2U] = {0U, 0U};
 8018c58:	2300      	movs	r3, #0
  uint32_t *scr = pSCR;

  /* Set Block Size To 8 Bytes */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 8U);
 8018c5a:	2108      	movs	r1, #8
  uint32_t tickstart = HAL_GetTick();
 8018c5c:	4606      	mov	r6, r0
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 8U);
 8018c5e:	6828      	ldr	r0, [r5, #0]
  uint32_t tempscr[2U] = {0U, 0U};
 8018c60:	e9cd 3300 	strd	r3, r3, [sp]
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 8U);
 8018c64:	f001 fe12 	bl	801a88c <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
 8018c68:	4604      	mov	r4, r0
 8018c6a:	b110      	cbz	r0, 8018c72 <SD_FindSCR.constprop.0+0x26>
            ((tempscr[0] & SDMMC_16TO23BITS) >> 8) | ((tempscr[0] & SDMMC_24TO31BITS) >> 24));

  }

  return HAL_SD_ERROR_NONE;
}
 8018c6c:	4620      	mov	r0, r4
 8018c6e:	b009      	add	sp, #36	@ 0x24
 8018c70:	bdf0      	pop	{r4, r5, r6, r7, pc}
  errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)((hsd->SdCard.RelCardAdd) << 16U));
 8018c72:	6d29      	ldr	r1, [r5, #80]	@ 0x50
 8018c74:	6828      	ldr	r0, [r5, #0]
 8018c76:	0409      	lsls	r1, r1, #16
 8018c78:	f002 fb00 	bl	801b27c <SDMMC_CmdAppCommand>
  if(errorstate != HAL_SD_ERROR_NONE)
 8018c7c:	4604      	mov	r4, r0
 8018c7e:	2800      	cmp	r0, #0
 8018c80:	d1f4      	bne.n	8018c6c <SD_FindSCR.constprop.0+0x20>
  config.DataTimeOut   = SDMMC_DATATIMEOUT;
 8018c82:	f04f 33ff 	mov.w	r3, #4294967295
  config.DPSM          = SDMMC_DPSM_ENABLE;
 8018c86:	2201      	movs	r2, #1
  config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
 8018c88:	9006      	str	r0, [sp, #24]
  config.DataTimeOut   = SDMMC_DATATIMEOUT;
 8018c8a:	9302      	str	r3, [sp, #8]
  config.DataLength    = 8U;
 8018c8c:	2308      	movs	r3, #8
  config.DPSM          = SDMMC_DPSM_ENABLE;
 8018c8e:	9207      	str	r2, [sp, #28]
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 8018c90:	2230      	movs	r2, #48	@ 0x30
  (void)SDMMC_ConfigData(hsd->Instance, &config);
 8018c92:	eb0d 0103 	add.w	r1, sp, r3
  config.DataLength    = 8U;
 8018c96:	9303      	str	r3, [sp, #12]
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 8018c98:	2302      	movs	r3, #2
  (void)SDMMC_ConfigData(hsd->Instance, &config);
 8018c9a:	6828      	ldr	r0, [r5, #0]
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 8018c9c:	e9cd 2304 	strd	r2, r3, [sp, #16]
  (void)SDMMC_ConfigData(hsd->Instance, &config);
 8018ca0:	f001 fdde 	bl	801a860 <SDMMC_ConfigData>
  errorstate = SDMMC_CmdSendSCR(hsd->Instance);
 8018ca4:	6828      	ldr	r0, [r5, #0]
 8018ca6:	f002 fc7b 	bl	801b5a0 <SDMMC_CmdSendSCR>
  if(errorstate != HAL_SD_ERROR_NONE)
 8018caa:	4604      	mov	r4, r0
 8018cac:	b140      	cbz	r0, 8018cc0 <SD_FindSCR.constprop.0+0x74>
 8018cae:	e7dd      	b.n	8018c6c <SD_FindSCR.constprop.0+0x20>
    else if(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXACT))
 8018cb0:	6b43      	ldr	r3, [r0, #52]	@ 0x34
 8018cb2:	0499      	lsls	r1, r3, #18
 8018cb4:	d515      	bpl.n	8018ce2 <SD_FindSCR.constprop.0+0x96>
    if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
 8018cb6:	f7fa f8d9 	bl	8012e6c <HAL_GetTick>
 8018cba:	1b83      	subs	r3, r0, r6
 8018cbc:	3301      	adds	r3, #1
 8018cbe:	d024      	beq.n	8018d0a <SD_FindSCR.constprop.0+0xbe>
  while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT))
 8018cc0:	6828      	ldr	r0, [r5, #0]
 8018cc2:	6b43      	ldr	r3, [r0, #52]	@ 0x34
 8018cc4:	f013 0f2a 	tst.w	r3, #42	@ 0x2a
 8018cc8:	d10b      	bne.n	8018ce2 <SD_FindSCR.constprop.0+0x96>
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXDAVL))
 8018cca:	6b43      	ldr	r3, [r0, #52]	@ 0x34
 8018ccc:	029b      	lsls	r3, r3, #10
 8018cce:	d5ef      	bpl.n	8018cb0 <SD_FindSCR.constprop.0+0x64>
      *(tempscr + index) = SDMMC_ReadFIFO(hsd->Instance);
 8018cd0:	f001 fdb4 	bl	801a83c <SDMMC_ReadFIFO>
 8018cd4:	ab08      	add	r3, sp, #32
 8018cd6:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 8018cda:	3401      	adds	r4, #1
 8018cdc:	f843 0c20 	str.w	r0, [r3, #-32]
 8018ce0:	e7e9      	b.n	8018cb6 <SD_FindSCR.constprop.0+0x6a>
  if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
 8018ce2:	6b43      	ldr	r3, [r0, #52]	@ 0x34
 8018ce4:	071a      	lsls	r2, r3, #28
 8018ce6:	d417      	bmi.n	8018d18 <SD_FindSCR.constprop.0+0xcc>
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
 8018ce8:	6b43      	ldr	r3, [r0, #52]	@ 0x34
 8018cea:	079b      	lsls	r3, r3, #30
 8018cec:	d418      	bmi.n	8018d20 <SD_FindSCR.constprop.0+0xd4>
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
 8018cee:	6b44      	ldr	r4, [r0, #52]	@ 0x34
 8018cf0:	f014 0420 	ands.w	r4, r4, #32
 8018cf4:	d10c      	bne.n	8018d10 <SD_FindSCR.constprop.0+0xc4>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 8018cf6:	f240 513a 	movw	r1, #1338	@ 0x53a
 8018cfa:	e9dd 3200 	ldrd	r3, r2, [sp]
 8018cfe:	6381      	str	r1, [r0, #56]	@ 0x38
    *scr = (((tempscr[1] & SDMMC_0TO7BITS) << 24)  | ((tempscr[1] & SDMMC_8TO15BITS) << 8) |\
 8018d00:	ba12      	rev	r2, r2
    *scr = (((tempscr[0] & SDMMC_0TO7BITS) << 24)  | ((tempscr[0] & SDMMC_8TO15BITS) << 8) |\
 8018d02:	ba1b      	rev	r3, r3
    *scr = (((tempscr[1] & SDMMC_0TO7BITS) << 24)  | ((tempscr[1] & SDMMC_8TO15BITS) << 8) |\
 8018d04:	e9c7 2300 	strd	r2, r3, [r7]
  return HAL_SD_ERROR_NONE;
 8018d08:	e7b0      	b.n	8018c6c <SD_FindSCR.constprop.0+0x20>
      return HAL_SD_ERROR_TIMEOUT;
 8018d0a:	f04f 4400 	mov.w	r4, #2147483648	@ 0x80000000
 8018d0e:	e7ad      	b.n	8018c6c <SD_FindSCR.constprop.0+0x20>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_RXOVERR);
 8018d10:	2320      	movs	r3, #32
    return HAL_SD_ERROR_RX_OVERRUN;
 8018d12:	461c      	mov	r4, r3
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_RXOVERR);
 8018d14:	6383      	str	r3, [r0, #56]	@ 0x38
    return HAL_SD_ERROR_RX_OVERRUN;
 8018d16:	e7a9      	b.n	8018c6c <SD_FindSCR.constprop.0+0x20>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DTIMEOUT);
 8018d18:	2308      	movs	r3, #8
    return HAL_SD_ERROR_DATA_TIMEOUT;
 8018d1a:	461c      	mov	r4, r3
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DTIMEOUT);
 8018d1c:	6383      	str	r3, [r0, #56]	@ 0x38
    return HAL_SD_ERROR_DATA_TIMEOUT;
 8018d1e:	e7a5      	b.n	8018c6c <SD_FindSCR.constprop.0+0x20>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DCRCFAIL);
 8018d20:	2302      	movs	r3, #2
    return HAL_SD_ERROR_DATA_CRC_FAIL;
 8018d22:	461c      	mov	r4, r3
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DCRCFAIL);
 8018d24:	6383      	str	r3, [r0, #56]	@ 0x38
    return HAL_SD_ERROR_DATA_CRC_FAIL;
 8018d26:	e7a1      	b.n	8018c6c <SD_FindSCR.constprop.0+0x20>

08018d28 <HAL_SD_ReadBlocks_DMA>:
{
 8018d28:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8018d2c:	4604      	mov	r4, r0
 8018d2e:	b087      	sub	sp, #28
  if(NULL == pData)
 8018d30:	2900      	cmp	r1, #0
 8018d32:	d07d      	beq.n	8018e30 <HAL_SD_ReadBlocks_DMA+0x108>
 8018d34:	461d      	mov	r5, r3
  if(hsd->State == HAL_SD_STATE_READY)
 8018d36:	f890 3034 	ldrb.w	r3, [r0, #52]	@ 0x34
 8018d3a:	2b01      	cmp	r3, #1
 8018d3c:	fa5f f883 	uxtb.w	r8, r3
 8018d40:	d163      	bne.n	8018e0a <HAL_SD_ReadBlocks_DMA+0xe2>
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 8018d42:	1953      	adds	r3, r2, r5
 8018d44:	4616      	mov	r6, r2
 8018d46:	6dc2      	ldr	r2, [r0, #92]	@ 0x5c
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
 8018d48:	2700      	movs	r7, #0
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 8018d4a:	4293      	cmp	r3, r2
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
 8018d4c:	6387      	str	r7, [r0, #56]	@ 0x38
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 8018d4e:	d908      	bls.n	8018d62 <HAL_SD_ReadBlocks_DMA+0x3a>
      hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
 8018d50:	6b83      	ldr	r3, [r0, #56]	@ 0x38
 8018d52:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
 8018d56:	6383      	str	r3, [r0, #56]	@ 0x38
    return HAL_ERROR;
 8018d58:	2701      	movs	r7, #1
}
 8018d5a:	4638      	mov	r0, r7
 8018d5c:	b007      	add	sp, #28
 8018d5e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if(HAL_DMA_Start_IT(hsd->hdmarx, (uint32_t)&hsd->Instance->FIFO, (uint32_t)pData, (uint32_t)(BLOCKSIZE * NumberOfBlocks)/4U) != HAL_OK)
 8018d62:	460a      	mov	r2, r1
    hsd->State = HAL_SD_STATE_BUSY;
 8018d64:	2303      	movs	r3, #3
    hsd->Instance->DCTRL = 0U;
 8018d66:	6801      	ldr	r1, [r0, #0]
    if(HAL_DMA_Start_IT(hsd->hdmarx, (uint32_t)&hsd->Instance->FIFO, (uint32_t)pData, (uint32_t)(BLOCKSIZE * NumberOfBlocks)/4U) != HAL_OK)
 8018d68:	ea4f 2945 	mov.w	r9, r5, lsl #9
    hsd->State = HAL_SD_STATE_BUSY;
 8018d6c:	f880 3034 	strb.w	r3, [r0, #52]	@ 0x34
    hsd->Instance->DCTRL = 0U;
 8018d70:	62cf      	str	r7, [r1, #44]	@ 0x2c
    if(HAL_DMA_Start_IT(hsd->hdmarx, (uint32_t)&hsd->Instance->FIFO, (uint32_t)pData, (uint32_t)(BLOCKSIZE * NumberOfBlocks)/4U) != HAL_OK)
 8018d72:	3180      	adds	r1, #128	@ 0x80
    __HAL_SD_ENABLE_IT(hsd, (SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT | SDMMC_IT_RXOVERR | SDMMC_IT_DATAEND));
 8018d74:	f851 3c44 	ldr.w	r3, [r1, #-68]
    hsd->hdmarx->XferCpltCallback = SD_DMAReceiveCplt;
 8018d78:	6c00      	ldr	r0, [r0, #64]	@ 0x40
    __HAL_SD_ENABLE_IT(hsd, (SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT | SDMMC_IT_RXOVERR | SDMMC_IT_DATAEND));
 8018d7a:	f443 7395 	orr.w	r3, r3, #298	@ 0x12a
    hsd->hdmarx->XferErrorCallback = SD_DMAError;
 8018d7e:	f8df c0d0 	ldr.w	ip, [pc, #208]	@ 8018e50 <HAL_SD_ReadBlocks_DMA+0x128>
    __HAL_SD_ENABLE_IT(hsd, (SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT | SDMMC_IT_RXOVERR | SDMMC_IT_DATAEND));
 8018d82:	f841 3c44 	str.w	r3, [r1, #-68]
    hsd->hdmarx->XferAbortCallback = NULL;
 8018d86:	6507      	str	r7, [r0, #80]	@ 0x50
    hsd->hdmarx->Init.Direction = DMA_PERIPH_TO_MEMORY;
 8018d88:	6087      	str	r7, [r0, #8]
    hsd->hdmarx->XferCpltCallback = SD_DMAReceiveCplt;
 8018d8a:	4b2f      	ldr	r3, [pc, #188]	@ (8018e48 <HAL_SD_ReadBlocks_DMA+0x120>)
    MODIFY_REG(hsd->hdmarx->Instance->CR, DMA_SxCR_DIR, hsd->hdmarx->Init.Direction);
 8018d8c:	6807      	ldr	r7, [r0, #0]
    hsd->hdmarx->XferCpltCallback = SD_DMAReceiveCplt;
 8018d8e:	63c3      	str	r3, [r0, #60]	@ 0x3c
    MODIFY_REG(hsd->hdmarx->Instance->CR, DMA_SxCR_DIR, hsd->hdmarx->Init.Direction);
 8018d90:	683b      	ldr	r3, [r7, #0]
    hsd->hdmarx->XferErrorCallback = SD_DMAError;
 8018d92:	f8c0 c04c 	str.w	ip, [r0, #76]	@ 0x4c
    MODIFY_REG(hsd->hdmarx->Instance->CR, DMA_SxCR_DIR, hsd->hdmarx->Init.Direction);
 8018d96:	f023 03c0 	bic.w	r3, r3, #192	@ 0xc0
 8018d9a:	603b      	str	r3, [r7, #0]
    if(HAL_DMA_Start_IT(hsd->hdmarx, (uint32_t)&hsd->Instance->FIFO, (uint32_t)pData, (uint32_t)(BLOCKSIZE * NumberOfBlocks)/4U) != HAL_OK)
 8018d9c:	ea4f 0399 	mov.w	r3, r9, lsr #2
 8018da0:	f7fa fcec 	bl	801377c <HAL_DMA_Start_IT>
 8018da4:	4607      	mov	r7, r0
 8018da6:	2800      	cmp	r0, #0
 8018da8:	d134      	bne.n	8018e14 <HAL_SD_ReadBlocks_DMA+0xec>
      __HAL_SD_DMA_ENABLE(hsd);
 8018daa:	6820      	ldr	r0, [r4, #0]
      config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 8018dac:	2190      	movs	r1, #144	@ 0x90
      if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
 8018dae:	6c62      	ldr	r2, [r4, #68]	@ 0x44
      config.DPSM          = SDMMC_DPSM_ENABLE;
 8018db0:	f04f 0c00 	mov.w	ip, #0
      __HAL_SD_DMA_ENABLE(hsd);
 8018db4:	6ac3      	ldr	r3, [r0, #44]	@ 0x2c
      if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
 8018db6:	2a01      	cmp	r2, #1
      config.DataLength    = BLOCKSIZE * NumberOfBlocks;
 8018db8:	f8cd 9004 	str.w	r9, [sp, #4]
      __HAL_SD_DMA_ENABLE(hsd);
 8018dbc:	f043 0308 	orr.w	r3, r3, #8
        add *= 512U;
 8018dc0:	bf18      	it	ne
 8018dc2:	0276      	lslne	r6, r6, #9
      __HAL_SD_DMA_ENABLE(hsd);
 8018dc4:	62c3      	str	r3, [r0, #44]	@ 0x2c
      config.DataTimeOut   = SDMMC_DATATIMEOUT;
 8018dc6:	f04f 33ff 	mov.w	r3, #4294967295
 8018dca:	9300      	str	r3, [sp, #0]
      config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 8018dcc:	2302      	movs	r3, #2
 8018dce:	e9cd 1302 	strd	r1, r3, [sp, #8]
      config.DPSM          = SDMMC_DPSM_ENABLE;
 8018dd2:	2301      	movs	r3, #1
      (void)SDMMC_ConfigData(hsd->Instance, &config);
 8018dd4:	4669      	mov	r1, sp
      config.DPSM          = SDMMC_DPSM_ENABLE;
 8018dd6:	e9cd c304 	strd	ip, r3, [sp, #16]
      (void)SDMMC_ConfigData(hsd->Instance, &config);
 8018dda:	f001 fd41 	bl	801a860 <SDMMC_ConfigData>
      if(NumberOfBlocks > 1U)
 8018dde:	2d01      	cmp	r5, #1
 8018de0:	d92b      	bls.n	8018e3a <HAL_SD_ReadBlocks_DMA+0x112>
        hsd->Context = (SD_CONTEXT_READ_MULTIPLE_BLOCK | SD_CONTEXT_DMA);
 8018de2:	2382      	movs	r3, #130	@ 0x82
        errorstate = SDMMC_CmdReadMultiBlock(hsd->Instance, add);
 8018de4:	4631      	mov	r1, r6
 8018de6:	6820      	ldr	r0, [r4, #0]
        hsd->Context = (SD_CONTEXT_READ_MULTIPLE_BLOCK | SD_CONTEXT_DMA);
 8018de8:	6323      	str	r3, [r4, #48]	@ 0x30
        errorstate = SDMMC_CmdReadMultiBlock(hsd->Instance, add);
 8018dea:	f001 fea1 	bl	801ab30 <SDMMC_CmdReadMultiBlock>
      if(errorstate != HAL_SD_ERROR_NONE)
 8018dee:	2800      	cmp	r0, #0
 8018df0:	d0b3      	beq.n	8018d5a <HAL_SD_ReadBlocks_DMA+0x32>
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8018df2:	6823      	ldr	r3, [r4, #0]
        hsd->State = HAL_SD_STATE_READY;
 8018df4:	2101      	movs	r1, #1
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8018df6:	4a15      	ldr	r2, [pc, #84]	@ (8018e4c <HAL_SD_ReadBlocks_DMA+0x124>)
 8018df8:	639a      	str	r2, [r3, #56]	@ 0x38
        hsd->Context = SD_CONTEXT_NONE;
 8018dfa:	2200      	movs	r2, #0
        hsd->ErrorCode |= errorstate;
 8018dfc:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 8018dfe:	4303      	orrs	r3, r0
 8018e00:	63a3      	str	r3, [r4, #56]	@ 0x38
        hsd->State = HAL_SD_STATE_READY;
 8018e02:	f884 1034 	strb.w	r1, [r4, #52]	@ 0x34
        hsd->Context = SD_CONTEXT_NONE;
 8018e06:	6322      	str	r2, [r4, #48]	@ 0x30
        return HAL_ERROR;
 8018e08:	e7a6      	b.n	8018d58 <HAL_SD_ReadBlocks_DMA+0x30>
    return HAL_BUSY;
 8018e0a:	2702      	movs	r7, #2
}
 8018e0c:	4638      	mov	r0, r7
 8018e0e:	b007      	add	sp, #28
 8018e10:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      __HAL_SD_DISABLE_IT(hsd, (SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT | SDMMC_IT_RXOVERR | SDMMC_IT_DATAEND));
 8018e14:	6823      	ldr	r3, [r4, #0]
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8018e16:	490d      	ldr	r1, [pc, #52]	@ (8018e4c <HAL_SD_ReadBlocks_DMA+0x124>)
      __HAL_SD_DISABLE_IT(hsd, (SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT | SDMMC_IT_RXOVERR | SDMMC_IT_DATAEND));
 8018e18:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 8018e1a:	f422 7295 	bic.w	r2, r2, #298	@ 0x12a
 8018e1e:	63da      	str	r2, [r3, #60]	@ 0x3c
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8018e20:	6399      	str	r1, [r3, #56]	@ 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_DMA;
 8018e22:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 8018e24:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 8018e28:	63a3      	str	r3, [r4, #56]	@ 0x38
      hsd->State = HAL_SD_STATE_READY;
 8018e2a:	f884 8034 	strb.w	r8, [r4, #52]	@ 0x34
      return HAL_ERROR;
 8018e2e:	e793      	b.n	8018d58 <HAL_SD_ReadBlocks_DMA+0x30>
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 8018e30:	6b83      	ldr	r3, [r0, #56]	@ 0x38
 8018e32:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
 8018e36:	6383      	str	r3, [r0, #56]	@ 0x38
    return HAL_ERROR;
 8018e38:	e78e      	b.n	8018d58 <HAL_SD_ReadBlocks_DMA+0x30>
        hsd->Context = (SD_CONTEXT_READ_SINGLE_BLOCK | SD_CONTEXT_DMA);
 8018e3a:	2381      	movs	r3, #129	@ 0x81
        errorstate = SDMMC_CmdReadSingleBlock(hsd->Instance, add);
 8018e3c:	4631      	mov	r1, r6
 8018e3e:	6820      	ldr	r0, [r4, #0]
        hsd->Context = (SD_CONTEXT_READ_SINGLE_BLOCK | SD_CONTEXT_DMA);
 8018e40:	6323      	str	r3, [r4, #48]	@ 0x30
        errorstate = SDMMC_CmdReadSingleBlock(hsd->Instance, add);
 8018e42:	f001 fdcd 	bl	801a9e0 <SDMMC_CmdReadSingleBlock>
 8018e46:	e7d2      	b.n	8018dee <HAL_SD_ReadBlocks_DMA+0xc6>
 8018e48:	08018f79 	.word	0x08018f79
 8018e4c:	004005ff 	.word	0x004005ff
 8018e50:	08018fc1 	.word	0x08018fc1

08018e54 <HAL_SD_WriteBlocks_DMA>:
{
 8018e54:	b5f0      	push	{r4, r5, r6, r7, lr}
 8018e56:	4604      	mov	r4, r0
 8018e58:	b087      	sub	sp, #28
  if(NULL == pData)
 8018e5a:	460e      	mov	r6, r1
 8018e5c:	2900      	cmp	r1, #0
 8018e5e:	d068      	beq.n	8018f32 <HAL_SD_WriteBlocks_DMA+0xde>
  if(hsd->State == HAL_SD_STATE_READY)
 8018e60:	461d      	mov	r5, r3
 8018e62:	f890 3034 	ldrb.w	r3, [r0, #52]	@ 0x34
 8018e66:	2b01      	cmp	r3, #1
 8018e68:	d12d      	bne.n	8018ec6 <HAL_SD_WriteBlocks_DMA+0x72>
 8018e6a:	4611      	mov	r1, r2
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
 8018e6c:	2200      	movs	r2, #0
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 8018e6e:	194b      	adds	r3, r1, r5
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
 8018e70:	6382      	str	r2, [r0, #56]	@ 0x38
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 8018e72:	6dc0      	ldr	r0, [r0, #92]	@ 0x5c
 8018e74:	4283      	cmp	r3, r0
 8018e76:	d82a      	bhi.n	8018ece <HAL_SD_WriteBlocks_DMA+0x7a>
    hsd->Instance->DCTRL = 0U;
 8018e78:	6820      	ldr	r0, [r4, #0]
    hsd->State = HAL_SD_STATE_BUSY;
 8018e7a:	2303      	movs	r3, #3
 8018e7c:	f884 3034 	strb.w	r3, [r4, #52]	@ 0x34
    hsd->Instance->DCTRL = 0U;
 8018e80:	62c2      	str	r2, [r0, #44]	@ 0x2c
    __HAL_SD_ENABLE_IT(hsd, (SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT | SDMMC_IT_TXUNDERR));   
 8018e82:	6bc3      	ldr	r3, [r0, #60]	@ 0x3c
 8018e84:	f043 031a 	orr.w	r3, r3, #26
 8018e88:	63c3      	str	r3, [r0, #60]	@ 0x3c
    hsd->hdmatx->XferCpltCallback = SD_DMATransmitCplt;
 8018e8a:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
    hsd->hdmatx->XferAbortCallback = NULL;
 8018e8c:	651a      	str	r2, [r3, #80]	@ 0x50
    hsd->hdmatx->XferCpltCallback = SD_DMATransmitCplt;
 8018e8e:	4a36      	ldr	r2, [pc, #216]	@ (8018f68 <HAL_SD_WriteBlocks_DMA+0x114>)
 8018e90:	63da      	str	r2, [r3, #60]	@ 0x3c
    hsd->hdmatx->XferErrorCallback = SD_DMAError;
 8018e92:	4a36      	ldr	r2, [pc, #216]	@ (8018f6c <HAL_SD_WriteBlocks_DMA+0x118>)
 8018e94:	64da      	str	r2, [r3, #76]	@ 0x4c
    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
 8018e96:	6c63      	ldr	r3, [r4, #68]	@ 0x44
 8018e98:	2b01      	cmp	r3, #1
      add *= 512U;
 8018e9a:	bf18      	it	ne
 8018e9c:	0249      	lslne	r1, r1, #9
    if(NumberOfBlocks > 1U)
 8018e9e:	2d01      	cmp	r5, #1
 8018ea0:	d94c      	bls.n	8018f3c <HAL_SD_WriteBlocks_DMA+0xe8>
      hsd->Context = (SD_CONTEXT_WRITE_MULTIPLE_BLOCK | SD_CONTEXT_DMA);
 8018ea2:	23a0      	movs	r3, #160	@ 0xa0
 8018ea4:	6323      	str	r3, [r4, #48]	@ 0x30
      errorstate = SDMMC_CmdWriteMultiBlock(hsd->Instance, add);
 8018ea6:	f001 ff95 	bl	801add4 <SDMMC_CmdWriteMultiBlock>
 8018eaa:	4607      	mov	r7, r0
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8018eac:	6822      	ldr	r2, [r4, #0]
    if(errorstate != HAL_SD_ERROR_NONE)
 8018eae:	b1b7      	cbz	r7, 8018ede <HAL_SD_WriteBlocks_DMA+0x8a>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8018eb0:	4b2f      	ldr	r3, [pc, #188]	@ (8018f70 <HAL_SD_WriteBlocks_DMA+0x11c>)
      hsd->State = HAL_SD_STATE_READY;
 8018eb2:	2101      	movs	r1, #1
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8018eb4:	6393      	str	r3, [r2, #56]	@ 0x38
      hsd->Context = SD_CONTEXT_NONE;
 8018eb6:	2200      	movs	r2, #0
      hsd->ErrorCode |= errorstate;
 8018eb8:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 8018eba:	433b      	orrs	r3, r7
 8018ebc:	63a3      	str	r3, [r4, #56]	@ 0x38
      hsd->State = HAL_SD_STATE_READY;
 8018ebe:	f884 1034 	strb.w	r1, [r4, #52]	@ 0x34
      hsd->Context = SD_CONTEXT_NONE;
 8018ec2:	6322      	str	r2, [r4, #48]	@ 0x30
      return HAL_ERROR;
 8018ec4:	e007      	b.n	8018ed6 <HAL_SD_WriteBlocks_DMA+0x82>
    return HAL_BUSY;
 8018ec6:	2602      	movs	r6, #2
}
 8018ec8:	4630      	mov	r0, r6
 8018eca:	b007      	add	sp, #28
 8018ecc:	bdf0      	pop	{r4, r5, r6, r7, pc}
      hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
 8018ece:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 8018ed0:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
 8018ed4:	63a3      	str	r3, [r4, #56]	@ 0x38
    return HAL_ERROR;
 8018ed6:	2601      	movs	r6, #1
}
 8018ed8:	4630      	mov	r0, r6
 8018eda:	b007      	add	sp, #28
 8018edc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    __HAL_SD_DMA_ENABLE(hsd);
 8018ede:	6ad3      	ldr	r3, [r2, #44]	@ 0x2c
    if(HAL_DMA_Start_IT(hsd->hdmatx, (uint32_t)pData, (uint32_t)&hsd->Instance->FIFO, (uint32_t)(BLOCKSIZE * NumberOfBlocks)/4U) != HAL_OK)
 8018ee0:	4631      	mov	r1, r6
    hsd->hdmatx->Init.Direction = DMA_MEMORY_TO_PERIPH;
 8018ee2:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
    if(HAL_DMA_Start_IT(hsd->hdmatx, (uint32_t)pData, (uint32_t)&hsd->Instance->FIFO, (uint32_t)(BLOCKSIZE * NumberOfBlocks)/4U) != HAL_OK)
 8018ee4:	026d      	lsls	r5, r5, #9
    __HAL_SD_DMA_ENABLE(hsd);
 8018ee6:	f043 0308 	orr.w	r3, r3, #8
    if(HAL_DMA_Start_IT(hsd->hdmatx, (uint32_t)pData, (uint32_t)&hsd->Instance->FIFO, (uint32_t)(BLOCKSIZE * NumberOfBlocks)/4U) != HAL_OK)
 8018eea:	3280      	adds	r2, #128	@ 0x80
    MODIFY_REG(hsd->hdmatx->Instance->CR, DMA_SxCR_DIR, hsd->hdmatx->Init.Direction);
 8018eec:	f8d0 c000 	ldr.w	ip, [r0]
    __HAL_SD_DMA_ENABLE(hsd);
 8018ef0:	f842 3c54 	str.w	r3, [r2, #-84]
    hsd->hdmatx->Init.Direction = DMA_MEMORY_TO_PERIPH;
 8018ef4:	2340      	movs	r3, #64	@ 0x40
    MODIFY_REG(hsd->hdmatx->Instance->CR, DMA_SxCR_DIR, hsd->hdmatx->Init.Direction);
 8018ef6:	f8dc 6000 	ldr.w	r6, [ip]
    hsd->hdmatx->Init.Direction = DMA_MEMORY_TO_PERIPH;
 8018efa:	6083      	str	r3, [r0, #8]
    if(HAL_DMA_Start_IT(hsd->hdmatx, (uint32_t)pData, (uint32_t)&hsd->Instance->FIFO, (uint32_t)(BLOCKSIZE * NumberOfBlocks)/4U) != HAL_OK)
 8018efc:	08ab      	lsrs	r3, r5, #2
    MODIFY_REG(hsd->hdmatx->Instance->CR, DMA_SxCR_DIR, hsd->hdmatx->Init.Direction);
 8018efe:	f026 06c0 	bic.w	r6, r6, #192	@ 0xc0
 8018f02:	f046 0640 	orr.w	r6, r6, #64	@ 0x40
 8018f06:	f8cc 6000 	str.w	r6, [ip]
    if(HAL_DMA_Start_IT(hsd->hdmatx, (uint32_t)pData, (uint32_t)&hsd->Instance->FIFO, (uint32_t)(BLOCKSIZE * NumberOfBlocks)/4U) != HAL_OK)
 8018f0a:	f7fa fc37 	bl	801377c <HAL_DMA_Start_IT>
 8018f0e:	4606      	mov	r6, r0
 8018f10:	b1d0      	cbz	r0, 8018f48 <HAL_SD_WriteBlocks_DMA+0xf4>
      __HAL_SD_DISABLE_IT(hsd, (SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT | SDMMC_IT_TXUNDERR));   
 8018f12:	6823      	ldr	r3, [r4, #0]
      hsd->State = HAL_SD_STATE_READY;
 8018f14:	2101      	movs	r1, #1
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8018f16:	4816      	ldr	r0, [pc, #88]	@ (8018f70 <HAL_SD_WriteBlocks_DMA+0x11c>)
      __HAL_SD_DISABLE_IT(hsd, (SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT | SDMMC_IT_TXUNDERR));   
 8018f18:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 8018f1a:	f022 021a 	bic.w	r2, r2, #26
 8018f1e:	63da      	str	r2, [r3, #60]	@ 0x3c
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8018f20:	6398      	str	r0, [r3, #56]	@ 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_DMA;
 8018f22:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 8018f24:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 8018f28:	63a3      	str	r3, [r4, #56]	@ 0x38
      hsd->State = HAL_SD_STATE_READY;
 8018f2a:	f884 1034 	strb.w	r1, [r4, #52]	@ 0x34
      hsd->Context = SD_CONTEXT_NONE;
 8018f2e:	6327      	str	r7, [r4, #48]	@ 0x30
      return HAL_ERROR;
 8018f30:	e7d1      	b.n	8018ed6 <HAL_SD_WriteBlocks_DMA+0x82>
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 8018f32:	6b83      	ldr	r3, [r0, #56]	@ 0x38
 8018f34:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
 8018f38:	6383      	str	r3, [r0, #56]	@ 0x38
    return HAL_ERROR;
 8018f3a:	e7cc      	b.n	8018ed6 <HAL_SD_WriteBlocks_DMA+0x82>
      hsd->Context = (SD_CONTEXT_WRITE_SINGLE_BLOCK | SD_CONTEXT_DMA);
 8018f3c:	2390      	movs	r3, #144	@ 0x90
 8018f3e:	6323      	str	r3, [r4, #48]	@ 0x30
      errorstate = SDMMC_CmdWriteSingleBlock(hsd->Instance, add);
 8018f40:	f001 fe9e 	bl	801ac80 <SDMMC_CmdWriteSingleBlock>
 8018f44:	4607      	mov	r7, r0
 8018f46:	e7b1      	b.n	8018eac <HAL_SD_WriteBlocks_DMA+0x58>
      config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
 8018f48:	2390      	movs	r3, #144	@ 0x90
      config.DataTimeOut   = SDMMC_DATATIMEOUT;
 8018f4a:	f04f 32ff 	mov.w	r2, #4294967295
      (void)SDMMC_ConfigData(hsd->Instance, &config);
 8018f4e:	6820      	ldr	r0, [r4, #0]
 8018f50:	4669      	mov	r1, sp
      config.DataLength    = BLOCKSIZE * NumberOfBlocks;
 8018f52:	9501      	str	r5, [sp, #4]
      config.DataTimeOut   = SDMMC_DATATIMEOUT;
 8018f54:	9200      	str	r2, [sp, #0]
      config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
 8018f56:	e9cd 3702 	strd	r3, r7, [sp, #8]
      config.DPSM          = SDMMC_DPSM_ENABLE;
 8018f5a:	2301      	movs	r3, #1
 8018f5c:	e9cd 7304 	strd	r7, r3, [sp, #16]
      (void)SDMMC_ConfigData(hsd->Instance, &config);
 8018f60:	f001 fc7e 	bl	801a860 <SDMMC_ConfigData>
      return HAL_OK;
 8018f64:	e7b0      	b.n	8018ec8 <HAL_SD_WriteBlocks_DMA+0x74>
 8018f66:	bf00      	nop
 8018f68:	08018c3d 	.word	0x08018c3d
 8018f6c:	08018fc1 	.word	0x08018fc1
 8018f70:	004005ff 	.word	0x004005ff

08018f74 <HAL_SD_ErrorCallback>:
__weak void HAL_SD_ErrorCallback(SD_HandleTypeDef *hsd)
 8018f74:	4770      	bx	lr
 8018f76:	bf00      	nop

08018f78 <SD_DMAReceiveCplt>:
{
 8018f78:	b510      	push	{r4, lr}
  SD_HandleTypeDef* hsd = (SD_HandleTypeDef* )(hdma->Parent);
 8018f7a:	6b84      	ldr	r4, [r0, #56]	@ 0x38
  if(hsd->Context == (SD_CONTEXT_READ_MULTIPLE_BLOCK | SD_CONTEXT_DMA))
 8018f7c:	6b23      	ldr	r3, [r4, #48]	@ 0x30
    errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
 8018f7e:	6820      	ldr	r0, [r4, #0]
  if(hsd->Context == (SD_CONTEXT_READ_MULTIPLE_BLOCK | SD_CONTEXT_DMA))
 8018f80:	2b82      	cmp	r3, #130	@ 0x82
 8018f82:	d00f      	beq.n	8018fa4 <SD_DMAReceiveCplt+0x2c>
  hsd->Instance->DCTRL &= (uint32_t)~((uint32_t)SDMMC_DCTRL_DMAEN);
 8018f84:	6ac3      	ldr	r3, [r0, #44]	@ 0x2c
  __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 8018f86:	f240 513a 	movw	r1, #1338	@ 0x53a
  hsd->State = HAL_SD_STATE_READY;
 8018f8a:	2201      	movs	r2, #1
  hsd->Instance->DCTRL &= (uint32_t)~((uint32_t)SDMMC_DCTRL_DMAEN);
 8018f8c:	f023 0308 	bic.w	r3, r3, #8
 8018f90:	62c3      	str	r3, [r0, #44]	@ 0x2c
  hsd->Context = SD_CONTEXT_NONE;
 8018f92:	2300      	movs	r3, #0
  __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 8018f94:	6381      	str	r1, [r0, #56]	@ 0x38
  HAL_SD_RxCpltCallback(hsd);
 8018f96:	4620      	mov	r0, r4
  hsd->State = HAL_SD_STATE_READY;
 8018f98:	f884 2034 	strb.w	r2, [r4, #52]	@ 0x34
  hsd->Context = SD_CONTEXT_NONE;
 8018f9c:	6323      	str	r3, [r4, #48]	@ 0x30
  HAL_SD_RxCpltCallback(hsd);
 8018f9e:	f003 fb55 	bl	801c64c <HAL_SD_RxCpltCallback>
}
 8018fa2:	bd10      	pop	{r4, pc}
    errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
 8018fa4:	f001 ffbe 	bl	801af24 <SDMMC_CmdStopTransfer>
    if(errorstate != HAL_SD_ERROR_NONE)
 8018fa8:	4603      	mov	r3, r0
 8018faa:	b908      	cbnz	r0, 8018fb0 <SD_DMAReceiveCplt+0x38>
 8018fac:	6820      	ldr	r0, [r4, #0]
 8018fae:	e7e9      	b.n	8018f84 <SD_DMAReceiveCplt+0xc>
      hsd->ErrorCode |= errorstate;
 8018fb0:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
      HAL_SD_ErrorCallback(hsd);
 8018fb2:	4620      	mov	r0, r4
      hsd->ErrorCode |= errorstate;
 8018fb4:	4313      	orrs	r3, r2
 8018fb6:	63a3      	str	r3, [r4, #56]	@ 0x38
      HAL_SD_ErrorCallback(hsd);
 8018fb8:	f7ff ffdc 	bl	8018f74 <HAL_SD_ErrorCallback>
 8018fbc:	e7f6      	b.n	8018fac <SD_DMAReceiveCplt+0x34>
 8018fbe:	bf00      	nop

08018fc0 <SD_DMAError>:
{
 8018fc0:	b510      	push	{r4, lr}
  SD_HandleTypeDef* hsd = (SD_HandleTypeDef* )(hdma->Parent);
 8018fc2:	6b84      	ldr	r4, [r0, #56]	@ 0x38
  if(HAL_DMA_GetError(hdma) != HAL_DMA_ERROR_FE)
 8018fc4:	f7fa fd4c 	bl	8013a60 <HAL_DMA_GetError>
 8018fc8:	2802      	cmp	r0, #2
 8018fca:	d00a      	beq.n	8018fe2 <SD_DMAError+0x22>
    TxErrorCode = hsd->hdmatx->ErrorCode;  
 8018fcc:	e9d4 230f 	ldrd	r2, r3, [r4, #60]	@ 0x3c
    RxErrorCode = hsd->hdmarx->ErrorCode;
 8018fd0:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
    TxErrorCode = hsd->hdmatx->ErrorCode;  
 8018fd2:	6d52      	ldr	r2, [r2, #84]	@ 0x54
    if((RxErrorCode == HAL_DMA_ERROR_TE) || (TxErrorCode == HAL_DMA_ERROR_TE))
 8018fd4:	2b01      	cmp	r3, #1
 8018fd6:	d005      	beq.n	8018fe4 <SD_DMAError+0x24>
 8018fd8:	2a01      	cmp	r2, #1
 8018fda:	d003      	beq.n	8018fe4 <SD_DMAError+0x24>
    HAL_SD_ErrorCallback(hsd);
 8018fdc:	4620      	mov	r0, r4
 8018fde:	f7ff ffc9 	bl	8018f74 <HAL_SD_ErrorCallback>
}
 8018fe2:	bd10      	pop	{r4, pc}
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8018fe4:	6820      	ldr	r0, [r4, #0]
 8018fe6:	4b14      	ldr	r3, [pc, #80]	@ (8019038 <SD_DMAError+0x78>)
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 8018fe8:	6d21      	ldr	r1, [r4, #80]	@ 0x50
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8018fea:	6383      	str	r3, [r0, #56]	@ 0x38
      __HAL_SD_DISABLE_IT(hsd, SDMMC_IT_DATAEND | SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT|\
 8018fec:	6bc3      	ldr	r3, [r0, #60]	@ 0x3c
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 8018fee:	0409      	lsls	r1, r1, #16
      __HAL_SD_DISABLE_IT(hsd, SDMMC_IT_DATAEND | SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT|\
 8018ff0:	f423 739d 	bic.w	r3, r3, #314	@ 0x13a
 8018ff4:	63c3      	str	r3, [r0, #60]	@ 0x3c
      hsd->ErrorCode |= HAL_SD_ERROR_DMA;
 8018ff6:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 8018ff8:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 8018ffc:	63a3      	str	r3, [r4, #56]	@ 0x38
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 8018ffe:	f002 fc49 	bl	801b894 <SDMMC_CmdSendStatus>
  if(errorstate != HAL_SD_ERROR_NONE)
 8019002:	b158      	cbz	r0, 801901c <SD_DMAError+0x5c>
        hsd->ErrorCode |= SDMMC_CmdStopTransfer(hsd->Instance);
 8019004:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 8019006:	4303      	orrs	r3, r0
 8019008:	63a3      	str	r3, [r4, #56]	@ 0x38
      hsd->State= HAL_SD_STATE_READY;
 801900a:	2201      	movs	r2, #1
      hsd->Context = SD_CONTEXT_NONE;
 801900c:	2300      	movs	r3, #0
    HAL_SD_ErrorCallback(hsd);
 801900e:	4620      	mov	r0, r4
      hsd->State= HAL_SD_STATE_READY;
 8019010:	f884 2034 	strb.w	r2, [r4, #52]	@ 0x34
      hsd->Context = SD_CONTEXT_NONE;
 8019014:	6323      	str	r3, [r4, #48]	@ 0x30
    HAL_SD_ErrorCallback(hsd);
 8019016:	f7ff ffad 	bl	8018f74 <HAL_SD_ErrorCallback>
 801901a:	e7e2      	b.n	8018fe2 <SD_DMAError+0x22>
  *pCardStatus = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 801901c:	4601      	mov	r1, r0
 801901e:	6820      	ldr	r0, [r4, #0]
 8019020:	f001 fc1a 	bl	801a858 <SDMMC_GetResponse>
  cardstate = ((resp1 >> 9U) & 0x0FU);
 8019024:	f3c0 2043 	ubfx	r0, r0, #9, #4
      if((CardState == HAL_SD_CARD_RECEIVING) || (CardState == HAL_SD_CARD_SENDING))
 8019028:	3805      	subs	r0, #5
 801902a:	2801      	cmp	r0, #1
 801902c:	d8ed      	bhi.n	801900a <SD_DMAError+0x4a>
        hsd->ErrorCode |= SDMMC_CmdStopTransfer(hsd->Instance);
 801902e:	6820      	ldr	r0, [r4, #0]
 8019030:	f001 ff78 	bl	801af24 <SDMMC_CmdStopTransfer>
 8019034:	e7e6      	b.n	8019004 <SD_DMAError+0x44>
 8019036:	bf00      	nop
 8019038:	004005ff 	.word	0x004005ff

0801903c <HAL_SD_GetCardCSD>:
  pCSD->CSDStruct = (uint8_t)((hsd->CSD[0] & 0xC0000000U) >> 30U);
 801903c:	6e42      	ldr	r2, [r0, #100]	@ 0x64
{
 801903e:	4603      	mov	r3, r0
 8019040:	b410      	push	{r4}
  pCSD->SysSpecVersion = (uint8_t)((hsd->CSD[0] & 0x3C000000U) >> 26U);
 8019042:	f3c2 6083 	ubfx	r0, r2, #26, #4
  pCSD->CSDStruct = (uint8_t)((hsd->CSD[0] & 0xC0000000U) >> 30U);
 8019046:	0f94      	lsrs	r4, r2, #30
 8019048:	700c      	strb	r4, [r1, #0]
  pCSD->Reserved1 = (uint8_t)((hsd->CSD[0] & 0x03000000U) >> 24U);
 801904a:	f3c2 6401 	ubfx	r4, r2, #24, #2
  pCSD->SysSpecVersion = (uint8_t)((hsd->CSD[0] & 0x3C000000U) >> 26U);
 801904e:	7048      	strb	r0, [r1, #1]
  pCSD->TAAC = (uint8_t)((hsd->CSD[0] & 0x00FF0000U) >> 16U);
 8019050:	f3c2 4007 	ubfx	r0, r2, #16, #8
  pCSD->Reserved1 = (uint8_t)((hsd->CSD[0] & 0x03000000U) >> 24U);
 8019054:	708c      	strb	r4, [r1, #2]
  pCSD->TAAC = (uint8_t)((hsd->CSD[0] & 0x00FF0000U) >> 16U);
 8019056:	70c8      	strb	r0, [r1, #3]
  pCSD->NSAC = (uint8_t)((hsd->CSD[0] & 0x0000FF00U) >> 8U);
 8019058:	f3c2 2007 	ubfx	r0, r2, #8, #8
  pCSD->MaxBusClkFrec = (uint8_t)(hsd->CSD[0] & 0x000000FFU);
 801905c:	b2d2      	uxtb	r2, r2
  pCSD->NSAC = (uint8_t)((hsd->CSD[0] & 0x0000FF00U) >> 8U);
 801905e:	7108      	strb	r0, [r1, #4]
  pCSD->Reserved2 = 0U; /*!< Reserved */
 8019060:	2000      	movs	r0, #0
  pCSD->MaxBusClkFrec = (uint8_t)(hsd->CSD[0] & 0x000000FFU);
 8019062:	714a      	strb	r2, [r1, #5]
  pCSD->CardComdClasses = (uint16_t)((hsd->CSD[1] & 0xFFF00000U) >> 20U);
 8019064:	6e9a      	ldr	r2, [r3, #104]	@ 0x68
 8019066:	0d14      	lsrs	r4, r2, #20
 8019068:	80cc      	strh	r4, [r1, #6]
  pCSD->RdBlockLen = (uint8_t)((hsd->CSD[1] & 0x000F0000U) >> 16U);
 801906a:	f3c2 4403 	ubfx	r4, r2, #16, #4
 801906e:	720c      	strb	r4, [r1, #8]
  pCSD->PartBlockRead   = (uint8_t)((hsd->CSD[1] & 0x00008000U) >> 15U);
 8019070:	f3c2 34c0 	ubfx	r4, r2, #15, #1
 8019074:	724c      	strb	r4, [r1, #9]
  pCSD->WrBlockMisalign = (uint8_t)((hsd->CSD[1] & 0x00004000U) >> 14U);
 8019076:	f3c2 3480 	ubfx	r4, r2, #14, #1
 801907a:	728c      	strb	r4, [r1, #10]
  pCSD->RdBlockMisalign = (uint8_t)((hsd->CSD[1] & 0x00002000U) >> 13U);
 801907c:	f3c2 3440 	ubfx	r4, r2, #13, #1
 8019080:	72cc      	strb	r4, [r1, #11]
  pCSD->DSRImpl = (uint8_t)((hsd->CSD[1] & 0x00001000U) >> 12U);
 8019082:	f3c2 3400 	ubfx	r4, r2, #12, #1
 8019086:	730c      	strb	r4, [r1, #12]
  pCSD->Reserved2 = 0U; /*!< Reserved */
 8019088:	7348      	strb	r0, [r1, #13]
  if(hsd->SdCard.CardType == CARD_SDSC)
 801908a:	6c58      	ldr	r0, [r3, #68]	@ 0x44
 801908c:	2800      	cmp	r0, #0
 801908e:	d16f      	bne.n	8019170 <HAL_SD_GetCardCSD+0x134>
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x000003FFU) << 2U) | ((hsd->CSD[2] & 0xC0000000U) >> 30U));
 8019090:	f640 74fc 	movw	r4, #4092	@ 0xffc
 8019094:	6ed8      	ldr	r0, [r3, #108]	@ 0x6c
 8019096:	ea04 0282 	and.w	r2, r4, r2, lsl #2
    pCSD->MaxRdCurrentVDDMin = (uint8_t)((hsd->CSD[2] & 0x38000000U) >> 27U);
 801909a:	f3c0 64c2 	ubfx	r4, r0, #27, #3
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x000003FFU) << 2U) | ((hsd->CSD[2] & 0xC0000000U) >> 30U));
 801909e:	ea42 7290 	orr.w	r2, r2, r0, lsr #30
 80190a2:	610a      	str	r2, [r1, #16]
    pCSD->MaxWrCurrentVDDMin = (uint8_t)((hsd->CSD[2] & 0x00E00000U) >> 21U);
 80190a4:	f3c0 5242 	ubfx	r2, r0, #21, #3
    pCSD->MaxRdCurrentVDDMin = (uint8_t)((hsd->CSD[2] & 0x38000000U) >> 27U);
 80190a8:	750c      	strb	r4, [r1, #20]
    pCSD->MaxRdCurrentVDDMax = (uint8_t)((hsd->CSD[2] & 0x07000000U) >> 24U);
 80190aa:	f3c0 6402 	ubfx	r4, r0, #24, #3
 80190ae:	754c      	strb	r4, [r1, #21]
    pCSD->MaxWrCurrentVDDMax = (uint8_t)((hsd->CSD[2] & 0x001C0000U) >> 18U);
 80190b0:	f3c0 4482 	ubfx	r4, r0, #18, #3
    pCSD->MaxWrCurrentVDDMin = (uint8_t)((hsd->CSD[2] & 0x00E00000U) >> 21U);
 80190b4:	758a      	strb	r2, [r1, #22]
    pCSD->DeviceSizeMul = (uint8_t)((hsd->CSD[2] & 0x00038000U) >> 15U);
 80190b6:	f3c0 32c2 	ubfx	r2, r0, #15, #3
    pCSD->MaxWrCurrentVDDMax = (uint8_t)((hsd->CSD[2] & 0x001C0000U) >> 18U);
 80190ba:	75cc      	strb	r4, [r1, #23]
    pCSD->DeviceSizeMul = (uint8_t)((hsd->CSD[2] & 0x00038000U) >> 15U);
 80190bc:	760a      	strb	r2, [r1, #24]
    hsd->SdCard.BlockNbr  = (pCSD->DeviceSize + 1U) ;
 80190be:	690c      	ldr	r4, [r1, #16]
    hsd->SdCard.BlockNbr *= (1UL << ((pCSD->DeviceSizeMul & 0x07U) + 2U));
 80190c0:	7e0a      	ldrb	r2, [r1, #24]
    hsd->SdCard.BlockNbr  = (pCSD->DeviceSize + 1U) ;
 80190c2:	3401      	adds	r4, #1
    hsd->SdCard.BlockNbr *= (1UL << ((pCSD->DeviceSizeMul & 0x07U) + 2U));
 80190c4:	f002 0207 	and.w	r2, r2, #7
 80190c8:	3202      	adds	r2, #2
 80190ca:	4094      	lsls	r4, r2
    hsd->SdCard.BlockSize = (1UL << (pCSD->RdBlockLen & 0x0FU));
 80190cc:	2201      	movs	r2, #1
    hsd->SdCard.BlockNbr *= (1UL << ((pCSD->DeviceSizeMul & 0x07U) + 2U));
 80190ce:	655c      	str	r4, [r3, #84]	@ 0x54
    hsd->SdCard.BlockSize = (1UL << (pCSD->RdBlockLen & 0x0FU));
 80190d0:	f891 c008 	ldrb.w	ip, [r1, #8]
 80190d4:	f00c 0c0f 	and.w	ip, ip, #15
 80190d8:	fa02 f20c 	lsl.w	r2, r2, ip
 80190dc:	659a      	str	r2, [r3, #88]	@ 0x58
    hsd->SdCard.LogBlockNbr =  (hsd->SdCard.BlockNbr) * ((hsd->SdCard.BlockSize) / 512U);
 80190de:	0a52      	lsrs	r2, r2, #9
 80190e0:	fb04 f202 	mul.w	r2, r4, r2
 80190e4:	65da      	str	r2, [r3, #92]	@ 0x5c
  pCSD->EraseGrSize = (uint8_t)((hsd->CSD[2] & 0x00004000U) >> 14U);
 80190e6:	f3c0 3280 	ubfx	r2, r0, #14, #1
    hsd->SdCard.LogBlockSize = 512U;
 80190ea:	f44f 7400 	mov.w	r4, #512	@ 0x200
 80190ee:	661c      	str	r4, [r3, #96]	@ 0x60
  pCSD->EraseGrMul = (uint8_t)((hsd->CSD[2] & 0x00003F80U) >> 7U);
 80190f0:	f3c0 14c6 	ubfx	r4, r0, #7, #7
  pCSD->EraseGrSize = (uint8_t)((hsd->CSD[2] & 0x00004000U) >> 14U);
 80190f4:	764a      	strb	r2, [r1, #25]
  pCSD->WrProtectGrSize = (uint8_t)(hsd->CSD[2] & 0x0000007FU);
 80190f6:	f000 027f 	and.w	r2, r0, #127	@ 0x7f
  pCSD->EraseGrMul = (uint8_t)((hsd->CSD[2] & 0x00003F80U) >> 7U);
 80190fa:	768c      	strb	r4, [r1, #26]
  pCSD->Reserved3 = 0;
 80190fc:	2000      	movs	r0, #0
  pCSD->WrProtectGrSize = (uint8_t)(hsd->CSD[2] & 0x0000007FU);
 80190fe:	76ca      	strb	r2, [r1, #27]
  pCSD->WrProtectGrEnable = (uint8_t)((hsd->CSD[3] & 0x80000000U) >> 31U);
 8019100:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8019102:	0fdc      	lsrs	r4, r3, #31
  pCSD->ManDeflECC = (uint8_t)((hsd->CSD[3] & 0x60000000U) >> 29U);
 8019104:	f3c3 7241 	ubfx	r2, r3, #29, #2
  pCSD->WrProtectGrEnable = (uint8_t)((hsd->CSD[3] & 0x80000000U) >> 31U);
 8019108:	770c      	strb	r4, [r1, #28]
  pCSD->WrSpeedFact = (uint8_t)((hsd->CSD[3] & 0x1C000000U) >> 26U);
 801910a:	f3c3 6482 	ubfx	r4, r3, #26, #3
  pCSD->ManDeflECC = (uint8_t)((hsd->CSD[3] & 0x60000000U) >> 29U);
 801910e:	774a      	strb	r2, [r1, #29]
  pCSD->MaxWrBlockLen= (uint8_t)((hsd->CSD[3] & 0x03C00000U) >> 22U);
 8019110:	f3c3 5283 	ubfx	r2, r3, #22, #4
  pCSD->WrSpeedFact = (uint8_t)((hsd->CSD[3] & 0x1C000000U) >> 26U);
 8019114:	778c      	strb	r4, [r1, #30]
  pCSD->WriteBlockPaPartial = (uint8_t)((hsd->CSD[3] & 0x00200000U) >> 21U);
 8019116:	f3c3 5440 	ubfx	r4, r3, #21, #1
  pCSD->MaxWrBlockLen= (uint8_t)((hsd->CSD[3] & 0x03C00000U) >> 22U);
 801911a:	77ca      	strb	r2, [r1, #31]
  pCSD->ContentProtectAppli = (uint8_t)((hsd->CSD[3] & 0x00010000U) >> 16U);
 801911c:	f3c3 4200 	ubfx	r2, r3, #16, #1
  pCSD->WriteBlockPaPartial = (uint8_t)((hsd->CSD[3] & 0x00200000U) >> 21U);
 8019120:	f881 4020 	strb.w	r4, [r1, #32]
  pCSD->FileFormatGroup = (uint8_t)((hsd->CSD[3] & 0x00008000U) >> 15U);
 8019124:	f3c3 34c0 	ubfx	r4, r3, #15, #1
  pCSD->Reserved3 = 0;
 8019128:	f881 0021 	strb.w	r0, [r1, #33]	@ 0x21
  pCSD->ContentProtectAppli = (uint8_t)((hsd->CSD[3] & 0x00010000U) >> 16U);
 801912c:	f881 2022 	strb.w	r2, [r1, #34]	@ 0x22
  pCSD->CopyFlag = (uint8_t)((hsd->CSD[3] & 0x00004000U) >> 14U);
 8019130:	f3c3 3280 	ubfx	r2, r3, #14, #1
  pCSD->FileFormatGroup = (uint8_t)((hsd->CSD[3] & 0x00008000U) >> 15U);
 8019134:	f881 4023 	strb.w	r4, [r1, #35]	@ 0x23
  pCSD->PermWrProtect = (uint8_t)((hsd->CSD[3] & 0x00002000U) >> 13U);
 8019138:	f3c3 3440 	ubfx	r4, r3, #13, #1
  pCSD->CopyFlag = (uint8_t)((hsd->CSD[3] & 0x00004000U) >> 14U);
 801913c:	f881 2024 	strb.w	r2, [r1, #36]	@ 0x24
  pCSD->TempWrProtect = (uint8_t)((hsd->CSD[3] & 0x00001000U) >> 12U);
 8019140:	f3c3 3200 	ubfx	r2, r3, #12, #1
  pCSD->PermWrProtect = (uint8_t)((hsd->CSD[3] & 0x00002000U) >> 13U);
 8019144:	f881 4025 	strb.w	r4, [r1, #37]	@ 0x25
  pCSD->FileFormat = (uint8_t)((hsd->CSD[3] & 0x00000C00U) >> 10U);
 8019148:	f3c3 2481 	ubfx	r4, r3, #10, #2
  pCSD->TempWrProtect = (uint8_t)((hsd->CSD[3] & 0x00001000U) >> 12U);
 801914c:	f881 2026 	strb.w	r2, [r1, #38]	@ 0x26
  pCSD->ECC= (uint8_t)((hsd->CSD[3] & 0x00000300U) >> 8U);
 8019150:	f3c3 2201 	ubfx	r2, r3, #8, #2
  pCSD->FileFormat = (uint8_t)((hsd->CSD[3] & 0x00000C00U) >> 10U);
 8019154:	f881 4027 	strb.w	r4, [r1, #39]	@ 0x27
  pCSD->CSD_CRC = (uint8_t)((hsd->CSD[3] & 0x000000FEU) >> 1U);
 8019158:	f3c3 0346 	ubfx	r3, r3, #1, #7
  pCSD->ECC= (uint8_t)((hsd->CSD[3] & 0x00000300U) >> 8U);
 801915c:	f881 2028 	strb.w	r2, [r1, #40]	@ 0x28
  pCSD->Reserved4 = 1;
 8019160:	2201      	movs	r2, #1
  pCSD->CSD_CRC = (uint8_t)((hsd->CSD[3] & 0x000000FEU) >> 1U);
 8019162:	f881 3029 	strb.w	r3, [r1, #41]	@ 0x29
  pCSD->Reserved4 = 1;
 8019166:	f881 202a 	strb.w	r2, [r1, #42]	@ 0x2a
}
 801916a:	f85d 4b04 	ldr.w	r4, [sp], #4
 801916e:	4770      	bx	lr
  else if(hsd->SdCard.CardType == CARD_SDHC_SDXC)
 8019170:	2801      	cmp	r0, #1
 8019172:	d10f      	bne.n	8019194 <HAL_SD_GetCardCSD+0x158>
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x0000003FU) << 16U) | ((hsd->CSD[2] & 0xFFFF0000U) >> 16U));
 8019174:	0412      	lsls	r2, r2, #16
 8019176:	6ed8      	ldr	r0, [r3, #108]	@ 0x6c
    hsd->SdCard.BlockSize = 512U;
 8019178:	f44f 7400 	mov.w	r4, #512	@ 0x200
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x0000003FU) << 16U) | ((hsd->CSD[2] & 0xFFFF0000U) >> 16U));
 801917c:	f402 127c 	and.w	r2, r2, #4128768	@ 0x3f0000
 8019180:	ea42 4210 	orr.w	r2, r2, r0, lsr #16
 8019184:	610a      	str	r2, [r1, #16]
    hsd->SdCard.BlockNbr = ((pCSD->DeviceSize + 1U) * 1024U);
 8019186:	690a      	ldr	r2, [r1, #16]
    hsd->SdCard.BlockSize = 512U;
 8019188:	659c      	str	r4, [r3, #88]	@ 0x58
    hsd->SdCard.BlockNbr = ((pCSD->DeviceSize + 1U) * 1024U);
 801918a:	3201      	adds	r2, #1
 801918c:	0292      	lsls	r2, r2, #10
 801918e:	655a      	str	r2, [r3, #84]	@ 0x54
    hsd->SdCard.LogBlockNbr = hsd->SdCard.BlockNbr;
 8019190:	65da      	str	r2, [r3, #92]	@ 0x5c
    hsd->SdCard.LogBlockSize = hsd->SdCard.BlockSize;
 8019192:	e7a8      	b.n	80190e6 <HAL_SD_GetCardCSD+0xaa>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8019194:	681a      	ldr	r2, [r3, #0]
    hsd->State = HAL_SD_STATE_READY;
 8019196:	2101      	movs	r1, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8019198:	4805      	ldr	r0, [pc, #20]	@ (80191b0 <HAL_SD_GetCardCSD+0x174>)
 801919a:	6390      	str	r0, [r2, #56]	@ 0x38
    return HAL_ERROR;
 801919c:	4608      	mov	r0, r1
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 801919e:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 80191a0:	f042 5280 	orr.w	r2, r2, #268435456	@ 0x10000000
 80191a4:	639a      	str	r2, [r3, #56]	@ 0x38
    hsd->State = HAL_SD_STATE_READY;
 80191a6:	f883 1034 	strb.w	r1, [r3, #52]	@ 0x34
}
 80191aa:	f85d 4b04 	ldr.w	r4, [sp], #4
 80191ae:	4770      	bx	lr
 80191b0:	004005ff 	.word	0x004005ff

080191b4 <HAL_SD_InitCard>:
{
 80191b4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80191b6:	b099      	sub	sp, #100	@ 0x64
  Init.ClockEdge           = SDMMC_CLOCK_EDGE_RISING;
 80191b8:	2300      	movs	r3, #0
  Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_DISABLE;
 80191ba:	2600      	movs	r6, #0
 80191bc:	2776      	movs	r7, #118	@ 0x76
  status = SDMMC_Init(hsd->Instance, Init);
 80191be:	aa09      	add	r2, sp, #36	@ 0x24
{
 80191c0:	4605      	mov	r5, r0
  Init.BusWide             = SDMMC_BUS_WIDE_1B;
 80191c2:	9309      	str	r3, [sp, #36]	@ 0x24
  Init.ClockPowerSave      = SDMMC_CLOCK_POWER_SAVE_DISABLE;
 80191c4:	9308      	str	r3, [sp, #32]
  Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_DISABLE;
 80191c6:	e9cd 670a 	strd	r6, r7, [sp, #40]	@ 0x28
  status = SDMMC_Init(hsd->Instance, Init);
 80191ca:	ca07      	ldmia	r2, {r0, r1, r2}
 80191cc:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
 80191d0:	aa06      	add	r2, sp, #24
 80191d2:	6828      	ldr	r0, [r5, #0]
  Init.ClockBypass         = SDMMC_CLOCK_BYPASS_DISABLE;
 80191d4:	e9cd 3306 	strd	r3, r3, [sp, #24]
  status = SDMMC_Init(hsd->Instance, Init);
 80191d8:	ca0e      	ldmia	r2, {r1, r2, r3}
 80191da:	f001 fb11 	bl	801a800 <SDMMC_Init>
  if(status != HAL_OK)
 80191de:	b118      	cbz	r0, 80191e8 <HAL_SD_InitCard+0x34>
    return HAL_ERROR;
 80191e0:	2401      	movs	r4, #1
}
 80191e2:	4620      	mov	r0, r4
 80191e4:	b019      	add	sp, #100	@ 0x64
 80191e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
  __HAL_SD_DISABLE(hsd);
 80191e8:	4604      	mov	r4, r0
 80191ea:	6828      	ldr	r0, [r5, #0]
 80191ec:	6843      	ldr	r3, [r0, #4]
 80191ee:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 80191f2:	6043      	str	r3, [r0, #4]
  (void)SDMMC_PowerState_ON(hsd->Instance);
 80191f4:	f001 fb26 	bl	801a844 <SDMMC_PowerState_ON>
  __HAL_SD_ENABLE(hsd);
 80191f8:	682a      	ldr	r2, [r5, #0]
  HAL_Delay(2);
 80191fa:	2002      	movs	r0, #2
  __HAL_SD_ENABLE(hsd);
 80191fc:	6853      	ldr	r3, [r2, #4]
 80191fe:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8019202:	6053      	str	r3, [r2, #4]
  HAL_Delay(2);
 8019204:	f7f9 fe38 	bl	8012e78 <HAL_Delay>
  errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
 8019208:	6828      	ldr	r0, [r5, #0]
  __IO uint32_t count = 0U;
 801920a:	9405      	str	r4, [sp, #20]
  errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
 801920c:	f001 ffce 	bl	801b1ac <SDMMC_CmdGoIdleState>
  if(errorstate != HAL_SD_ERROR_NONE)
 8019210:	4604      	mov	r4, r0
 8019212:	b960      	cbnz	r0, 801922e <HAL_SD_InitCard+0x7a>
  errorstate = SDMMC_CmdOperCond(hsd->Instance);
 8019214:	6828      	ldr	r0, [r5, #0]
 8019216:	f001 fff3 	bl	801b200 <SDMMC_CmdOperCond>
  if(errorstate != HAL_SD_ERROR_NONE)
 801921a:	b978      	cbnz	r0, 801923c <HAL_SD_InitCard+0x88>
    hsd->SdCard.CardVersion = CARD_V2_X;
 801921c:	2301      	movs	r3, #1
 801921e:	64ab      	str	r3, [r5, #72]	@ 0x48
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, 0);
 8019220:	2100      	movs	r1, #0
 8019222:	6828      	ldr	r0, [r5, #0]
 8019224:	f002 f82a 	bl	801b27c <SDMMC_CmdAppCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
 8019228:	b190      	cbz	r0, 8019250 <HAL_SD_InitCard+0x9c>
      return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 801922a:	f04f 5480 	mov.w	r4, #268435456	@ 0x10000000
    hsd->State = HAL_SD_STATE_READY;
 801922e:	2301      	movs	r3, #1
 8019230:	f885 3034 	strb.w	r3, [r5, #52]	@ 0x34
    hsd->ErrorCode |= errorstate;
 8019234:	6bab      	ldr	r3, [r5, #56]	@ 0x38
 8019236:	4323      	orrs	r3, r4
 8019238:	63ab      	str	r3, [r5, #56]	@ 0x38
    return HAL_ERROR;
 801923a:	e7d1      	b.n	80191e0 <HAL_SD_InitCard+0x2c>
    errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
 801923c:	6828      	ldr	r0, [r5, #0]
    hsd->SdCard.CardVersion = CARD_V1_X;
 801923e:	64ac      	str	r4, [r5, #72]	@ 0x48
    errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
 8019240:	f001 ffb4 	bl	801b1ac <SDMMC_CmdGoIdleState>
    if(errorstate != HAL_SD_ERROR_NONE)
 8019244:	2800      	cmp	r0, #0
 8019246:	f040 80c4 	bne.w	80193d2 <HAL_SD_InitCard+0x21e>
  if( hsd->SdCard.CardVersion == CARD_V2_X)
 801924a:	6cab      	ldr	r3, [r5, #72]	@ 0x48
 801924c:	2b01      	cmp	r3, #1
 801924e:	d0e7      	beq.n	8019220 <HAL_SD_InitCard+0x6c>
  while((count < SDMMC_MAX_VOLT_TRIAL) && (validvoltage == 0U))
 8019250:	9b05      	ldr	r3, [sp, #20]
 8019252:	f64f 76fe 	movw	r6, #65534	@ 0xfffe
 8019256:	42b3      	cmp	r3, r6
 8019258:	d81c      	bhi.n	8019294 <HAL_SD_InitCard+0xe0>
    errorstate = SDMMC_CmdAppOperCommand(hsd->Instance, SDMMC_VOLTAGE_WINDOW_SD | SDMMC_HIGH_CAPACITY | SD_SWITCH_1_8V_CAPACITY);
 801925a:	4f61      	ldr	r7, [pc, #388]	@ (80193e0 <HAL_SD_InitCard+0x22c>)
 801925c:	e011      	b.n	8019282 <HAL_SD_InitCard+0xce>
 801925e:	6828      	ldr	r0, [r5, #0]
 8019260:	f002 f8b4 	bl	801b3cc <SDMMC_CmdAppOperCommand>
    response = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 8019264:	4621      	mov	r1, r4
    if(errorstate != HAL_SD_ERROR_NONE)
 8019266:	2800      	cmp	r0, #0
 8019268:	d1df      	bne.n	801922a <HAL_SD_InitCard+0x76>
    response = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 801926a:	6828      	ldr	r0, [r5, #0]
 801926c:	f001 faf4 	bl	801a858 <SDMMC_GetResponse>
    count++;
 8019270:	9b05      	ldr	r3, [sp, #20]
  while((count < SDMMC_MAX_VOLT_TRIAL) && (validvoltage == 0U))
 8019272:	1e04      	subs	r4, r0, #0
    count++;
 8019274:	f103 0301 	add.w	r3, r3, #1
 8019278:	9305      	str	r3, [sp, #20]
  while((count < SDMMC_MAX_VOLT_TRIAL) && (validvoltage == 0U))
 801927a:	9b05      	ldr	r3, [sp, #20]
 801927c:	db0a      	blt.n	8019294 <HAL_SD_InitCard+0xe0>
 801927e:	42b3      	cmp	r3, r6
 8019280:	d808      	bhi.n	8019294 <HAL_SD_InitCard+0xe0>
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, 0);
 8019282:	2100      	movs	r1, #0
 8019284:	6828      	ldr	r0, [r5, #0]
 8019286:	f001 fff9 	bl	801b27c <SDMMC_CmdAppCommand>
    errorstate = SDMMC_CmdAppOperCommand(hsd->Instance, SDMMC_VOLTAGE_WINDOW_SD | SDMMC_HIGH_CAPACITY | SD_SWITCH_1_8V_CAPACITY);
 801928a:	4639      	mov	r1, r7
    if(errorstate != HAL_SD_ERROR_NONE)
 801928c:	4604      	mov	r4, r0
 801928e:	2800      	cmp	r0, #0
 8019290:	d0e5      	beq.n	801925e <HAL_SD_InitCard+0xaa>
 8019292:	e7cc      	b.n	801922e <HAL_SD_InitCard+0x7a>
  if(count >= SDMMC_MAX_VOLT_TRIAL)
 8019294:	9a05      	ldr	r2, [sp, #20]
 8019296:	f64f 73fe 	movw	r3, #65534	@ 0xfffe
 801929a:	429a      	cmp	r2, r3
 801929c:	f200 809b 	bhi.w	80193d6 <HAL_SD_InitCard+0x222>
  if((response & SDMMC_HIGH_CAPACITY) == SDMMC_HIGH_CAPACITY) /* (response &= SD_HIGH_CAPACITY) */
 80192a0:	f3c4 7480 	ubfx	r4, r4, #30, #1
  uint16_t sd_rca = 1U;
 80192a4:	2301      	movs	r3, #1
  if(SDMMC_GetPowerState(hsd->Instance) == 0U)
 80192a6:	6828      	ldr	r0, [r5, #0]
 80192a8:	646c      	str	r4, [r5, #68]	@ 0x44
  uint16_t sd_rca = 1U;
 80192aa:	f8ad 3012 	strh.w	r3, [sp, #18]
  if(SDMMC_GetPowerState(hsd->Instance) == 0U)
 80192ae:	f001 facf 	bl	801a850 <SDMMC_GetPowerState>
 80192b2:	2800      	cmp	r0, #0
 80192b4:	f000 8087 	beq.w	80193c6 <HAL_SD_InitCard+0x212>
  if(hsd->SdCard.CardType != CARD_SECURED)
 80192b8:	6c6b      	ldr	r3, [r5, #68]	@ 0x44
    errorstate = SDMMC_CmdSendCID(hsd->Instance);
 80192ba:	6828      	ldr	r0, [r5, #0]
  if(hsd->SdCard.CardType != CARD_SECURED)
 80192bc:	2b03      	cmp	r3, #3
 80192be:	d130      	bne.n	8019322 <HAL_SD_InitCard+0x16e>
  hsd->SdCard.Class = (SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2) >> 20U);
 80192c0:	2104      	movs	r1, #4
 80192c2:	f001 fac9 	bl	801a858 <SDMMC_GetResponse>
 80192c6:	4603      	mov	r3, r0
  if (HAL_SD_GetCardCSD(hsd, &CSD) != HAL_OK)
 80192c8:	a90d      	add	r1, sp, #52	@ 0x34
 80192ca:	4628      	mov	r0, r5
  hsd->SdCard.Class = (SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2) >> 20U);
 80192cc:	0d1b      	lsrs	r3, r3, #20
 80192ce:	64eb      	str	r3, [r5, #76]	@ 0x4c
  if (HAL_SD_GetCardCSD(hsd, &CSD) != HAL_OK)
 80192d0:	f7ff feb4 	bl	801903c <HAL_SD_GetCardCSD>
 80192d4:	4604      	mov	r4, r0
 80192d6:	2800      	cmp	r0, #0
 80192d8:	d178      	bne.n	80193cc <HAL_SD_InitCard+0x218>
  errorstate = SDMMC_CmdSelDesel(hsd->Instance, (uint32_t)(((uint32_t)hsd->SdCard.RelCardAdd) << 16U));
 80192da:	6d2a      	ldr	r2, [r5, #80]	@ 0x50
 80192dc:	4603      	mov	r3, r0
 80192de:	6828      	ldr	r0, [r5, #0]
 80192e0:	0412      	lsls	r2, r2, #16
 80192e2:	f001 fec3 	bl	801b06c <SDMMC_CmdSelDesel>
  if(errorstate != HAL_SD_ERROR_NONE)
 80192e6:	b9f8      	cbnz	r0, 8019328 <HAL_SD_InitCard+0x174>
  (void)SDMMC_Init(hsd->Instance, hsd->Init);
 80192e8:	462a      	mov	r2, r5
 80192ea:	1d2b      	adds	r3, r5, #4
 80192ec:	f852 6b10 	ldr.w	r6, [r2], #16
 80192f0:	ca07      	ldmia	r2, {r0, r1, r2}
 80192f2:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
 80192f6:	4630      	mov	r0, r6
 80192f8:	cb0e      	ldmia	r3, {r1, r2, r3}
 80192fa:	f001 fa81 	bl	801a800 <SDMMC_Init>
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
 80192fe:	f44f 7100 	mov.w	r1, #512	@ 0x200
 8019302:	6828      	ldr	r0, [r5, #0]
 8019304:	f001 fac2 	bl	801a88c <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
 8019308:	2800      	cmp	r0, #0
 801930a:	f43f af6a 	beq.w	80191e2 <HAL_SD_InitCard+0x2e>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 801930e:	682b      	ldr	r3, [r5, #0]
    hsd->State = HAL_SD_STATE_READY;
 8019310:	2201      	movs	r2, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8019312:	4934      	ldr	r1, [pc, #208]	@ (80193e4 <HAL_SD_InitCard+0x230>)
 8019314:	6399      	str	r1, [r3, #56]	@ 0x38
    hsd->ErrorCode |= errorstate;
 8019316:	6bab      	ldr	r3, [r5, #56]	@ 0x38
 8019318:	4303      	orrs	r3, r0
 801931a:	63ab      	str	r3, [r5, #56]	@ 0x38
    hsd->State = HAL_SD_STATE_READY;
 801931c:	f885 2034 	strb.w	r2, [r5, #52]	@ 0x34
    return HAL_ERROR;
 8019320:	e75e      	b.n	80191e0 <HAL_SD_InitCard+0x2c>
    errorstate = SDMMC_CmdSendCID(hsd->Instance);
 8019322:	f002 f9df 	bl	801b6e4 <SDMMC_CmdSendCID>
    if(errorstate != HAL_SD_ERROR_NONE)
 8019326:	b130      	cbz	r0, 8019336 <HAL_SD_InitCard+0x182>
    hsd->State = HAL_SD_STATE_READY;
 8019328:	2301      	movs	r3, #1
 801932a:	f885 3034 	strb.w	r3, [r5, #52]	@ 0x34
    hsd->ErrorCode |= errorstate;
 801932e:	6bab      	ldr	r3, [r5, #56]	@ 0x38
 8019330:	4303      	orrs	r3, r0
 8019332:	63ab      	str	r3, [r5, #56]	@ 0x38
    return HAL_ERROR;
 8019334:	e754      	b.n	80191e0 <HAL_SD_InitCard+0x2c>
      hsd->CID[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 8019336:	4601      	mov	r1, r0
 8019338:	6828      	ldr	r0, [r5, #0]
 801933a:	f001 fa8d 	bl	801a858 <SDMMC_GetResponse>
 801933e:	4603      	mov	r3, r0
      hsd->CID[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 8019340:	2104      	movs	r1, #4
 8019342:	6828      	ldr	r0, [r5, #0]
      hsd->CID[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 8019344:	676b      	str	r3, [r5, #116]	@ 0x74
      hsd->CID[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 8019346:	f001 fa87 	bl	801a858 <SDMMC_GetResponse>
 801934a:	4603      	mov	r3, r0
      hsd->CID[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 801934c:	2108      	movs	r1, #8
 801934e:	6828      	ldr	r0, [r5, #0]
      hsd->CID[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 8019350:	67ab      	str	r3, [r5, #120]	@ 0x78
      hsd->CID[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 8019352:	f001 fa81 	bl	801a858 <SDMMC_GetResponse>
 8019356:	4603      	mov	r3, r0
      hsd->CID[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
 8019358:	210c      	movs	r1, #12
 801935a:	6828      	ldr	r0, [r5, #0]
      hsd->CID[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 801935c:	67eb      	str	r3, [r5, #124]	@ 0x7c
      hsd->CID[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
 801935e:	f001 fa7b 	bl	801a858 <SDMMC_GetResponse>
  if(hsd->SdCard.CardType != CARD_SECURED)
 8019362:	6c6b      	ldr	r3, [r5, #68]	@ 0x44
      hsd->CID[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
 8019364:	f8c5 0080 	str.w	r0, [r5, #128]	@ 0x80
  if(hsd->SdCard.CardType != CARD_SECURED)
 8019368:	2b03      	cmp	r3, #3
 801936a:	d037      	beq.n	80193dc <HAL_SD_InitCard+0x228>
    errorstate = SDMMC_CmdSetRelAdd(hsd->Instance, &sd_rca);
 801936c:	f10d 0112 	add.w	r1, sp, #18
 8019370:	6828      	ldr	r0, [r5, #0]
 8019372:	f002 fa31 	bl	801b7d8 <SDMMC_CmdSetRelAdd>
    if(errorstate != HAL_SD_ERROR_NONE)
 8019376:	2800      	cmp	r0, #0
 8019378:	d1d6      	bne.n	8019328 <HAL_SD_InitCard+0x174>
  if(hsd->SdCard.CardType != CARD_SECURED)
 801937a:	6c6b      	ldr	r3, [r5, #68]	@ 0x44
    errorstate = SDMMC_CmdSendCSD(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 801937c:	6828      	ldr	r0, [r5, #0]
  if(hsd->SdCard.CardType != CARD_SECURED)
 801937e:	2b03      	cmp	r3, #3
 8019380:	d09e      	beq.n	80192c0 <HAL_SD_InitCard+0x10c>
    hsd->SdCard.RelCardAdd = sd_rca;
 8019382:	f8bd 3012 	ldrh.w	r3, [sp, #18]
    errorstate = SDMMC_CmdSendCSD(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 8019386:	0419      	lsls	r1, r3, #16
    hsd->SdCard.RelCardAdd = sd_rca;
 8019388:	652b      	str	r3, [r5, #80]	@ 0x50
    errorstate = SDMMC_CmdSendCSD(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 801938a:	f002 f9e7 	bl	801b75c <SDMMC_CmdSendCSD>
    if(errorstate != HAL_SD_ERROR_NONE)
 801938e:	2800      	cmp	r0, #0
 8019390:	d1ca      	bne.n	8019328 <HAL_SD_InitCard+0x174>
      hsd->CSD[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 8019392:	4601      	mov	r1, r0
 8019394:	6828      	ldr	r0, [r5, #0]
 8019396:	f001 fa5f 	bl	801a858 <SDMMC_GetResponse>
 801939a:	4603      	mov	r3, r0
      hsd->CSD[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 801939c:	2104      	movs	r1, #4
 801939e:	6828      	ldr	r0, [r5, #0]
      hsd->CSD[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 80193a0:	666b      	str	r3, [r5, #100]	@ 0x64
      hsd->CSD[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 80193a2:	f001 fa59 	bl	801a858 <SDMMC_GetResponse>
 80193a6:	4603      	mov	r3, r0
      hsd->CSD[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 80193a8:	2108      	movs	r1, #8
 80193aa:	6828      	ldr	r0, [r5, #0]
      hsd->CSD[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 80193ac:	66ab      	str	r3, [r5, #104]	@ 0x68
      hsd->CSD[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 80193ae:	f001 fa53 	bl	801a858 <SDMMC_GetResponse>
 80193b2:	4603      	mov	r3, r0
      hsd->CSD[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
 80193b4:	210c      	movs	r1, #12
 80193b6:	6828      	ldr	r0, [r5, #0]
      hsd->CSD[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 80193b8:	66eb      	str	r3, [r5, #108]	@ 0x6c
      hsd->CSD[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
 80193ba:	f001 fa4d 	bl	801a858 <SDMMC_GetResponse>
 80193be:	4603      	mov	r3, r0
 80193c0:	6828      	ldr	r0, [r5, #0]
 80193c2:	672b      	str	r3, [r5, #112]	@ 0x70
 80193c4:	e77c      	b.n	80192c0 <HAL_SD_InitCard+0x10c>
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
 80193c6:	f04f 6080 	mov.w	r0, #67108864	@ 0x4000000
 80193ca:	e7ad      	b.n	8019328 <HAL_SD_InitCard+0x174>
    return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 80193cc:	f04f 5080 	mov.w	r0, #268435456	@ 0x10000000
 80193d0:	e7aa      	b.n	8019328 <HAL_SD_InitCard+0x174>
      return errorstate;
 80193d2:	4604      	mov	r4, r0
 80193d4:	e72b      	b.n	801922e <HAL_SD_InitCard+0x7a>
    return HAL_SD_ERROR_INVALID_VOLTRANGE;
 80193d6:	f04f 7480 	mov.w	r4, #16777216	@ 0x1000000
 80193da:	e728      	b.n	801922e <HAL_SD_InitCard+0x7a>
 80193dc:	6828      	ldr	r0, [r5, #0]
 80193de:	e76f      	b.n	80192c0 <HAL_SD_InitCard+0x10c>
 80193e0:	c1100000 	.word	0xc1100000
 80193e4:	004005ff 	.word	0x004005ff

080193e8 <HAL_SD_Init>:
  if(hsd == NULL)
 80193e8:	b1c8      	cbz	r0, 801941e <HAL_SD_Init+0x36>
{
 80193ea:	b510      	push	{r4, lr}
  if(hsd->State == HAL_SD_STATE_RESET)
 80193ec:	f890 3034 	ldrb.w	r3, [r0, #52]	@ 0x34
 80193f0:	4604      	mov	r4, r0
 80193f2:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
 80193f6:	b173      	cbz	r3, 8019416 <HAL_SD_Init+0x2e>
  hsd->State = HAL_SD_STATE_BUSY;
 80193f8:	2303      	movs	r3, #3
  if (HAL_SD_InitCard(hsd) != HAL_OK)
 80193fa:	4620      	mov	r0, r4
  hsd->State = HAL_SD_STATE_BUSY;
 80193fc:	f884 3034 	strb.w	r3, [r4, #52]	@ 0x34
  if (HAL_SD_InitCard(hsd) != HAL_OK)
 8019400:	f7ff fed8 	bl	80191b4 <HAL_SD_InitCard>
 8019404:	b928      	cbnz	r0, 8019412 <HAL_SD_Init+0x2a>
  hsd->State = HAL_SD_STATE_READY;
 8019406:	2301      	movs	r3, #1
  hsd->ErrorCode = HAL_SD_ERROR_NONE;
 8019408:	63a0      	str	r0, [r4, #56]	@ 0x38
  hsd->Context = SD_CONTEXT_NONE;
 801940a:	6320      	str	r0, [r4, #48]	@ 0x30
  hsd->State = HAL_SD_STATE_READY;
 801940c:	f884 3034 	strb.w	r3, [r4, #52]	@ 0x34
}
 8019410:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 8019412:	2001      	movs	r0, #1
}
 8019414:	bd10      	pop	{r4, pc}
    hsd->Lock = HAL_UNLOCKED;
 8019416:	7702      	strb	r2, [r0, #28]
    HAL_SD_MspInit(hsd);
 8019418:	f7f9 f8d6 	bl	80125c8 <HAL_SD_MspInit>
 801941c:	e7ec      	b.n	80193f8 <HAL_SD_Init+0x10>
    return HAL_ERROR;
 801941e:	2001      	movs	r0, #1
}
 8019420:	4770      	bx	lr
 8019422:	bf00      	nop

08019424 <HAL_SD_GetCardInfo>:
{
 8019424:	b5f0      	push	{r4, r5, r6, r7, lr}
  pCardInfo->CardType     = (uint32_t)(hsd->SdCard.CardType);
 8019426:	e9d0 e311 	ldrd	lr, r3, [r0, #68]	@ 0x44
 801942a:	e9d0 7613 	ldrd	r7, r6, [r0, #76]	@ 0x4c
 801942e:	e9d0 5415 	ldrd	r5, r4, [r0, #84]	@ 0x54
 8019432:	e9d0 2017 	ldrd	r2, r0, [r0, #92]	@ 0x5c
 8019436:	e9c1 e300 	strd	lr, r3, [r1]
 801943a:	e9c1 2006 	strd	r2, r0, [r1, #24]
 801943e:	e9c1 7602 	strd	r7, r6, [r1, #8]
}
 8019442:	2000      	movs	r0, #0
  pCardInfo->CardType     = (uint32_t)(hsd->SdCard.CardType);
 8019444:	e9c1 5404 	strd	r5, r4, [r1, #16]
}
 8019448:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801944a:	bf00      	nop
 801944c:	0000      	movs	r0, r0
	...

08019450 <HAL_SD_ConfigWideBusOperation>:
  if(hsd->SdCard.CardType != CARD_SECURED)
 8019450:	6c42      	ldr	r2, [r0, #68]	@ 0x44
  hsd->State = HAL_SD_STATE_BUSY;
 8019452:	2303      	movs	r3, #3
  if(hsd->SdCard.CardType != CARD_SECURED)
 8019454:	2a03      	cmp	r2, #3
{
 8019456:	b570      	push	{r4, r5, r6, lr}
  hsd->State = HAL_SD_STATE_BUSY;
 8019458:	f880 3034 	strb.w	r3, [r0, #52]	@ 0x34
{
 801945c:	b08a      	sub	sp, #40	@ 0x28
 801945e:	4604      	mov	r4, r0
 8019460:	460e      	mov	r6, r1
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 8019462:	6803      	ldr	r3, [r0, #0]
  if(hsd->SdCard.CardType != CARD_SECURED)
 8019464:	d025      	beq.n	80194b2 <HAL_SD_ConfigWideBusOperation+0x62>
    if(WideMode == SDMMC_BUS_WIDE_8B)
 8019466:	f5b1 5f80 	cmp.w	r1, #4096	@ 0x1000
 801946a:	d022      	beq.n	80194b2 <HAL_SD_ConfigWideBusOperation+0x62>
    else if(WideMode == SDMMC_BUS_WIDE_4B)
 801946c:	f5b1 6f00 	cmp.w	r1, #2048	@ 0x800
 8019470:	d05f      	beq.n	8019532 <HAL_SD_ConfigWideBusOperation+0xe2>
    else if(WideMode == SDMMC_BUS_WIDE_1B)
 8019472:	2900      	cmp	r1, #0
 8019474:	d03d      	beq.n	80194f2 <HAL_SD_ConfigWideBusOperation+0xa2>
      hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 8019476:	6b82      	ldr	r2, [r0, #56]	@ 0x38
 8019478:	f042 6200 	orr.w	r2, r2, #134217728	@ 0x8000000
 801947c:	6382      	str	r2, [r0, #56]	@ 0x38
  if(hsd->ErrorCode != HAL_SD_ERROR_NONE)
 801947e:	6ba5      	ldr	r5, [r4, #56]	@ 0x38
 8019480:	b9f5      	cbnz	r5, 80194c0 <HAL_SD_ConfigWideBusOperation+0x70>
    Init.ClockEdge           = hsd->Init.ClockEdge;
 8019482:	6862      	ldr	r2, [r4, #4]
    Init.HardwareFlowControl = hsd->Init.HardwareFlowControl;
 8019484:	6961      	ldr	r1, [r4, #20]
    Init.ClockEdge           = hsd->Init.ClockEdge;
 8019486:	9204      	str	r2, [sp, #16]
    Init.ClockBypass         = hsd->Init.ClockBypass;
 8019488:	68a2      	ldr	r2, [r4, #8]
    Init.BusWide             = WideMode;
 801948a:	9607      	str	r6, [sp, #28]
    (void)SDMMC_Init(hsd->Instance, Init);
 801948c:	ae04      	add	r6, sp, #16
    Init.ClockBypass         = hsd->Init.ClockBypass;
 801948e:	9205      	str	r2, [sp, #20]
    Init.ClockPowerSave      = hsd->Init.ClockPowerSave;
 8019490:	68e2      	ldr	r2, [r4, #12]
    Init.HardwareFlowControl = hsd->Init.HardwareFlowControl;
 8019492:	9108      	str	r1, [sp, #32]
    Init.ClockPowerSave      = hsd->Init.ClockPowerSave;
 8019494:	9206      	str	r2, [sp, #24]
    Init.HardwareFlowControl = hsd->Init.HardwareFlowControl;
 8019496:	69a2      	ldr	r2, [r4, #24]
 8019498:	9209      	str	r2, [sp, #36]	@ 0x24
    (void)SDMMC_Init(hsd->Instance, Init);
 801949a:	aa0a      	add	r2, sp, #40	@ 0x28
 801949c:	e912 0007 	ldmdb	r2, {r0, r1, r2}
 80194a0:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
 80194a4:	4618      	mov	r0, r3
 80194a6:	e896 000e 	ldmia.w	r6, {r1, r2, r3}
 80194aa:	f001 f9a9 	bl	801a800 <SDMMC_Init>
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
 80194ae:	6823      	ldr	r3, [r4, #0]
 80194b0:	e00c      	b.n	80194cc <HAL_SD_ConfigWideBusOperation+0x7c>
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 80194b2:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
 80194b4:	f042 5280 	orr.w	r2, r2, #268435456	@ 0x10000000
 80194b8:	63a2      	str	r2, [r4, #56]	@ 0x38
  if(hsd->ErrorCode != HAL_SD_ERROR_NONE)
 80194ba:	6ba5      	ldr	r5, [r4, #56]	@ 0x38
 80194bc:	2d00      	cmp	r5, #0
 80194be:	d0e0      	beq.n	8019482 <HAL_SD_ConfigWideBusOperation+0x32>
    hsd->State = HAL_SD_STATE_READY;
 80194c0:	2201      	movs	r2, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 80194c2:	4931      	ldr	r1, [pc, #196]	@ (8019588 <HAL_SD_ConfigWideBusOperation+0x138>)
    status = HAL_ERROR;
 80194c4:	4615      	mov	r5, r2
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 80194c6:	6399      	str	r1, [r3, #56]	@ 0x38
    hsd->State = HAL_SD_STATE_READY;
 80194c8:	f884 2034 	strb.w	r2, [r4, #52]	@ 0x34
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
 80194cc:	f44f 7100 	mov.w	r1, #512	@ 0x200
 80194d0:	4618      	mov	r0, r3
 80194d2:	f001 f9db 	bl	801a88c <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
 80194d6:	b130      	cbz	r0, 80194e6 <HAL_SD_ConfigWideBusOperation+0x96>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 80194d8:	6823      	ldr	r3, [r4, #0]
    status = HAL_ERROR;
 80194da:	2501      	movs	r5, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 80194dc:	4a2a      	ldr	r2, [pc, #168]	@ (8019588 <HAL_SD_ConfigWideBusOperation+0x138>)
 80194de:	639a      	str	r2, [r3, #56]	@ 0x38
    hsd->ErrorCode |= errorstate;
 80194e0:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 80194e2:	4303      	orrs	r3, r0
 80194e4:	63a3      	str	r3, [r4, #56]	@ 0x38
  hsd->State = HAL_SD_STATE_READY;
 80194e6:	2301      	movs	r3, #1
}
 80194e8:	4628      	mov	r0, r5
  hsd->State = HAL_SD_STATE_READY;
 80194ea:	f884 3034 	strb.w	r3, [r4, #52]	@ 0x34
}
 80194ee:	b00a      	add	sp, #40	@ 0x28
 80194f0:	bd70      	pop	{r4, r5, r6, pc}
  uint32_t scr[2U] = {0U, 0U};
 80194f2:	2200      	movs	r2, #0
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 80194f4:	4618      	mov	r0, r3
  uint32_t scr[2U] = {0U, 0U};
 80194f6:	2300      	movs	r3, #0
 80194f8:	e9cd 2304 	strd	r2, r3, [sp, #16]
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 80194fc:	f001 f9ac 	bl	801a858 <SDMMC_GetResponse>
 8019500:	0182      	lsls	r2, r0, #6
 8019502:	d435      	bmi.n	8019570 <HAL_SD_ConfigWideBusOperation+0x120>
  errorstate = SD_FindSCR(hsd, scr);
 8019504:	a904      	add	r1, sp, #16
 8019506:	4620      	mov	r0, r4
 8019508:	f7ff fba0 	bl	8018c4c <SD_FindSCR.constprop.0>
  if(errorstate != HAL_SD_ERROR_NONE)
 801950c:	b960      	cbnz	r0, 8019528 <HAL_SD_ConfigWideBusOperation+0xd8>
  if((scr[1U] & SDMMC_SINGLE_BUS_SUPPORT) != SDMMC_ALLZERO)
 801950e:	9b05      	ldr	r3, [sp, #20]
 8019510:	03db      	lsls	r3, r3, #15
 8019512:	d530      	bpl.n	8019576 <HAL_SD_ConfigWideBusOperation+0x126>
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 8019514:	6d21      	ldr	r1, [r4, #80]	@ 0x50
 8019516:	6820      	ldr	r0, [r4, #0]
 8019518:	0409      	lsls	r1, r1, #16
 801951a:	f001 feaf 	bl	801b27c <SDMMC_CmdAppCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
 801951e:	b918      	cbnz	r0, 8019528 <HAL_SD_ConfigWideBusOperation+0xd8>
    errorstate = SDMMC_CmdBusWidth(hsd->Instance, 0U);
 8019520:	4601      	mov	r1, r0
 8019522:	6820      	ldr	r0, [r4, #0]
 8019524:	f001 ff94 	bl	801b450 <SDMMC_CmdBusWidth>
      hsd->ErrorCode |= errorstate;
 8019528:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
 801952a:	6823      	ldr	r3, [r4, #0]
 801952c:	4302      	orrs	r2, r0
 801952e:	63a2      	str	r2, [r4, #56]	@ 0x38
 8019530:	e7c3      	b.n	80194ba <HAL_SD_ConfigWideBusOperation+0x6a>
  uint32_t scr[2U] = {0U, 0U};
 8019532:	ed9f 7b13 	vldr	d7, [pc, #76]	@ 8019580 <HAL_SD_ConfigWideBusOperation+0x130>
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 8019536:	4618      	mov	r0, r3
 8019538:	2100      	movs	r1, #0
  uint32_t scr[2U] = {0U, 0U};
 801953a:	ed8d 7b04 	vstr	d7, [sp, #16]
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 801953e:	f001 f98b 	bl	801a858 <SDMMC_GetResponse>
 8019542:	0180      	lsls	r0, r0, #6
 8019544:	d414      	bmi.n	8019570 <HAL_SD_ConfigWideBusOperation+0x120>
  errorstate = SD_FindSCR(hsd, scr);
 8019546:	a904      	add	r1, sp, #16
 8019548:	4620      	mov	r0, r4
 801954a:	f7ff fb7f 	bl	8018c4c <SD_FindSCR.constprop.0>
  if(errorstate != HAL_SD_ERROR_NONE)
 801954e:	2800      	cmp	r0, #0
 8019550:	d1ea      	bne.n	8019528 <HAL_SD_ConfigWideBusOperation+0xd8>
  if((scr[1U] & SDMMC_WIDE_BUS_SUPPORT) != SDMMC_ALLZERO)
 8019552:	9b05      	ldr	r3, [sp, #20]
 8019554:	0359      	lsls	r1, r3, #13
 8019556:	d50e      	bpl.n	8019576 <HAL_SD_ConfigWideBusOperation+0x126>
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 8019558:	6d21      	ldr	r1, [r4, #80]	@ 0x50
 801955a:	6820      	ldr	r0, [r4, #0]
 801955c:	0409      	lsls	r1, r1, #16
 801955e:	f001 fe8d 	bl	801b27c <SDMMC_CmdAppCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
 8019562:	2800      	cmp	r0, #0
 8019564:	d1e0      	bne.n	8019528 <HAL_SD_ConfigWideBusOperation+0xd8>
    errorstate = SDMMC_CmdBusWidth(hsd->Instance, 2U);
 8019566:	2102      	movs	r1, #2
 8019568:	6820      	ldr	r0, [r4, #0]
 801956a:	f001 ff71 	bl	801b450 <SDMMC_CmdBusWidth>
    if(errorstate != HAL_SD_ERROR_NONE)
 801956e:	e7db      	b.n	8019528 <HAL_SD_ConfigWideBusOperation+0xd8>
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
 8019570:	f44f 6000 	mov.w	r0, #2048	@ 0x800
 8019574:	e7d8      	b.n	8019528 <HAL_SD_ConfigWideBusOperation+0xd8>
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
 8019576:	f04f 6080 	mov.w	r0, #67108864	@ 0x4000000
 801957a:	e7d5      	b.n	8019528 <HAL_SD_ConfigWideBusOperation+0xd8>
 801957c:	f3af 8000 	nop.w
	...
 8019588:	004005ff 	.word	0x004005ff

0801958c <HAL_SD_GetCardState>:
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 801958c:	6d01      	ldr	r1, [r0, #80]	@ 0x50
{
 801958e:	b510      	push	{r4, lr}
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 8019590:	0409      	lsls	r1, r1, #16
{
 8019592:	4604      	mov	r4, r0
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 8019594:	6800      	ldr	r0, [r0, #0]
 8019596:	f002 f97d 	bl	801b894 <SDMMC_CmdSendStatus>
  if(errorstate != HAL_SD_ERROR_NONE)
 801959a:	4601      	mov	r1, r0
 801959c:	b120      	cbz	r0, 80195a8 <HAL_SD_GetCardState+0x1c>
    hsd->ErrorCode |= errorstate;
 801959e:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 80195a0:	2000      	movs	r0, #0
 80195a2:	430b      	orrs	r3, r1
 80195a4:	63a3      	str	r3, [r4, #56]	@ 0x38
}
 80195a6:	bd10      	pop	{r4, pc}
  *pCardStatus = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 80195a8:	6820      	ldr	r0, [r4, #0]
 80195aa:	f001 f955 	bl	801a858 <SDMMC_GetResponse>
  cardstate = ((resp1 >> 9U) & 0x0FU);
 80195ae:	f3c0 2043 	ubfx	r0, r0, #9, #4
}
 80195b2:	bd10      	pop	{r4, pc}

080195b4 <HAL_SDRAM_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_Init(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_TimingTypeDef *Timing)
{
  /* Check the SDRAM handle parameter */
  if (hsdram == NULL)
 80195b4:	b1f0      	cbz	r0, 80195f4 <HAL_SDRAM_Init+0x40>
{
 80195b6:	b538      	push	{r3, r4, r5, lr}
  {
    return HAL_ERROR;
  }

  if (hsdram->State == HAL_SDRAM_STATE_RESET)
 80195b8:	f890 302c 	ldrb.w	r3, [r0, #44]	@ 0x2c
 80195bc:	4604      	mov	r4, r0
 80195be:	460d      	mov	r5, r1
 80195c0:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
 80195c4:	b18b      	cbz	r3, 80195ea <HAL_SDRAM_Init+0x36>

  /* Initialize the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;

  /* Initialize SDRAM control Interface */
  (void)FMC_SDRAM_Init(hsdram->Instance, &(hsdram->Init));
 80195c6:	4621      	mov	r1, r4
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 80195c8:	2302      	movs	r3, #2
 80195ca:	f884 302c 	strb.w	r3, [r4, #44]	@ 0x2c
  (void)FMC_SDRAM_Init(hsdram->Instance, &(hsdram->Init));
 80195ce:	f851 0b04 	ldr.w	r0, [r1], #4
 80195d2:	f001 f879 	bl	801a6c8 <FMC_SDRAM_Init>

  /* Initialize SDRAM timing Interface */
  (void)FMC_SDRAM_Timing_Init(hsdram->Instance, Timing, hsdram->Init.SDBank);
 80195d6:	6862      	ldr	r2, [r4, #4]
 80195d8:	4629      	mov	r1, r5
 80195da:	6820      	ldr	r0, [r4, #0]
 80195dc:	f001 f8ac 	bl	801a738 <FMC_SDRAM_Timing_Init>
  /* Update the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_READY;
 80195e0:	2301      	movs	r3, #1

  return HAL_OK;
 80195e2:	2000      	movs	r0, #0
  hsdram->State = HAL_SDRAM_STATE_READY;
 80195e4:	f884 302c 	strb.w	r3, [r4, #44]	@ 0x2c
}
 80195e8:	bd38      	pop	{r3, r4, r5, pc}
    hsdram->Lock = HAL_UNLOCKED;
 80195ea:	f880 202d 	strb.w	r2, [r0, #45]	@ 0x2d
    HAL_SDRAM_MspInit(hsdram);
 80195ee:	f7f9 fa83 	bl	8012af8 <HAL_SDRAM_MspInit>
 80195f2:	e7e8      	b.n	80195c6 <HAL_SDRAM_Init+0x12>
    return HAL_ERROR;
 80195f4:	2001      	movs	r0, #1
}
 80195f6:	4770      	bx	lr

080195f8 <HAL_SDRAM_SendCommand>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_SendCommand(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_CommandTypeDef *Command,
                                        uint32_t Timeout)
{
 80195f8:	b570      	push	{r4, r5, r6, lr}
  HAL_SDRAM_StateTypeDef state = hsdram->State;
 80195fa:	f890 302c 	ldrb.w	r3, [r0, #44]	@ 0x2c
{
 80195fe:	4605      	mov	r5, r0

  /* Check the SDRAM controller state */
  if (state == HAL_SDRAM_STATE_BUSY)
 8019600:	2b02      	cmp	r3, #2
  HAL_SDRAM_StateTypeDef state = hsdram->State;
 8019602:	b2d8      	uxtb	r0, r3
  if (state == HAL_SDRAM_STATE_BUSY)
 8019604:	d004      	beq.n	8019610 <HAL_SDRAM_SendCommand+0x18>
  {
    return HAL_BUSY;
  }
  else if ((state == HAL_SDRAM_STATE_READY) || (state == HAL_SDRAM_STATE_PRECHARGED))
 8019606:	f000 04fb 	and.w	r4, r0, #251	@ 0xfb
 801960a:	2c01      	cmp	r4, #1
 801960c:	d001      	beq.n	8019612 <HAL_SDRAM_SendCommand+0x1a>
      hsdram->State = HAL_SDRAM_STATE_READY;
    }
  }
  else
  {
    return HAL_ERROR;
 801960e:	2001      	movs	r0, #1
  }

  return HAL_OK;
}
 8019610:	bd70      	pop	{r4, r5, r6, pc}
    hsdram->State = HAL_SDRAM_STATE_BUSY;
 8019612:	2302      	movs	r3, #2
 8019614:	460e      	mov	r6, r1
    (void)FMC_SDRAM_SendCommand(hsdram->Instance, Command, Timeout);
 8019616:	6828      	ldr	r0, [r5, #0]
    hsdram->State = HAL_SDRAM_STATE_BUSY;
 8019618:	f885 302c 	strb.w	r3, [r5, #44]	@ 0x2c
    (void)FMC_SDRAM_SendCommand(hsdram->Instance, Command, Timeout);
 801961c:	f001 f8ca 	bl	801a7b4 <FMC_SDRAM_SendCommand>
    if (Command->CommandMode == FMC_SDRAM_CMD_PALL)
 8019620:	6833      	ldr	r3, [r6, #0]
 8019622:	2b02      	cmp	r3, #2
 8019624:	d003      	beq.n	801962e <HAL_SDRAM_SendCommand+0x36>
      hsdram->State = HAL_SDRAM_STATE_READY;
 8019626:	f885 402c 	strb.w	r4, [r5, #44]	@ 0x2c
  return HAL_OK;
 801962a:	2000      	movs	r0, #0
}
 801962c:	bd70      	pop	{r4, r5, r6, pc}
      hsdram->State = HAL_SDRAM_STATE_PRECHARGED;
 801962e:	2305      	movs	r3, #5
 8019630:	f885 302c 	strb.w	r3, [r5, #44]	@ 0x2c
 8019634:	e7f9      	b.n	801962a <HAL_SDRAM_SendCommand+0x32>
 8019636:	bf00      	nop

08019638 <HAL_SDRAM_ProgramRefreshRate>:
  *                the configuration information for SDRAM module.
  * @param  RefreshRate The SDRAM refresh rate value
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_ProgramRefreshRate(SDRAM_HandleTypeDef *hsdram, uint32_t RefreshRate)
{
 8019638:	b538      	push	{r3, r4, r5, lr}
  /* Check the SDRAM controller state */
  if (hsdram->State == HAL_SDRAM_STATE_BUSY)
 801963a:	f890 302c 	ldrb.w	r3, [r0, #44]	@ 0x2c
{
 801963e:	4604      	mov	r4, r0
  if (hsdram->State == HAL_SDRAM_STATE_BUSY)
 8019640:	2b02      	cmp	r3, #2
 8019642:	b2d8      	uxtb	r0, r3
 8019644:	d005      	beq.n	8019652 <HAL_SDRAM_ProgramRefreshRate+0x1a>
  {
    return HAL_BUSY;
  }
  else if (hsdram->State == HAL_SDRAM_STATE_READY)
 8019646:	f894 302c 	ldrb.w	r3, [r4, #44]	@ 0x2c
 801964a:	2b01      	cmp	r3, #1
 801964c:	b2dd      	uxtb	r5, r3
 801964e:	d001      	beq.n	8019654 <HAL_SDRAM_ProgramRefreshRate+0x1c>
    /* Update the SDRAM state */
    hsdram->State = HAL_SDRAM_STATE_READY;
  }
  else
  {
    return HAL_ERROR;
 8019650:	2001      	movs	r0, #1
  }

  return HAL_OK;
}
 8019652:	bd38      	pop	{r3, r4, r5, pc}
    hsdram->State = HAL_SDRAM_STATE_BUSY;
 8019654:	2302      	movs	r3, #2
    (void)FMC_SDRAM_ProgramRefreshRate(hsdram->Instance, RefreshRate);
 8019656:	6820      	ldr	r0, [r4, #0]
    hsdram->State = HAL_SDRAM_STATE_BUSY;
 8019658:	f884 302c 	strb.w	r3, [r4, #44]	@ 0x2c
    (void)FMC_SDRAM_ProgramRefreshRate(hsdram->Instance, RefreshRate);
 801965c:	f001 f8c2 	bl	801a7e4 <FMC_SDRAM_ProgramRefreshRate>
  return HAL_OK;
 8019660:	2000      	movs	r0, #0
    hsdram->State = HAL_SDRAM_STATE_READY;
 8019662:	f884 502c 	strb.w	r5, [r4, #44]	@ 0x2c
}
 8019666:	bd38      	pop	{r3, r4, r5, pc}

08019668 <HAL_SPDIFRX_Init>:
HAL_StatusTypeDef HAL_SPDIFRX_Init(SPDIFRX_HandleTypeDef *hspdif)
{
  uint32_t tmpreg;

  /* Check the SPDIFRX handle allocation */
  if (hspdif == NULL)
 8019668:	b390      	cbz	r0, 80196d0 <HAL_SPDIFRX_Init+0x68>
{
 801966a:	b538      	push	{r3, r4, r5, lr}

    /* Init the low level hardware */
    hspdif->MspInitCallback(hspdif);
  }
#else
  if (hspdif->State == HAL_SPDIFRX_STATE_RESET)
 801966c:	f890 3045 	ldrb.w	r3, [r0, #69]	@ 0x45
 8019670:	4604      	mov	r4, r0
 8019672:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
 8019676:	b333      	cbz	r3, 80196c6 <HAL_SPDIFRX_Init+0x5e>
              SPDIFRX_CR_VMSK | SPDIFRX_CR_CUMSK | SPDIFRX_CR_PTMSK  |
              SPDIFRX_CR_CHSEL | SPDIFRX_CR_NBTR | SPDIFRX_CR_WFA |
              SPDIFRX_CR_INSEL);

  /* Sets the new configuration of the SPDIFRX peripheral */
  tmpreg |= (hspdif->Init.StereoMode |
 8019678:	69a3      	ldr	r3, [r4, #24]
  hspdif->State = HAL_SPDIFRX_STATE_BUSY;
 801967a:	2502      	movs	r5, #2
             hspdif->Init.InputSelection |
             hspdif->Init.Retries |
 801967c:	68e0      	ldr	r0, [r4, #12]
  hspdif->State = HAL_SPDIFRX_STATE_BUSY;
 801967e:	f884 5045 	strb.w	r5, [r4, #69]	@ 0x45
            );


  hspdif->Instance->CR = tmpreg;

  hspdif->ErrorCode = HAL_SPDIFRX_ERROR_NONE;
 8019682:	2500      	movs	r5, #0
             hspdif->Init.InputSelection |
 8019684:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
  tmpreg |= (hspdif->Init.StereoMode |
 8019688:	4313      	orrs	r3, r2
  __HAL_SPDIFRX_IDLE(hspdif);
 801968a:	6822      	ldr	r2, [r4, #0]
             hspdif->Init.InputSelection |
 801968c:	430b      	orrs	r3, r1
             hspdif->Init.WaitForActivity |
 801968e:	6921      	ldr	r1, [r4, #16]
             hspdif->Init.Retries |
 8019690:	4303      	orrs	r3, r0
             hspdif->Init.ChannelSelection |
 8019692:	6960      	ldr	r0, [r4, #20]
             hspdif->Init.WaitForActivity |
 8019694:	430b      	orrs	r3, r1
             hspdif->Init.DataFormat |
 8019696:	69e1      	ldr	r1, [r4, #28]
             hspdif->Init.ChannelSelection |
 8019698:	4303      	orrs	r3, r0
             hspdif->Init.DataFormat |
 801969a:	430b      	orrs	r3, r1
             hspdif->Init.ChannelStatusMask |
 801969c:	e9d4 0108 	ldrd	r0, r1, [r4, #32]
             hspdif->Init.PreambleTypeMask |
 80196a0:	4303      	orrs	r3, r0
             hspdif->Init.ChannelStatusMask |
 80196a2:	430b      	orrs	r3, r1
             hspdif->Init.ValidityBitMask |
 80196a4:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
 80196a6:	430b      	orrs	r3, r1
  __HAL_SPDIFRX_IDLE(hspdif);
 80196a8:	6811      	ldr	r1, [r2, #0]
 80196aa:	f021 0103 	bic.w	r1, r1, #3
 80196ae:	6011      	str	r1, [r2, #0]
  tmpreg &= ~(SPDIFRX_CR_RXSTEO  | SPDIFRX_CR_DRFMT  | SPDIFRX_CR_PMSK |
 80196b0:	4908      	ldr	r1, [pc, #32]	@ (80196d4 <HAL_SPDIFRX_Init+0x6c>)
  tmpreg = hspdif->Instance->CR;
 80196b2:	6810      	ldr	r0, [r2, #0]
  tmpreg &= ~(SPDIFRX_CR_RXSTEO  | SPDIFRX_CR_DRFMT  | SPDIFRX_CR_PMSK |
 80196b4:	4001      	ands	r1, r0

  /* SPDIFRX peripheral state is READY*/
  hspdif->State = HAL_SPDIFRX_STATE_READY;

  return HAL_OK;
 80196b6:	4628      	mov	r0, r5
  tmpreg |= (hspdif->Init.StereoMode |
 80196b8:	430b      	orrs	r3, r1
  hspdif->State = HAL_SPDIFRX_STATE_READY;
 80196ba:	2101      	movs	r1, #1
  hspdif->Instance->CR = tmpreg;
 80196bc:	6013      	str	r3, [r2, #0]
  hspdif->ErrorCode = HAL_SPDIFRX_ERROR_NONE;
 80196be:	64a5      	str	r5, [r4, #72]	@ 0x48
  hspdif->State = HAL_SPDIFRX_STATE_READY;
 80196c0:	f884 1045 	strb.w	r1, [r4, #69]	@ 0x45
}
 80196c4:	bd38      	pop	{r3, r4, r5, pc}
    hspdif->Lock = HAL_UNLOCKED;
 80196c6:	f880 2044 	strb.w	r2, [r0, #68]	@ 0x44
    HAL_SPDIFRX_MspInit(hspdif);
 80196ca:	f7f8 ffc9 	bl	8012660 <HAL_SPDIFRX_MspInit>
 80196ce:	e7d3      	b.n	8019678 <HAL_SPDIFRX_Init+0x10>
    return HAL_ERROR;
 80196d0:	2001      	movs	r0, #1
}
 80196d2:	4770      	bx	lr
 80196d4:	fff88407 	.word	0xfff88407

080196d8 <HAL_SPI_Init>:
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
  uint32_t frxth;

  /* Check the SPI handle allocation */
  if (hspi == NULL)
 80196d8:	2800      	cmp	r0, #0
 80196da:	d071      	beq.n	80197c0 <HAL_SPI_Init+0xe8>
  assert_param(IS_SPI_NSS(hspi->Init.NSS));
  assert_param(IS_SPI_NSSP(hspi->Init.NSSPMode));
  assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
  assert_param(IS_SPI_FIRST_BIT(hspi->Init.FirstBit));
  assert_param(IS_SPI_TIMODE(hspi->Init.TIMode));
  if (hspi->Init.TIMode == SPI_TIMODE_DISABLE)
 80196dc:	6a42      	ldr	r2, [r0, #36]	@ 0x24
{
 80196de:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80196e0:	4604      	mov	r4, r0
  if (hspi->Init.TIMode == SPI_TIMODE_DISABLE)
 80196e2:	2a00      	cmp	r2, #0
 80196e4:	d05c      	beq.n	80197a0 <HAL_SPI_Init+0xc8>
  else
  {
    assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));

    /* Force polarity and phase to TI protocaol requirements */
    hspi->Init.CLKPolarity = SPI_POLARITY_LOW;
 80196e6:	2300      	movs	r3, #0
 80196e8:	e9c0 3304 	strd	r3, r3, [r0, #16]
  {
    assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
    assert_param(IS_SPI_CRC_LENGTH(hspi->Init.CRCLength));
  }
#else
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 80196ec:	2100      	movs	r1, #0
#endif /* USE_SPI_CRC */

  if (hspi->State == HAL_SPI_STATE_RESET)
 80196ee:	f894 305d 	ldrb.w	r3, [r4, #93]	@ 0x5d
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 80196f2:	62a1      	str	r1, [r4, #40]	@ 0x28
  if (hspi->State == HAL_SPI_STATE_RESET)
 80196f4:	f003 01ff 	and.w	r1, r3, #255	@ 0xff
 80196f8:	2b00      	cmp	r3, #0
 80196fa:	d05a      	beq.n	80197b2 <HAL_SPI_Init+0xda>
  }

  hspi->State = HAL_SPI_STATE_BUSY;

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 80196fc:	6821      	ldr	r1, [r4, #0]
  hspi->State = HAL_SPI_STATE_BUSY;
 80196fe:	2302      	movs	r3, #2

  /* Align by default the rs fifo threshold on the data size */
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8019700:	68e6      	ldr	r6, [r4, #12]
  hspi->State = HAL_SPI_STATE_BUSY;
 8019702:	f884 305d 	strb.w	r3, [r4, #93]	@ 0x5d
  __HAL_SPI_DISABLE(hspi);
 8019706:	680b      	ldr	r3, [r1, #0]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8019708:	f5b6 6fe0 	cmp.w	r6, #1792	@ 0x700
  __HAL_SPI_DISABLE(hspi);
 801970c:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8019710:	bf8c      	ite	hi
 8019712:	f04f 0e00 	movhi.w	lr, #0
 8019716:	f04f 0e01 	movls.w	lr, #1
  __HAL_SPI_DISABLE(hspi);
 801971a:	600b      	str	r3, [r1, #0]
  {
    frxth = SPI_RXFIFO_THRESHOLD_QF;
  }

  /* CRC calculation is valid only for 16Bit and 8 Bit */
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 801971c:	f426 6300 	bic.w	r3, r6, #2048	@ 0x800
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8019720:	ea4f 3e0e 	mov.w	lr, lr, lsl #12
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 8019724:	f5b3 6fe0 	cmp.w	r3, #1792	@ 0x700
 8019728:	d140      	bne.n	80197ac <HAL_SPI_Init+0xd4>
  }

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 801972a:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
 801972c:	f400 5000 	and.w	r0, r0, #8192	@ 0x2000
 8019730:	6863      	ldr	r3, [r4, #4]
    }
  }
#endif /* USE_SPI_CRC */

  /* Configure : NSS management, TI Mode, NSS Pulse, Data size and Rx Fifo threshold */
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) |
 8019732:	f002 0c10 	and.w	ip, r2, #16
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 8019736:	69a5      	ldr	r5, [r4, #24]
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) |
 8019738:	f406 6670 	and.w	r6, r6, #3840	@ 0xf00
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 801973c:	f403 7282 	and.w	r2, r3, #260	@ 0x104
 8019740:	68a3      	ldr	r3, [r4, #8]
 8019742:	f405 7700 	and.w	r7, r5, #512	@ 0x200
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) |
 8019746:	0c2d      	lsrs	r5, r5, #16
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 8019748:	f403 4304 	and.w	r3, r3, #33792	@ 0x8400
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) |
 801974c:	f005 0504 	and.w	r5, r5, #4
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 8019750:	431a      	orrs	r2, r3
 8019752:	6923      	ldr	r3, [r4, #16]
 8019754:	f003 0302 	and.w	r3, r3, #2
 8019758:	431a      	orrs	r2, r3
 801975a:	6963      	ldr	r3, [r4, #20]
 801975c:	f003 0301 	and.w	r3, r3, #1
 8019760:	431a      	orrs	r2, r3
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) |
 8019762:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 8019764:	f003 0308 	and.w	r3, r3, #8
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 8019768:	433a      	orrs	r2, r7
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) |
 801976a:	4333      	orrs	r3, r6
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 801976c:	69e6      	ldr	r6, [r4, #28]
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) |
 801976e:	432b      	orrs	r3, r5
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 8019770:	f006 0638 	and.w	r6, r6, #56	@ 0x38
 8019774:	6a25      	ldr	r5, [r4, #32]
 8019776:	4332      	orrs	r2, r6
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) |
 8019778:	ea43 030e 	orr.w	r3, r3, lr
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 801977c:	f005 0580 	and.w	r5, r5, #128	@ 0x80
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) |
 8019780:	ea43 030c 	orr.w	r3, r3, ip
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 8019784:	432a      	orrs	r2, r5
 8019786:	4302      	orrs	r2, r0
#if defined(SPI_I2SCFGR_I2SMOD)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
#endif /* SPI_I2SCFGR_I2SMOD */

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8019788:	2000      	movs	r0, #0
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 801978a:	600a      	str	r2, [r1, #0]
  hspi->State     = HAL_SPI_STATE_READY;
 801978c:	2201      	movs	r2, #1
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) |
 801978e:	604b      	str	r3, [r1, #4]
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 8019790:	69cb      	ldr	r3, [r1, #28]
 8019792:	f423 6300 	bic.w	r3, r3, #2048	@ 0x800
 8019796:	61cb      	str	r3, [r1, #28]
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8019798:	6620      	str	r0, [r4, #96]	@ 0x60
  hspi->State     = HAL_SPI_STATE_READY;
 801979a:	f884 205d 	strb.w	r2, [r4, #93]	@ 0x5d

  return HAL_OK;
}
 801979e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (hspi->Init.Mode == SPI_MODE_MASTER)
 80197a0:	6843      	ldr	r3, [r0, #4]
 80197a2:	f5b3 7f82 	cmp.w	r3, #260	@ 0x104
 80197a6:	d0a1      	beq.n	80196ec <HAL_SPI_Init+0x14>
      hspi->Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
 80197a8:	61c2      	str	r2, [r0, #28]
 80197aa:	e79f      	b.n	80196ec <HAL_SPI_Init+0x14>
    hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 80197ac:	2000      	movs	r0, #0
 80197ae:	62a0      	str	r0, [r4, #40]	@ 0x28
 80197b0:	e7be      	b.n	8019730 <HAL_SPI_Init+0x58>
    HAL_SPI_MspInit(hspi);
 80197b2:	4620      	mov	r0, r4
    hspi->Lock = HAL_UNLOCKED;
 80197b4:	f884 105c 	strb.w	r1, [r4, #92]	@ 0x5c
    HAL_SPI_MspInit(hspi);
 80197b8:	f7f8 ffaa 	bl	8012710 <HAL_SPI_MspInit>
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) |
 80197bc:	6a62      	ldr	r2, [r4, #36]	@ 0x24
 80197be:	e79d      	b.n	80196fc <HAL_SPI_Init+0x24>
    return HAL_ERROR;
 80197c0:	2001      	movs	r0, #1
}
 80197c2:	4770      	bx	lr

080197c4 <HAL_TIM_Base_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
{
  /* Check the TIM handle allocation */
  if (htim == NULL)
 80197c4:	2800      	cmp	r0, #0
 80197c6:	f000 8092 	beq.w	80198ee <HAL_TIM_Base_Init+0x12a>
{
 80197ca:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_PERIOD(htim, htim->Init.Period));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
 80197cc:	f890 303d 	ldrb.w	r3, [r0, #61]	@ 0x3d
 80197d0:	4604      	mov	r4, r0
 80197d2:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
 80197d6:	2b00      	cmp	r3, #0
 80197d8:	f000 8084 	beq.w	80198e4 <HAL_TIM_Base_Init+0x120>

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;

  /* Set the Time Base configuration */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 80197dc:	6822      	ldr	r2, [r4, #0]
  htim->State = HAL_TIM_STATE_BUSY;
 80197de:	2302      	movs	r3, #2
{
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 80197e0:	4944      	ldr	r1, [pc, #272]	@ (80198f4 <HAL_TIM_Base_Init+0x130>)
 80197e2:	4845      	ldr	r0, [pc, #276]	@ (80198f8 <HAL_TIM_Base_Init+0x134>)
 80197e4:	f1b2 4f80 	cmp.w	r2, #1073741824	@ 0x40000000
 80197e8:	eba2 0101 	sub.w	r1, r2, r1
  htim->State = HAL_TIM_STATE_BUSY;
 80197ec:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 80197f0:	eba2 0e00 	sub.w	lr, r2, r0
  tmpcr1 = TIMx->CR1;
 80197f4:	6813      	ldr	r3, [r2, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 80197f6:	fab1 f181 	clz	r1, r1
    tmpcr1 &= ~TIM_CR1_CKD;
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 80197fa:	69a7      	ldr	r7, [r4, #24]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 80197fc:	fabe fe8e 	clz	lr, lr

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 8019800:	6865      	ldr	r5, [r4, #4]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8019802:	ea4f 1151 	mov.w	r1, r1, lsr #5
  TIMx->ARR = (uint32_t)Structure->Period ;
 8019806:	68e6      	ldr	r6, [r4, #12]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8019808:	ea4f 1e5e 	mov.w	lr, lr, lsr #5
 801980c:	d055      	beq.n	80198ba <HAL_TIM_Base_Init+0xf6>
 801980e:	2900      	cmp	r1, #0
 8019810:	d153      	bne.n	80198ba <HAL_TIM_Base_Init+0xf6>
 8019812:	f8df c0ec 	ldr.w	ip, [pc, #236]	@ 8019900 <HAL_TIM_Base_Init+0x13c>
 8019816:	4562      	cmp	r2, ip
 8019818:	d04f      	beq.n	80198ba <HAL_TIM_Base_Init+0xf6>
 801981a:	f50c 6c80 	add.w	ip, ip, #1024	@ 0x400
 801981e:	4562      	cmp	r2, ip
 8019820:	d04b      	beq.n	80198ba <HAL_TIM_Base_Init+0xf6>
 8019822:	f50c 6c80 	add.w	ip, ip, #1024	@ 0x400
 8019826:	4562      	cmp	r2, ip
 8019828:	d047      	beq.n	80198ba <HAL_TIM_Base_Init+0xf6>
 801982a:	f1be 0f00 	cmp.w	lr, #0
 801982e:	d144      	bne.n	80198ba <HAL_TIM_Base_Init+0xf6>
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8019830:	4932      	ldr	r1, [pc, #200]	@ (80198fc <HAL_TIM_Base_Init+0x138>)
 8019832:	428a      	cmp	r2, r1
 8019834:	d013      	beq.n	801985e <HAL_TIM_Base_Init+0x9a>
 8019836:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 801983a:	428a      	cmp	r2, r1
 801983c:	d00f      	beq.n	801985e <HAL_TIM_Base_Init+0x9a>
 801983e:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 8019842:	428a      	cmp	r2, r1
 8019844:	d00b      	beq.n	801985e <HAL_TIM_Base_Init+0x9a>
 8019846:	f5a1 3198 	sub.w	r1, r1, #77824	@ 0x13000
 801984a:	428a      	cmp	r2, r1
 801984c:	d007      	beq.n	801985e <HAL_TIM_Base_Init+0x9a>
 801984e:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 8019852:	428a      	cmp	r2, r1
 8019854:	d003      	beq.n	801985e <HAL_TIM_Base_Init+0x9a>
 8019856:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 801985a:	428a      	cmp	r2, r1
 801985c:	d103      	bne.n	8019866 <HAL_TIM_Base_Init+0xa2>
    tmpcr1 &= ~TIM_CR1_CKD;
 801985e:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8019862:	6921      	ldr	r1, [r4, #16]
 8019864:	430b      	orrs	r3, r1
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8019866:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 801986a:	433b      	orrs	r3, r7
  TIMx->CR1 = tmpcr1;
 801986c:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 801986e:	62d6      	str	r6, [r2, #44]	@ 0x2c
  TIMx->PSC = Structure->Prescaler;
 8019870:	6295      	str	r5, [r2, #40]	@ 0x28
    TIMx->RCR = Structure->RepetitionCounter;
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 8019872:	2301      	movs	r3, #1
 8019874:	6153      	str	r3, [r2, #20]

  /* Check if the update flag is set after the Update Generation, if so clear the UIF flag */
  if (HAL_IS_BIT_SET(TIMx->SR, TIM_FLAG_UPDATE))
 8019876:	6913      	ldr	r3, [r2, #16]
 8019878:	07db      	lsls	r3, r3, #31
 801987a:	d503      	bpl.n	8019884 <HAL_TIM_Base_Init+0xc0>
  {
    /* Clear the update flag */
    CLEAR_BIT(TIMx->SR, TIM_FLAG_UPDATE);
 801987c:	6913      	ldr	r3, [r2, #16]
 801987e:	f023 0301 	bic.w	r3, r3, #1
 8019882:	6113      	str	r3, [r2, #16]
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8019884:	2301      	movs	r3, #1
  return HAL_OK;
 8019886:	2000      	movs	r0, #0
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8019888:	f884 3048 	strb.w	r3, [r4, #72]	@ 0x48
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 801988c:	f884 303e 	strb.w	r3, [r4, #62]	@ 0x3e
 8019890:	f884 303f 	strb.w	r3, [r4, #63]	@ 0x3f
 8019894:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
 8019898:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
 801989c:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
 80198a0:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 80198a4:	f884 3044 	strb.w	r3, [r4, #68]	@ 0x44
 80198a8:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
 80198ac:	f884 3046 	strb.w	r3, [r4, #70]	@ 0x46
 80198b0:	f884 3047 	strb.w	r3, [r4, #71]	@ 0x47
  htim->State = HAL_TIM_STATE_READY;
 80198b4:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
}
 80198b8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    tmpcr1 |= Structure->CounterMode;
 80198ba:	68a0      	ldr	r0, [r4, #8]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 80198bc:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
    tmpcr1 |= Structure->CounterMode;
 80198c0:	4303      	orrs	r3, r0
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80198c2:	6920      	ldr	r0, [r4, #16]
    tmpcr1 &= ~TIM_CR1_CKD;
 80198c4:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80198c8:	4303      	orrs	r3, r0
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 80198ca:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 80198ce:	433b      	orrs	r3, r7
  TIMx->CR1 = tmpcr1;
 80198d0:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 80198d2:	62d6      	str	r6, [r2, #44]	@ 0x2c
  TIMx->PSC = Structure->Prescaler;
 80198d4:	6295      	str	r5, [r2, #40]	@ 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 80198d6:	b911      	cbnz	r1, 80198de <HAL_TIM_Base_Init+0x11a>
 80198d8:	f1be 0f00 	cmp.w	lr, #0
 80198dc:	d0c9      	beq.n	8019872 <HAL_TIM_Base_Init+0xae>
    TIMx->RCR = Structure->RepetitionCounter;
 80198de:	6963      	ldr	r3, [r4, #20]
 80198e0:	6313      	str	r3, [r2, #48]	@ 0x30
 80198e2:	e7c6      	b.n	8019872 <HAL_TIM_Base_Init+0xae>
    htim->Lock = HAL_UNLOCKED;
 80198e4:	f880 203c 	strb.w	r2, [r0, #60]	@ 0x3c
    HAL_TIM_Base_MspInit(htim);
 80198e8:	f7f8 ff5c 	bl	80127a4 <HAL_TIM_Base_MspInit>
 80198ec:	e776      	b.n	80197dc <HAL_TIM_Base_Init+0x18>
    return HAL_ERROR;
 80198ee:	2001      	movs	r0, #1
}
 80198f0:	4770      	bx	lr
 80198f2:	bf00      	nop
 80198f4:	40010000 	.word	0x40010000
 80198f8:	40010400 	.word	0x40010400
 80198fc:	40014000 	.word	0x40014000
 8019900:	40000400 	.word	0x40000400

08019904 <HAL_TIM_Base_Start_IT>:
  if (htim->State != HAL_TIM_STATE_READY)
 8019904:	f890 303d 	ldrb.w	r3, [r0, #61]	@ 0x3d
 8019908:	2b01      	cmp	r3, #1
 801990a:	d13d      	bne.n	8019988 <HAL_TIM_Base_Start_IT+0x84>
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 801990c:	6802      	ldr	r2, [r0, #0]
  htim->State = HAL_TIM_STATE_BUSY;
 801990e:	2102      	movs	r1, #2
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8019910:	4b1e      	ldr	r3, [pc, #120]	@ (801998c <HAL_TIM_Base_Start_IT+0x88>)
 8019912:	f1b2 4f80 	cmp.w	r2, #1073741824	@ 0x40000000
 8019916:	bf18      	it	ne
 8019918:	429a      	cmpne	r2, r3
{
 801991a:	b430      	push	{r4, r5}
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 801991c:	bf0c      	ite	eq
 801991e:	2301      	moveq	r3, #1
 8019920:	2300      	movne	r3, #0
 8019922:	4d1b      	ldr	r5, [pc, #108]	@ (8019990 <HAL_TIM_Base_Start_IT+0x8c>)
 8019924:	4c1b      	ldr	r4, [pc, #108]	@ (8019994 <HAL_TIM_Base_Start_IT+0x90>)
 8019926:	42aa      	cmp	r2, r5
 8019928:	bf08      	it	eq
 801992a:	f043 0301 	orreq.w	r3, r3, #1
  htim->State = HAL_TIM_STATE_BUSY;
 801992e:	f880 103d 	strb.w	r1, [r0, #61]	@ 0x3d
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8019932:	68d1      	ldr	r1, [r2, #12]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8019934:	42a2      	cmp	r2, r4
 8019936:	bf08      	it	eq
 8019938:	f043 0301 	orreq.w	r3, r3, #1
 801993c:	f504 6480 	add.w	r4, r4, #1024	@ 0x400
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8019940:	f041 0101 	orr.w	r1, r1, #1
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8019944:	4814      	ldr	r0, [pc, #80]	@ (8019998 <HAL_TIM_Base_Start_IT+0x94>)
 8019946:	42a2      	cmp	r2, r4
 8019948:	bf08      	it	eq
 801994a:	f043 0301 	orreq.w	r3, r3, #1
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 801994e:	60d1      	str	r1, [r2, #12]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8019950:	4282      	cmp	r2, r0
 8019952:	bf08      	it	eq
 8019954:	f043 0301 	orreq.w	r3, r3, #1
 8019958:	4910      	ldr	r1, [pc, #64]	@ (801999c <HAL_TIM_Base_Start_IT+0x98>)
 801995a:	428a      	cmp	r2, r1
 801995c:	bf08      	it	eq
 801995e:	f043 0301 	orreq.w	r3, r3, #1
 8019962:	b913      	cbnz	r3, 801996a <HAL_TIM_Base_Start_IT+0x66>
 8019964:	4b0e      	ldr	r3, [pc, #56]	@ (80199a0 <HAL_TIM_Base_Start_IT+0x9c>)
 8019966:	429a      	cmp	r2, r3
 8019968:	d107      	bne.n	801997a <HAL_TIM_Base_Start_IT+0x76>
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 801996a:	6891      	ldr	r1, [r2, #8]
 801996c:	4b0d      	ldr	r3, [pc, #52]	@ (80199a4 <HAL_TIM_Base_Start_IT+0xa0>)
 801996e:	400b      	ands	r3, r1
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8019970:	2b06      	cmp	r3, #6
 8019972:	d006      	beq.n	8019982 <HAL_TIM_Base_Start_IT+0x7e>
 8019974:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8019978:	d003      	beq.n	8019982 <HAL_TIM_Base_Start_IT+0x7e>
      __HAL_TIM_ENABLE(htim);
 801997a:	6813      	ldr	r3, [r2, #0]
 801997c:	f043 0301 	orr.w	r3, r3, #1
 8019980:	6013      	str	r3, [r2, #0]
  return HAL_OK;
 8019982:	2000      	movs	r0, #0
}
 8019984:	bc30      	pop	{r4, r5}
 8019986:	4770      	bx	lr
    return HAL_ERROR;
 8019988:	2001      	movs	r0, #1
}
 801998a:	4770      	bx	lr
 801998c:	40010000 	.word	0x40010000
 8019990:	40000400 	.word	0x40000400
 8019994:	40000800 	.word	0x40000800
 8019998:	40010400 	.word	0x40010400
 801999c:	40014000 	.word	0x40014000
 80199a0:	40001800 	.word	0x40001800
 80199a4:	00010007 	.word	0x00010007

080199a8 <HAL_TIM_PWM_Init>:
  if (htim == NULL)
 80199a8:	2800      	cmp	r0, #0
 80199aa:	f000 8092 	beq.w	8019ad2 <HAL_TIM_PWM_Init+0x12a>
{
 80199ae:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (htim->State == HAL_TIM_STATE_RESET)
 80199b0:	f890 303d 	ldrb.w	r3, [r0, #61]	@ 0x3d
 80199b4:	4604      	mov	r4, r0
 80199b6:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
 80199ba:	2b00      	cmp	r3, #0
 80199bc:	f000 8084 	beq.w	8019ac8 <HAL_TIM_PWM_Init+0x120>
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 80199c0:	6822      	ldr	r2, [r4, #0]
  htim->State = HAL_TIM_STATE_BUSY;
 80199c2:	2302      	movs	r3, #2
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 80199c4:	4944      	ldr	r1, [pc, #272]	@ (8019ad8 <HAL_TIM_PWM_Init+0x130>)
 80199c6:	4845      	ldr	r0, [pc, #276]	@ (8019adc <HAL_TIM_PWM_Init+0x134>)
 80199c8:	f1b2 4f80 	cmp.w	r2, #1073741824	@ 0x40000000
 80199cc:	eba2 0101 	sub.w	r1, r2, r1
  htim->State = HAL_TIM_STATE_BUSY;
 80199d0:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 80199d4:	eba2 0e00 	sub.w	lr, r2, r0
  tmpcr1 = TIMx->CR1;
 80199d8:	6813      	ldr	r3, [r2, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 80199da:	fab1 f181 	clz	r1, r1
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 80199de:	69a7      	ldr	r7, [r4, #24]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 80199e0:	fabe fe8e 	clz	lr, lr
  TIMx->PSC = Structure->Prescaler;
 80199e4:	6865      	ldr	r5, [r4, #4]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 80199e6:	ea4f 1151 	mov.w	r1, r1, lsr #5
  TIMx->ARR = (uint32_t)Structure->Period ;
 80199ea:	68e6      	ldr	r6, [r4, #12]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 80199ec:	ea4f 1e5e 	mov.w	lr, lr, lsr #5
 80199f0:	d055      	beq.n	8019a9e <HAL_TIM_PWM_Init+0xf6>
 80199f2:	2900      	cmp	r1, #0
 80199f4:	d153      	bne.n	8019a9e <HAL_TIM_PWM_Init+0xf6>
 80199f6:	f8df c0ec 	ldr.w	ip, [pc, #236]	@ 8019ae4 <HAL_TIM_PWM_Init+0x13c>
 80199fa:	4562      	cmp	r2, ip
 80199fc:	d04f      	beq.n	8019a9e <HAL_TIM_PWM_Init+0xf6>
 80199fe:	f50c 6c80 	add.w	ip, ip, #1024	@ 0x400
 8019a02:	4562      	cmp	r2, ip
 8019a04:	d04b      	beq.n	8019a9e <HAL_TIM_PWM_Init+0xf6>
 8019a06:	f50c 6c80 	add.w	ip, ip, #1024	@ 0x400
 8019a0a:	4562      	cmp	r2, ip
 8019a0c:	d047      	beq.n	8019a9e <HAL_TIM_PWM_Init+0xf6>
 8019a0e:	f1be 0f00 	cmp.w	lr, #0
 8019a12:	d144      	bne.n	8019a9e <HAL_TIM_PWM_Init+0xf6>
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8019a14:	4932      	ldr	r1, [pc, #200]	@ (8019ae0 <HAL_TIM_PWM_Init+0x138>)
 8019a16:	428a      	cmp	r2, r1
 8019a18:	d013      	beq.n	8019a42 <HAL_TIM_PWM_Init+0x9a>
 8019a1a:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 8019a1e:	428a      	cmp	r2, r1
 8019a20:	d00f      	beq.n	8019a42 <HAL_TIM_PWM_Init+0x9a>
 8019a22:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 8019a26:	428a      	cmp	r2, r1
 8019a28:	d00b      	beq.n	8019a42 <HAL_TIM_PWM_Init+0x9a>
 8019a2a:	f5a1 3198 	sub.w	r1, r1, #77824	@ 0x13000
 8019a2e:	428a      	cmp	r2, r1
 8019a30:	d007      	beq.n	8019a42 <HAL_TIM_PWM_Init+0x9a>
 8019a32:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 8019a36:	428a      	cmp	r2, r1
 8019a38:	d003      	beq.n	8019a42 <HAL_TIM_PWM_Init+0x9a>
 8019a3a:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 8019a3e:	428a      	cmp	r2, r1
 8019a40:	d103      	bne.n	8019a4a <HAL_TIM_PWM_Init+0xa2>
    tmpcr1 &= ~TIM_CR1_CKD;
 8019a42:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8019a46:	6921      	ldr	r1, [r4, #16]
 8019a48:	430b      	orrs	r3, r1
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8019a4a:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 8019a4e:	433b      	orrs	r3, r7
  TIMx->CR1 = tmpcr1;
 8019a50:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8019a52:	62d6      	str	r6, [r2, #44]	@ 0x2c
  TIMx->PSC = Structure->Prescaler;
 8019a54:	6295      	str	r5, [r2, #40]	@ 0x28
  TIMx->EGR = TIM_EGR_UG;
 8019a56:	2301      	movs	r3, #1
 8019a58:	6153      	str	r3, [r2, #20]
  if (HAL_IS_BIT_SET(TIMx->SR, TIM_FLAG_UPDATE))
 8019a5a:	6913      	ldr	r3, [r2, #16]
 8019a5c:	07db      	lsls	r3, r3, #31
 8019a5e:	d503      	bpl.n	8019a68 <HAL_TIM_PWM_Init+0xc0>
    CLEAR_BIT(TIMx->SR, TIM_FLAG_UPDATE);
 8019a60:	6913      	ldr	r3, [r2, #16]
 8019a62:	f023 0301 	bic.w	r3, r3, #1
 8019a66:	6113      	str	r3, [r2, #16]
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8019a68:	2301      	movs	r3, #1
  return HAL_OK;
 8019a6a:	2000      	movs	r0, #0
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8019a6c:	f884 3048 	strb.w	r3, [r4, #72]	@ 0x48
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8019a70:	f884 303e 	strb.w	r3, [r4, #62]	@ 0x3e
 8019a74:	f884 303f 	strb.w	r3, [r4, #63]	@ 0x3f
 8019a78:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
 8019a7c:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
 8019a80:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
 8019a84:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8019a88:	f884 3044 	strb.w	r3, [r4, #68]	@ 0x44
 8019a8c:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
 8019a90:	f884 3046 	strb.w	r3, [r4, #70]	@ 0x46
 8019a94:	f884 3047 	strb.w	r3, [r4, #71]	@ 0x47
  htim->State = HAL_TIM_STATE_READY;
 8019a98:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
}
 8019a9c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    tmpcr1 |= Structure->CounterMode;
 8019a9e:	68a0      	ldr	r0, [r4, #8]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8019aa0:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
    tmpcr1 |= Structure->CounterMode;
 8019aa4:	4303      	orrs	r3, r0
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8019aa6:	6920      	ldr	r0, [r4, #16]
    tmpcr1 &= ~TIM_CR1_CKD;
 8019aa8:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8019aac:	4303      	orrs	r3, r0
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8019aae:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 8019ab2:	433b      	orrs	r3, r7
  TIMx->CR1 = tmpcr1;
 8019ab4:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8019ab6:	62d6      	str	r6, [r2, #44]	@ 0x2c
  TIMx->PSC = Structure->Prescaler;
 8019ab8:	6295      	str	r5, [r2, #40]	@ 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8019aba:	b911      	cbnz	r1, 8019ac2 <HAL_TIM_PWM_Init+0x11a>
 8019abc:	f1be 0f00 	cmp.w	lr, #0
 8019ac0:	d0c9      	beq.n	8019a56 <HAL_TIM_PWM_Init+0xae>
    TIMx->RCR = Structure->RepetitionCounter;
 8019ac2:	6963      	ldr	r3, [r4, #20]
 8019ac4:	6313      	str	r3, [r2, #48]	@ 0x30
 8019ac6:	e7c6      	b.n	8019a56 <HAL_TIM_PWM_Init+0xae>
    htim->Lock = HAL_UNLOCKED;
 8019ac8:	f880 203c 	strb.w	r2, [r0, #60]	@ 0x3c
    HAL_TIM_PWM_MspInit(htim);
 8019acc:	f7f8 fec2 	bl	8012854 <HAL_TIM_PWM_MspInit>
 8019ad0:	e776      	b.n	80199c0 <HAL_TIM_PWM_Init+0x18>
    return HAL_ERROR;
 8019ad2:	2001      	movs	r0, #1
}
 8019ad4:	4770      	bx	lr
 8019ad6:	bf00      	nop
 8019ad8:	40010000 	.word	0x40010000
 8019adc:	40010400 	.word	0x40010400
 8019ae0:	40014000 	.word	0x40014000
 8019ae4:	40000400 	.word	0x40000400

08019ae8 <HAL_TIM_PWM_ConfigChannel>:
  __HAL_LOCK(htim);
 8019ae8:	f890 303c 	ldrb.w	r3, [r0, #60]	@ 0x3c
 8019aec:	2b01      	cmp	r3, #1
 8019aee:	f000 8132 	beq.w	8019d56 <HAL_TIM_PWM_ConfigChannel+0x26e>
 8019af2:	2301      	movs	r3, #1
 8019af4:	4684      	mov	ip, r0
{
 8019af6:	b470      	push	{r4, r5, r6}
  __HAL_LOCK(htim);
 8019af8:	f880 303c 	strb.w	r3, [r0, #60]	@ 0x3c
  switch (Channel)
 8019afc:	2a14      	cmp	r2, #20
 8019afe:	d816      	bhi.n	8019b2e <HAL_TIM_PWM_ConfigChannel+0x46>
 8019b00:	e8df f012 	tbh	[pc, r2, lsl #1]
 8019b04:	0015004e 	.word	0x0015004e
 8019b08:	00150015 	.word	0x00150015
 8019b0c:	00150079 	.word	0x00150079
 8019b10:	00150015 	.word	0x00150015
 8019b14:	001500d5 	.word	0x001500d5
 8019b18:	00150015 	.word	0x00150015
 8019b1c:	001500a7 	.word	0x001500a7
 8019b20:	00150015 	.word	0x00150015
 8019b24:	001500ff 	.word	0x001500ff
 8019b28:	00150015 	.word	0x00150015
 8019b2c:	001b      	.short	0x001b
  __HAL_UNLOCK(htim);
 8019b2e:	2300      	movs	r3, #0
  switch (Channel)
 8019b30:	2001      	movs	r0, #1
  __HAL_UNLOCK(htim);
 8019b32:	f88c 303c 	strb.w	r3, [ip, #60]	@ 0x3c
}
 8019b36:	bc70      	pop	{r4, r5, r6}
 8019b38:	4770      	bx	lr
      TIM_OC6_SetConfig(htim->Instance, sConfig);
 8019b3a:	6803      	ldr	r3, [r0, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8019b3c:	6a1a      	ldr	r2, [r3, #32]

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC6E;
 8019b3e:	6a18      	ldr	r0, [r3, #32]
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);

  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
 8019b40:	f422 1200 	bic.w	r2, r2, #2097152	@ 0x200000
  TIMx->CCER &= ~TIM_CCER_CC6E;
 8019b44:	f420 1080 	bic.w	r0, r0, #1048576	@ 0x100000
 8019b48:	6218      	str	r0, [r3, #32]
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
 8019b4a:	48a2      	ldr	r0, [pc, #648]	@ (8019dd4 <HAL_TIM_PWM_ConfigChannel+0x2ec>)
  tmpcr2 =  TIMx->CR2;
 8019b4c:	685c      	ldr	r4, [r3, #4]
  tmpccmrx = TIMx->CCMR3;
 8019b4e:	6d5d      	ldr	r5, [r3, #84]	@ 0x54
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
 8019b50:	4028      	ands	r0, r5
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8019b52:	680d      	ldr	r5, [r1, #0]
 8019b54:	ea40 2005 	orr.w	r0, r0, r5, lsl #8
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 20U);
 8019b58:	688d      	ldr	r5, [r1, #8]
 8019b5a:	ea42 5205 	orr.w	r2, r2, r5, lsl #20

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8019b5e:	4d9e      	ldr	r5, [pc, #632]	@ (8019dd8 <HAL_TIM_PWM_ConfigChannel+0x2f0>)
 8019b60:	42ab      	cmp	r3, r5
 8019b62:	f000 80fa 	beq.w	8019d5a <HAL_TIM_PWM_ConfigChannel+0x272>
 8019b66:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 8019b6a:	42ab      	cmp	r3, r5
 8019b6c:	f000 80f5 	beq.w	8019d5a <HAL_TIM_PWM_ConfigChannel+0x272>
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 10U);
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8019b70:	605c      	str	r4, [r3, #4]

  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;
 8019b72:	6558      	str	r0, [r3, #84]	@ 0x54

  /* Set the Capture Compare Register value */
  TIMx->CCR6 = OC_Config->Pulse;
 8019b74:	6848      	ldr	r0, [r1, #4]
      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8U;
 8019b76:	6909      	ldr	r1, [r1, #16]
  TIMx->CCR6 = OC_Config->Pulse;
 8019b78:	65d8      	str	r0, [r3, #92]	@ 0x5c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8019b7a:	621a      	str	r2, [r3, #32]
      htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;
 8019b7c:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
 8019b7e:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
 8019b82:	655a      	str	r2, [r3, #84]	@ 0x54
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC6FE;
 8019b84:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
 8019b86:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 8019b8a:	655a      	str	r2, [r3, #84]	@ 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8U;
 8019b8c:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
 8019b8e:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8019b92:	655a      	str	r2, [r3, #84]	@ 0x54
  __HAL_UNLOCK(htim);
 8019b94:	2300      	movs	r3, #0
  HAL_StatusTypeDef status = HAL_OK;
 8019b96:	2000      	movs	r0, #0
  __HAL_UNLOCK(htim);
 8019b98:	f88c 303c 	strb.w	r3, [ip, #60]	@ 0x3c
}
 8019b9c:	bc70      	pop	{r4, r5, r6}
 8019b9e:	4770      	bx	lr
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 8019ba0:	6803      	ldr	r3, [r0, #0]
  tmpccer = TIMx->CCER;
 8019ba2:	6a1a      	ldr	r2, [r3, #32]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8019ba4:	6a18      	ldr	r0, [r3, #32]
  tmpccer &= ~TIM_CCER_CC1P;
 8019ba6:	f022 0202 	bic.w	r2, r2, #2
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8019baa:	f020 0001 	bic.w	r0, r0, #1
 8019bae:	6218      	str	r0, [r3, #32]
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 8019bb0:	488a      	ldr	r0, [pc, #552]	@ (8019ddc <HAL_TIM_PWM_ConfigChannel+0x2f4>)
  tmpcr2 =  TIMx->CR2;
 8019bb2:	685c      	ldr	r4, [r3, #4]
  tmpccmrx = TIMx->CCMR1;
 8019bb4:	699d      	ldr	r5, [r3, #24]
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 8019bb6:	4028      	ands	r0, r5
  tmpccmrx |= OC_Config->OCMode;
 8019bb8:	680d      	ldr	r5, [r1, #0]
 8019bba:	4328      	orrs	r0, r5
  tmpccer |= OC_Config->OCPolarity;
 8019bbc:	688d      	ldr	r5, [r1, #8]
 8019bbe:	432a      	orrs	r2, r5
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 8019bc0:	4d85      	ldr	r5, [pc, #532]	@ (8019dd8 <HAL_TIM_PWM_ConfigChannel+0x2f0>)
 8019bc2:	42ab      	cmp	r3, r5
 8019bc4:	f000 80d5 	beq.w	8019d72 <HAL_TIM_PWM_ConfigChannel+0x28a>
 8019bc8:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 8019bcc:	42ab      	cmp	r3, r5
 8019bce:	f000 80d0 	beq.w	8019d72 <HAL_TIM_PWM_ConfigChannel+0x28a>
  TIMx->CR2 = tmpcr2;
 8019bd2:	605c      	str	r4, [r3, #4]
  TIMx->CCMR1 = tmpccmrx;
 8019bd4:	6198      	str	r0, [r3, #24]
  TIMx->CCR1 = OC_Config->Pulse;
 8019bd6:	6848      	ldr	r0, [r1, #4]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 8019bd8:	6909      	ldr	r1, [r1, #16]
  TIMx->CCR1 = OC_Config->Pulse;
 8019bda:	6358      	str	r0, [r3, #52]	@ 0x34
  TIMx->CCER = tmpccer;
 8019bdc:	621a      	str	r2, [r3, #32]
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 8019bde:	699a      	ldr	r2, [r3, #24]
 8019be0:	f042 0208 	orr.w	r2, r2, #8
 8019be4:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
 8019be6:	699a      	ldr	r2, [r3, #24]
 8019be8:	f022 0204 	bic.w	r2, r2, #4
 8019bec:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 8019bee:	699a      	ldr	r2, [r3, #24]
 8019bf0:	430a      	orrs	r2, r1
 8019bf2:	619a      	str	r2, [r3, #24]
      break;
 8019bf4:	e7ce      	b.n	8019b94 <HAL_TIM_PWM_ConfigChannel+0xac>
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 8019bf6:	6803      	ldr	r3, [r0, #0]
  tmpccer = TIMx->CCER;
 8019bf8:	6a1a      	ldr	r2, [r3, #32]
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8019bfa:	6a18      	ldr	r0, [r3, #32]
  tmpccer &= ~TIM_CCER_CC2P;
 8019bfc:	f022 0220 	bic.w	r2, r2, #32
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8019c00:	f020 0010 	bic.w	r0, r0, #16
 8019c04:	6218      	str	r0, [r3, #32]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 8019c06:	4876      	ldr	r0, [pc, #472]	@ (8019de0 <HAL_TIM_PWM_ConfigChannel+0x2f8>)
  tmpcr2 =  TIMx->CR2;
 8019c08:	685c      	ldr	r4, [r3, #4]
  tmpccmrx = TIMx->CCMR1;
 8019c0a:	699d      	ldr	r5, [r3, #24]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 8019c0c:	4028      	ands	r0, r5
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8019c0e:	680d      	ldr	r5, [r1, #0]
 8019c10:	ea40 2005 	orr.w	r0, r0, r5, lsl #8
  tmpccer |= (OC_Config->OCPolarity << 4U);
 8019c14:	688d      	ldr	r5, [r1, #8]
 8019c16:	ea42 1205 	orr.w	r2, r2, r5, lsl #4
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 8019c1a:	4d6f      	ldr	r5, [pc, #444]	@ (8019dd8 <HAL_TIM_PWM_ConfigChannel+0x2f0>)
 8019c1c:	42ab      	cmp	r3, r5
 8019c1e:	f000 80bb 	beq.w	8019d98 <HAL_TIM_PWM_ConfigChannel+0x2b0>
 8019c22:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 8019c26:	42ab      	cmp	r3, r5
 8019c28:	f000 80b6 	beq.w	8019d98 <HAL_TIM_PWM_ConfigChannel+0x2b0>
  TIMx->CR2 = tmpcr2;
 8019c2c:	605c      	str	r4, [r3, #4]
  TIMx->CCMR1 = tmpccmrx;
 8019c2e:	6198      	str	r0, [r3, #24]
  TIMx->CCR2 = OC_Config->Pulse;
 8019c30:	6848      	ldr	r0, [r1, #4]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
 8019c32:	6909      	ldr	r1, [r1, #16]
  TIMx->CCR2 = OC_Config->Pulse;
 8019c34:	6398      	str	r0, [r3, #56]	@ 0x38
  TIMx->CCER = tmpccer;
 8019c36:	621a      	str	r2, [r3, #32]
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 8019c38:	699a      	ldr	r2, [r3, #24]
 8019c3a:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
 8019c3e:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
 8019c40:	699a      	ldr	r2, [r3, #24]
 8019c42:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 8019c46:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
 8019c48:	699a      	ldr	r2, [r3, #24]
 8019c4a:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8019c4e:	619a      	str	r2, [r3, #24]
      break;
 8019c50:	e7a0      	b.n	8019b94 <HAL_TIM_PWM_ConfigChannel+0xac>
      TIM_OC4_SetConfig(htim->Instance, sConfig);
 8019c52:	6803      	ldr	r3, [r0, #0]
  tmpccer = TIMx->CCER;
 8019c54:	6a1a      	ldr	r2, [r3, #32]
  TIMx->CCER &= ~TIM_CCER_CC4E;
 8019c56:	6a18      	ldr	r0, [r3, #32]
  tmpccer &= ~TIM_CCER_CC4P;
 8019c58:	f422 5200 	bic.w	r2, r2, #8192	@ 0x2000
  TIMx->CCER &= ~TIM_CCER_CC4E;
 8019c5c:	f420 5080 	bic.w	r0, r0, #4096	@ 0x1000
 8019c60:	6218      	str	r0, [r3, #32]
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 8019c62:	485f      	ldr	r0, [pc, #380]	@ (8019de0 <HAL_TIM_PWM_ConfigChannel+0x2f8>)
  tmpcr2 =  TIMx->CR2;
 8019c64:	685c      	ldr	r4, [r3, #4]
  tmpccmrx = TIMx->CCMR2;
 8019c66:	69dd      	ldr	r5, [r3, #28]
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 8019c68:	4028      	ands	r0, r5
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8019c6a:	680d      	ldr	r5, [r1, #0]
 8019c6c:	ea40 2005 	orr.w	r0, r0, r5, lsl #8
  tmpccer |= (OC_Config->OCPolarity << 12U);
 8019c70:	688d      	ldr	r5, [r1, #8]
 8019c72:	ea42 3205 	orr.w	r2, r2, r5, lsl #12
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8019c76:	4d58      	ldr	r5, [pc, #352]	@ (8019dd8 <HAL_TIM_PWM_ConfigChannel+0x2f0>)
 8019c78:	42ab      	cmp	r3, r5
 8019c7a:	f000 8087 	beq.w	8019d8c <HAL_TIM_PWM_ConfigChannel+0x2a4>
 8019c7e:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 8019c82:	42ab      	cmp	r3, r5
 8019c84:	f000 8082 	beq.w	8019d8c <HAL_TIM_PWM_ConfigChannel+0x2a4>
  TIMx->CR2 = tmpcr2;
 8019c88:	605c      	str	r4, [r3, #4]
  TIMx->CCMR2 = tmpccmrx;
 8019c8a:	61d8      	str	r0, [r3, #28]
  TIMx->CCR4 = OC_Config->Pulse;
 8019c8c:	6848      	ldr	r0, [r1, #4]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
 8019c8e:	6909      	ldr	r1, [r1, #16]
  TIMx->CCR4 = OC_Config->Pulse;
 8019c90:	6418      	str	r0, [r3, #64]	@ 0x40
  TIMx->CCER = tmpccer;
 8019c92:	621a      	str	r2, [r3, #32]
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 8019c94:	69da      	ldr	r2, [r3, #28]
 8019c96:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
 8019c9a:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
 8019c9c:	69da      	ldr	r2, [r3, #28]
 8019c9e:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 8019ca2:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
 8019ca4:	69da      	ldr	r2, [r3, #28]
 8019ca6:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8019caa:	61da      	str	r2, [r3, #28]
      break;
 8019cac:	e772      	b.n	8019b94 <HAL_TIM_PWM_ConfigChannel+0xac>
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 8019cae:	6803      	ldr	r3, [r0, #0]
  tmpccer = TIMx->CCER;
 8019cb0:	6a1a      	ldr	r2, [r3, #32]
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8019cb2:	6a18      	ldr	r0, [r3, #32]
  tmpccer &= ~TIM_CCER_CC3P;
 8019cb4:	f422 7200 	bic.w	r2, r2, #512	@ 0x200
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8019cb8:	f420 7080 	bic.w	r0, r0, #256	@ 0x100
 8019cbc:	6218      	str	r0, [r3, #32]
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 8019cbe:	4847      	ldr	r0, [pc, #284]	@ (8019ddc <HAL_TIM_PWM_ConfigChannel+0x2f4>)
  tmpcr2 =  TIMx->CR2;
 8019cc0:	685c      	ldr	r4, [r3, #4]
  tmpccmrx = TIMx->CCMR2;
 8019cc2:	69dd      	ldr	r5, [r3, #28]
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 8019cc4:	4028      	ands	r0, r5
  tmpccmrx |= OC_Config->OCMode;
 8019cc6:	680d      	ldr	r5, [r1, #0]
 8019cc8:	4328      	orrs	r0, r5
  tmpccer |= (OC_Config->OCPolarity << 8U);
 8019cca:	688d      	ldr	r5, [r1, #8]
 8019ccc:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 8019cd0:	4d41      	ldr	r5, [pc, #260]	@ (8019dd8 <HAL_TIM_PWM_ConfigChannel+0x2f0>)
 8019cd2:	42ab      	cmp	r3, r5
 8019cd4:	d06f      	beq.n	8019db6 <HAL_TIM_PWM_ConfigChannel+0x2ce>
 8019cd6:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 8019cda:	42ab      	cmp	r3, r5
 8019cdc:	d06b      	beq.n	8019db6 <HAL_TIM_PWM_ConfigChannel+0x2ce>
  TIMx->CR2 = tmpcr2;
 8019cde:	605c      	str	r4, [r3, #4]
  TIMx->CCMR2 = tmpccmrx;
 8019ce0:	61d8      	str	r0, [r3, #28]
  TIMx->CCR3 = OC_Config->Pulse;
 8019ce2:	6848      	ldr	r0, [r1, #4]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
 8019ce4:	6909      	ldr	r1, [r1, #16]
  TIMx->CCR3 = OC_Config->Pulse;
 8019ce6:	63d8      	str	r0, [r3, #60]	@ 0x3c
  TIMx->CCER = tmpccer;
 8019ce8:	621a      	str	r2, [r3, #32]
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 8019cea:	69da      	ldr	r2, [r3, #28]
 8019cec:	f042 0208 	orr.w	r2, r2, #8
 8019cf0:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
 8019cf2:	69da      	ldr	r2, [r3, #28]
 8019cf4:	f022 0204 	bic.w	r2, r2, #4
 8019cf8:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
 8019cfa:	69da      	ldr	r2, [r3, #28]
 8019cfc:	430a      	orrs	r2, r1
 8019cfe:	61da      	str	r2, [r3, #28]
      break;
 8019d00:	e748      	b.n	8019b94 <HAL_TIM_PWM_ConfigChannel+0xac>
      TIM_OC5_SetConfig(htim->Instance, sConfig);
 8019d02:	6803      	ldr	r3, [r0, #0]
  tmpccer = TIMx->CCER;
 8019d04:	6a1a      	ldr	r2, [r3, #32]
  TIMx->CCER &= ~TIM_CCER_CC5E;
 8019d06:	6a18      	ldr	r0, [r3, #32]
  tmpccer &= ~TIM_CCER_CC5P;
 8019d08:	f422 3200 	bic.w	r2, r2, #131072	@ 0x20000
  TIMx->CCER &= ~TIM_CCER_CC5E;
 8019d0c:	f420 3080 	bic.w	r0, r0, #65536	@ 0x10000
 8019d10:	6218      	str	r0, [r3, #32]
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
 8019d12:	4834      	ldr	r0, [pc, #208]	@ (8019de4 <HAL_TIM_PWM_ConfigChannel+0x2fc>)
  tmpcr2 =  TIMx->CR2;
 8019d14:	685c      	ldr	r4, [r3, #4]
  tmpccmrx = TIMx->CCMR3;
 8019d16:	6d5d      	ldr	r5, [r3, #84]	@ 0x54
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
 8019d18:	4028      	ands	r0, r5
  tmpccmrx |= OC_Config->OCMode;
 8019d1a:	680d      	ldr	r5, [r1, #0]
 8019d1c:	4328      	orrs	r0, r5
  tmpccer |= (OC_Config->OCPolarity << 16U);
 8019d1e:	688d      	ldr	r5, [r1, #8]
 8019d20:	ea42 4205 	orr.w	r2, r2, r5, lsl #16
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8019d24:	4d2c      	ldr	r5, [pc, #176]	@ (8019dd8 <HAL_TIM_PWM_ConfigChannel+0x2f0>)
 8019d26:	42ab      	cmp	r3, r5
 8019d28:	d01d      	beq.n	8019d66 <HAL_TIM_PWM_ConfigChannel+0x27e>
 8019d2a:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 8019d2e:	42ab      	cmp	r3, r5
 8019d30:	d019      	beq.n	8019d66 <HAL_TIM_PWM_ConfigChannel+0x27e>
  TIMx->CR2 = tmpcr2;
 8019d32:	605c      	str	r4, [r3, #4]
  TIMx->CCMR3 = tmpccmrx;
 8019d34:	6558      	str	r0, [r3, #84]	@ 0x54
  TIMx->CCR5 = OC_Config->Pulse;
 8019d36:	6848      	ldr	r0, [r1, #4]
      htim->Instance->CCMR3 |= sConfig->OCFastMode;
 8019d38:	6909      	ldr	r1, [r1, #16]
  TIMx->CCR5 = OC_Config->Pulse;
 8019d3a:	6598      	str	r0, [r3, #88]	@ 0x58
  TIMx->CCER = tmpccer;
 8019d3c:	621a      	str	r2, [r3, #32]
      htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;
 8019d3e:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
 8019d40:	f042 0208 	orr.w	r2, r2, #8
 8019d44:	655a      	str	r2, [r3, #84]	@ 0x54
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC5FE;
 8019d46:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
 8019d48:	f022 0204 	bic.w	r2, r2, #4
 8019d4c:	655a      	str	r2, [r3, #84]	@ 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode;
 8019d4e:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
 8019d50:	430a      	orrs	r2, r1
 8019d52:	655a      	str	r2, [r3, #84]	@ 0x54
      break;
 8019d54:	e71e      	b.n	8019b94 <HAL_TIM_PWM_ConfigChannel+0xac>
  __HAL_LOCK(htim);
 8019d56:	2002      	movs	r0, #2
}
 8019d58:	4770      	bx	lr
    tmpcr2 &= ~TIM_CR2_OIS6;
 8019d5a:	f424 2480 	bic.w	r4, r4, #262144	@ 0x40000
    tmpcr2 |= (OC_Config->OCIdleState << 10U);
 8019d5e:	694d      	ldr	r5, [r1, #20]
 8019d60:	ea44 2485 	orr.w	r4, r4, r5, lsl #10
 8019d64:	e704      	b.n	8019b70 <HAL_TIM_PWM_ConfigChannel+0x88>
    tmpcr2 &= ~TIM_CR2_OIS5;
 8019d66:	f424 3480 	bic.w	r4, r4, #65536	@ 0x10000
    tmpcr2 |= (OC_Config->OCIdleState << 8U);
 8019d6a:	694d      	ldr	r5, [r1, #20]
 8019d6c:	ea44 2405 	orr.w	r4, r4, r5, lsl #8
 8019d70:	e7df      	b.n	8019d32 <HAL_TIM_PWM_ConfigChannel+0x24a>
    tmpccer |= OC_Config->OCNPolarity;
 8019d72:	68cd      	ldr	r5, [r1, #12]
    tmpccer &= ~TIM_CCER_CC1NP;
 8019d74:	f022 0208 	bic.w	r2, r2, #8
    tmpcr2 &= ~TIM_CR2_OIS1N;
 8019d78:	f424 7440 	bic.w	r4, r4, #768	@ 0x300
    tmpccer |= OC_Config->OCNPolarity;
 8019d7c:	432a      	orrs	r2, r5
    tmpcr2 |= OC_Config->OCNIdleState;
 8019d7e:	e9d1 5605 	ldrd	r5, r6, [r1, #20]
    tmpccer &= ~TIM_CCER_CC1NE;
 8019d82:	f022 0204 	bic.w	r2, r2, #4
    tmpcr2 |= OC_Config->OCNIdleState;
 8019d86:	4335      	orrs	r5, r6
 8019d88:	432c      	orrs	r4, r5
 8019d8a:	e722      	b.n	8019bd2 <HAL_TIM_PWM_ConfigChannel+0xea>
    tmpcr2 &= ~TIM_CR2_OIS4;
 8019d8c:	f424 4480 	bic.w	r4, r4, #16384	@ 0x4000
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
 8019d90:	694d      	ldr	r5, [r1, #20]
 8019d92:	ea44 1485 	orr.w	r4, r4, r5, lsl #6
 8019d96:	e777      	b.n	8019c88 <HAL_TIM_PWM_ConfigChannel+0x1a0>
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 8019d98:	68cd      	ldr	r5, [r1, #12]
    tmpccer &= ~TIM_CCER_CC2NP;
 8019d9a:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
    tmpcr2 &= ~TIM_CR2_OIS2N;
 8019d9e:	f424 6440 	bic.w	r4, r4, #3072	@ 0xc00
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 8019da2:	ea42 1205 	orr.w	r2, r2, r5, lsl #4
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 8019da6:	e9d1 5605 	ldrd	r5, r6, [r1, #20]
    tmpccer &= ~TIM_CCER_CC2NE;
 8019daa:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 8019dae:	4335      	orrs	r5, r6
 8019db0:	ea44 0485 	orr.w	r4, r4, r5, lsl #2
 8019db4:	e73a      	b.n	8019c2c <HAL_TIM_PWM_ConfigChannel+0x144>
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 8019db6:	68cd      	ldr	r5, [r1, #12]
    tmpccer &= ~TIM_CCER_CC3NP;
 8019db8:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
    tmpcr2 &= ~TIM_CR2_OIS3N;
 8019dbc:	f424 5440 	bic.w	r4, r4, #12288	@ 0x3000
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 8019dc0:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 8019dc4:	e9d1 5605 	ldrd	r5, r6, [r1, #20]
    tmpccer &= ~TIM_CCER_CC3NE;
 8019dc8:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 8019dcc:	4335      	orrs	r5, r6
 8019dce:	ea44 1405 	orr.w	r4, r4, r5, lsl #4
 8019dd2:	e784      	b.n	8019cde <HAL_TIM_PWM_ConfigChannel+0x1f6>
 8019dd4:	feff8fff 	.word	0xfeff8fff
 8019dd8:	40010000 	.word	0x40010000
 8019ddc:	fffeff8c 	.word	0xfffeff8c
 8019de0:	feff8cff 	.word	0xfeff8cff
 8019de4:	fffeff8f 	.word	0xfffeff8f

08019de8 <HAL_TIM_ConfigClockSource>:
  __HAL_LOCK(htim);
 8019de8:	f890 303c 	ldrb.w	r3, [r0, #60]	@ 0x3c
 8019dec:	2b01      	cmp	r3, #1
 8019dee:	d06f      	beq.n	8019ed0 <HAL_TIM_ConfigClockSource+0xe8>
 8019df0:	4602      	mov	r2, r0
  htim->State = HAL_TIM_STATE_BUSY;
 8019df2:	2302      	movs	r3, #2
{
 8019df4:	b430      	push	{r4, r5}
  tmpsmcr = htim->Instance->SMCR;
 8019df6:	6804      	ldr	r4, [r0, #0]
  __HAL_LOCK(htim);
 8019df8:	2001      	movs	r0, #1
  htim->State = HAL_TIM_STATE_BUSY;
 8019dfa:	f882 303d 	strb.w	r3, [r2, #61]	@ 0x3d
  __HAL_LOCK(htim);
 8019dfe:	f882 003c 	strb.w	r0, [r2, #60]	@ 0x3c
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 8019e02:	4b4d      	ldr	r3, [pc, #308]	@ (8019f38 <HAL_TIM_ConfigClockSource+0x150>)
  tmpsmcr = htim->Instance->SMCR;
 8019e04:	68a5      	ldr	r5, [r4, #8]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 8019e06:	402b      	ands	r3, r5
  htim->Instance->SMCR = tmpsmcr;
 8019e08:	60a3      	str	r3, [r4, #8]
  switch (sClockSourceConfig->ClockSource)
 8019e0a:	680b      	ldr	r3, [r1, #0]
 8019e0c:	2b60      	cmp	r3, #96	@ 0x60
 8019e0e:	d061      	beq.n	8019ed4 <HAL_TIM_ConfigClockSource+0xec>
 8019e10:	d824      	bhi.n	8019e5c <HAL_TIM_ConfigClockSource+0x74>
 8019e12:	2b40      	cmp	r3, #64	@ 0x40
 8019e14:	d077      	beq.n	8019f06 <HAL_TIM_ConfigClockSource+0x11e>
 8019e16:	d94a      	bls.n	8019eae <HAL_TIM_ConfigClockSource+0xc6>
 8019e18:	2b50      	cmp	r3, #80	@ 0x50
 8019e1a:	d117      	bne.n	8019e4c <HAL_TIM_ConfigClockSource+0x64>
                               sClockSourceConfig->ClockPolarity,
 8019e1c:	684b      	ldr	r3, [r1, #4]
                               sClockSourceConfig->ClockFilter);
 8019e1e:	68c8      	ldr	r0, [r1, #12]
{
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 1: Reset the CC1E Bit */
  tmpccer = TIMx->CCER;
 8019e20:	6a21      	ldr	r1, [r4, #32]
  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
  tmpccmr1 |= (TIM_ICFilter << 4U);

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8019e22:	f021 010a 	bic.w	r1, r1, #10
  tmpccer |= TIM_ICPolarity;
 8019e26:	4319      	orrs	r1, r3
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8019e28:	6a23      	ldr	r3, [r4, #32]
 8019e2a:	f023 0301 	bic.w	r3, r3, #1
 8019e2e:	6223      	str	r3, [r4, #32]
  tmpccmr1 = TIMx->CCMR1;
 8019e30:	69a3      	ldr	r3, [r4, #24]
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 8019e32:	f023 03f0 	bic.w	r3, r3, #240	@ 0xf0
  tmpccmr1 |= (TIM_ICFilter << 4U);
 8019e36:	ea43 1300 	orr.w	r3, r3, r0, lsl #4

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
 8019e3a:	61a3      	str	r3, [r4, #24]
  TIMx->CCER = tmpccer;
 8019e3c:	6221      	str	r1, [r4, #32]
static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource)
{
  uint32_t tmpsmcr;

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 8019e3e:	68a3      	ldr	r3, [r4, #8]
  /* Reset the TS Bits */
  tmpsmcr &= ~TIM_SMCR_TS;
 8019e40:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
  /* Set the Input Trigger source and the slave mode*/
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8019e44:	f043 0357 	orr.w	r3, r3, #87	@ 0x57
  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8019e48:	60a3      	str	r3, [r4, #8]
  HAL_StatusTypeDef status = HAL_OK;
 8019e4a:	2000      	movs	r0, #0
  htim->State = HAL_TIM_STATE_READY;
 8019e4c:	2101      	movs	r1, #1
  __HAL_UNLOCK(htim);
 8019e4e:	2300      	movs	r3, #0
  htim->State = HAL_TIM_STATE_READY;
 8019e50:	f882 103d 	strb.w	r1, [r2, #61]	@ 0x3d
  __HAL_UNLOCK(htim);
 8019e54:	f882 303c 	strb.w	r3, [r2, #60]	@ 0x3c
}
 8019e58:	bc30      	pop	{r4, r5}
 8019e5a:	4770      	bx	lr
  switch (sClockSourceConfig->ClockSource)
 8019e5c:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8019e60:	d0f3      	beq.n	8019e4a <HAL_TIM_ConfigClockSource+0x62>
 8019e62:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8019e66:	d110      	bne.n	8019e8a <HAL_TIM_ConfigClockSource+0xa2>
void TIM_ETR_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ExtTRGPrescaler,
                       uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
{
  uint32_t tmpsmcr;

  tmpsmcr = TIMx->SMCR;
 8019e68:	68a0      	ldr	r0, [r4, #8]

  /* Reset the ETR Bits */
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8019e6a:	e9d1 5301 	ldrd	r5, r3, [r1, #4]
 8019e6e:	432b      	orrs	r3, r5
 8019e70:	68cd      	ldr	r5, [r1, #12]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 8019e72:	f420 417f 	bic.w	r1, r0, #65280	@ 0xff00
  HAL_StatusTypeDef status = HAL_OK;
 8019e76:	2000      	movs	r0, #0
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8019e78:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
 8019e7c:	430b      	orrs	r3, r1

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8019e7e:	60a3      	str	r3, [r4, #8]
      htim->Instance->SMCR |= TIM_SMCR_ECE;
 8019e80:	68a3      	ldr	r3, [r4, #8]
 8019e82:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 8019e86:	60a3      	str	r3, [r4, #8]
      break;
 8019e88:	e7e0      	b.n	8019e4c <HAL_TIM_ConfigClockSource+0x64>
  switch (sClockSourceConfig->ClockSource)
 8019e8a:	2b70      	cmp	r3, #112	@ 0x70
 8019e8c:	d1de      	bne.n	8019e4c <HAL_TIM_ConfigClockSource+0x64>
  tmpsmcr = TIMx->SMCR;
 8019e8e:	68a0      	ldr	r0, [r4, #8]
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8019e90:	e9d1 5301 	ldrd	r5, r3, [r1, #4]
 8019e94:	432b      	orrs	r3, r5
 8019e96:	68cd      	ldr	r5, [r1, #12]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 8019e98:	f420 417f 	bic.w	r1, r0, #65280	@ 0xff00
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8019e9c:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
 8019ea0:	430b      	orrs	r3, r1
  TIMx->SMCR = tmpsmcr;
 8019ea2:	60a3      	str	r3, [r4, #8]
      tmpsmcr = htim->Instance->SMCR;
 8019ea4:	68a3      	ldr	r3, [r4, #8]
      tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
 8019ea6:	f043 0377 	orr.w	r3, r3, #119	@ 0x77
      htim->Instance->SMCR = tmpsmcr;
 8019eaa:	60a3      	str	r3, [r4, #8]
      break;
 8019eac:	e7cd      	b.n	8019e4a <HAL_TIM_ConfigClockSource+0x62>
  switch (sClockSourceConfig->ClockSource)
 8019eae:	2b20      	cmp	r3, #32
 8019eb0:	d002      	beq.n	8019eb8 <HAL_TIM_ConfigClockSource+0xd0>
 8019eb2:	d909      	bls.n	8019ec8 <HAL_TIM_ConfigClockSource+0xe0>
 8019eb4:	2b30      	cmp	r3, #48	@ 0x30
 8019eb6:	d1c9      	bne.n	8019e4c <HAL_TIM_ConfigClockSource+0x64>
  tmpsmcr = TIMx->SMCR;
 8019eb8:	68a1      	ldr	r1, [r4, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
 8019eba:	f021 0170 	bic.w	r1, r1, #112	@ 0x70
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8019ebe:	430b      	orrs	r3, r1
 8019ec0:	f043 0307 	orr.w	r3, r3, #7
  TIMx->SMCR = tmpsmcr;
 8019ec4:	60a3      	str	r3, [r4, #8]
}
 8019ec6:	e7c0      	b.n	8019e4a <HAL_TIM_ConfigClockSource+0x62>
  switch (sClockSourceConfig->ClockSource)
 8019ec8:	f033 0110 	bics.w	r1, r3, #16
 8019ecc:	d1be      	bne.n	8019e4c <HAL_TIM_ConfigClockSource+0x64>
 8019ece:	e7f3      	b.n	8019eb8 <HAL_TIM_ConfigClockSource+0xd0>
  __HAL_LOCK(htim);
 8019ed0:	2002      	movs	r0, #2
}
 8019ed2:	4770      	bx	lr
  tmpccer = TIMx->CCER;
 8019ed4:	6a23      	ldr	r3, [r4, #32]
                               sClockSourceConfig->ClockPolarity,
 8019ed6:	684d      	ldr	r5, [r1, #4]
                               sClockSourceConfig->ClockFilter);
 8019ed8:	68c8      	ldr	r0, [r1, #12]
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 8019eda:	f023 03a0 	bic.w	r3, r3, #160	@ 0xa0
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8019ede:	6a21      	ldr	r1, [r4, #32]
  tmpccer |= (TIM_ICPolarity << 4U);
 8019ee0:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8019ee4:	f021 0110 	bic.w	r1, r1, #16
 8019ee8:	6221      	str	r1, [r4, #32]
  tmpccmr1 = TIMx->CCMR1;
 8019eea:	69a1      	ldr	r1, [r4, #24]
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 8019eec:	f421 4170 	bic.w	r1, r1, #61440	@ 0xf000
  tmpccmr1 |= (TIM_ICFilter << 12U);
 8019ef0:	ea41 3100 	orr.w	r1, r1, r0, lsl #12
  TIMx->CCMR1 = tmpccmr1 ;
 8019ef4:	61a1      	str	r1, [r4, #24]
  TIMx->CCER = tmpccer;
 8019ef6:	6223      	str	r3, [r4, #32]
  tmpsmcr = TIMx->SMCR;
 8019ef8:	68a3      	ldr	r3, [r4, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
 8019efa:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8019efe:	f043 0367 	orr.w	r3, r3, #103	@ 0x67
  TIMx->SMCR = tmpsmcr;
 8019f02:	60a3      	str	r3, [r4, #8]
}
 8019f04:	e7a1      	b.n	8019e4a <HAL_TIM_ConfigClockSource+0x62>
                               sClockSourceConfig->ClockPolarity,
 8019f06:	684b      	ldr	r3, [r1, #4]
                               sClockSourceConfig->ClockFilter);
 8019f08:	68c8      	ldr	r0, [r1, #12]
  tmpccer = TIMx->CCER;
 8019f0a:	6a21      	ldr	r1, [r4, #32]
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8019f0c:	f021 010a 	bic.w	r1, r1, #10
  tmpccer |= TIM_ICPolarity;
 8019f10:	4319      	orrs	r1, r3
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8019f12:	6a23      	ldr	r3, [r4, #32]
 8019f14:	f023 0301 	bic.w	r3, r3, #1
 8019f18:	6223      	str	r3, [r4, #32]
  tmpccmr1 = TIMx->CCMR1;
 8019f1a:	69a3      	ldr	r3, [r4, #24]
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 8019f1c:	f023 03f0 	bic.w	r3, r3, #240	@ 0xf0
  tmpccmr1 |= (TIM_ICFilter << 4U);
 8019f20:	ea43 1300 	orr.w	r3, r3, r0, lsl #4
  TIMx->CCMR1 = tmpccmr1;
 8019f24:	61a3      	str	r3, [r4, #24]
  TIMx->CCER = tmpccer;
 8019f26:	6221      	str	r1, [r4, #32]
  tmpsmcr = TIMx->SMCR;
 8019f28:	68a3      	ldr	r3, [r4, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
 8019f2a:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8019f2e:	f043 0347 	orr.w	r3, r3, #71	@ 0x47
  TIMx->SMCR = tmpsmcr;
 8019f32:	60a3      	str	r3, [r4, #8]
}
 8019f34:	e789      	b.n	8019e4a <HAL_TIM_ConfigClockSource+0x62>
 8019f36:	bf00      	nop
 8019f38:	fffe0088 	.word	0xfffe0088

08019f3c <HAL_TIM_OC_DelayElapsedCallback>:
__weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
 8019f3c:	4770      	bx	lr
 8019f3e:	bf00      	nop

08019f40 <HAL_TIM_IC_CaptureCallback>:
__weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
 8019f40:	4770      	bx	lr
 8019f42:	bf00      	nop

08019f44 <HAL_TIM_PWM_PulseFinishedCallback>:
__weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
 8019f44:	4770      	bx	lr
 8019f46:	bf00      	nop

08019f48 <HAL_TIM_TriggerCallback>:
__weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
 8019f48:	4770      	bx	lr
 8019f4a:	bf00      	nop

08019f4c <HAL_TIM_IRQHandler>:
{
 8019f4c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t itsource = htim->Instance->DIER;
 8019f4e:	6803      	ldr	r3, [r0, #0]
{
 8019f50:	4605      	mov	r5, r0
  uint32_t itsource = htim->Instance->DIER;
 8019f52:	68de      	ldr	r6, [r3, #12]
  uint32_t itflag   = htim->Instance->SR;
 8019f54:	691c      	ldr	r4, [r3, #16]
  if ((itflag & (TIM_FLAG_CC1)) == (TIM_FLAG_CC1))
 8019f56:	07a1      	lsls	r1, r4, #30
 8019f58:	d501      	bpl.n	8019f5e <HAL_TIM_IRQHandler+0x12>
    if ((itsource & (TIM_IT_CC1)) == (TIM_IT_CC1))
 8019f5a:	07b2      	lsls	r2, r6, #30
 8019f5c:	d457      	bmi.n	801a00e <HAL_TIM_IRQHandler+0xc2>
  if ((itflag & (TIM_FLAG_CC2)) == (TIM_FLAG_CC2))
 8019f5e:	0767      	lsls	r7, r4, #29
 8019f60:	d501      	bpl.n	8019f66 <HAL_TIM_IRQHandler+0x1a>
    if ((itsource & (TIM_IT_CC2)) == (TIM_IT_CC2))
 8019f62:	0770      	lsls	r0, r6, #29
 8019f64:	d440      	bmi.n	8019fe8 <HAL_TIM_IRQHandler+0x9c>
  if ((itflag & (TIM_FLAG_CC3)) == (TIM_FLAG_CC3))
 8019f66:	0721      	lsls	r1, r4, #28
 8019f68:	d501      	bpl.n	8019f6e <HAL_TIM_IRQHandler+0x22>
    if ((itsource & (TIM_IT_CC3)) == (TIM_IT_CC3))
 8019f6a:	0732      	lsls	r2, r6, #28
 8019f6c:	d42a      	bmi.n	8019fc4 <HAL_TIM_IRQHandler+0x78>
  if ((itflag & (TIM_FLAG_CC4)) == (TIM_FLAG_CC4))
 8019f6e:	06e7      	lsls	r7, r4, #27
 8019f70:	d501      	bpl.n	8019f76 <HAL_TIM_IRQHandler+0x2a>
    if ((itsource & (TIM_IT_CC4)) == (TIM_IT_CC4))
 8019f72:	06f0      	lsls	r0, r6, #27
 8019f74:	d413      	bmi.n	8019f9e <HAL_TIM_IRQHandler+0x52>
  if ((itflag & (TIM_FLAG_UPDATE)) == (TIM_FLAG_UPDATE))
 8019f76:	07e1      	lsls	r1, r4, #31
 8019f78:	d501      	bpl.n	8019f7e <HAL_TIM_IRQHandler+0x32>
    if ((itsource & (TIM_IT_UPDATE)) == (TIM_IT_UPDATE))
 8019f7a:	07f2      	lsls	r2, r6, #31
 8019f7c:	d465      	bmi.n	801a04a <HAL_TIM_IRQHandler+0xfe>
  if (((itflag & (TIM_FLAG_BREAK)) == (TIM_FLAG_BREAK)) || \
 8019f7e:	f414 5f02 	tst.w	r4, #8320	@ 0x2080
  if ((itflag & (TIM_FLAG_BREAK2)) == (TIM_FLAG_BREAK2))
 8019f82:	f404 7780 	and.w	r7, r4, #256	@ 0x100
  if (((itflag & (TIM_FLAG_BREAK)) == (TIM_FLAG_BREAK)) || \
 8019f86:	d052      	beq.n	801a02e <HAL_TIM_IRQHandler+0xe2>
    if ((itsource & (TIM_IT_BREAK)) == (TIM_IT_BREAK))
 8019f88:	0633      	lsls	r3, r6, #24
 8019f8a:	d466      	bmi.n	801a05a <HAL_TIM_IRQHandler+0x10e>
  if ((itflag & (TIM_FLAG_TRIGGER)) == (TIM_FLAG_TRIGGER))
 8019f8c:	0660      	lsls	r0, r4, #25
 8019f8e:	d501      	bpl.n	8019f94 <HAL_TIM_IRQHandler+0x48>
    if ((itsource & (TIM_IT_TRIGGER)) == (TIM_IT_TRIGGER))
 8019f90:	0671      	lsls	r1, r6, #25
 8019f92:	d473      	bmi.n	801a07c <HAL_TIM_IRQHandler+0x130>
  if ((itflag & (TIM_FLAG_COM)) == (TIM_FLAG_COM))
 8019f94:	06a2      	lsls	r2, r4, #26
 8019f96:	d501      	bpl.n	8019f9c <HAL_TIM_IRQHandler+0x50>
    if ((itsource & (TIM_IT_COM)) == (TIM_IT_COM))
 8019f98:	06b3      	lsls	r3, r6, #26
 8019f9a:	d44d      	bmi.n	801a038 <HAL_TIM_IRQHandler+0xec>
}
 8019f9c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC4);
 8019f9e:	682b      	ldr	r3, [r5, #0]
 8019fa0:	f06f 0210 	mvn.w	r2, #16
        HAL_TIM_IC_CaptureCallback(htim);
 8019fa4:	4628      	mov	r0, r5
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC4);
 8019fa6:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8019fa8:	2208      	movs	r2, #8
 8019faa:	772a      	strb	r2, [r5, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8019fac:	69db      	ldr	r3, [r3, #28]
 8019fae:	f413 7f40 	tst.w	r3, #768	@ 0x300
 8019fb2:	d174      	bne.n	801a09e <HAL_TIM_IRQHandler+0x152>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8019fb4:	f7ff ffc2 	bl	8019f3c <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8019fb8:	4628      	mov	r0, r5
 8019fba:	f7ff ffc3 	bl	8019f44 <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8019fbe:	2300      	movs	r3, #0
 8019fc0:	772b      	strb	r3, [r5, #28]
 8019fc2:	e7d8      	b.n	8019f76 <HAL_TIM_IRQHandler+0x2a>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC3);
 8019fc4:	682b      	ldr	r3, [r5, #0]
 8019fc6:	f06f 0208 	mvn.w	r2, #8
        HAL_TIM_IC_CaptureCallback(htim);
 8019fca:	4628      	mov	r0, r5
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC3);
 8019fcc:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8019fce:	2204      	movs	r2, #4
 8019fd0:	772a      	strb	r2, [r5, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8019fd2:	69db      	ldr	r3, [r3, #28]
 8019fd4:	079b      	lsls	r3, r3, #30
 8019fd6:	d15f      	bne.n	801a098 <HAL_TIM_IRQHandler+0x14c>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8019fd8:	f7ff ffb0 	bl	8019f3c <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8019fdc:	4628      	mov	r0, r5
 8019fde:	f7ff ffb1 	bl	8019f44 <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8019fe2:	2300      	movs	r3, #0
 8019fe4:	772b      	strb	r3, [r5, #28]
 8019fe6:	e7c2      	b.n	8019f6e <HAL_TIM_IRQHandler+0x22>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC2);
 8019fe8:	682b      	ldr	r3, [r5, #0]
 8019fea:	f06f 0204 	mvn.w	r2, #4
        HAL_TIM_IC_CaptureCallback(htim);
 8019fee:	4628      	mov	r0, r5
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC2);
 8019ff0:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8019ff2:	2202      	movs	r2, #2
 8019ff4:	772a      	strb	r2, [r5, #28]
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8019ff6:	699b      	ldr	r3, [r3, #24]
 8019ff8:	f413 7f40 	tst.w	r3, #768	@ 0x300
 8019ffc:	d149      	bne.n	801a092 <HAL_TIM_IRQHandler+0x146>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8019ffe:	f7ff ff9d 	bl	8019f3c <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 801a002:	4628      	mov	r0, r5
 801a004:	f7ff ff9e 	bl	8019f44 <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 801a008:	2300      	movs	r3, #0
 801a00a:	772b      	strb	r3, [r5, #28]
 801a00c:	e7ab      	b.n	8019f66 <HAL_TIM_IRQHandler+0x1a>
        __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC1);
 801a00e:	f06f 0202 	mvn.w	r2, #2
 801a012:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 801a014:	2201      	movs	r2, #1
 801a016:	7702      	strb	r2, [r0, #28]
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 801a018:	699b      	ldr	r3, [r3, #24]
 801a01a:	079b      	lsls	r3, r3, #30
 801a01c:	d136      	bne.n	801a08c <HAL_TIM_IRQHandler+0x140>
          HAL_TIM_OC_DelayElapsedCallback(htim);
 801a01e:	f7ff ff8d 	bl	8019f3c <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 801a022:	4628      	mov	r0, r5
 801a024:	f7ff ff8e 	bl	8019f44 <HAL_TIM_PWM_PulseFinishedCallback>
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 801a028:	2300      	movs	r3, #0
 801a02a:	772b      	strb	r3, [r5, #28]
 801a02c:	e797      	b.n	8019f5e <HAL_TIM_IRQHandler+0x12>
  if ((itflag & (TIM_FLAG_BREAK2)) == (TIM_FLAG_BREAK2))
 801a02e:	2f00      	cmp	r7, #0
 801a030:	d0ac      	beq.n	8019f8c <HAL_TIM_IRQHandler+0x40>
    if ((itsource & (TIM_IT_BREAK)) == (TIM_IT_BREAK))
 801a032:	0637      	lsls	r7, r6, #24
 801a034:	d41a      	bmi.n	801a06c <HAL_TIM_IRQHandler+0x120>
 801a036:	e7a9      	b.n	8019f8c <HAL_TIM_IRQHandler+0x40>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_COM);
 801a038:	682b      	ldr	r3, [r5, #0]
 801a03a:	f06f 0220 	mvn.w	r2, #32
      HAL_TIMEx_CommutCallback(htim);
 801a03e:	4628      	mov	r0, r5
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_COM);
 801a040:	611a      	str	r2, [r3, #16]
}
 801a042:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
      HAL_TIMEx_CommutCallback(htim);
 801a046:	f000 b8cd 	b.w	801a1e4 <HAL_TIMEx_CommutCallback>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_UPDATE);
 801a04a:	682b      	ldr	r3, [r5, #0]
 801a04c:	f06f 0201 	mvn.w	r2, #1
      HAL_TIM_PeriodElapsedCallback(htim);
 801a050:	4628      	mov	r0, r5
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_UPDATE);
 801a052:	611a      	str	r2, [r3, #16]
      HAL_TIM_PeriodElapsedCallback(htim);
 801a054:	f7f7 ff2a 	bl	8011eac <HAL_TIM_PeriodElapsedCallback>
 801a058:	e791      	b.n	8019f7e <HAL_TIM_IRQHandler+0x32>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK | TIM_FLAG_SYSTEM_BREAK);
 801a05a:	682b      	ldr	r3, [r5, #0]
 801a05c:	f46f 5202 	mvn.w	r2, #8320	@ 0x2080
      HAL_TIMEx_BreakCallback(htim);
 801a060:	4628      	mov	r0, r5
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK | TIM_FLAG_SYSTEM_BREAK);
 801a062:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 801a064:	f000 f8c0 	bl	801a1e8 <HAL_TIMEx_BreakCallback>
  if ((itflag & (TIM_FLAG_BREAK2)) == (TIM_FLAG_BREAK2))
 801a068:	2f00      	cmp	r7, #0
 801a06a:	d08f      	beq.n	8019f8c <HAL_TIM_IRQHandler+0x40>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
 801a06c:	682b      	ldr	r3, [r5, #0]
 801a06e:	f46f 7280 	mvn.w	r2, #256	@ 0x100
      HAL_TIMEx_Break2Callback(htim);
 801a072:	4628      	mov	r0, r5
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
 801a074:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_Break2Callback(htim);
 801a076:	f000 f8b9 	bl	801a1ec <HAL_TIMEx_Break2Callback>
 801a07a:	e787      	b.n	8019f8c <HAL_TIM_IRQHandler+0x40>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_TRIGGER);
 801a07c:	682b      	ldr	r3, [r5, #0]
 801a07e:	f06f 0240 	mvn.w	r2, #64	@ 0x40
      HAL_TIM_TriggerCallback(htim);
 801a082:	4628      	mov	r0, r5
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_TRIGGER);
 801a084:	611a      	str	r2, [r3, #16]
      HAL_TIM_TriggerCallback(htim);
 801a086:	f7ff ff5f 	bl	8019f48 <HAL_TIM_TriggerCallback>
 801a08a:	e783      	b.n	8019f94 <HAL_TIM_IRQHandler+0x48>
          HAL_TIM_IC_CaptureCallback(htim);
 801a08c:	f7ff ff58 	bl	8019f40 <HAL_TIM_IC_CaptureCallback>
 801a090:	e7ca      	b.n	801a028 <HAL_TIM_IRQHandler+0xdc>
        HAL_TIM_IC_CaptureCallback(htim);
 801a092:	f7ff ff55 	bl	8019f40 <HAL_TIM_IC_CaptureCallback>
 801a096:	e7b7      	b.n	801a008 <HAL_TIM_IRQHandler+0xbc>
        HAL_TIM_IC_CaptureCallback(htim);
 801a098:	f7ff ff52 	bl	8019f40 <HAL_TIM_IC_CaptureCallback>
 801a09c:	e7a1      	b.n	8019fe2 <HAL_TIM_IRQHandler+0x96>
        HAL_TIM_IC_CaptureCallback(htim);
 801a09e:	f7ff ff4f 	bl	8019f40 <HAL_TIM_IC_CaptureCallback>
 801a0a2:	e78c      	b.n	8019fbe <HAL_TIM_IRQHandler+0x72>

0801a0a4 <HAL_TIMEx_MasterConfigSynchronization>:
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  /* Check input state */
  __HAL_LOCK(htim);
 801a0a4:	f890 303c 	ldrb.w	r3, [r0, #60]	@ 0x3c
 801a0a8:	2b01      	cmp	r3, #1
 801a0aa:	d04b      	beq.n	801a144 <HAL_TIMEx_MasterConfigSynchronization+0xa0>

  /* Change the handler state */
  htim->State = HAL_TIM_STATE_BUSY;

  /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
 801a0ac:	6803      	ldr	r3, [r0, #0]
 801a0ae:	4602      	mov	r2, r0
  htim->State = HAL_TIM_STATE_BUSY;
 801a0b0:	2002      	movs	r0, #2
{
 801a0b2:	b430      	push	{r4, r5}

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;

  /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 801a0b4:	4d24      	ldr	r5, [pc, #144]	@ (801a148 <HAL_TIMEx_MasterConfigSynchronization+0xa4>)
  htim->State = HAL_TIM_STATE_BUSY;
 801a0b6:	f882 003d 	strb.w	r0, [r2, #61]	@ 0x3d
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 801a0ba:	42ab      	cmp	r3, r5
  tmpcr2 = htim->Instance->CR2;
 801a0bc:	6858      	ldr	r0, [r3, #4]
  tmpsmcr = htim->Instance->SMCR;
 801a0be:	689c      	ldr	r4, [r3, #8]
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 801a0c0:	d029      	beq.n	801a116 <HAL_TIMEx_MasterConfigSynchronization+0x72>
 801a0c2:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 801a0c6:	42ab      	cmp	r3, r5
 801a0c8:	d025      	beq.n	801a116 <HAL_TIMEx_MasterConfigSynchronization+0x72>
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;

  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 801a0ca:	4d20      	ldr	r5, [pc, #128]	@ (801a14c <HAL_TIMEx_MasterConfigSynchronization+0xa8>)
  tmpcr2 &= ~TIM_CR2_MMS;
 801a0cc:	f020 0070 	bic.w	r0, r0, #112	@ 0x70
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 801a0d0:	42ab      	cmp	r3, r5
 801a0d2:	bf18      	it	ne
 801a0d4:	f1b3 4f80 	cmpne.w	r3, #1073741824	@ 0x40000000
 801a0d8:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 801a0dc:	bf0c      	ite	eq
 801a0de:	f04f 0c01 	moveq.w	ip, #1
 801a0e2:	f04f 0c00 	movne.w	ip, #0
 801a0e6:	42ab      	cmp	r3, r5
 801a0e8:	bf08      	it	eq
 801a0ea:	f04c 0c01 	orreq.w	ip, ip, #1
 801a0ee:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 801a0f2:	42ab      	cmp	r3, r5
 801a0f4:	bf08      	it	eq
 801a0f6:	f04c 0c01 	orreq.w	ip, ip, #1
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 801a0fa:	680d      	ldr	r5, [r1, #0]
 801a0fc:	4328      	orrs	r0, r5
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 801a0fe:	4d14      	ldr	r5, [pc, #80]	@ (801a150 <HAL_TIMEx_MasterConfigSynchronization+0xac>)
  htim->Instance->CR2 = tmpcr2;
 801a100:	6058      	str	r0, [r3, #4]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 801a102:	42ab      	cmp	r3, r5
 801a104:	bf14      	ite	ne
 801a106:	4660      	movne	r0, ip
 801a108:	f04c 0001 	orreq.w	r0, ip, #1
 801a10c:	b960      	cbnz	r0, 801a128 <HAL_TIMEx_MasterConfigSynchronization+0x84>
 801a10e:	4811      	ldr	r0, [pc, #68]	@ (801a154 <HAL_TIMEx_MasterConfigSynchronization+0xb0>)
 801a110:	4283      	cmp	r3, r0
 801a112:	d009      	beq.n	801a128 <HAL_TIMEx_MasterConfigSynchronization+0x84>
 801a114:	e00d      	b.n	801a132 <HAL_TIMEx_MasterConfigSynchronization+0x8e>
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 801a116:	684d      	ldr	r5, [r1, #4]
    tmpcr2 &= ~TIM_CR2_MMS2;
 801a118:	f420 0070 	bic.w	r0, r0, #15728640	@ 0xf00000
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 801a11c:	4328      	orrs	r0, r5
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 801a11e:	680d      	ldr	r5, [r1, #0]
  tmpcr2 &= ~TIM_CR2_MMS;
 801a120:	f020 0070 	bic.w	r0, r0, #112	@ 0x70
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 801a124:	4328      	orrs	r0, r5
  htim->Instance->CR2 = tmpcr2;
 801a126:	6058      	str	r0, [r3, #4]
  {
    /* Reset the MSM Bit */
    tmpsmcr &= ~TIM_SMCR_MSM;
    /* Set master mode */
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 801a128:	6889      	ldr	r1, [r1, #8]
    tmpsmcr &= ~TIM_SMCR_MSM;
 801a12a:	f024 0480 	bic.w	r4, r4, #128	@ 0x80
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 801a12e:	430c      	orrs	r4, r1

    /* Update TIMx SMCR */
    htim->Instance->SMCR = tmpsmcr;
 801a130:	609c      	str	r4, [r3, #8]
  }

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;

  __HAL_UNLOCK(htim);
 801a132:	2300      	movs	r3, #0
  htim->State = HAL_TIM_STATE_READY;
 801a134:	2101      	movs	r1, #1

  return HAL_OK;
 801a136:	4618      	mov	r0, r3
  htim->State = HAL_TIM_STATE_READY;
 801a138:	f882 103d 	strb.w	r1, [r2, #61]	@ 0x3d
  __HAL_UNLOCK(htim);
 801a13c:	f882 303c 	strb.w	r3, [r2, #60]	@ 0x3c
}
 801a140:	bc30      	pop	{r4, r5}
 801a142:	4770      	bx	lr
  __HAL_LOCK(htim);
 801a144:	2002      	movs	r0, #2
}
 801a146:	4770      	bx	lr
 801a148:	40010000 	.word	0x40010000
 801a14c:	40000400 	.word	0x40000400
 801a150:	40014000 	.word	0x40014000
 801a154:	40001800 	.word	0x40001800

0801a158 <HAL_TIMEx_ConfigBreakDeadTime>:
  assert_param(IS_TIM_BREAK_POLARITY(sBreakDeadTimeConfig->BreakPolarity));
  assert_param(IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig->BreakFilter));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(sBreakDeadTimeConfig->AutomaticOutput));

  /* Check input state */
  __HAL_LOCK(htim);
 801a158:	f890 303c 	ldrb.w	r3, [r0, #60]	@ 0x3c
 801a15c:	2b01      	cmp	r3, #1
 801a15e:	d03d      	beq.n	801a1dc <HAL_TIMEx_ConfigBreakDeadTime+0x84>
     the OSSI State, the dead time value and the Automatic Output Enable Bit */

  /* Set the BDTR bits */
  MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, sBreakDeadTimeConfig->DeadTime);
  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, sBreakDeadTimeConfig->OffStateIDLEMode);
 801a160:	4602      	mov	r2, r0
 801a162:	6848      	ldr	r0, [r1, #4]
{
 801a164:	b410      	push	{r4}
  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
 801a166:	e9d1 4302 	ldrd	r4, r3, [r1, #8]
 801a16a:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 801a16e:	4323      	orrs	r3, r4
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);
 801a170:	680c      	ldr	r4, [r1, #0]
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, sBreakDeadTimeConfig->OffStateIDLEMode);
 801a172:	f423 6380 	bic.w	r3, r3, #1024	@ 0x400
 801a176:	4303      	orrs	r3, r0
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);
 801a178:	6908      	ldr	r0, [r1, #16]
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);
 801a17a:	f423 6300 	bic.w	r3, r3, #2048	@ 0x800
 801a17e:	4323      	orrs	r3, r4
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
 801a180:	694c      	ldr	r4, [r1, #20]
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);
 801a182:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 801a186:	4303      	orrs	r3, r0
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
 801a188:	6a88      	ldr	r0, [r1, #40]	@ 0x28
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
 801a18a:	f423 5300 	bic.w	r3, r3, #8192	@ 0x2000
 801a18e:	4323      	orrs	r3, r4
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKF, (sBreakDeadTimeConfig->BreakFilter << TIM_BDTR_BKF_Pos));
 801a190:	698c      	ldr	r4, [r1, #24]
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
 801a192:	f423 4380 	bic.w	r3, r3, #16384	@ 0x4000
 801a196:	4303      	orrs	r3, r0

  if (IS_TIM_BKIN2_INSTANCE(htim->Instance))
 801a198:	6810      	ldr	r0, [r2, #0]
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKF, (sBreakDeadTimeConfig->BreakFilter << TIM_BDTR_BKF_Pos));
 801a19a:	f423 2370 	bic.w	r3, r3, #983040	@ 0xf0000
 801a19e:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
  if (IS_TIM_BKIN2_INSTANCE(htim->Instance))
 801a1a2:	4c0f      	ldr	r4, [pc, #60]	@ (801a1e0 <HAL_TIMEx_ConfigBreakDeadTime+0x88>)
 801a1a4:	42a0      	cmp	r0, r4
 801a1a6:	d00b      	beq.n	801a1c0 <HAL_TIMEx_ConfigBreakDeadTime+0x68>
 801a1a8:	f504 6480 	add.w	r4, r4, #1024	@ 0x400
 801a1ac:	42a0      	cmp	r0, r4
 801a1ae:	d007      	beq.n	801a1c0 <HAL_TIMEx_ConfigBreakDeadTime+0x68>
  }

  /* Set TIMx_BDTR */
  htim->Instance->BDTR = tmpbdtr;

  __HAL_UNLOCK(htim);
 801a1b0:	2100      	movs	r1, #0
  htim->Instance->BDTR = tmpbdtr;
 801a1b2:	6443      	str	r3, [r0, #68]	@ 0x44
  __HAL_UNLOCK(htim);
 801a1b4:	f882 103c 	strb.w	r1, [r2, #60]	@ 0x3c

  return HAL_OK;
 801a1b8:	4608      	mov	r0, r1
}
 801a1ba:	f85d 4b04 	ldr.w	r4, [sp], #4
 801a1be:	4770      	bx	lr
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2F, (sBreakDeadTimeConfig->Break2Filter << TIM_BDTR_BK2F_Pos));
 801a1c0:	6a4c      	ldr	r4, [r1, #36]	@ 0x24
 801a1c2:	f423 0370 	bic.w	r3, r3, #15728640	@ 0xf00000
 801a1c6:	ea43 5304 	orr.w	r3, r3, r4, lsl #20
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2P, sBreakDeadTimeConfig->Break2Polarity);
 801a1ca:	e9d1 4107 	ldrd	r4, r1, [r1, #28]
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2E, sBreakDeadTimeConfig->Break2State);
 801a1ce:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
 801a1d2:	4323      	orrs	r3, r4
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2P, sBreakDeadTimeConfig->Break2Polarity);
 801a1d4:	f023 7300 	bic.w	r3, r3, #33554432	@ 0x2000000
 801a1d8:	430b      	orrs	r3, r1
 801a1da:	e7e9      	b.n	801a1b0 <HAL_TIMEx_ConfigBreakDeadTime+0x58>
  __HAL_LOCK(htim);
 801a1dc:	2002      	movs	r0, #2
}
 801a1de:	4770      	bx	lr
 801a1e0:	40010000 	.word	0x40010000

0801a1e4 <HAL_TIMEx_CommutCallback>:
/**
  * @brief  Commutation callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_CommutCallback(TIM_HandleTypeDef *htim)
 801a1e4:	4770      	bx	lr
 801a1e6:	bf00      	nop

0801a1e8 <HAL_TIMEx_BreakCallback>:
/**
  * @brief  Break detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
 801a1e8:	4770      	bx	lr
 801a1ea:	bf00      	nop

0801a1ec <HAL_TIMEx_Break2Callback>:
/**
  * @brief  Break2 detection callback in non blocking mode
  * @param  htim: TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_Break2Callback(TIM_HandleTypeDef *htim)
 801a1ec:	4770      	bx	lr
 801a1ee:	bf00      	nop

0801a1f0 <UART_SetConfig>:
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 801a1f0:	6901      	ldr	r1, [r0, #16]
 801a1f2:	6882      	ldr	r2, [r0, #8]
{
 801a1f4:	b538      	push	{r3, r4, r5, lr}
 801a1f6:	4604      	mov	r4, r0
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 801a1f8:	6803      	ldr	r3, [r0, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 801a1fa:	430a      	orrs	r2, r1
 801a1fc:	69c0      	ldr	r0, [r0, #28]
 801a1fe:	6961      	ldr	r1, [r4, #20]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 801a200:	681d      	ldr	r5, [r3, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 801a202:	430a      	orrs	r2, r1
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 801a204:	4996      	ldr	r1, [pc, #600]	@ (801a460 <UART_SetConfig+0x270>)
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 801a206:	4302      	orrs	r2, r0
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 801a208:	4029      	ands	r1, r5

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 801a20a:	68e5      	ldr	r5, [r4, #12]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 801a20c:	430a      	orrs	r2, r1
 801a20e:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 801a210:	6859      	ldr	r1, [r3, #4]
  /* Configure
  * - UART HardWare Flow Control: set CTSE and RTSE bits according
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 801a212:	69a2      	ldr	r2, [r4, #24]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 801a214:	f421 5140 	bic.w	r1, r1, #12288	@ 0x3000
 801a218:	4329      	orrs	r1, r5
 801a21a:	6059      	str	r1, [r3, #4]

  tmpreg |= huart->Init.OneBitSampling;
 801a21c:	6a21      	ldr	r1, [r4, #32]
 801a21e:	430a      	orrs	r2, r1
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 801a220:	6899      	ldr	r1, [r3, #8]
 801a222:	f421 6130 	bic.w	r1, r1, #2816	@ 0xb00
 801a226:	430a      	orrs	r2, r1


  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 801a228:	498e      	ldr	r1, [pc, #568]	@ (801a464 <UART_SetConfig+0x274>)
 801a22a:	428b      	cmp	r3, r1
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 801a22c:	609a      	str	r2, [r3, #8]
  UART_GETCLOCKSOURCE(huart, clocksource);
 801a22e:	d03d      	beq.n	801a2ac <UART_SetConfig+0xbc>
 801a230:	4a8d      	ldr	r2, [pc, #564]	@ (801a468 <UART_SetConfig+0x278>)
 801a232:	4293      	cmp	r3, r2
 801a234:	d016      	beq.n	801a264 <UART_SetConfig+0x74>
 801a236:	4a8d      	ldr	r2, [pc, #564]	@ (801a46c <UART_SetConfig+0x27c>)
 801a238:	4293      	cmp	r3, r2
 801a23a:	d064      	beq.n	801a306 <UART_SetConfig+0x116>
 801a23c:	4a8c      	ldr	r2, [pc, #560]	@ (801a470 <UART_SetConfig+0x280>)
 801a23e:	4293      	cmp	r3, r2
 801a240:	f000 80bb 	beq.w	801a3ba <UART_SetConfig+0x1ca>
 801a244:	4a8b      	ldr	r2, [pc, #556]	@ (801a474 <UART_SetConfig+0x284>)
 801a246:	4293      	cmp	r3, r2
 801a248:	d07b      	beq.n	801a342 <UART_SetConfig+0x152>
 801a24a:	4a8b      	ldr	r2, [pc, #556]	@ (801a478 <UART_SetConfig+0x288>)
 801a24c:	4293      	cmp	r3, r2
 801a24e:	d04d      	beq.n	801a2ec <UART_SetConfig+0xfc>
 801a250:	4a8a      	ldr	r2, [pc, #552]	@ (801a47c <UART_SetConfig+0x28c>)
 801a252:	4293      	cmp	r3, r2
 801a254:	f000 80d8 	beq.w	801a408 <UART_SetConfig+0x218>
 801a258:	4a89      	ldr	r2, [pc, #548]	@ (801a480 <UART_SetConfig+0x290>)
 801a25a:	4293      	cmp	r3, r2
 801a25c:	f000 80ea 	beq.w	801a434 <UART_SetConfig+0x244>
        break;
      case UART_CLOCKSOURCE_PCLK2:
        pclk = HAL_RCC_GetPCLK2Freq();
        break;
      case UART_CLOCKSOURCE_HSI:
        pclk = (uint32_t) HSI_VALUE;
 801a260:	2001      	movs	r0, #1
 801a262:	e03f      	b.n	801a2e4 <UART_SetConfig+0xf4>
  UART_GETCLOCKSOURCE(huart, clocksource);
 801a264:	4b87      	ldr	r3, [pc, #540]	@ (801a484 <UART_SetConfig+0x294>)
 801a266:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 801a26a:	f003 030c 	and.w	r3, r3, #12
 801a26e:	2b0c      	cmp	r3, #12
 801a270:	d8f6      	bhi.n	801a260 <UART_SetConfig+0x70>
 801a272:	a201      	add	r2, pc, #4	@ (adr r2, 801a278 <UART_SetConfig+0x88>)
 801a274:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801a278:	0801a39d 	.word	0x0801a39d
 801a27c:	0801a261 	.word	0x0801a261
 801a280:	0801a261 	.word	0x0801a261
 801a284:	0801a261 	.word	0x0801a261
 801a288:	0801a31f 	.word	0x0801a31f
 801a28c:	0801a261 	.word	0x0801a261
 801a290:	0801a261 	.word	0x0801a261
 801a294:	0801a261 	.word	0x0801a261
 801a298:	0801a2fd 	.word	0x0801a2fd
 801a29c:	0801a261 	.word	0x0801a261
 801a2a0:	0801a261 	.word	0x0801a261
 801a2a4:	0801a261 	.word	0x0801a261
 801a2a8:	0801a2bf 	.word	0x0801a2bf
 801a2ac:	4b75      	ldr	r3, [pc, #468]	@ (801a484 <UART_SetConfig+0x294>)
 801a2ae:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 801a2b2:	f003 0303 	and.w	r3, r3, #3
 801a2b6:	2b02      	cmp	r3, #2
 801a2b8:	d020      	beq.n	801a2fc <UART_SetConfig+0x10c>
 801a2ba:	2b03      	cmp	r3, #3
 801a2bc:	d137      	bne.n	801a32e <UART_SetConfig+0x13e>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 801a2be:	f5b0 4f00 	cmp.w	r0, #32768	@ 0x8000
 801a2c2:	d062      	beq.n	801a38a <UART_SetConfig+0x19a>
        break;
      case UART_CLOCKSOURCE_SYSCLK:
        pclk = HAL_RCC_GetSysClockFreq();
        break;
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
 801a2c4:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
    }

    if (pclk != 0U)
    {
      /* USARTDIV must be greater than or equal to 0d16 */
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate));
 801a2c8:	6863      	ldr	r3, [r4, #4]
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 801a2ca:	f64f 72ef 	movw	r2, #65519	@ 0xffef
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate));
 801a2ce:	eb00 0053 	add.w	r0, r0, r3, lsr #1
 801a2d2:	fbb0 f0f3 	udiv	r0, r0, r3
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 801a2d6:	f1a0 0310 	sub.w	r3, r0, #16
 801a2da:	4293      	cmp	r3, r2
 801a2dc:	d8c0      	bhi.n	801a260 <UART_SetConfig+0x70>
      {
        huart->Instance->BRR = (uint16_t)usartdiv;
 801a2de:	6823      	ldr	r3, [r4, #0]
 801a2e0:	60d8      	str	r0, [r3, #12]
        pclk = (uint32_t) HSI_VALUE;
 801a2e2:	2000      	movs	r0, #0
    }
  }


  /* Clear ISR function pointers */
  huart->RxISR = NULL;
 801a2e4:	2300      	movs	r3, #0
 801a2e6:	e9c4 331a 	strd	r3, r3, [r4, #104]	@ 0x68
  huart->TxISR = NULL;

  return ret;
}
 801a2ea:	bd38      	pop	{r3, r4, r5, pc}
  UART_GETCLOCKSOURCE(huart, clocksource);
 801a2ec:	4b65      	ldr	r3, [pc, #404]	@ (801a484 <UART_SetConfig+0x294>)
 801a2ee:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 801a2f2:	f403 6340 	and.w	r3, r3, #3072	@ 0xc00
 801a2f6:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 801a2fa:	d179      	bne.n	801a3f0 <UART_SetConfig+0x200>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 801a2fc:	f5b0 4f00 	cmp.w	r0, #32768	@ 0x8000
 801a300:	d02d      	beq.n	801a35e <UART_SetConfig+0x16e>
        pclk = (uint32_t) HSI_VALUE;
 801a302:	4861      	ldr	r0, [pc, #388]	@ (801a488 <UART_SetConfig+0x298>)
 801a304:	e7e0      	b.n	801a2c8 <UART_SetConfig+0xd8>
  UART_GETCLOCKSOURCE(huart, clocksource);
 801a306:	4b5f      	ldr	r3, [pc, #380]	@ (801a484 <UART_SetConfig+0x294>)
 801a308:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 801a30c:	f003 0330 	and.w	r3, r3, #48	@ 0x30
 801a310:	2b20      	cmp	r3, #32
 801a312:	d0f3      	beq.n	801a2fc <UART_SetConfig+0x10c>
 801a314:	d84e      	bhi.n	801a3b4 <UART_SetConfig+0x1c4>
 801a316:	2b00      	cmp	r3, #0
 801a318:	d040      	beq.n	801a39c <UART_SetConfig+0x1ac>
 801a31a:	2b10      	cmp	r3, #16
 801a31c:	d1a0      	bne.n	801a260 <UART_SetConfig+0x70>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 801a31e:	f5b0 4f00 	cmp.w	r0, #32768	@ 0x8000
 801a322:	d035      	beq.n	801a390 <UART_SetConfig+0x1a0>
        pclk = HAL_RCC_GetSysClockFreq();
 801a324:	f7fd fd1c 	bl	8017d60 <HAL_RCC_GetSysClockFreq>
    if (pclk != 0U)
 801a328:	2800      	cmp	r0, #0
 801a32a:	d0da      	beq.n	801a2e2 <UART_SetConfig+0xf2>
 801a32c:	e7cc      	b.n	801a2c8 <UART_SetConfig+0xd8>
  UART_GETCLOCKSOURCE(huart, clocksource);
 801a32e:	2b01      	cmp	r3, #1
 801a330:	d0f5      	beq.n	801a31e <UART_SetConfig+0x12e>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 801a332:	f5b0 4f00 	cmp.w	r0, #32768	@ 0x8000
 801a336:	d055      	beq.n	801a3e4 <UART_SetConfig+0x1f4>
        pclk = HAL_RCC_GetPCLK2Freq();
 801a338:	f7fd fd5c 	bl	8017df4 <HAL_RCC_GetPCLK2Freq>
    if (pclk != 0U)
 801a33c:	2800      	cmp	r0, #0
 801a33e:	d0d0      	beq.n	801a2e2 <UART_SetConfig+0xf2>
 801a340:	e7c2      	b.n	801a2c8 <UART_SetConfig+0xd8>
  UART_GETCLOCKSOURCE(huart, clocksource);
 801a342:	4b50      	ldr	r3, [pc, #320]	@ (801a484 <UART_SetConfig+0x294>)
 801a344:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 801a348:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 801a34c:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 801a350:	d0d4      	beq.n	801a2fc <UART_SetConfig+0x10c>
 801a352:	d82b      	bhi.n	801a3ac <UART_SetConfig+0x1bc>
 801a354:	b313      	cbz	r3, 801a39c <UART_SetConfig+0x1ac>
 801a356:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 801a35a:	d0e0      	beq.n	801a31e <UART_SetConfig+0x12e>
 801a35c:	e780      	b.n	801a260 <UART_SetConfig+0x70>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 801a35e:	484b      	ldr	r0, [pc, #300]	@ (801a48c <UART_SetConfig+0x29c>)
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate));
 801a360:	6863      	ldr	r3, [r4, #4]
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 801a362:	f64f 72ef 	movw	r2, #65519	@ 0xffef
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate));
 801a366:	eb00 0053 	add.w	r0, r0, r3, lsr #1
 801a36a:	fbb0 f3f3 	udiv	r3, r0, r3
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 801a36e:	f1a3 0110 	sub.w	r1, r3, #16
 801a372:	4291      	cmp	r1, r2
 801a374:	f63f af74 	bhi.w	801a260 <UART_SetConfig+0x70>
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 801a378:	f023 020f 	bic.w	r2, r3, #15
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 801a37c:	f3c3 0342 	ubfx	r3, r3, #1, #3
        huart->Instance->BRR = brrtemp;
 801a380:	6821      	ldr	r1, [r4, #0]
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 801a382:	b292      	uxth	r2, r2
        huart->Instance->BRR = brrtemp;
 801a384:	4313      	orrs	r3, r2
 801a386:	60cb      	str	r3, [r1, #12]
 801a388:	e7ab      	b.n	801a2e2 <UART_SetConfig+0xf2>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 801a38a:	f44f 3080 	mov.w	r0, #65536	@ 0x10000
 801a38e:	e7e7      	b.n	801a360 <UART_SetConfig+0x170>
        pclk = HAL_RCC_GetSysClockFreq();
 801a390:	f7fd fce6 	bl	8017d60 <HAL_RCC_GetSysClockFreq>
    if (pclk != 0U)
 801a394:	2800      	cmp	r0, #0
 801a396:	d0a4      	beq.n	801a2e2 <UART_SetConfig+0xf2>
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate));
 801a398:	0040      	lsls	r0, r0, #1
 801a39a:	e7e1      	b.n	801a360 <UART_SetConfig+0x170>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 801a39c:	f5b0 4f00 	cmp.w	r0, #32768	@ 0x8000
 801a3a0:	d023      	beq.n	801a3ea <UART_SetConfig+0x1fa>
        pclk = HAL_RCC_GetPCLK1Freq();
 801a3a2:	f7fd fd17 	bl	8017dd4 <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 801a3a6:	2800      	cmp	r0, #0
 801a3a8:	d09b      	beq.n	801a2e2 <UART_SetConfig+0xf2>
 801a3aa:	e78d      	b.n	801a2c8 <UART_SetConfig+0xd8>
  UART_GETCLOCKSOURCE(huart, clocksource);
 801a3ac:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 801a3b0:	d085      	beq.n	801a2be <UART_SetConfig+0xce>
 801a3b2:	e755      	b.n	801a260 <UART_SetConfig+0x70>
 801a3b4:	2b30      	cmp	r3, #48	@ 0x30
 801a3b6:	d082      	beq.n	801a2be <UART_SetConfig+0xce>
 801a3b8:	e752      	b.n	801a260 <UART_SetConfig+0x70>
 801a3ba:	4b32      	ldr	r3, [pc, #200]	@ (801a484 <UART_SetConfig+0x294>)
 801a3bc:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 801a3c0:	f003 03c0 	and.w	r3, r3, #192	@ 0xc0
 801a3c4:	2b80      	cmp	r3, #128	@ 0x80
 801a3c6:	d099      	beq.n	801a2fc <UART_SetConfig+0x10c>
 801a3c8:	d808      	bhi.n	801a3dc <UART_SetConfig+0x1ec>
 801a3ca:	2b00      	cmp	r3, #0
 801a3cc:	d0e6      	beq.n	801a39c <UART_SetConfig+0x1ac>
 801a3ce:	2b40      	cmp	r3, #64	@ 0x40
 801a3d0:	f47f af46 	bne.w	801a260 <UART_SetConfig+0x70>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 801a3d4:	f5b0 4f00 	cmp.w	r0, #32768	@ 0x8000
 801a3d8:	d1a4      	bne.n	801a324 <UART_SetConfig+0x134>
 801a3da:	e7d9      	b.n	801a390 <UART_SetConfig+0x1a0>
  UART_GETCLOCKSOURCE(huart, clocksource);
 801a3dc:	2bc0      	cmp	r3, #192	@ 0xc0
 801a3de:	f43f af6e 	beq.w	801a2be <UART_SetConfig+0xce>
 801a3e2:	e73d      	b.n	801a260 <UART_SetConfig+0x70>
        pclk = HAL_RCC_GetPCLK2Freq();
 801a3e4:	f7fd fd06 	bl	8017df4 <HAL_RCC_GetPCLK2Freq>
        break;
 801a3e8:	e7d4      	b.n	801a394 <UART_SetConfig+0x1a4>
        pclk = HAL_RCC_GetPCLK1Freq();
 801a3ea:	f7fd fcf3 	bl	8017dd4 <HAL_RCC_GetPCLK1Freq>
        break;
 801a3ee:	e7d1      	b.n	801a394 <UART_SetConfig+0x1a4>
  UART_GETCLOCKSOURCE(huart, clocksource);
 801a3f0:	d805      	bhi.n	801a3fe <UART_SetConfig+0x20e>
 801a3f2:	2b00      	cmp	r3, #0
 801a3f4:	d09d      	beq.n	801a332 <UART_SetConfig+0x142>
 801a3f6:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 801a3fa:	d090      	beq.n	801a31e <UART_SetConfig+0x12e>
 801a3fc:	e730      	b.n	801a260 <UART_SetConfig+0x70>
 801a3fe:	f5b3 6f40 	cmp.w	r3, #3072	@ 0xc00
 801a402:	f43f af5c 	beq.w	801a2be <UART_SetConfig+0xce>
 801a406:	e72b      	b.n	801a260 <UART_SetConfig+0x70>
 801a408:	4b1e      	ldr	r3, [pc, #120]	@ (801a484 <UART_SetConfig+0x294>)
 801a40a:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 801a40e:	f403 5340 	and.w	r3, r3, #12288	@ 0x3000
 801a412:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 801a416:	f43f af71 	beq.w	801a2fc <UART_SetConfig+0x10c>
 801a41a:	d806      	bhi.n	801a42a <UART_SetConfig+0x23a>
 801a41c:	2b00      	cmp	r3, #0
 801a41e:	d0bd      	beq.n	801a39c <UART_SetConfig+0x1ac>
 801a420:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 801a424:	f43f af7b 	beq.w	801a31e <UART_SetConfig+0x12e>
 801a428:	e71a      	b.n	801a260 <UART_SetConfig+0x70>
 801a42a:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 801a42e:	f43f af46 	beq.w	801a2be <UART_SetConfig+0xce>
 801a432:	e715      	b.n	801a260 <UART_SetConfig+0x70>
 801a434:	4b13      	ldr	r3, [pc, #76]	@ (801a484 <UART_SetConfig+0x294>)
 801a436:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 801a43a:	f403 4340 	and.w	r3, r3, #49152	@ 0xc000
 801a43e:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 801a442:	f43f af5b 	beq.w	801a2fc <UART_SetConfig+0x10c>
 801a446:	d806      	bhi.n	801a456 <UART_SetConfig+0x266>
 801a448:	2b00      	cmp	r3, #0
 801a44a:	d0a7      	beq.n	801a39c <UART_SetConfig+0x1ac>
 801a44c:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 801a450:	f43f af65 	beq.w	801a31e <UART_SetConfig+0x12e>
 801a454:	e704      	b.n	801a260 <UART_SetConfig+0x70>
 801a456:	f5b3 4f40 	cmp.w	r3, #49152	@ 0xc000
 801a45a:	f43f af30 	beq.w	801a2be <UART_SetConfig+0xce>
 801a45e:	e6ff      	b.n	801a260 <UART_SetConfig+0x70>
 801a460:	efff69f3 	.word	0xefff69f3
 801a464:	40011000 	.word	0x40011000
 801a468:	40004400 	.word	0x40004400
 801a46c:	40004800 	.word	0x40004800
 801a470:	40004c00 	.word	0x40004c00
 801a474:	40005000 	.word	0x40005000
 801a478:	40011400 	.word	0x40011400
 801a47c:	40007800 	.word	0x40007800
 801a480:	40007c00 	.word	0x40007c00
 801a484:	40023800 	.word	0x40023800
 801a488:	00f42400 	.word	0x00f42400
 801a48c:	01e84800 	.word	0x01e84800

0801a490 <UART_AdvFeatureConfig>:
{
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 801a490:	6a43      	ldr	r3, [r0, #36]	@ 0x24
 801a492:	071a      	lsls	r2, r3, #28
{
 801a494:	b410      	push	{r4}
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 801a496:	d506      	bpl.n	801a4a6 <UART_AdvFeatureConfig+0x16>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 801a498:	6801      	ldr	r1, [r0, #0]
 801a49a:	6b44      	ldr	r4, [r0, #52]	@ 0x34
 801a49c:	684a      	ldr	r2, [r1, #4]
 801a49e:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
 801a4a2:	4322      	orrs	r2, r4
 801a4a4:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 801a4a6:	07dc      	lsls	r4, r3, #31
 801a4a8:	d506      	bpl.n	801a4b8 <UART_AdvFeatureConfig+0x28>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 801a4aa:	6801      	ldr	r1, [r0, #0]
 801a4ac:	6a84      	ldr	r4, [r0, #40]	@ 0x28
 801a4ae:	684a      	ldr	r2, [r1, #4]
 801a4b0:	f422 3200 	bic.w	r2, r2, #131072	@ 0x20000
 801a4b4:	4322      	orrs	r2, r4
 801a4b6:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 801a4b8:	0799      	lsls	r1, r3, #30
 801a4ba:	d506      	bpl.n	801a4ca <UART_AdvFeatureConfig+0x3a>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 801a4bc:	6801      	ldr	r1, [r0, #0]
 801a4be:	6ac4      	ldr	r4, [r0, #44]	@ 0x2c
 801a4c0:	684a      	ldr	r2, [r1, #4]
 801a4c2:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
 801a4c6:	4322      	orrs	r2, r4
 801a4c8:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 801a4ca:	075a      	lsls	r2, r3, #29
 801a4cc:	d506      	bpl.n	801a4dc <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 801a4ce:	6801      	ldr	r1, [r0, #0]
 801a4d0:	6b04      	ldr	r4, [r0, #48]	@ 0x30
 801a4d2:	684a      	ldr	r2, [r1, #4]
 801a4d4:	f422 2280 	bic.w	r2, r2, #262144	@ 0x40000
 801a4d8:	4322      	orrs	r2, r4
 801a4da:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 801a4dc:	06dc      	lsls	r4, r3, #27
 801a4de:	d506      	bpl.n	801a4ee <UART_AdvFeatureConfig+0x5e>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 801a4e0:	6801      	ldr	r1, [r0, #0]
 801a4e2:	6b84      	ldr	r4, [r0, #56]	@ 0x38
 801a4e4:	688a      	ldr	r2, [r1, #8]
 801a4e6:	f422 5280 	bic.w	r2, r2, #4096	@ 0x1000
 801a4ea:	4322      	orrs	r2, r4
 801a4ec:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 801a4ee:	0699      	lsls	r1, r3, #26
 801a4f0:	d506      	bpl.n	801a500 <UART_AdvFeatureConfig+0x70>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 801a4f2:	6801      	ldr	r1, [r0, #0]
 801a4f4:	6bc4      	ldr	r4, [r0, #60]	@ 0x3c
 801a4f6:	688a      	ldr	r2, [r1, #8]
 801a4f8:	f422 5200 	bic.w	r2, r2, #8192	@ 0x2000
 801a4fc:	4322      	orrs	r2, r4
 801a4fe:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 801a500:	065a      	lsls	r2, r3, #25
 801a502:	d50a      	bpl.n	801a51a <UART_AdvFeatureConfig+0x8a>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 801a504:	6801      	ldr	r1, [r0, #0]
 801a506:	6c04      	ldr	r4, [r0, #64]	@ 0x40
 801a508:	684a      	ldr	r2, [r1, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 801a50a:	f5b4 1f80 	cmp.w	r4, #1048576	@ 0x100000
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 801a50e:	f422 1280 	bic.w	r2, r2, #1048576	@ 0x100000
 801a512:	ea42 0204 	orr.w	r2, r2, r4
 801a516:	604a      	str	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 801a518:	d00b      	beq.n	801a532 <UART_AdvFeatureConfig+0xa2>
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 801a51a:	061b      	lsls	r3, r3, #24
 801a51c:	d506      	bpl.n	801a52c <UART_AdvFeatureConfig+0x9c>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 801a51e:	6802      	ldr	r2, [r0, #0]
 801a520:	6c81      	ldr	r1, [r0, #72]	@ 0x48
 801a522:	6853      	ldr	r3, [r2, #4]
 801a524:	f423 2300 	bic.w	r3, r3, #524288	@ 0x80000
 801a528:	430b      	orrs	r3, r1
 801a52a:	6053      	str	r3, [r2, #4]
  }
}
 801a52c:	f85d 4b04 	ldr.w	r4, [sp], #4
 801a530:	4770      	bx	lr
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 801a532:	684a      	ldr	r2, [r1, #4]
 801a534:	6c44      	ldr	r4, [r0, #68]	@ 0x44
 801a536:	f422 02c0 	bic.w	r2, r2, #6291456	@ 0x600000
 801a53a:	4322      	orrs	r2, r4
 801a53c:	604a      	str	r2, [r1, #4]
 801a53e:	e7ec      	b.n	801a51a <UART_AdvFeatureConfig+0x8a>

0801a540 <UART_CheckIdleState>:
  * @brief Check the UART Idle State.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
 801a540:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart;

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 801a542:	2300      	movs	r3, #0
{
 801a544:	4604      	mov	r4, r0
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 801a546:	f8c0 3084 	str.w	r3, [r0, #132]	@ 0x84

  /* Init tickstart for timeout management */
  tickstart = HAL_GetTick();
 801a54a:	f7f8 fc8f 	bl	8012e6c <HAL_GetTick>

  /* Check if the Transmitter is enabled */
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 801a54e:	6823      	ldr	r3, [r4, #0]
 801a550:	681a      	ldr	r2, [r3, #0]
 801a552:	0712      	lsls	r2, r2, #28
 801a554:	d40b      	bmi.n	801a56e <UART_CheckIdleState+0x2e>
#endif /* USART_ISR_REACK */

  /* Initialize the UART State */
  huart->gState = HAL_UART_STATE_READY;
  huart->RxState = HAL_UART_STATE_READY;
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 801a556:	2300      	movs	r3, #0
  huart->gState = HAL_UART_STATE_READY;
 801a558:	2220      	movs	r2, #32
  huart->RxEventType = HAL_UART_RXEVENT_TC;

  __HAL_UNLOCK(huart);

  return HAL_OK;
 801a55a:	4618      	mov	r0, r3
  huart->gState = HAL_UART_STATE_READY;
 801a55c:	67e2      	str	r2, [r4, #124]	@ 0x7c
  huart->RxState = HAL_UART_STATE_READY;
 801a55e:	f8c4 2080 	str.w	r2, [r4, #128]	@ 0x80
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 801a562:	6623      	str	r3, [r4, #96]	@ 0x60
  huart->RxEventType = HAL_UART_RXEVENT_TC;
 801a564:	6663      	str	r3, [r4, #100]	@ 0x64
      __HAL_UNLOCK(huart);
 801a566:	2300      	movs	r3, #0
 801a568:	f884 3078 	strb.w	r3, [r4, #120]	@ 0x78
}
 801a56c:	bd38      	pop	{r3, r4, r5, pc}
 801a56e:	4605      	mov	r5, r0
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                              uint32_t Tickstart, uint32_t Timeout)
{
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 801a570:	69db      	ldr	r3, [r3, #28]
 801a572:	029b      	lsls	r3, r3, #10
 801a574:	d4ef      	bmi.n	801a556 <UART_CheckIdleState+0x16>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 801a576:	f7f8 fc79 	bl	8012e6c <HAL_GetTick>
 801a57a:	1b43      	subs	r3, r0, r5
 801a57c:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 801a580:	6823      	ldr	r3, [r4, #0]
 801a582:	d22c      	bcs.n	801a5de <UART_CheckIdleState+0x9e>
      {

        return HAL_TIMEOUT;
      }

      if ((READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U) && (Flag != UART_FLAG_TXE) && (Flag != UART_FLAG_TC))
 801a584:	681a      	ldr	r2, [r3, #0]
 801a586:	0750      	lsls	r0, r2, #29
 801a588:	d5f2      	bpl.n	801a570 <UART_CheckIdleState+0x30>
      {
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_ORE) == SET)
 801a58a:	69da      	ldr	r2, [r3, #28]
 801a58c:	0711      	lsls	r1, r2, #28
 801a58e:	d43b      	bmi.n	801a608 <UART_CheckIdleState+0xc8>
          /* Process Unlocked */
          __HAL_UNLOCK(huart);

          return HAL_ERROR;
        }
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 801a590:	69da      	ldr	r2, [r3, #28]
 801a592:	0512      	lsls	r2, r2, #20
 801a594:	d5ec      	bpl.n	801a570 <UART_CheckIdleState+0x30>
        {
          /* Clear Receiver Timeout flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 801a596:	f44f 6200 	mov.w	r2, #2048	@ 0x800
 801a59a:	621a      	str	r2, [r3, #32]
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 801a59c:	e853 2f00 	ldrex	r2, [r3]
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 801a5a0:	f422 7290 	bic.w	r2, r2, #288	@ 0x120
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801a5a4:	e843 2100 	strex	r1, r2, [r3]
 801a5a8:	2900      	cmp	r1, #0
 801a5aa:	d1f7      	bne.n	801a59c <UART_CheckIdleState+0x5c>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 801a5ac:	f103 0208 	add.w	r2, r3, #8
 801a5b0:	e852 2f00 	ldrex	r2, [r2]
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 801a5b4:	f022 0201 	bic.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801a5b8:	f103 0008 	add.w	r0, r3, #8
 801a5bc:	e840 2100 	strex	r1, r2, [r0]
 801a5c0:	2900      	cmp	r1, #0
 801a5c2:	d1f3      	bne.n	801a5ac <UART_CheckIdleState+0x6c>

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 801a5c4:	6e22      	ldr	r2, [r4, #96]	@ 0x60
 801a5c6:	2a01      	cmp	r2, #1
 801a5c8:	d015      	beq.n	801a5f6 <UART_CheckIdleState+0xb6>
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 801a5ca:	2200      	movs	r2, #0
  huart->RxState = HAL_UART_STATE_READY;
 801a5cc:	2120      	movs	r1, #32

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
 801a5ce:	66a2      	str	r2, [r4, #104]	@ 0x68
  huart->RxState = HAL_UART_STATE_READY;
 801a5d0:	f8c4 1080 	str.w	r1, [r4, #128]	@ 0x80
          __HAL_UNLOCK(huart);
 801a5d4:	f884 2078 	strb.w	r2, [r4, #120]	@ 0x78
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 801a5d8:	6622      	str	r2, [r4, #96]	@ 0x60
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 801a5da:	f8c4 1084 	str.w	r1, [r4, #132]	@ 0x84
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 801a5de:	e853 2f00 	ldrex	r2, [r3]
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE));
 801a5e2:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801a5e6:	e843 2100 	strex	r1, r2, [r3]
 801a5ea:	2900      	cmp	r1, #0
 801a5ec:	d1f7      	bne.n	801a5de <UART_CheckIdleState+0x9e>
      huart->gState = HAL_UART_STATE_READY;
 801a5ee:	2320      	movs	r3, #32
 801a5f0:	2003      	movs	r0, #3
 801a5f2:	67e3      	str	r3, [r4, #124]	@ 0x7c
      return HAL_TIMEOUT;
 801a5f4:	e7b7      	b.n	801a566 <UART_CheckIdleState+0x26>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 801a5f6:	e853 2f00 	ldrex	r2, [r3]
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 801a5fa:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801a5fe:	e843 2100 	strex	r1, r2, [r3]
 801a602:	2900      	cmp	r1, #0
 801a604:	d1f7      	bne.n	801a5f6 <UART_CheckIdleState+0xb6>
 801a606:	e7e0      	b.n	801a5ca <UART_CheckIdleState+0x8a>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
 801a608:	2208      	movs	r2, #8
 801a60a:	621a      	str	r2, [r3, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 801a60c:	e853 2f00 	ldrex	r2, [r3]
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 801a610:	f422 7290 	bic.w	r2, r2, #288	@ 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801a614:	e843 2100 	strex	r1, r2, [r3]
 801a618:	2900      	cmp	r1, #0
 801a61a:	d1f7      	bne.n	801a60c <UART_CheckIdleState+0xcc>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 801a61c:	f103 0208 	add.w	r2, r3, #8
 801a620:	e852 2f00 	ldrex	r2, [r2]
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 801a624:	f022 0201 	bic.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801a628:	f103 0008 	add.w	r0, r3, #8
 801a62c:	e840 2100 	strex	r1, r2, [r0]
 801a630:	2900      	cmp	r1, #0
 801a632:	d1f3      	bne.n	801a61c <UART_CheckIdleState+0xdc>
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 801a634:	6e22      	ldr	r2, [r4, #96]	@ 0x60
 801a636:	2a01      	cmp	r2, #1
 801a638:	d00b      	beq.n	801a652 <UART_CheckIdleState+0x112>
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 801a63a:	2200      	movs	r2, #0
  huart->RxState = HAL_UART_STATE_READY;
 801a63c:	2020      	movs	r0, #32
          huart->ErrorCode = HAL_UART_ERROR_ORE;
 801a63e:	2108      	movs	r1, #8
  huart->RxState = HAL_UART_STATE_READY;
 801a640:	f8c4 0080 	str.w	r0, [r4, #128]	@ 0x80
  huart->RxISR = NULL;
 801a644:	66a2      	str	r2, [r4, #104]	@ 0x68
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 801a646:	6622      	str	r2, [r4, #96]	@ 0x60
          __HAL_UNLOCK(huart);
 801a648:	f884 2078 	strb.w	r2, [r4, #120]	@ 0x78
          huart->ErrorCode = HAL_UART_ERROR_ORE;
 801a64c:	f8c4 1084 	str.w	r1, [r4, #132]	@ 0x84
          return HAL_ERROR;
 801a650:	e7c5      	b.n	801a5de <UART_CheckIdleState+0x9e>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 801a652:	e853 2f00 	ldrex	r2, [r3]
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 801a656:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801a65a:	e843 2100 	strex	r1, r2, [r3]
 801a65e:	2900      	cmp	r1, #0
 801a660:	d1f7      	bne.n	801a652 <UART_CheckIdleState+0x112>
 801a662:	e7ea      	b.n	801a63a <UART_CheckIdleState+0xfa>

0801a664 <HAL_UART_Init>:
  if (huart == NULL)
 801a664:	b370      	cbz	r0, 801a6c4 <HAL_UART_Init+0x60>
  if (huart->gState == HAL_UART_STATE_RESET)
 801a666:	6fc3      	ldr	r3, [r0, #124]	@ 0x7c
{
 801a668:	b510      	push	{r4, lr}
 801a66a:	4604      	mov	r4, r0
  if (huart->gState == HAL_UART_STATE_RESET)
 801a66c:	b32b      	cbz	r3, 801a6ba <HAL_UART_Init+0x56>
  __HAL_UART_DISABLE(huart);
 801a66e:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 801a670:	2324      	movs	r3, #36	@ 0x24
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 801a672:	6a61      	ldr	r1, [r4, #36]	@ 0x24
  huart->gState = HAL_UART_STATE_BUSY;
 801a674:	67e3      	str	r3, [r4, #124]	@ 0x7c
  __HAL_UART_DISABLE(huart);
 801a676:	6813      	ldr	r3, [r2, #0]
 801a678:	f023 0301 	bic.w	r3, r3, #1
 801a67c:	6013      	str	r3, [r2, #0]
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 801a67e:	b9c1      	cbnz	r1, 801a6b2 <HAL_UART_Init+0x4e>
  if (UART_SetConfig(huart) == HAL_ERROR)
 801a680:	4620      	mov	r0, r4
 801a682:	f7ff fdb5 	bl	801a1f0 <UART_SetConfig>
 801a686:	2801      	cmp	r0, #1
 801a688:	d011      	beq.n	801a6ae <HAL_UART_Init+0x4a>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 801a68a:	6823      	ldr	r3, [r4, #0]
  return (UART_CheckIdleState(huart));
 801a68c:	4620      	mov	r0, r4
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 801a68e:	685a      	ldr	r2, [r3, #4]
 801a690:	f422 4290 	bic.w	r2, r2, #18432	@ 0x4800
 801a694:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 801a696:	689a      	ldr	r2, [r3, #8]
 801a698:	f022 022a 	bic.w	r2, r2, #42	@ 0x2a
 801a69c:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
 801a69e:	681a      	ldr	r2, [r3, #0]
 801a6a0:	f042 0201 	orr.w	r2, r2, #1
}
 801a6a4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  __HAL_UART_ENABLE(huart);
 801a6a8:	601a      	str	r2, [r3, #0]
  return (UART_CheckIdleState(huart));
 801a6aa:	f7ff bf49 	b.w	801a540 <UART_CheckIdleState>
}
 801a6ae:	2001      	movs	r0, #1
 801a6b0:	bd10      	pop	{r4, pc}
    UART_AdvFeatureConfig(huart);
 801a6b2:	4620      	mov	r0, r4
 801a6b4:	f7ff feec 	bl	801a490 <UART_AdvFeatureConfig>
 801a6b8:	e7e2      	b.n	801a680 <HAL_UART_Init+0x1c>
    huart->Lock = HAL_UNLOCKED;
 801a6ba:	f880 3078 	strb.w	r3, [r0, #120]	@ 0x78
    HAL_UART_MspInit(huart);
 801a6be:	f7f8 f989 	bl	80129d4 <HAL_UART_MspInit>
 801a6c2:	e7d4      	b.n	801a66e <HAL_UART_Init+0xa>
}
 801a6c4:	2001      	movs	r0, #1
 801a6c6:	4770      	bx	lr

0801a6c8 <FMC_SDRAM_Init>:
  * @param  Device Pointer to SDRAM device instance
  * @param  Init Pointer to SDRAM Initialization structure
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_SDRAM_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_InitTypeDef *Init)
{
 801a6c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  assert_param(IS_FMC_READPIPE_DELAY(Init->ReadPipeDelay));

  /* Set SDRAM bank configuration parameters */
  if (Init->SDBank == FMC_SDRAM_BANK1)
  {
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK1],
 801a6cc:	e9d1 3e07 	ldrd	r3, lr, [r1, #28]
 801a6d0:	e9d1 8200 	ldrd	r8, r2, [r1]
 801a6d4:	6a4f      	ldr	r7, [r1, #36]	@ 0x24
 801a6d6:	ea43 030e 	orr.w	r3, r3, lr
 801a6da:	e9d1 c602 	ldrd	ip, r6, [r1, #8]
 801a6de:	e9d1 5404 	ldrd	r5, r4, [r1, #16]
 801a6e2:	6989      	ldr	r1, [r1, #24]
  if (Init->SDBank == FMC_SDRAM_BANK1)
 801a6e4:	f1b8 0f00 	cmp.w	r8, #0
 801a6e8:	d10f      	bne.n	801a70a <FMC_SDRAM_Init+0x42>
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK1],
 801a6ea:	433b      	orrs	r3, r7
 801a6ec:	4313      	orrs	r3, r2
 801a6ee:	4a11      	ldr	r2, [pc, #68]	@ (801a734 <FMC_SDRAM_Init+0x6c>)
 801a6f0:	ea43 030c 	orr.w	r3, r3, ip
 801a6f4:	4333      	orrs	r3, r6
 801a6f6:	432b      	orrs	r3, r5
 801a6f8:	4323      	orrs	r3, r4
 801a6fa:	430b      	orrs	r3, r1
 801a6fc:	6801      	ldr	r1, [r0, #0]
 801a6fe:	400a      	ands	r2, r1
 801a700:	4313      	orrs	r3, r2
 801a702:	6003      	str	r3, [r0, #0]
                Init->CASLatency         |
                Init->WriteProtection));
  }

  return HAL_OK;
}
 801a704:	2000      	movs	r0, #0
 801a706:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK2],
 801a70a:	ea42 020c 	orr.w	r2, r2, ip
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK1],
 801a70e:	433b      	orrs	r3, r7
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK2],
 801a710:	4332      	orrs	r2, r6
 801a712:	432a      	orrs	r2, r5
 801a714:	4322      	orrs	r2, r4
 801a716:	4c07      	ldr	r4, [pc, #28]	@ (801a734 <FMC_SDRAM_Init+0x6c>)
 801a718:	430a      	orrs	r2, r1
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK1],
 801a71a:	6801      	ldr	r1, [r0, #0]
 801a71c:	f421 41f8 	bic.w	r1, r1, #31744	@ 0x7c00
 801a720:	430b      	orrs	r3, r1
 801a722:	6003      	str	r3, [r0, #0]
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK2],
 801a724:	6843      	ldr	r3, [r0, #4]
 801a726:	401c      	ands	r4, r3
 801a728:	4322      	orrs	r2, r4
 801a72a:	6042      	str	r2, [r0, #4]
}
 801a72c:	2000      	movs	r0, #0
 801a72e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801a732:	bf00      	nop
 801a734:	ffff8000 	.word	0xffff8000

0801a738 <FMC_SDRAM_Timing_Init>:
  * @param  Bank SDRAM bank number
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_SDRAM_Timing_Init(FMC_SDRAM_TypeDef *Device,
                                        FMC_SDRAM_TimingTypeDef *Timing, uint32_t Bank)
{
 801a738:	b5f0      	push	{r4, r5, r6, r7, lr}
  assert_param(IS_FMC_SDRAM_BANK(Bank));

  /* Set SDRAM device timing parameters */
  if (Bank == FMC_SDRAM_BANK1)
  {
    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK1],
 801a73a:	68cc      	ldr	r4, [r1, #12]
 801a73c:	694b      	ldr	r3, [r1, #20]
 801a73e:	3c01      	subs	r4, #1
 801a740:	688d      	ldr	r5, [r1, #8]
 801a742:	698f      	ldr	r7, [r1, #24]
 801a744:	3b01      	subs	r3, #1
 801a746:	ea4f 3e04 	mov.w	lr, r4, lsl #12
 801a74a:	684c      	ldr	r4, [r1, #4]
 801a74c:	680e      	ldr	r6, [r1, #0]
 801a74e:	3d01      	subs	r5, #1
 801a750:	3c01      	subs	r4, #1
 801a752:	051b      	lsls	r3, r3, #20
 801a754:	022d      	lsls	r5, r5, #8
 801a756:	3e01      	subs	r6, #1
 801a758:	ea4f 1c04 	mov.w	ip, r4, lsl #4
 801a75c:	690c      	ldr	r4, [r1, #16]
 801a75e:	1e79      	subs	r1, r7, #1
 801a760:	3c01      	subs	r4, #1
 801a762:	0609      	lsls	r1, r1, #24
 801a764:	0424      	lsls	r4, r4, #16
  if (Bank == FMC_SDRAM_BANK1)
 801a766:	b972      	cbnz	r2, 801a786 <FMC_SDRAM_Timing_Init+0x4e>
    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK1],
 801a768:	ea4e 0303 	orr.w	r3, lr, r3
 801a76c:	6882      	ldr	r2, [r0, #8]
 801a76e:	4333      	orrs	r3, r6
 801a770:	f002 4270 	and.w	r2, r2, #4026531840	@ 0xf0000000
 801a774:	ea43 030c 	orr.w	r3, r3, ip
 801a778:	432b      	orrs	r3, r5
 801a77a:	4323      	orrs	r3, r4
 801a77c:	430b      	orrs	r3, r1
 801a77e:	4313      	orrs	r3, r2
 801a780:	6083      	str	r3, [r0, #8]
                (((Timing->WriteRecoveryTime) - 1U)    << FMC_SDTR1_TWR_Pos)  |
                (((Timing->RCDDelay) - 1U)             << FMC_SDTR1_TRCD_Pos)));
  }

  return HAL_OK;
}
 801a782:	2000      	movs	r0, #0
 801a784:	bdf0      	pop	{r4, r5, r6, r7, pc}
    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK1],
 801a786:	ea4e 0e03 	orr.w	lr, lr, r3
    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK2],
 801a78a:	ea4c 0305 	orr.w	r3, ip, r5
    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK1],
 801a78e:	4a08      	ldr	r2, [pc, #32]	@ (801a7b0 <FMC_SDRAM_Timing_Init+0x78>)
    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK2],
 801a790:	4333      	orrs	r3, r6
 801a792:	4323      	orrs	r3, r4
 801a794:	430b      	orrs	r3, r1
    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK1],
 801a796:	6881      	ldr	r1, [r0, #8]
 801a798:	400a      	ands	r2, r1
 801a79a:	ea42 020e 	orr.w	r2, r2, lr
 801a79e:	6082      	str	r2, [r0, #8]
    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK2],
 801a7a0:	68c2      	ldr	r2, [r0, #12]
 801a7a2:	f002 4270 	and.w	r2, r2, #4026531840	@ 0xf0000000
 801a7a6:	4313      	orrs	r3, r2
 801a7a8:	60c3      	str	r3, [r0, #12]
}
 801a7aa:	2000      	movs	r0, #0
 801a7ac:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801a7ae:	bf00      	nop
 801a7b0:	ff0f0fff 	.word	0xff0f0fff

0801a7b4 <FMC_SDRAM_SendCommand>:
  * @param  Timeout Timeout wait value
  * @retval HAL state
  */
HAL_StatusTypeDef FMC_SDRAM_SendCommand(FMC_SDRAM_TypeDef *Device,
                                        FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
{
 801a7b4:	b410      	push	{r4}
  assert_param(IS_FMC_COMMAND_TARGET(Command->CommandTarget));
  assert_param(IS_FMC_AUTOREFRESH_NUMBER(Command->AutoRefreshNumber));
  assert_param(IS_FMC_MODE_REGISTER(Command->ModeRegisterDefinition));

  /* Set command register */
  MODIFY_REG(Device->SDCMR, (FMC_SDCMR_MODE | FMC_SDCMR_CTB2 | FMC_SDCMR_CTB1 | FMC_SDCMR_NRFS | FMC_SDCMR_MRD),
 801a7b6:	e9d1 3400 	ldrd	r3, r4, [r1]
{
 801a7ba:	4602      	mov	r2, r0
  MODIFY_REG(Device->SDCMR, (FMC_SDCMR_MODE | FMC_SDCMR_CTB2 | FMC_SDCMR_CTB1 | FMC_SDCMR_NRFS | FMC_SDCMR_MRD),
 801a7bc:	6900      	ldr	r0, [r0, #16]
 801a7be:	4323      	orrs	r3, r4
 801a7c0:	e9d1 1402 	ldrd	r1, r4, [r1, #8]
 801a7c4:	ea43 2344 	orr.w	r3, r3, r4, lsl #9
 801a7c8:	4c05      	ldr	r4, [pc, #20]	@ (801a7e0 <FMC_SDRAM_SendCommand+0x2c>)
 801a7ca:	3901      	subs	r1, #1
 801a7cc:	4004      	ands	r4, r0
              (((Command->AutoRefreshNumber) - 1U) << FMC_SDCMR_NRFS_Pos) |
              ((Command->ModeRegisterDefinition) << FMC_SDCMR_MRD_Pos)));
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Timeout);
  return HAL_OK;
}
 801a7ce:	2000      	movs	r0, #0
  MODIFY_REG(Device->SDCMR, (FMC_SDCMR_MODE | FMC_SDCMR_CTB2 | FMC_SDCMR_CTB1 | FMC_SDCMR_NRFS | FMC_SDCMR_MRD),
 801a7d0:	4323      	orrs	r3, r4
}
 801a7d2:	f85d 4b04 	ldr.w	r4, [sp], #4
  MODIFY_REG(Device->SDCMR, (FMC_SDCMR_MODE | FMC_SDCMR_CTB2 | FMC_SDCMR_CTB1 | FMC_SDCMR_NRFS | FMC_SDCMR_MRD),
 801a7d6:	ea43 1341 	orr.w	r3, r3, r1, lsl #5
 801a7da:	6113      	str	r3, [r2, #16]
}
 801a7dc:	4770      	bx	lr
 801a7de:	bf00      	nop
 801a7e0:	ffc00000 	.word	0xffc00000

0801a7e4 <FMC_SDRAM_ProgramRefreshRate>:
  * @param  Device Pointer to SDRAM device instance
  * @param  RefreshRate The SDRAM refresh rate value.
  * @retval HAL state
  */
HAL_StatusTypeDef FMC_SDRAM_ProgramRefreshRate(FMC_SDRAM_TypeDef *Device, uint32_t RefreshRate)
{
 801a7e4:	4602      	mov	r2, r0
  /* Check the parameters */
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
  assert_param(IS_FMC_REFRESH_RATE(RefreshRate));

  /* Set the refresh rate in command register */
  MODIFY_REG(Device->SDRTR, FMC_SDRTR_COUNT, (RefreshRate << FMC_SDRTR_COUNT_Pos));
 801a7e6:	4b05      	ldr	r3, [pc, #20]	@ (801a7fc <FMC_SDRAM_ProgramRefreshRate+0x18>)

  return HAL_OK;
}
 801a7e8:	2000      	movs	r0, #0
{
 801a7ea:	b410      	push	{r4}
  MODIFY_REG(Device->SDRTR, FMC_SDRTR_COUNT, (RefreshRate << FMC_SDRTR_COUNT_Pos));
 801a7ec:	6954      	ldr	r4, [r2, #20]
 801a7ee:	4023      	ands	r3, r4
}
 801a7f0:	f85d 4b04 	ldr.w	r4, [sp], #4
  MODIFY_REG(Device->SDRTR, FMC_SDRTR_COUNT, (RefreshRate << FMC_SDRTR_COUNT_Pos));
 801a7f4:	ea43 0341 	orr.w	r3, r3, r1, lsl #1
 801a7f8:	6153      	str	r3, [r2, #20]
}
 801a7fa:	4770      	bx	lr
 801a7fc:	ffffc001 	.word	0xffffc001

0801a800 <SDMMC_Init>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @param  Init: SDMMC initialization structure   
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_Init(SDMMC_TypeDef *SDMMCx, SDMMC_InitTypeDef Init)
{
 801a800:	b084      	sub	sp, #16
 801a802:	b410      	push	{r4}
 801a804:	f10d 0c08 	add.w	ip, sp, #8
 801a808:	e88c 000e 	stmia.w	ip, {r1, r2, r3}
 801a80c:	4602      	mov	r2, r0
  assert_param(IS_SDMMC_BUS_WIDE(Init.BusWide));
  assert_param(IS_SDMMC_HARDWARE_FLOW_CONTROL(Init.HardwareFlowControl));
  assert_param(IS_SDMMC_CLKDIV(Init.ClockDiv));
  
  /* Set SDMMC configuration parameters */
  tmpreg |= (Init.ClockEdge           |\
 801a80e:	460b      	mov	r3, r1
 801a810:	9803      	ldr	r0, [sp, #12]
             Init.ClockBypass         |\
 801a812:	9904      	ldr	r1, [sp, #16]
  tmpreg |= (Init.ClockEdge           |\
 801a814:	4303      	orrs	r3, r0
             Init.HardwareFlowControl |\
             Init.ClockDiv
             ); 
  
  /* Write to SDMMC CLKCR */
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);  
 801a816:	6850      	ldr	r0, [r2, #4]
             Init.ClockBypass         |\
 801a818:	430b      	orrs	r3, r1
             Init.ClockPowerSave      |\
 801a81a:	e9dd 4105 	ldrd	r4, r1, [sp, #20]
 801a81e:	4323      	orrs	r3, r4
             Init.HardwareFlowControl |\
 801a820:	9c07      	ldr	r4, [sp, #28]
             Init.BusWide             |\
 801a822:	430b      	orrs	r3, r1
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);  
 801a824:	4904      	ldr	r1, [pc, #16]	@ (801a838 <SDMMC_Init+0x38>)
             Init.HardwareFlowControl |\
 801a826:	4323      	orrs	r3, r4
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);  
 801a828:	4001      	ands	r1, r0

  return HAL_OK;
}
 801a82a:	f85d 4b04 	ldr.w	r4, [sp], #4
 801a82e:	2000      	movs	r0, #0
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);  
 801a830:	430b      	orrs	r3, r1
}
 801a832:	b004      	add	sp, #16
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);  
 801a834:	6053      	str	r3, [r2, #4]
}
 801a836:	4770      	bx	lr
 801a838:	ffff8100 	.word	0xffff8100

0801a83c <SDMMC_ReadFIFO>:
  * @retval HAL status
  */
uint32_t SDMMC_ReadFIFO(SDMMC_TypeDef *SDMMCx)
{
  /* Read data from Rx FIFO */ 
  return (SDMMCx->FIFO);
 801a83c:	f8d0 0080 	ldr.w	r0, [r0, #128]	@ 0x80
}
 801a840:	4770      	bx	lr
 801a842:	bf00      	nop

0801a844 <SDMMC_PowerState_ON>:
  * @brief  Set SDMMC Power state to ON. 
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_PowerState_ON(SDMMC_TypeDef *SDMMCx)
{  
 801a844:	4603      	mov	r3, r0
  /* Set power state to ON */ 
  SDMMCx->POWER = SDMMC_POWER_PWRCTRL;
 801a846:	2203      	movs	r2, #3

  return HAL_OK;
}
 801a848:	2000      	movs	r0, #0
  SDMMCx->POWER = SDMMC_POWER_PWRCTRL;
 801a84a:	601a      	str	r2, [r3, #0]
}
 801a84c:	4770      	bx	lr
 801a84e:	bf00      	nop

0801a850 <SDMMC_GetPowerState>:
  *            - 0x02: Power UP
  *            - 0x03: Power ON 
  */
uint32_t SDMMC_GetPowerState(SDMMC_TypeDef *SDMMCx)  
{
  return (SDMMCx->POWER & SDMMC_POWER_PWRCTRL);
 801a850:	6800      	ldr	r0, [r0, #0]
}
 801a852:	f000 0003 	and.w	r0, r0, #3
 801a856:	4770      	bx	lr

0801a858 <SDMMC_GetResponse>:

  /* Check the parameters */
  assert_param(IS_SDMMC_RESP(Response));
  
  /* Get the response */
  tmp = (uint32_t)(&(SDMMCx->RESP1)) + Response;
 801a858:	3014      	adds	r0, #20
  
  return (*(__IO uint32_t *) tmp);
 801a85a:	5840      	ldr	r0, [r0, r1]
}  
 801a85c:	4770      	bx	lr
 801a85e:	bf00      	nop

0801a860 <SDMMC_ConfigData>:
  * @param  Data : pointer to a SDMMC_DataInitTypeDef structure 
  *         that contains the configuration information for the SDMMC data.
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_ConfigData(SDMMC_TypeDef *SDMMCx, SDMMC_DataInitTypeDef* Data)
{
 801a860:	b430      	push	{r4, r5}

  /* Set the SDMMC DataLength value */
  SDMMCx->DLEN = Data->DataLength;

  /* Set the SDMMC data configuration parameters */
  tmpreg |= (uint32_t)(Data->DataBlockSize |\
 801a862:	e9d1 3402 	ldrd	r3, r4, [r1, #8]
                       Data->TransferDir   |\
 801a866:	690d      	ldr	r5, [r1, #16]
{
 801a868:	4602      	mov	r2, r0
  tmpreg |= (uint32_t)(Data->DataBlockSize |\
 801a86a:	4323      	orrs	r3, r4
  SDMMCx->DTIMER = Data->DataTimeOut;
 801a86c:	6808      	ldr	r0, [r1, #0]
  SDMMCx->DLEN = Data->DataLength;
 801a86e:	684c      	ldr	r4, [r1, #4]
  SDMMCx->DTIMER = Data->DataTimeOut;
 801a870:	6250      	str	r0, [r2, #36]	@ 0x24
                       Data->TransferDir   |\
 801a872:	432b      	orrs	r3, r5
                       Data->TransferMode  |\
 801a874:	6948      	ldr	r0, [r1, #20]
  SDMMCx->DLEN = Data->DataLength;
 801a876:	6294      	str	r4, [r2, #40]	@ 0x28
                       Data->DPSM);
  
  /* Write to SDMMC DCTRL */
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 801a878:	6ad1      	ldr	r1, [r2, #44]	@ 0x2c
                       Data->TransferMode  |\
 801a87a:	4303      	orrs	r3, r0

  return HAL_OK;

}
 801a87c:	2000      	movs	r0, #0
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 801a87e:	f021 01f7 	bic.w	r1, r1, #247	@ 0xf7
 801a882:	430b      	orrs	r3, r1
}
 801a884:	bc30      	pop	{r4, r5}
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 801a886:	62d3      	str	r3, [r2, #44]	@ 0x2c
}
 801a888:	4770      	bx	lr
 801a88a:	bf00      	nop

0801a88c <SDMMC_CmdBlockLength>:
  uint32_t response_r1;
  uint32_t sta_reg;
  
  /* 8 is the number of required instructions cycles for the below loop statement.
  The Timeout is expressed in ms */
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801a88c:	4b50      	ldr	r3, [pc, #320]	@ (801a9d0 <SDMMC_CmdBlockLength+0x144>)
{
 801a88e:	4684      	mov	ip, r0
 801a890:	b410      	push	{r4}
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801a892:	681a      	ldr	r2, [r3, #0]
 801a894:	4c4f      	ldr	r4, [pc, #316]	@ (801a9d4 <SDMMC_CmdBlockLength+0x148>)
  SDMMCx->ARG = Command->Argument;
 801a896:	6081      	str	r1, [r0, #8]
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801a898:	f241 3188 	movw	r1, #5000	@ 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801a89c:	68c0      	ldr	r0, [r0, #12]
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801a89e:	fba4 4202 	umull	r4, r2, r4, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801a8a2:	4b4d      	ldr	r3, [pc, #308]	@ (801a9d8 <SDMMC_CmdBlockLength+0x14c>)
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801a8a4:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801a8a6:	4003      	ands	r3, r0
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801a8a8:	fb01 f202 	mul.w	r2, r1, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801a8ac:	f443 638a 	orr.w	r3, r3, #1104	@ 0x450
 801a8b0:	f8cc 300c 	str.w	r3, [ip, #12]
  
  do
  {
    if (count-- == 0U)
 801a8b4:	b152      	cbz	r2, 801a8cc <SDMMC_CmdBlockLength+0x40>
 801a8b6:	1e53      	subs	r3, r2, #1
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    sta_reg = SDMMCx->STA;
 801a8b8:	f8dc 2034 	ldr.w	r2, [ip, #52]	@ 0x34
    if (count-- == 0U)
 801a8bc:	3b01      	subs	r3, #1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 801a8be:	f012 0f45 	tst.w	r2, #69	@ 0x45
 801a8c2:	d001      	beq.n	801a8c8 <SDMMC_CmdBlockLength+0x3c>
 801a8c4:	0514      	lsls	r4, r2, #20
 801a8c6:	d506      	bpl.n	801a8d6 <SDMMC_CmdBlockLength+0x4a>
    if (count-- == 0U)
 801a8c8:	1c5a      	adds	r2, r3, #1
 801a8ca:	d1f5      	bne.n	801a8b8 <SDMMC_CmdBlockLength+0x2c>
      return SDMMC_ERROR_TIMEOUT;
 801a8cc:	f04f 4000 	mov.w	r0, #2147483648	@ 0x80000000
}
 801a8d0:	f85d 4b04 	ldr.w	r4, [sp], #4
 801a8d4:	4770      	bx	lr
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
    
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 801a8d6:	f8dc 3034 	ldr.w	r3, [ip, #52]	@ 0x34
 801a8da:	0758      	lsls	r0, r3, #29
 801a8dc:	d441      	bmi.n	801a962 <SDMMC_CmdBlockLength+0xd6>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
    
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
  }
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 801a8de:	f8dc 3034 	ldr.w	r3, [ip, #52]	@ 0x34
 801a8e2:	07d9      	lsls	r1, r3, #31
 801a8e4:	d409      	bmi.n	801a8fa <SDMMC_CmdBlockLength+0x6e>
  {
    /* Nothing to do */
  }
  
  /* Clear all the static flags */
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 801a8e6:	23c5      	movs	r3, #197	@ 0xc5
 801a8e8:	f8cc 3038 	str.w	r3, [ip, #56]	@ 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 801a8ec:	f8dc 3010 	ldr.w	r3, [ip, #16]
  
  /* Check response received is of desired command */
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 801a8f0:	b2db      	uxtb	r3, r3
 801a8f2:	2b10      	cmp	r3, #16
 801a8f4:	d005      	beq.n	801a902 <SDMMC_CmdBlockLength+0x76>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 801a8f6:	2001      	movs	r0, #1
 801a8f8:	e7ea      	b.n	801a8d0 <SDMMC_CmdBlockLength+0x44>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 801a8fa:	2301      	movs	r3, #1
 801a8fc:	f8cc 3038 	str.w	r3, [ip, #56]	@ 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 801a900:	e7f9      	b.n	801a8f6 <SDMMC_CmdBlockLength+0x6a>
  return (*(__IO uint32_t *) tmp);
 801a902:	f8dc 3014 	ldr.w	r3, [ip, #20]
  }
  
  /* We have received response, retrieve it for analysis  */
  response_r1 = SDMMC_GetResponse(SDMMCx, SDMMC_RESP1);
  
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 801a906:	4835      	ldr	r0, [pc, #212]	@ (801a9dc <SDMMC_CmdBlockLength+0x150>)
 801a908:	4018      	ands	r0, r3
 801a90a:	2800      	cmp	r0, #0
 801a90c:	d0e0      	beq.n	801a8d0 <SDMMC_CmdBlockLength+0x44>
  {
    return SDMMC_ERROR_NONE;
  }
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
 801a90e:	2b00      	cmp	r3, #0
 801a910:	db2c      	blt.n	801a96c <SDMMC_CmdBlockLength+0xe0>
  {
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
  }
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
 801a912:	005a      	lsls	r2, r3, #1
 801a914:	d42d      	bmi.n	801a972 <SDMMC_CmdBlockLength+0xe6>
  {
    return SDMMC_ERROR_ADDR_MISALIGNED;
  }
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
 801a916:	009c      	lsls	r4, r3, #2
 801a918:	d42d      	bmi.n	801a976 <SDMMC_CmdBlockLength+0xea>
  {
    return SDMMC_ERROR_BLOCK_LEN_ERR;
  }
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
 801a91a:	00d9      	lsls	r1, r3, #3
 801a91c:	d42d      	bmi.n	801a97a <SDMMC_CmdBlockLength+0xee>
  {
    return SDMMC_ERROR_ERASE_SEQ_ERR;
  }
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
 801a91e:	011a      	lsls	r2, r3, #4
 801a920:	d42e      	bmi.n	801a980 <SDMMC_CmdBlockLength+0xf4>
  {
    return SDMMC_ERROR_BAD_ERASE_PARAM;
  }
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
 801a922:	015c      	lsls	r4, r3, #5
 801a924:	d42f      	bmi.n	801a986 <SDMMC_CmdBlockLength+0xfa>
  {
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
  }
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
 801a926:	01d9      	lsls	r1, r3, #7
 801a928:	d430      	bmi.n	801a98c <SDMMC_CmdBlockLength+0x100>
  {
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
  }
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
 801a92a:	021a      	lsls	r2, r3, #8
 801a92c:	d431      	bmi.n	801a992 <SDMMC_CmdBlockLength+0x106>
  {
    return SDMMC_ERROR_COM_CRC_FAILED;
  }
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
 801a92e:	025c      	lsls	r4, r3, #9
 801a930:	d432      	bmi.n	801a998 <SDMMC_CmdBlockLength+0x10c>
  {
    return SDMMC_ERROR_ILLEGAL_CMD;
  }
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
 801a932:	0299      	lsls	r1, r3, #10
 801a934:	d43c      	bmi.n	801a9b0 <SDMMC_CmdBlockLength+0x124>
  {
    return SDMMC_ERROR_CARD_ECC_FAILED;
  }
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
 801a936:	02da      	lsls	r2, r3, #11
 801a938:	d437      	bmi.n	801a9aa <SDMMC_CmdBlockLength+0x11e>
  {
    return SDMMC_ERROR_CC_ERR;
  }
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
 801a93a:	035c      	lsls	r4, r3, #13
 801a93c:	d432      	bmi.n	801a9a4 <SDMMC_CmdBlockLength+0x118>
  {
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
  }
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
 801a93e:	0399      	lsls	r1, r3, #14
 801a940:	d42d      	bmi.n	801a99e <SDMMC_CmdBlockLength+0x112>
  {
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
  }
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
 801a942:	03da      	lsls	r2, r3, #15
 801a944:	d440      	bmi.n	801a9c8 <SDMMC_CmdBlockLength+0x13c>
  {
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
  }
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
 801a946:	041c      	lsls	r4, r3, #16
 801a948:	d43b      	bmi.n	801a9c2 <SDMMC_CmdBlockLength+0x136>
  {
    return SDMMC_ERROR_WP_ERASE_SKIP;
  }
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
 801a94a:	0459      	lsls	r1, r3, #17
 801a94c:	d436      	bmi.n	801a9bc <SDMMC_CmdBlockLength+0x130>
  {
    return SDMMC_ERROR_CARD_ECC_DISABLED;
  }
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
 801a94e:	049a      	lsls	r2, r3, #18
 801a950:	d431      	bmi.n	801a9b6 <SDMMC_CmdBlockLength+0x12a>
  {
    return SDMMC_ERROR_ERASE_RESET;
  }
  else if((response_r1 & SDMMC_OCR_AKE_SEQ_ERROR) == SDMMC_OCR_AKE_SEQ_ERROR)
  {
    return SDMMC_ERROR_AKE_SEQ_ERR;
 801a952:	f013 0f08 	tst.w	r3, #8
 801a956:	bf0c      	ite	eq
 801a958:	f44f 3080 	moveq.w	r0, #65536	@ 0x10000
 801a95c:	f44f 0000 	movne.w	r0, #8388608	@ 0x800000
 801a960:	e7b6      	b.n	801a8d0 <SDMMC_CmdBlockLength+0x44>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 801a962:	2304      	movs	r3, #4
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 801a964:	4618      	mov	r0, r3
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 801a966:	f8cc 3038 	str.w	r3, [ip, #56]	@ 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 801a96a:	e7b1      	b.n	801a8d0 <SDMMC_CmdBlockLength+0x44>
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
 801a96c:	f04f 7000 	mov.w	r0, #33554432	@ 0x2000000
 801a970:	e7ae      	b.n	801a8d0 <SDMMC_CmdBlockLength+0x44>
    return SDMMC_ERROR_ADDR_MISALIGNED;
 801a972:	2040      	movs	r0, #64	@ 0x40
 801a974:	e7ac      	b.n	801a8d0 <SDMMC_CmdBlockLength+0x44>
    return SDMMC_ERROR_BLOCK_LEN_ERR;
 801a976:	2080      	movs	r0, #128	@ 0x80
 801a978:	e7aa      	b.n	801a8d0 <SDMMC_CmdBlockLength+0x44>
    return SDMMC_ERROR_ERASE_SEQ_ERR;
 801a97a:	f44f 7080 	mov.w	r0, #256	@ 0x100
 801a97e:	e7a7      	b.n	801a8d0 <SDMMC_CmdBlockLength+0x44>
    return SDMMC_ERROR_BAD_ERASE_PARAM;
 801a980:	f44f 7000 	mov.w	r0, #512	@ 0x200
 801a984:	e7a4      	b.n	801a8d0 <SDMMC_CmdBlockLength+0x44>
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
 801a986:	f44f 6080 	mov.w	r0, #1024	@ 0x400
 801a98a:	e7a1      	b.n	801a8d0 <SDMMC_CmdBlockLength+0x44>
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
 801a98c:	f44f 6000 	mov.w	r0, #2048	@ 0x800
 801a990:	e79e      	b.n	801a8d0 <SDMMC_CmdBlockLength+0x44>
    return SDMMC_ERROR_COM_CRC_FAILED;
 801a992:	f44f 5080 	mov.w	r0, #4096	@ 0x1000
 801a996:	e79b      	b.n	801a8d0 <SDMMC_CmdBlockLength+0x44>
    return SDMMC_ERROR_ILLEGAL_CMD;
 801a998:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
 801a99c:	e798      	b.n	801a8d0 <SDMMC_CmdBlockLength+0x44>
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
 801a99e:	f44f 2080 	mov.w	r0, #262144	@ 0x40000
 801a9a2:	e795      	b.n	801a8d0 <SDMMC_CmdBlockLength+0x44>
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
 801a9a4:	f44f 3000 	mov.w	r0, #131072	@ 0x20000
 801a9a8:	e792      	b.n	801a8d0 <SDMMC_CmdBlockLength+0x44>
    return SDMMC_ERROR_CC_ERR;
 801a9aa:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
 801a9ae:	e78f      	b.n	801a8d0 <SDMMC_CmdBlockLength+0x44>
    return SDMMC_ERROR_CARD_ECC_FAILED;
 801a9b0:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
 801a9b4:	e78c      	b.n	801a8d0 <SDMMC_CmdBlockLength+0x44>
    return SDMMC_ERROR_ERASE_RESET;
 801a9b6:	f44f 0080 	mov.w	r0, #4194304	@ 0x400000
 801a9ba:	e789      	b.n	801a8d0 <SDMMC_CmdBlockLength+0x44>
    return SDMMC_ERROR_CARD_ECC_DISABLED;
 801a9bc:	f44f 1000 	mov.w	r0, #2097152	@ 0x200000
 801a9c0:	e786      	b.n	801a8d0 <SDMMC_CmdBlockLength+0x44>
    return SDMMC_ERROR_WP_ERASE_SKIP;
 801a9c2:	f44f 1080 	mov.w	r0, #1048576	@ 0x100000
 801a9c6:	e783      	b.n	801a8d0 <SDMMC_CmdBlockLength+0x44>
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
 801a9c8:	f44f 2000 	mov.w	r0, #524288	@ 0x80000
 801a9cc:	e780      	b.n	801a8d0 <SDMMC_CmdBlockLength+0x44>
 801a9ce:	bf00      	nop
 801a9d0:	2000000c 	.word	0x2000000c
 801a9d4:	10624dd3 	.word	0x10624dd3
 801a9d8:	fffff000 	.word	0xfffff000
 801a9dc:	fdffe008 	.word	0xfdffe008

0801a9e0 <SDMMC_CmdReadSingleBlock>:
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801a9e0:	4a4f      	ldr	r2, [pc, #316]	@ (801ab20 <SDMMC_CmdReadSingleBlock+0x140>)
{
 801a9e2:	4684      	mov	ip, r0
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801a9e4:	4b4f      	ldr	r3, [pc, #316]	@ (801ab24 <SDMMC_CmdReadSingleBlock+0x144>)
 801a9e6:	6812      	ldr	r2, [r2, #0]
  SDMMCx->ARG = Command->Argument;
 801a9e8:	f8cc 1008 	str.w	r1, [ip, #8]
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801a9ec:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801a9f0:	f8dc 100c 	ldr.w	r1, [ip, #12]
 801a9f4:	484c      	ldr	r0, [pc, #304]	@ (801ab28 <SDMMC_CmdReadSingleBlock+0x148>)
 801a9f6:	f240 4351 	movw	r3, #1105	@ 0x451
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801a9fa:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801a9fc:	4008      	ands	r0, r1
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801a9fe:	f241 3188 	movw	r1, #5000	@ 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801aa02:	4303      	orrs	r3, r0
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801aa04:	fb01 f202 	mul.w	r2, r1, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801aa08:	f8cc 300c 	str.w	r3, [ip, #12]
    if (count-- == 0U)
 801aa0c:	1e53      	subs	r3, r2, #1
 801aa0e:	b14a      	cbz	r2, 801aa24 <SDMMC_CmdReadSingleBlock+0x44>
    sta_reg = SDMMCx->STA;
 801aa10:	f8dc 2034 	ldr.w	r2, [ip, #52]	@ 0x34
    if (count-- == 0U)
 801aa14:	3b01      	subs	r3, #1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 801aa16:	f012 0f45 	tst.w	r2, #69	@ 0x45
 801aa1a:	d001      	beq.n	801aa20 <SDMMC_CmdReadSingleBlock+0x40>
 801aa1c:	0512      	lsls	r2, r2, #20
 801aa1e:	d504      	bpl.n	801aa2a <SDMMC_CmdReadSingleBlock+0x4a>
    if (count-- == 0U)
 801aa20:	1c59      	adds	r1, r3, #1
 801aa22:	d1f5      	bne.n	801aa10 <SDMMC_CmdReadSingleBlock+0x30>
      return SDMMC_ERROR_TIMEOUT;
 801aa24:	f04f 4000 	mov.w	r0, #2147483648	@ 0x80000000
 801aa28:	4770      	bx	lr
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 801aa2a:	f8dc 3034 	ldr.w	r3, [ip, #52]	@ 0x34
 801aa2e:	075b      	lsls	r3, r3, #29
 801aa30:	d443      	bmi.n	801aaba <SDMMC_CmdReadSingleBlock+0xda>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 801aa32:	f8dc 3034 	ldr.w	r3, [ip, #52]	@ 0x34
 801aa36:	07d8      	lsls	r0, r3, #31
 801aa38:	d409      	bmi.n	801aa4e <SDMMC_CmdReadSingleBlock+0x6e>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 801aa3a:	23c5      	movs	r3, #197	@ 0xc5
 801aa3c:	f8cc 3038 	str.w	r3, [ip, #56]	@ 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 801aa40:	f8dc 3010 	ldr.w	r3, [ip, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 801aa44:	b2db      	uxtb	r3, r3
 801aa46:	2b11      	cmp	r3, #17
 801aa48:	d005      	beq.n	801aa56 <SDMMC_CmdReadSingleBlock+0x76>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 801aa4a:	2001      	movs	r0, #1
 801aa4c:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 801aa4e:	2301      	movs	r3, #1
 801aa50:	f8cc 3038 	str.w	r3, [ip, #56]	@ 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 801aa54:	e7f9      	b.n	801aa4a <SDMMC_CmdReadSingleBlock+0x6a>
  return (*(__IO uint32_t *) tmp);
 801aa56:	f8dc 3014 	ldr.w	r3, [ip, #20]
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 801aa5a:	4834      	ldr	r0, [pc, #208]	@ (801ab2c <SDMMC_CmdReadSingleBlock+0x14c>)
 801aa5c:	4018      	ands	r0, r3
 801aa5e:	b358      	cbz	r0, 801aab8 <SDMMC_CmdReadSingleBlock+0xd8>
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
 801aa60:	2b00      	cmp	r3, #0
 801aa62:	db2f      	blt.n	801aac4 <SDMMC_CmdReadSingleBlock+0xe4>
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
 801aa64:	0059      	lsls	r1, r3, #1
 801aa66:	d430      	bmi.n	801aaca <SDMMC_CmdReadSingleBlock+0xea>
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
 801aa68:	009a      	lsls	r2, r3, #2
 801aa6a:	d430      	bmi.n	801aace <SDMMC_CmdReadSingleBlock+0xee>
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
 801aa6c:	00d9      	lsls	r1, r3, #3
 801aa6e:	d430      	bmi.n	801aad2 <SDMMC_CmdReadSingleBlock+0xf2>
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
 801aa70:	011a      	lsls	r2, r3, #4
 801aa72:	d431      	bmi.n	801aad8 <SDMMC_CmdReadSingleBlock+0xf8>
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
 801aa74:	0159      	lsls	r1, r3, #5
 801aa76:	d432      	bmi.n	801aade <SDMMC_CmdReadSingleBlock+0xfe>
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
 801aa78:	01da      	lsls	r2, r3, #7
 801aa7a:	d433      	bmi.n	801aae4 <SDMMC_CmdReadSingleBlock+0x104>
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
 801aa7c:	0219      	lsls	r1, r3, #8
 801aa7e:	d434      	bmi.n	801aaea <SDMMC_CmdReadSingleBlock+0x10a>
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
 801aa80:	025a      	lsls	r2, r3, #9
 801aa82:	d435      	bmi.n	801aaf0 <SDMMC_CmdReadSingleBlock+0x110>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
 801aa84:	0299      	lsls	r1, r3, #10
 801aa86:	d43f      	bmi.n	801ab08 <SDMMC_CmdReadSingleBlock+0x128>
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
 801aa88:	02da      	lsls	r2, r3, #11
 801aa8a:	d43a      	bmi.n	801ab02 <SDMMC_CmdReadSingleBlock+0x122>
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
 801aa8c:	0359      	lsls	r1, r3, #13
 801aa8e:	d435      	bmi.n	801aafc <SDMMC_CmdReadSingleBlock+0x11c>
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
 801aa90:	039a      	lsls	r2, r3, #14
 801aa92:	d430      	bmi.n	801aaf6 <SDMMC_CmdReadSingleBlock+0x116>
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
 801aa94:	03d9      	lsls	r1, r3, #15
 801aa96:	d440      	bmi.n	801ab1a <SDMMC_CmdReadSingleBlock+0x13a>
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
 801aa98:	041a      	lsls	r2, r3, #16
 801aa9a:	d43b      	bmi.n	801ab14 <SDMMC_CmdReadSingleBlock+0x134>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
 801aa9c:	0459      	lsls	r1, r3, #17
 801aa9e:	d436      	bmi.n	801ab0e <SDMMC_CmdReadSingleBlock+0x12e>
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
 801aaa0:	049a      	lsls	r2, r3, #18
 801aaa2:	d407      	bmi.n	801aab4 <SDMMC_CmdReadSingleBlock+0xd4>
    return SDMMC_ERROR_AKE_SEQ_ERR;
 801aaa4:	f013 0f08 	tst.w	r3, #8
 801aaa8:	bf0c      	ite	eq
 801aaaa:	f44f 3080 	moveq.w	r0, #65536	@ 0x10000
 801aaae:	f44f 0000 	movne.w	r0, #8388608	@ 0x800000
 801aab2:	4770      	bx	lr
    return SDMMC_ERROR_ERASE_RESET;
 801aab4:	f44f 0080 	mov.w	r0, #4194304	@ 0x400000
}
 801aab8:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 801aaba:	2304      	movs	r3, #4
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 801aabc:	4618      	mov	r0, r3
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 801aabe:	f8cc 3038 	str.w	r3, [ip, #56]	@ 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 801aac2:	4770      	bx	lr
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
 801aac4:	f04f 7000 	mov.w	r0, #33554432	@ 0x2000000
 801aac8:	4770      	bx	lr
    return SDMMC_ERROR_ADDR_MISALIGNED;
 801aaca:	2040      	movs	r0, #64	@ 0x40
 801aacc:	4770      	bx	lr
    return SDMMC_ERROR_BLOCK_LEN_ERR;
 801aace:	2080      	movs	r0, #128	@ 0x80
 801aad0:	4770      	bx	lr
    return SDMMC_ERROR_ERASE_SEQ_ERR;
 801aad2:	f44f 7080 	mov.w	r0, #256	@ 0x100
 801aad6:	4770      	bx	lr
    return SDMMC_ERROR_BAD_ERASE_PARAM;
 801aad8:	f44f 7000 	mov.w	r0, #512	@ 0x200
 801aadc:	4770      	bx	lr
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
 801aade:	f44f 6080 	mov.w	r0, #1024	@ 0x400
 801aae2:	4770      	bx	lr
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
 801aae4:	f44f 6000 	mov.w	r0, #2048	@ 0x800
 801aae8:	4770      	bx	lr
    return SDMMC_ERROR_COM_CRC_FAILED;
 801aaea:	f44f 5080 	mov.w	r0, #4096	@ 0x1000
 801aaee:	4770      	bx	lr
    return SDMMC_ERROR_ILLEGAL_CMD;
 801aaf0:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
 801aaf4:	4770      	bx	lr
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
 801aaf6:	f44f 2080 	mov.w	r0, #262144	@ 0x40000
 801aafa:	4770      	bx	lr
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
 801aafc:	f44f 3000 	mov.w	r0, #131072	@ 0x20000
 801ab00:	4770      	bx	lr
    return SDMMC_ERROR_CC_ERR;
 801ab02:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
 801ab06:	4770      	bx	lr
    return SDMMC_ERROR_CARD_ECC_FAILED;
 801ab08:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
 801ab0c:	4770      	bx	lr
    return SDMMC_ERROR_CARD_ECC_DISABLED;
 801ab0e:	f44f 1000 	mov.w	r0, #2097152	@ 0x200000
 801ab12:	4770      	bx	lr
    return SDMMC_ERROR_WP_ERASE_SKIP;
 801ab14:	f44f 1080 	mov.w	r0, #1048576	@ 0x100000
 801ab18:	4770      	bx	lr
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
 801ab1a:	f44f 2000 	mov.w	r0, #524288	@ 0x80000
 801ab1e:	4770      	bx	lr
 801ab20:	2000000c 	.word	0x2000000c
 801ab24:	10624dd3 	.word	0x10624dd3
 801ab28:	fffff000 	.word	0xfffff000
 801ab2c:	fdffe008 	.word	0xfdffe008

0801ab30 <SDMMC_CmdReadMultiBlock>:
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801ab30:	4a4f      	ldr	r2, [pc, #316]	@ (801ac70 <SDMMC_CmdReadMultiBlock+0x140>)
{
 801ab32:	4684      	mov	ip, r0
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801ab34:	4b4f      	ldr	r3, [pc, #316]	@ (801ac74 <SDMMC_CmdReadMultiBlock+0x144>)
 801ab36:	6812      	ldr	r2, [r2, #0]
  SDMMCx->ARG = Command->Argument;
 801ab38:	f8cc 1008 	str.w	r1, [ip, #8]
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801ab3c:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801ab40:	f8dc 100c 	ldr.w	r1, [ip, #12]
 801ab44:	484c      	ldr	r0, [pc, #304]	@ (801ac78 <SDMMC_CmdReadMultiBlock+0x148>)
 801ab46:	f240 4352 	movw	r3, #1106	@ 0x452
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801ab4a:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801ab4c:	4008      	ands	r0, r1
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801ab4e:	f241 3188 	movw	r1, #5000	@ 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801ab52:	4303      	orrs	r3, r0
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801ab54:	fb01 f202 	mul.w	r2, r1, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801ab58:	f8cc 300c 	str.w	r3, [ip, #12]
    if (count-- == 0U)
 801ab5c:	1e53      	subs	r3, r2, #1
 801ab5e:	b14a      	cbz	r2, 801ab74 <SDMMC_CmdReadMultiBlock+0x44>
    sta_reg = SDMMCx->STA;
 801ab60:	f8dc 2034 	ldr.w	r2, [ip, #52]	@ 0x34
    if (count-- == 0U)
 801ab64:	3b01      	subs	r3, #1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 801ab66:	f012 0f45 	tst.w	r2, #69	@ 0x45
 801ab6a:	d001      	beq.n	801ab70 <SDMMC_CmdReadMultiBlock+0x40>
 801ab6c:	0512      	lsls	r2, r2, #20
 801ab6e:	d504      	bpl.n	801ab7a <SDMMC_CmdReadMultiBlock+0x4a>
    if (count-- == 0U)
 801ab70:	1c59      	adds	r1, r3, #1
 801ab72:	d1f5      	bne.n	801ab60 <SDMMC_CmdReadMultiBlock+0x30>
      return SDMMC_ERROR_TIMEOUT;
 801ab74:	f04f 4000 	mov.w	r0, #2147483648	@ 0x80000000
 801ab78:	4770      	bx	lr
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 801ab7a:	f8dc 3034 	ldr.w	r3, [ip, #52]	@ 0x34
 801ab7e:	075b      	lsls	r3, r3, #29
 801ab80:	d443      	bmi.n	801ac0a <SDMMC_CmdReadMultiBlock+0xda>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 801ab82:	f8dc 3034 	ldr.w	r3, [ip, #52]	@ 0x34
 801ab86:	07d8      	lsls	r0, r3, #31
 801ab88:	d409      	bmi.n	801ab9e <SDMMC_CmdReadMultiBlock+0x6e>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 801ab8a:	23c5      	movs	r3, #197	@ 0xc5
 801ab8c:	f8cc 3038 	str.w	r3, [ip, #56]	@ 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 801ab90:	f8dc 3010 	ldr.w	r3, [ip, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 801ab94:	b2db      	uxtb	r3, r3
 801ab96:	2b12      	cmp	r3, #18
 801ab98:	d005      	beq.n	801aba6 <SDMMC_CmdReadMultiBlock+0x76>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 801ab9a:	2001      	movs	r0, #1
 801ab9c:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 801ab9e:	2301      	movs	r3, #1
 801aba0:	f8cc 3038 	str.w	r3, [ip, #56]	@ 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 801aba4:	e7f9      	b.n	801ab9a <SDMMC_CmdReadMultiBlock+0x6a>
  return (*(__IO uint32_t *) tmp);
 801aba6:	f8dc 3014 	ldr.w	r3, [ip, #20]
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 801abaa:	4834      	ldr	r0, [pc, #208]	@ (801ac7c <SDMMC_CmdReadMultiBlock+0x14c>)
 801abac:	4018      	ands	r0, r3
 801abae:	b358      	cbz	r0, 801ac08 <SDMMC_CmdReadMultiBlock+0xd8>
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
 801abb0:	2b00      	cmp	r3, #0
 801abb2:	db2f      	blt.n	801ac14 <SDMMC_CmdReadMultiBlock+0xe4>
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
 801abb4:	0059      	lsls	r1, r3, #1
 801abb6:	d430      	bmi.n	801ac1a <SDMMC_CmdReadMultiBlock+0xea>
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
 801abb8:	009a      	lsls	r2, r3, #2
 801abba:	d430      	bmi.n	801ac1e <SDMMC_CmdReadMultiBlock+0xee>
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
 801abbc:	00d9      	lsls	r1, r3, #3
 801abbe:	d430      	bmi.n	801ac22 <SDMMC_CmdReadMultiBlock+0xf2>
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
 801abc0:	011a      	lsls	r2, r3, #4
 801abc2:	d431      	bmi.n	801ac28 <SDMMC_CmdReadMultiBlock+0xf8>
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
 801abc4:	0159      	lsls	r1, r3, #5
 801abc6:	d432      	bmi.n	801ac2e <SDMMC_CmdReadMultiBlock+0xfe>
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
 801abc8:	01da      	lsls	r2, r3, #7
 801abca:	d433      	bmi.n	801ac34 <SDMMC_CmdReadMultiBlock+0x104>
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
 801abcc:	0219      	lsls	r1, r3, #8
 801abce:	d434      	bmi.n	801ac3a <SDMMC_CmdReadMultiBlock+0x10a>
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
 801abd0:	025a      	lsls	r2, r3, #9
 801abd2:	d435      	bmi.n	801ac40 <SDMMC_CmdReadMultiBlock+0x110>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
 801abd4:	0299      	lsls	r1, r3, #10
 801abd6:	d43f      	bmi.n	801ac58 <SDMMC_CmdReadMultiBlock+0x128>
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
 801abd8:	02da      	lsls	r2, r3, #11
 801abda:	d43a      	bmi.n	801ac52 <SDMMC_CmdReadMultiBlock+0x122>
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
 801abdc:	0359      	lsls	r1, r3, #13
 801abde:	d435      	bmi.n	801ac4c <SDMMC_CmdReadMultiBlock+0x11c>
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
 801abe0:	039a      	lsls	r2, r3, #14
 801abe2:	d430      	bmi.n	801ac46 <SDMMC_CmdReadMultiBlock+0x116>
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
 801abe4:	03d9      	lsls	r1, r3, #15
 801abe6:	d440      	bmi.n	801ac6a <SDMMC_CmdReadMultiBlock+0x13a>
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
 801abe8:	041a      	lsls	r2, r3, #16
 801abea:	d43b      	bmi.n	801ac64 <SDMMC_CmdReadMultiBlock+0x134>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
 801abec:	0459      	lsls	r1, r3, #17
 801abee:	d436      	bmi.n	801ac5e <SDMMC_CmdReadMultiBlock+0x12e>
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
 801abf0:	049a      	lsls	r2, r3, #18
 801abf2:	d407      	bmi.n	801ac04 <SDMMC_CmdReadMultiBlock+0xd4>
    return SDMMC_ERROR_AKE_SEQ_ERR;
 801abf4:	f013 0f08 	tst.w	r3, #8
 801abf8:	bf0c      	ite	eq
 801abfa:	f44f 3080 	moveq.w	r0, #65536	@ 0x10000
 801abfe:	f44f 0000 	movne.w	r0, #8388608	@ 0x800000
 801ac02:	4770      	bx	lr
    return SDMMC_ERROR_ERASE_RESET;
 801ac04:	f44f 0080 	mov.w	r0, #4194304	@ 0x400000
}
 801ac08:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 801ac0a:	2304      	movs	r3, #4
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 801ac0c:	4618      	mov	r0, r3
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 801ac0e:	f8cc 3038 	str.w	r3, [ip, #56]	@ 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 801ac12:	4770      	bx	lr
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
 801ac14:	f04f 7000 	mov.w	r0, #33554432	@ 0x2000000
 801ac18:	4770      	bx	lr
    return SDMMC_ERROR_ADDR_MISALIGNED;
 801ac1a:	2040      	movs	r0, #64	@ 0x40
 801ac1c:	4770      	bx	lr
    return SDMMC_ERROR_BLOCK_LEN_ERR;
 801ac1e:	2080      	movs	r0, #128	@ 0x80
 801ac20:	4770      	bx	lr
    return SDMMC_ERROR_ERASE_SEQ_ERR;
 801ac22:	f44f 7080 	mov.w	r0, #256	@ 0x100
 801ac26:	4770      	bx	lr
    return SDMMC_ERROR_BAD_ERASE_PARAM;
 801ac28:	f44f 7000 	mov.w	r0, #512	@ 0x200
 801ac2c:	4770      	bx	lr
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
 801ac2e:	f44f 6080 	mov.w	r0, #1024	@ 0x400
 801ac32:	4770      	bx	lr
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
 801ac34:	f44f 6000 	mov.w	r0, #2048	@ 0x800
 801ac38:	4770      	bx	lr
    return SDMMC_ERROR_COM_CRC_FAILED;
 801ac3a:	f44f 5080 	mov.w	r0, #4096	@ 0x1000
 801ac3e:	4770      	bx	lr
    return SDMMC_ERROR_ILLEGAL_CMD;
 801ac40:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
 801ac44:	4770      	bx	lr
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
 801ac46:	f44f 2080 	mov.w	r0, #262144	@ 0x40000
 801ac4a:	4770      	bx	lr
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
 801ac4c:	f44f 3000 	mov.w	r0, #131072	@ 0x20000
 801ac50:	4770      	bx	lr
    return SDMMC_ERROR_CC_ERR;
 801ac52:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
 801ac56:	4770      	bx	lr
    return SDMMC_ERROR_CARD_ECC_FAILED;
 801ac58:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
 801ac5c:	4770      	bx	lr
    return SDMMC_ERROR_CARD_ECC_DISABLED;
 801ac5e:	f44f 1000 	mov.w	r0, #2097152	@ 0x200000
 801ac62:	4770      	bx	lr
    return SDMMC_ERROR_WP_ERASE_SKIP;
 801ac64:	f44f 1080 	mov.w	r0, #1048576	@ 0x100000
 801ac68:	4770      	bx	lr
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
 801ac6a:	f44f 2000 	mov.w	r0, #524288	@ 0x80000
 801ac6e:	4770      	bx	lr
 801ac70:	2000000c 	.word	0x2000000c
 801ac74:	10624dd3 	.word	0x10624dd3
 801ac78:	fffff000 	.word	0xfffff000
 801ac7c:	fdffe008 	.word	0xfdffe008

0801ac80 <SDMMC_CmdWriteSingleBlock>:
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801ac80:	4b50      	ldr	r3, [pc, #320]	@ (801adc4 <SDMMC_CmdWriteSingleBlock+0x144>)
{
 801ac82:	4684      	mov	ip, r0
 801ac84:	b410      	push	{r4}
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801ac86:	681a      	ldr	r2, [r3, #0]
 801ac88:	4c4f      	ldr	r4, [pc, #316]	@ (801adc8 <SDMMC_CmdWriteSingleBlock+0x148>)
  SDMMCx->ARG = Command->Argument;
 801ac8a:	6081      	str	r1, [r0, #8]
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801ac8c:	f241 3188 	movw	r1, #5000	@ 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801ac90:	68c0      	ldr	r0, [r0, #12]
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801ac92:	fba4 4202 	umull	r4, r2, r4, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801ac96:	4b4d      	ldr	r3, [pc, #308]	@ (801adcc <SDMMC_CmdWriteSingleBlock+0x14c>)
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801ac98:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801ac9a:	4003      	ands	r3, r0
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801ac9c:	fb01 f202 	mul.w	r2, r1, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801aca0:	f443 638b 	orr.w	r3, r3, #1112	@ 0x458
 801aca4:	f8cc 300c 	str.w	r3, [ip, #12]
    if (count-- == 0U)
 801aca8:	b152      	cbz	r2, 801acc0 <SDMMC_CmdWriteSingleBlock+0x40>
 801acaa:	1e53      	subs	r3, r2, #1
    sta_reg = SDMMCx->STA;
 801acac:	f8dc 2034 	ldr.w	r2, [ip, #52]	@ 0x34
    if (count-- == 0U)
 801acb0:	3b01      	subs	r3, #1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 801acb2:	f012 0f45 	tst.w	r2, #69	@ 0x45
 801acb6:	d001      	beq.n	801acbc <SDMMC_CmdWriteSingleBlock+0x3c>
 801acb8:	0514      	lsls	r4, r2, #20
 801acba:	d506      	bpl.n	801acca <SDMMC_CmdWriteSingleBlock+0x4a>
    if (count-- == 0U)
 801acbc:	1c5a      	adds	r2, r3, #1
 801acbe:	d1f5      	bne.n	801acac <SDMMC_CmdWriteSingleBlock+0x2c>
      return SDMMC_ERROR_TIMEOUT;
 801acc0:	f04f 4000 	mov.w	r0, #2147483648	@ 0x80000000
}
 801acc4:	f85d 4b04 	ldr.w	r4, [sp], #4
 801acc8:	4770      	bx	lr
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 801acca:	f8dc 3034 	ldr.w	r3, [ip, #52]	@ 0x34
 801acce:	0758      	lsls	r0, r3, #29
 801acd0:	d441      	bmi.n	801ad56 <SDMMC_CmdWriteSingleBlock+0xd6>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 801acd2:	f8dc 3034 	ldr.w	r3, [ip, #52]	@ 0x34
 801acd6:	07d9      	lsls	r1, r3, #31
 801acd8:	d409      	bmi.n	801acee <SDMMC_CmdWriteSingleBlock+0x6e>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 801acda:	23c5      	movs	r3, #197	@ 0xc5
 801acdc:	f8cc 3038 	str.w	r3, [ip, #56]	@ 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 801ace0:	f8dc 3010 	ldr.w	r3, [ip, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 801ace4:	b2db      	uxtb	r3, r3
 801ace6:	2b18      	cmp	r3, #24
 801ace8:	d005      	beq.n	801acf6 <SDMMC_CmdWriteSingleBlock+0x76>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 801acea:	2001      	movs	r0, #1
 801acec:	e7ea      	b.n	801acc4 <SDMMC_CmdWriteSingleBlock+0x44>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 801acee:	2301      	movs	r3, #1
 801acf0:	f8cc 3038 	str.w	r3, [ip, #56]	@ 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 801acf4:	e7f9      	b.n	801acea <SDMMC_CmdWriteSingleBlock+0x6a>
  return (*(__IO uint32_t *) tmp);
 801acf6:	f8dc 3014 	ldr.w	r3, [ip, #20]
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 801acfa:	4835      	ldr	r0, [pc, #212]	@ (801add0 <SDMMC_CmdWriteSingleBlock+0x150>)
 801acfc:	4018      	ands	r0, r3
 801acfe:	2800      	cmp	r0, #0
 801ad00:	d0e0      	beq.n	801acc4 <SDMMC_CmdWriteSingleBlock+0x44>
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
 801ad02:	2b00      	cmp	r3, #0
 801ad04:	db2c      	blt.n	801ad60 <SDMMC_CmdWriteSingleBlock+0xe0>
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
 801ad06:	005a      	lsls	r2, r3, #1
 801ad08:	d42d      	bmi.n	801ad66 <SDMMC_CmdWriteSingleBlock+0xe6>
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
 801ad0a:	009c      	lsls	r4, r3, #2
 801ad0c:	d42d      	bmi.n	801ad6a <SDMMC_CmdWriteSingleBlock+0xea>
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
 801ad0e:	00d9      	lsls	r1, r3, #3
 801ad10:	d42d      	bmi.n	801ad6e <SDMMC_CmdWriteSingleBlock+0xee>
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
 801ad12:	011a      	lsls	r2, r3, #4
 801ad14:	d42e      	bmi.n	801ad74 <SDMMC_CmdWriteSingleBlock+0xf4>
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
 801ad16:	015c      	lsls	r4, r3, #5
 801ad18:	d42f      	bmi.n	801ad7a <SDMMC_CmdWriteSingleBlock+0xfa>
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
 801ad1a:	01d9      	lsls	r1, r3, #7
 801ad1c:	d430      	bmi.n	801ad80 <SDMMC_CmdWriteSingleBlock+0x100>
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
 801ad1e:	021a      	lsls	r2, r3, #8
 801ad20:	d431      	bmi.n	801ad86 <SDMMC_CmdWriteSingleBlock+0x106>
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
 801ad22:	025c      	lsls	r4, r3, #9
 801ad24:	d432      	bmi.n	801ad8c <SDMMC_CmdWriteSingleBlock+0x10c>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
 801ad26:	0299      	lsls	r1, r3, #10
 801ad28:	d43c      	bmi.n	801ada4 <SDMMC_CmdWriteSingleBlock+0x124>
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
 801ad2a:	02da      	lsls	r2, r3, #11
 801ad2c:	d437      	bmi.n	801ad9e <SDMMC_CmdWriteSingleBlock+0x11e>
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
 801ad2e:	035c      	lsls	r4, r3, #13
 801ad30:	d432      	bmi.n	801ad98 <SDMMC_CmdWriteSingleBlock+0x118>
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
 801ad32:	0399      	lsls	r1, r3, #14
 801ad34:	d42d      	bmi.n	801ad92 <SDMMC_CmdWriteSingleBlock+0x112>
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
 801ad36:	03da      	lsls	r2, r3, #15
 801ad38:	d440      	bmi.n	801adbc <SDMMC_CmdWriteSingleBlock+0x13c>
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
 801ad3a:	041c      	lsls	r4, r3, #16
 801ad3c:	d43b      	bmi.n	801adb6 <SDMMC_CmdWriteSingleBlock+0x136>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
 801ad3e:	0459      	lsls	r1, r3, #17
 801ad40:	d436      	bmi.n	801adb0 <SDMMC_CmdWriteSingleBlock+0x130>
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
 801ad42:	049a      	lsls	r2, r3, #18
 801ad44:	d431      	bmi.n	801adaa <SDMMC_CmdWriteSingleBlock+0x12a>
    return SDMMC_ERROR_AKE_SEQ_ERR;
 801ad46:	f013 0f08 	tst.w	r3, #8
 801ad4a:	bf0c      	ite	eq
 801ad4c:	f44f 3080 	moveq.w	r0, #65536	@ 0x10000
 801ad50:	f44f 0000 	movne.w	r0, #8388608	@ 0x800000
 801ad54:	e7b6      	b.n	801acc4 <SDMMC_CmdWriteSingleBlock+0x44>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 801ad56:	2304      	movs	r3, #4
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 801ad58:	4618      	mov	r0, r3
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 801ad5a:	f8cc 3038 	str.w	r3, [ip, #56]	@ 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 801ad5e:	e7b1      	b.n	801acc4 <SDMMC_CmdWriteSingleBlock+0x44>
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
 801ad60:	f04f 7000 	mov.w	r0, #33554432	@ 0x2000000
 801ad64:	e7ae      	b.n	801acc4 <SDMMC_CmdWriteSingleBlock+0x44>
    return SDMMC_ERROR_ADDR_MISALIGNED;
 801ad66:	2040      	movs	r0, #64	@ 0x40
 801ad68:	e7ac      	b.n	801acc4 <SDMMC_CmdWriteSingleBlock+0x44>
    return SDMMC_ERROR_BLOCK_LEN_ERR;
 801ad6a:	2080      	movs	r0, #128	@ 0x80
 801ad6c:	e7aa      	b.n	801acc4 <SDMMC_CmdWriteSingleBlock+0x44>
    return SDMMC_ERROR_ERASE_SEQ_ERR;
 801ad6e:	f44f 7080 	mov.w	r0, #256	@ 0x100
 801ad72:	e7a7      	b.n	801acc4 <SDMMC_CmdWriteSingleBlock+0x44>
    return SDMMC_ERROR_BAD_ERASE_PARAM;
 801ad74:	f44f 7000 	mov.w	r0, #512	@ 0x200
 801ad78:	e7a4      	b.n	801acc4 <SDMMC_CmdWriteSingleBlock+0x44>
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
 801ad7a:	f44f 6080 	mov.w	r0, #1024	@ 0x400
 801ad7e:	e7a1      	b.n	801acc4 <SDMMC_CmdWriteSingleBlock+0x44>
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
 801ad80:	f44f 6000 	mov.w	r0, #2048	@ 0x800
 801ad84:	e79e      	b.n	801acc4 <SDMMC_CmdWriteSingleBlock+0x44>
    return SDMMC_ERROR_COM_CRC_FAILED;
 801ad86:	f44f 5080 	mov.w	r0, #4096	@ 0x1000
 801ad8a:	e79b      	b.n	801acc4 <SDMMC_CmdWriteSingleBlock+0x44>
    return SDMMC_ERROR_ILLEGAL_CMD;
 801ad8c:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
 801ad90:	e798      	b.n	801acc4 <SDMMC_CmdWriteSingleBlock+0x44>
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
 801ad92:	f44f 2080 	mov.w	r0, #262144	@ 0x40000
 801ad96:	e795      	b.n	801acc4 <SDMMC_CmdWriteSingleBlock+0x44>
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
 801ad98:	f44f 3000 	mov.w	r0, #131072	@ 0x20000
 801ad9c:	e792      	b.n	801acc4 <SDMMC_CmdWriteSingleBlock+0x44>
    return SDMMC_ERROR_CC_ERR;
 801ad9e:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
 801ada2:	e78f      	b.n	801acc4 <SDMMC_CmdWriteSingleBlock+0x44>
    return SDMMC_ERROR_CARD_ECC_FAILED;
 801ada4:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
 801ada8:	e78c      	b.n	801acc4 <SDMMC_CmdWriteSingleBlock+0x44>
    return SDMMC_ERROR_ERASE_RESET;
 801adaa:	f44f 0080 	mov.w	r0, #4194304	@ 0x400000
 801adae:	e789      	b.n	801acc4 <SDMMC_CmdWriteSingleBlock+0x44>
    return SDMMC_ERROR_CARD_ECC_DISABLED;
 801adb0:	f44f 1000 	mov.w	r0, #2097152	@ 0x200000
 801adb4:	e786      	b.n	801acc4 <SDMMC_CmdWriteSingleBlock+0x44>
    return SDMMC_ERROR_WP_ERASE_SKIP;
 801adb6:	f44f 1080 	mov.w	r0, #1048576	@ 0x100000
 801adba:	e783      	b.n	801acc4 <SDMMC_CmdWriteSingleBlock+0x44>
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
 801adbc:	f44f 2000 	mov.w	r0, #524288	@ 0x80000
 801adc0:	e780      	b.n	801acc4 <SDMMC_CmdWriteSingleBlock+0x44>
 801adc2:	bf00      	nop
 801adc4:	2000000c 	.word	0x2000000c
 801adc8:	10624dd3 	.word	0x10624dd3
 801adcc:	fffff000 	.word	0xfffff000
 801add0:	fdffe008 	.word	0xfdffe008

0801add4 <SDMMC_CmdWriteMultiBlock>:
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801add4:	4a4f      	ldr	r2, [pc, #316]	@ (801af14 <SDMMC_CmdWriteMultiBlock+0x140>)
{
 801add6:	4684      	mov	ip, r0
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801add8:	4b4f      	ldr	r3, [pc, #316]	@ (801af18 <SDMMC_CmdWriteMultiBlock+0x144>)
 801adda:	6812      	ldr	r2, [r2, #0]
  SDMMCx->ARG = Command->Argument;
 801addc:	f8cc 1008 	str.w	r1, [ip, #8]
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801ade0:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801ade4:	f8dc 100c 	ldr.w	r1, [ip, #12]
 801ade8:	484c      	ldr	r0, [pc, #304]	@ (801af1c <SDMMC_CmdWriteMultiBlock+0x148>)
 801adea:	f240 4359 	movw	r3, #1113	@ 0x459
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801adee:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801adf0:	4008      	ands	r0, r1
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801adf2:	f241 3188 	movw	r1, #5000	@ 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801adf6:	4303      	orrs	r3, r0
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801adf8:	fb01 f202 	mul.w	r2, r1, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801adfc:	f8cc 300c 	str.w	r3, [ip, #12]
    if (count-- == 0U)
 801ae00:	1e53      	subs	r3, r2, #1
 801ae02:	b14a      	cbz	r2, 801ae18 <SDMMC_CmdWriteMultiBlock+0x44>
    sta_reg = SDMMCx->STA;
 801ae04:	f8dc 2034 	ldr.w	r2, [ip, #52]	@ 0x34
    if (count-- == 0U)
 801ae08:	3b01      	subs	r3, #1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 801ae0a:	f012 0f45 	tst.w	r2, #69	@ 0x45
 801ae0e:	d001      	beq.n	801ae14 <SDMMC_CmdWriteMultiBlock+0x40>
 801ae10:	0512      	lsls	r2, r2, #20
 801ae12:	d504      	bpl.n	801ae1e <SDMMC_CmdWriteMultiBlock+0x4a>
    if (count-- == 0U)
 801ae14:	1c59      	adds	r1, r3, #1
 801ae16:	d1f5      	bne.n	801ae04 <SDMMC_CmdWriteMultiBlock+0x30>
      return SDMMC_ERROR_TIMEOUT;
 801ae18:	f04f 4000 	mov.w	r0, #2147483648	@ 0x80000000
 801ae1c:	4770      	bx	lr
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 801ae1e:	f8dc 3034 	ldr.w	r3, [ip, #52]	@ 0x34
 801ae22:	075b      	lsls	r3, r3, #29
 801ae24:	d443      	bmi.n	801aeae <SDMMC_CmdWriteMultiBlock+0xda>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 801ae26:	f8dc 3034 	ldr.w	r3, [ip, #52]	@ 0x34
 801ae2a:	07d8      	lsls	r0, r3, #31
 801ae2c:	d409      	bmi.n	801ae42 <SDMMC_CmdWriteMultiBlock+0x6e>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 801ae2e:	23c5      	movs	r3, #197	@ 0xc5
 801ae30:	f8cc 3038 	str.w	r3, [ip, #56]	@ 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 801ae34:	f8dc 3010 	ldr.w	r3, [ip, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 801ae38:	b2db      	uxtb	r3, r3
 801ae3a:	2b19      	cmp	r3, #25
 801ae3c:	d005      	beq.n	801ae4a <SDMMC_CmdWriteMultiBlock+0x76>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 801ae3e:	2001      	movs	r0, #1
 801ae40:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 801ae42:	2301      	movs	r3, #1
 801ae44:	f8cc 3038 	str.w	r3, [ip, #56]	@ 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 801ae48:	e7f9      	b.n	801ae3e <SDMMC_CmdWriteMultiBlock+0x6a>
  return (*(__IO uint32_t *) tmp);
 801ae4a:	f8dc 3014 	ldr.w	r3, [ip, #20]
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 801ae4e:	4834      	ldr	r0, [pc, #208]	@ (801af20 <SDMMC_CmdWriteMultiBlock+0x14c>)
 801ae50:	4018      	ands	r0, r3
 801ae52:	b358      	cbz	r0, 801aeac <SDMMC_CmdWriteMultiBlock+0xd8>
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
 801ae54:	2b00      	cmp	r3, #0
 801ae56:	db2f      	blt.n	801aeb8 <SDMMC_CmdWriteMultiBlock+0xe4>
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
 801ae58:	0059      	lsls	r1, r3, #1
 801ae5a:	d430      	bmi.n	801aebe <SDMMC_CmdWriteMultiBlock+0xea>
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
 801ae5c:	009a      	lsls	r2, r3, #2
 801ae5e:	d430      	bmi.n	801aec2 <SDMMC_CmdWriteMultiBlock+0xee>
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
 801ae60:	00d9      	lsls	r1, r3, #3
 801ae62:	d430      	bmi.n	801aec6 <SDMMC_CmdWriteMultiBlock+0xf2>
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
 801ae64:	011a      	lsls	r2, r3, #4
 801ae66:	d431      	bmi.n	801aecc <SDMMC_CmdWriteMultiBlock+0xf8>
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
 801ae68:	0159      	lsls	r1, r3, #5
 801ae6a:	d432      	bmi.n	801aed2 <SDMMC_CmdWriteMultiBlock+0xfe>
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
 801ae6c:	01da      	lsls	r2, r3, #7
 801ae6e:	d433      	bmi.n	801aed8 <SDMMC_CmdWriteMultiBlock+0x104>
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
 801ae70:	0219      	lsls	r1, r3, #8
 801ae72:	d434      	bmi.n	801aede <SDMMC_CmdWriteMultiBlock+0x10a>
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
 801ae74:	025a      	lsls	r2, r3, #9
 801ae76:	d435      	bmi.n	801aee4 <SDMMC_CmdWriteMultiBlock+0x110>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
 801ae78:	0299      	lsls	r1, r3, #10
 801ae7a:	d43f      	bmi.n	801aefc <SDMMC_CmdWriteMultiBlock+0x128>
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
 801ae7c:	02da      	lsls	r2, r3, #11
 801ae7e:	d43a      	bmi.n	801aef6 <SDMMC_CmdWriteMultiBlock+0x122>
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
 801ae80:	0359      	lsls	r1, r3, #13
 801ae82:	d435      	bmi.n	801aef0 <SDMMC_CmdWriteMultiBlock+0x11c>
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
 801ae84:	039a      	lsls	r2, r3, #14
 801ae86:	d430      	bmi.n	801aeea <SDMMC_CmdWriteMultiBlock+0x116>
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
 801ae88:	03d9      	lsls	r1, r3, #15
 801ae8a:	d440      	bmi.n	801af0e <SDMMC_CmdWriteMultiBlock+0x13a>
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
 801ae8c:	041a      	lsls	r2, r3, #16
 801ae8e:	d43b      	bmi.n	801af08 <SDMMC_CmdWriteMultiBlock+0x134>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
 801ae90:	0459      	lsls	r1, r3, #17
 801ae92:	d436      	bmi.n	801af02 <SDMMC_CmdWriteMultiBlock+0x12e>
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
 801ae94:	049a      	lsls	r2, r3, #18
 801ae96:	d407      	bmi.n	801aea8 <SDMMC_CmdWriteMultiBlock+0xd4>
    return SDMMC_ERROR_AKE_SEQ_ERR;
 801ae98:	f013 0f08 	tst.w	r3, #8
 801ae9c:	bf0c      	ite	eq
 801ae9e:	f44f 3080 	moveq.w	r0, #65536	@ 0x10000
 801aea2:	f44f 0000 	movne.w	r0, #8388608	@ 0x800000
 801aea6:	4770      	bx	lr
    return SDMMC_ERROR_ERASE_RESET;
 801aea8:	f44f 0080 	mov.w	r0, #4194304	@ 0x400000
}
 801aeac:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 801aeae:	2304      	movs	r3, #4
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 801aeb0:	4618      	mov	r0, r3
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 801aeb2:	f8cc 3038 	str.w	r3, [ip, #56]	@ 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 801aeb6:	4770      	bx	lr
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
 801aeb8:	f04f 7000 	mov.w	r0, #33554432	@ 0x2000000
 801aebc:	4770      	bx	lr
    return SDMMC_ERROR_ADDR_MISALIGNED;
 801aebe:	2040      	movs	r0, #64	@ 0x40
 801aec0:	4770      	bx	lr
    return SDMMC_ERROR_BLOCK_LEN_ERR;
 801aec2:	2080      	movs	r0, #128	@ 0x80
 801aec4:	4770      	bx	lr
    return SDMMC_ERROR_ERASE_SEQ_ERR;
 801aec6:	f44f 7080 	mov.w	r0, #256	@ 0x100
 801aeca:	4770      	bx	lr
    return SDMMC_ERROR_BAD_ERASE_PARAM;
 801aecc:	f44f 7000 	mov.w	r0, #512	@ 0x200
 801aed0:	4770      	bx	lr
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
 801aed2:	f44f 6080 	mov.w	r0, #1024	@ 0x400
 801aed6:	4770      	bx	lr
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
 801aed8:	f44f 6000 	mov.w	r0, #2048	@ 0x800
 801aedc:	4770      	bx	lr
    return SDMMC_ERROR_COM_CRC_FAILED;
 801aede:	f44f 5080 	mov.w	r0, #4096	@ 0x1000
 801aee2:	4770      	bx	lr
    return SDMMC_ERROR_ILLEGAL_CMD;
 801aee4:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
 801aee8:	4770      	bx	lr
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
 801aeea:	f44f 2080 	mov.w	r0, #262144	@ 0x40000
 801aeee:	4770      	bx	lr
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
 801aef0:	f44f 3000 	mov.w	r0, #131072	@ 0x20000
 801aef4:	4770      	bx	lr
    return SDMMC_ERROR_CC_ERR;
 801aef6:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
 801aefa:	4770      	bx	lr
    return SDMMC_ERROR_CARD_ECC_FAILED;
 801aefc:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
 801af00:	4770      	bx	lr
    return SDMMC_ERROR_CARD_ECC_DISABLED;
 801af02:	f44f 1000 	mov.w	r0, #2097152	@ 0x200000
 801af06:	4770      	bx	lr
    return SDMMC_ERROR_WP_ERASE_SKIP;
 801af08:	f44f 1080 	mov.w	r0, #1048576	@ 0x100000
 801af0c:	4770      	bx	lr
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
 801af0e:	f44f 2000 	mov.w	r0, #524288	@ 0x80000
 801af12:	4770      	bx	lr
 801af14:	2000000c 	.word	0x2000000c
 801af18:	10624dd3 	.word	0x10624dd3
 801af1c:	fffff000 	.word	0xfffff000
 801af20:	fdffe008 	.word	0xfdffe008

0801af24 <SDMMC_CmdStopTransfer>:
{
 801af24:	4601      	mov	r1, r0
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801af26:	4a4c      	ldr	r2, [pc, #304]	@ (801b058 <SDMMC_CmdStopTransfer+0x134>)
 801af28:	4b4c      	ldr	r3, [pc, #304]	@ (801b05c <SDMMC_CmdStopTransfer+0x138>)
 801af2a:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801af2c:	484c      	ldr	r0, [pc, #304]	@ (801b060 <SDMMC_CmdStopTransfer+0x13c>)
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801af2e:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801af32:	f240 434c 	movw	r3, #1100	@ 0x44c
{
 801af36:	b410      	push	{r4}
  SDMMCx->ARG = Command->Argument;
 801af38:	2400      	movs	r4, #0
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801af3a:	0a52      	lsrs	r2, r2, #9
  SDMMCx->ARG = Command->Argument;
 801af3c:	608c      	str	r4, [r1, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801af3e:	68cc      	ldr	r4, [r1, #12]
 801af40:	4020      	ands	r0, r4
 801af42:	4303      	orrs	r3, r0
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801af44:	4847      	ldr	r0, [pc, #284]	@ (801b064 <SDMMC_CmdStopTransfer+0x140>)
 801af46:	fb00 f202 	mul.w	r2, r0, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801af4a:	60cb      	str	r3, [r1, #12]
    if (count-- == 0U)
 801af4c:	b14a      	cbz	r2, 801af62 <SDMMC_CmdStopTransfer+0x3e>
 801af4e:	1e53      	subs	r3, r2, #1
    sta_reg = SDMMCx->STA;
 801af50:	6b4a      	ldr	r2, [r1, #52]	@ 0x34
    if (count-- == 0U)
 801af52:	3b01      	subs	r3, #1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 801af54:	f012 0f45 	tst.w	r2, #69	@ 0x45
 801af58:	d001      	beq.n	801af5e <SDMMC_CmdStopTransfer+0x3a>
 801af5a:	0512      	lsls	r2, r2, #20
 801af5c:	d506      	bpl.n	801af6c <SDMMC_CmdStopTransfer+0x48>
    if (count-- == 0U)
 801af5e:	1c58      	adds	r0, r3, #1
 801af60:	d1f6      	bne.n	801af50 <SDMMC_CmdStopTransfer+0x2c>
      return SDMMC_ERROR_TIMEOUT;
 801af62:	f04f 4000 	mov.w	r0, #2147483648	@ 0x80000000
}
 801af66:	f85d 4b04 	ldr.w	r4, [sp], #4
 801af6a:	4770      	bx	lr
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 801af6c:	6b4b      	ldr	r3, [r1, #52]	@ 0x34
 801af6e:	075c      	lsls	r4, r3, #29
 801af70:	d43c      	bmi.n	801afec <SDMMC_CmdStopTransfer+0xc8>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 801af72:	6b4b      	ldr	r3, [r1, #52]	@ 0x34
 801af74:	07d8      	lsls	r0, r3, #31
 801af76:	d407      	bmi.n	801af88 <SDMMC_CmdStopTransfer+0x64>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 801af78:	23c5      	movs	r3, #197	@ 0xc5
 801af7a:	638b      	str	r3, [r1, #56]	@ 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 801af7c:	690b      	ldr	r3, [r1, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 801af7e:	b2db      	uxtb	r3, r3
 801af80:	2b0c      	cmp	r3, #12
 801af82:	d004      	beq.n	801af8e <SDMMC_CmdStopTransfer+0x6a>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 801af84:	2001      	movs	r0, #1
 801af86:	e7ee      	b.n	801af66 <SDMMC_CmdStopTransfer+0x42>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 801af88:	2301      	movs	r3, #1
 801af8a:	638b      	str	r3, [r1, #56]	@ 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 801af8c:	e7fa      	b.n	801af84 <SDMMC_CmdStopTransfer+0x60>
  return (*(__IO uint32_t *) tmp);
 801af8e:	694b      	ldr	r3, [r1, #20]
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 801af90:	4835      	ldr	r0, [pc, #212]	@ (801b068 <SDMMC_CmdStopTransfer+0x144>)
 801af92:	4018      	ands	r0, r3
 801af94:	2800      	cmp	r0, #0
 801af96:	d0e6      	beq.n	801af66 <SDMMC_CmdStopTransfer+0x42>
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
 801af98:	2b00      	cmp	r3, #0
 801af9a:	db2b      	blt.n	801aff4 <SDMMC_CmdStopTransfer+0xd0>
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
 801af9c:	005a      	lsls	r2, r3, #1
 801af9e:	d42c      	bmi.n	801affa <SDMMC_CmdStopTransfer+0xd6>
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
 801afa0:	009c      	lsls	r4, r3, #2
 801afa2:	d42c      	bmi.n	801affe <SDMMC_CmdStopTransfer+0xda>
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
 801afa4:	00d9      	lsls	r1, r3, #3
 801afa6:	d42c      	bmi.n	801b002 <SDMMC_CmdStopTransfer+0xde>
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
 801afa8:	011a      	lsls	r2, r3, #4
 801afaa:	d42d      	bmi.n	801b008 <SDMMC_CmdStopTransfer+0xe4>
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
 801afac:	015c      	lsls	r4, r3, #5
 801afae:	d42e      	bmi.n	801b00e <SDMMC_CmdStopTransfer+0xea>
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
 801afb0:	01d9      	lsls	r1, r3, #7
 801afb2:	d42f      	bmi.n	801b014 <SDMMC_CmdStopTransfer+0xf0>
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
 801afb4:	021a      	lsls	r2, r3, #8
 801afb6:	d430      	bmi.n	801b01a <SDMMC_CmdStopTransfer+0xf6>
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
 801afb8:	025c      	lsls	r4, r3, #9
 801afba:	d431      	bmi.n	801b020 <SDMMC_CmdStopTransfer+0xfc>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
 801afbc:	0299      	lsls	r1, r3, #10
 801afbe:	d43b      	bmi.n	801b038 <SDMMC_CmdStopTransfer+0x114>
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
 801afc0:	02da      	lsls	r2, r3, #11
 801afc2:	d436      	bmi.n	801b032 <SDMMC_CmdStopTransfer+0x10e>
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
 801afc4:	035c      	lsls	r4, r3, #13
 801afc6:	d431      	bmi.n	801b02c <SDMMC_CmdStopTransfer+0x108>
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
 801afc8:	0399      	lsls	r1, r3, #14
 801afca:	d42c      	bmi.n	801b026 <SDMMC_CmdStopTransfer+0x102>
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
 801afcc:	03da      	lsls	r2, r3, #15
 801afce:	d43f      	bmi.n	801b050 <SDMMC_CmdStopTransfer+0x12c>
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
 801afd0:	041c      	lsls	r4, r3, #16
 801afd2:	d43a      	bmi.n	801b04a <SDMMC_CmdStopTransfer+0x126>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
 801afd4:	0459      	lsls	r1, r3, #17
 801afd6:	d435      	bmi.n	801b044 <SDMMC_CmdStopTransfer+0x120>
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
 801afd8:	049a      	lsls	r2, r3, #18
 801afda:	d430      	bmi.n	801b03e <SDMMC_CmdStopTransfer+0x11a>
    return SDMMC_ERROR_AKE_SEQ_ERR;
 801afdc:	f013 0f08 	tst.w	r3, #8
 801afe0:	bf0c      	ite	eq
 801afe2:	f44f 3080 	moveq.w	r0, #65536	@ 0x10000
 801afe6:	f44f 0000 	movne.w	r0, #8388608	@ 0x800000
 801afea:	e7bc      	b.n	801af66 <SDMMC_CmdStopTransfer+0x42>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 801afec:	2304      	movs	r3, #4
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 801afee:	4618      	mov	r0, r3
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 801aff0:	638b      	str	r3, [r1, #56]	@ 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 801aff2:	e7b8      	b.n	801af66 <SDMMC_CmdStopTransfer+0x42>
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
 801aff4:	f04f 7000 	mov.w	r0, #33554432	@ 0x2000000
 801aff8:	e7b5      	b.n	801af66 <SDMMC_CmdStopTransfer+0x42>
    return SDMMC_ERROR_ADDR_MISALIGNED;
 801affa:	2040      	movs	r0, #64	@ 0x40
 801affc:	e7b3      	b.n	801af66 <SDMMC_CmdStopTransfer+0x42>
    return SDMMC_ERROR_BLOCK_LEN_ERR;
 801affe:	2080      	movs	r0, #128	@ 0x80
 801b000:	e7b1      	b.n	801af66 <SDMMC_CmdStopTransfer+0x42>
    return SDMMC_ERROR_ERASE_SEQ_ERR;
 801b002:	f44f 7080 	mov.w	r0, #256	@ 0x100
 801b006:	e7ae      	b.n	801af66 <SDMMC_CmdStopTransfer+0x42>
    return SDMMC_ERROR_BAD_ERASE_PARAM;
 801b008:	f44f 7000 	mov.w	r0, #512	@ 0x200
 801b00c:	e7ab      	b.n	801af66 <SDMMC_CmdStopTransfer+0x42>
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
 801b00e:	f44f 6080 	mov.w	r0, #1024	@ 0x400
 801b012:	e7a8      	b.n	801af66 <SDMMC_CmdStopTransfer+0x42>
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
 801b014:	f44f 6000 	mov.w	r0, #2048	@ 0x800
 801b018:	e7a5      	b.n	801af66 <SDMMC_CmdStopTransfer+0x42>
    return SDMMC_ERROR_COM_CRC_FAILED;
 801b01a:	f44f 5080 	mov.w	r0, #4096	@ 0x1000
 801b01e:	e7a2      	b.n	801af66 <SDMMC_CmdStopTransfer+0x42>
    return SDMMC_ERROR_ILLEGAL_CMD;
 801b020:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
 801b024:	e79f      	b.n	801af66 <SDMMC_CmdStopTransfer+0x42>
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
 801b026:	f44f 2080 	mov.w	r0, #262144	@ 0x40000
 801b02a:	e79c      	b.n	801af66 <SDMMC_CmdStopTransfer+0x42>
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
 801b02c:	f44f 3000 	mov.w	r0, #131072	@ 0x20000
 801b030:	e799      	b.n	801af66 <SDMMC_CmdStopTransfer+0x42>
    return SDMMC_ERROR_CC_ERR;
 801b032:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
 801b036:	e796      	b.n	801af66 <SDMMC_CmdStopTransfer+0x42>
    return SDMMC_ERROR_CARD_ECC_FAILED;
 801b038:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
 801b03c:	e793      	b.n	801af66 <SDMMC_CmdStopTransfer+0x42>
    return SDMMC_ERROR_ERASE_RESET;
 801b03e:	f44f 0080 	mov.w	r0, #4194304	@ 0x400000
 801b042:	e790      	b.n	801af66 <SDMMC_CmdStopTransfer+0x42>
    return SDMMC_ERROR_CARD_ECC_DISABLED;
 801b044:	f44f 1000 	mov.w	r0, #2097152	@ 0x200000
 801b048:	e78d      	b.n	801af66 <SDMMC_CmdStopTransfer+0x42>
    return SDMMC_ERROR_WP_ERASE_SKIP;
 801b04a:	f44f 1080 	mov.w	r0, #1048576	@ 0x100000
 801b04e:	e78a      	b.n	801af66 <SDMMC_CmdStopTransfer+0x42>
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
 801b050:	f44f 2000 	mov.w	r0, #524288	@ 0x80000
 801b054:	e787      	b.n	801af66 <SDMMC_CmdStopTransfer+0x42>
 801b056:	bf00      	nop
 801b058:	2000000c 	.word	0x2000000c
 801b05c:	10624dd3 	.word	0x10624dd3
 801b060:	fffff000 	.word	0xfffff000
 801b064:	05f5e100 	.word	0x05f5e100
 801b068:	fdffe008 	.word	0xfdffe008

0801b06c <SDMMC_CmdSelDesel>:
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801b06c:	4b4b      	ldr	r3, [pc, #300]	@ (801b19c <SDMMC_CmdSelDesel+0x130>)
{
 801b06e:	4601      	mov	r1, r0
 801b070:	b430      	push	{r4, r5}
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801b072:	681b      	ldr	r3, [r3, #0]
 801b074:	4d4a      	ldr	r5, [pc, #296]	@ (801b1a0 <SDMMC_CmdSelDesel+0x134>)
  SDMMCx->ARG = Command->Argument;
 801b076:	6082      	str	r2, [r0, #8]
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801b078:	fba5 5303 	umull	r5, r3, r5, r3
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801b07c:	4c49      	ldr	r4, [pc, #292]	@ (801b1a4 <SDMMC_CmdSelDesel+0x138>)
 801b07e:	68c5      	ldr	r5, [r0, #12]
 801b080:	f240 4047 	movw	r0, #1095	@ 0x447
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801b084:	0a5a      	lsrs	r2, r3, #9
 801b086:	f241 3388 	movw	r3, #5000	@ 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801b08a:	402c      	ands	r4, r5
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801b08c:	fb03 f202 	mul.w	r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801b090:	4320      	orrs	r0, r4
 801b092:	60c8      	str	r0, [r1, #12]
    if (count-- == 0U)
 801b094:	b14a      	cbz	r2, 801b0aa <SDMMC_CmdSelDesel+0x3e>
 801b096:	1e53      	subs	r3, r2, #1
    sta_reg = SDMMCx->STA;
 801b098:	6b4a      	ldr	r2, [r1, #52]	@ 0x34
    if (count-- == 0U)
 801b09a:	3b01      	subs	r3, #1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 801b09c:	f012 0f45 	tst.w	r2, #69	@ 0x45
 801b0a0:	d001      	beq.n	801b0a6 <SDMMC_CmdSelDesel+0x3a>
 801b0a2:	0510      	lsls	r0, r2, #20
 801b0a4:	d505      	bpl.n	801b0b2 <SDMMC_CmdSelDesel+0x46>
    if (count-- == 0U)
 801b0a6:	1c5c      	adds	r4, r3, #1
 801b0a8:	d1f6      	bne.n	801b098 <SDMMC_CmdSelDesel+0x2c>
      return SDMMC_ERROR_TIMEOUT;
 801b0aa:	f04f 4000 	mov.w	r0, #2147483648	@ 0x80000000
}
 801b0ae:	bc30      	pop	{r4, r5}
 801b0b0:	4770      	bx	lr
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 801b0b2:	6b4b      	ldr	r3, [r1, #52]	@ 0x34
 801b0b4:	075a      	lsls	r2, r3, #29
 801b0b6:	d43c      	bmi.n	801b132 <SDMMC_CmdSelDesel+0xc6>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 801b0b8:	6b4b      	ldr	r3, [r1, #52]	@ 0x34
 801b0ba:	07db      	lsls	r3, r3, #31
 801b0bc:	d407      	bmi.n	801b0ce <SDMMC_CmdSelDesel+0x62>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 801b0be:	23c5      	movs	r3, #197	@ 0xc5
 801b0c0:	638b      	str	r3, [r1, #56]	@ 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 801b0c2:	690b      	ldr	r3, [r1, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 801b0c4:	b2db      	uxtb	r3, r3
 801b0c6:	2b07      	cmp	r3, #7
 801b0c8:	d004      	beq.n	801b0d4 <SDMMC_CmdSelDesel+0x68>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 801b0ca:	2001      	movs	r0, #1
 801b0cc:	e7ef      	b.n	801b0ae <SDMMC_CmdSelDesel+0x42>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 801b0ce:	2301      	movs	r3, #1
 801b0d0:	638b      	str	r3, [r1, #56]	@ 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 801b0d2:	e7fa      	b.n	801b0ca <SDMMC_CmdSelDesel+0x5e>
  return (*(__IO uint32_t *) tmp);
 801b0d4:	694b      	ldr	r3, [r1, #20]
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 801b0d6:	4834      	ldr	r0, [pc, #208]	@ (801b1a8 <SDMMC_CmdSelDesel+0x13c>)
 801b0d8:	4018      	ands	r0, r3
 801b0da:	2800      	cmp	r0, #0
 801b0dc:	d0e7      	beq.n	801b0ae <SDMMC_CmdSelDesel+0x42>
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
 801b0de:	2b00      	cmp	r3, #0
 801b0e0:	db2b      	blt.n	801b13a <SDMMC_CmdSelDesel+0xce>
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
 801b0e2:	005d      	lsls	r5, r3, #1
 801b0e4:	d42c      	bmi.n	801b140 <SDMMC_CmdSelDesel+0xd4>
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
 801b0e6:	009c      	lsls	r4, r3, #2
 801b0e8:	d42c      	bmi.n	801b144 <SDMMC_CmdSelDesel+0xd8>
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
 801b0ea:	00d9      	lsls	r1, r3, #3
 801b0ec:	d42c      	bmi.n	801b148 <SDMMC_CmdSelDesel+0xdc>
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
 801b0ee:	011a      	lsls	r2, r3, #4
 801b0f0:	d42d      	bmi.n	801b14e <SDMMC_CmdSelDesel+0xe2>
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
 801b0f2:	015d      	lsls	r5, r3, #5
 801b0f4:	d42e      	bmi.n	801b154 <SDMMC_CmdSelDesel+0xe8>
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
 801b0f6:	01dc      	lsls	r4, r3, #7
 801b0f8:	d42f      	bmi.n	801b15a <SDMMC_CmdSelDesel+0xee>
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
 801b0fa:	0219      	lsls	r1, r3, #8
 801b0fc:	d430      	bmi.n	801b160 <SDMMC_CmdSelDesel+0xf4>
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
 801b0fe:	025a      	lsls	r2, r3, #9
 801b100:	d431      	bmi.n	801b166 <SDMMC_CmdSelDesel+0xfa>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
 801b102:	029d      	lsls	r5, r3, #10
 801b104:	d43b      	bmi.n	801b17e <SDMMC_CmdSelDesel+0x112>
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
 801b106:	02dc      	lsls	r4, r3, #11
 801b108:	d436      	bmi.n	801b178 <SDMMC_CmdSelDesel+0x10c>
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
 801b10a:	0359      	lsls	r1, r3, #13
 801b10c:	d431      	bmi.n	801b172 <SDMMC_CmdSelDesel+0x106>
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
 801b10e:	039a      	lsls	r2, r3, #14
 801b110:	d42c      	bmi.n	801b16c <SDMMC_CmdSelDesel+0x100>
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
 801b112:	03dd      	lsls	r5, r3, #15
 801b114:	d43f      	bmi.n	801b196 <SDMMC_CmdSelDesel+0x12a>
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
 801b116:	041c      	lsls	r4, r3, #16
 801b118:	d43a      	bmi.n	801b190 <SDMMC_CmdSelDesel+0x124>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
 801b11a:	0459      	lsls	r1, r3, #17
 801b11c:	d435      	bmi.n	801b18a <SDMMC_CmdSelDesel+0x11e>
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
 801b11e:	049a      	lsls	r2, r3, #18
 801b120:	d430      	bmi.n	801b184 <SDMMC_CmdSelDesel+0x118>
    return SDMMC_ERROR_AKE_SEQ_ERR;
 801b122:	f013 0f08 	tst.w	r3, #8
 801b126:	bf0c      	ite	eq
 801b128:	f44f 3080 	moveq.w	r0, #65536	@ 0x10000
 801b12c:	f44f 0000 	movne.w	r0, #8388608	@ 0x800000
 801b130:	e7bd      	b.n	801b0ae <SDMMC_CmdSelDesel+0x42>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 801b132:	2304      	movs	r3, #4
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 801b134:	4618      	mov	r0, r3
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 801b136:	638b      	str	r3, [r1, #56]	@ 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 801b138:	e7b9      	b.n	801b0ae <SDMMC_CmdSelDesel+0x42>
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
 801b13a:	f04f 7000 	mov.w	r0, #33554432	@ 0x2000000
 801b13e:	e7b6      	b.n	801b0ae <SDMMC_CmdSelDesel+0x42>
    return SDMMC_ERROR_ADDR_MISALIGNED;
 801b140:	2040      	movs	r0, #64	@ 0x40
 801b142:	e7b4      	b.n	801b0ae <SDMMC_CmdSelDesel+0x42>
    return SDMMC_ERROR_BLOCK_LEN_ERR;
 801b144:	2080      	movs	r0, #128	@ 0x80
 801b146:	e7b2      	b.n	801b0ae <SDMMC_CmdSelDesel+0x42>
    return SDMMC_ERROR_ERASE_SEQ_ERR;
 801b148:	f44f 7080 	mov.w	r0, #256	@ 0x100
 801b14c:	e7af      	b.n	801b0ae <SDMMC_CmdSelDesel+0x42>
    return SDMMC_ERROR_BAD_ERASE_PARAM;
 801b14e:	f44f 7000 	mov.w	r0, #512	@ 0x200
 801b152:	e7ac      	b.n	801b0ae <SDMMC_CmdSelDesel+0x42>
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
 801b154:	f44f 6080 	mov.w	r0, #1024	@ 0x400
 801b158:	e7a9      	b.n	801b0ae <SDMMC_CmdSelDesel+0x42>
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
 801b15a:	f44f 6000 	mov.w	r0, #2048	@ 0x800
 801b15e:	e7a6      	b.n	801b0ae <SDMMC_CmdSelDesel+0x42>
    return SDMMC_ERROR_COM_CRC_FAILED;
 801b160:	f44f 5080 	mov.w	r0, #4096	@ 0x1000
 801b164:	e7a3      	b.n	801b0ae <SDMMC_CmdSelDesel+0x42>
    return SDMMC_ERROR_ILLEGAL_CMD;
 801b166:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
 801b16a:	e7a0      	b.n	801b0ae <SDMMC_CmdSelDesel+0x42>
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
 801b16c:	f44f 2080 	mov.w	r0, #262144	@ 0x40000
 801b170:	e79d      	b.n	801b0ae <SDMMC_CmdSelDesel+0x42>
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
 801b172:	f44f 3000 	mov.w	r0, #131072	@ 0x20000
 801b176:	e79a      	b.n	801b0ae <SDMMC_CmdSelDesel+0x42>
    return SDMMC_ERROR_CC_ERR;
 801b178:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
 801b17c:	e797      	b.n	801b0ae <SDMMC_CmdSelDesel+0x42>
    return SDMMC_ERROR_CARD_ECC_FAILED;
 801b17e:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
 801b182:	e794      	b.n	801b0ae <SDMMC_CmdSelDesel+0x42>
    return SDMMC_ERROR_ERASE_RESET;
 801b184:	f44f 0080 	mov.w	r0, #4194304	@ 0x400000
 801b188:	e791      	b.n	801b0ae <SDMMC_CmdSelDesel+0x42>
    return SDMMC_ERROR_CARD_ECC_DISABLED;
 801b18a:	f44f 1000 	mov.w	r0, #2097152	@ 0x200000
 801b18e:	e78e      	b.n	801b0ae <SDMMC_CmdSelDesel+0x42>
    return SDMMC_ERROR_WP_ERASE_SKIP;
 801b190:	f44f 1080 	mov.w	r0, #1048576	@ 0x100000
 801b194:	e78b      	b.n	801b0ae <SDMMC_CmdSelDesel+0x42>
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
 801b196:	f44f 2000 	mov.w	r0, #524288	@ 0x80000
 801b19a:	e788      	b.n	801b0ae <SDMMC_CmdSelDesel+0x42>
 801b19c:	2000000c 	.word	0x2000000c
 801b1a0:	10624dd3 	.word	0x10624dd3
 801b1a4:	fffff000 	.word	0xfffff000
 801b1a8:	fdffe008 	.word	0xfdffe008

0801b1ac <SDMMC_CmdGoIdleState>:
  */
static uint32_t SDMMC_GetCmdError(SDMMC_TypeDef *SDMMCx)
{
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 801b1ac:	4b11      	ldr	r3, [pc, #68]	@ (801b1f4 <SDMMC_CmdGoIdleState+0x48>)
{
 801b1ae:	4601      	mov	r1, r0
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801b1b0:	4a11      	ldr	r2, [pc, #68]	@ (801b1f8 <SDMMC_CmdGoIdleState+0x4c>)
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 801b1b2:	681b      	ldr	r3, [r3, #0]
{
 801b1b4:	b430      	push	{r4, r5}
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 801b1b6:	4c11      	ldr	r4, [pc, #68]	@ (801b1fc <SDMMC_CmdGoIdleState+0x50>)
  SDMMCx->ARG = Command->Argument;
 801b1b8:	2500      	movs	r5, #0
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 801b1ba:	fba4 4303 	umull	r4, r3, r4, r3
  SDMMCx->ARG = Command->Argument;
 801b1be:	6085      	str	r5, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801b1c0:	68c4      	ldr	r4, [r0, #12]
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 801b1c2:	0a5b      	lsrs	r3, r3, #9
 801b1c4:	f241 3088 	movw	r0, #5000	@ 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801b1c8:	4022      	ands	r2, r4
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 801b1ca:	fb00 f303 	mul.w	r3, r0, r3
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801b1ce:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
 801b1d2:	60ca      	str	r2, [r1, #12]
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 801b1d4:	e002      	b.n	801b1dc <SDMMC_CmdGoIdleState+0x30>
    if (count-- == 0U)
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    
  }while(!__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CMDSENT));
 801b1d6:	6b4a      	ldr	r2, [r1, #52]	@ 0x34
 801b1d8:	0612      	lsls	r2, r2, #24
 801b1da:	d405      	bmi.n	801b1e8 <SDMMC_CmdGoIdleState+0x3c>
    if (count-- == 0U)
 801b1dc:	3b01      	subs	r3, #1
 801b1de:	d2fa      	bcs.n	801b1d6 <SDMMC_CmdGoIdleState+0x2a>
      return SDMMC_ERROR_TIMEOUT;
 801b1e0:	f04f 4000 	mov.w	r0, #2147483648	@ 0x80000000
}
 801b1e4:	bc30      	pop	{r4, r5}
 801b1e6:	4770      	bx	lr
  
  /* Clear all the static flags */
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 801b1e8:	23c5      	movs	r3, #197	@ 0xc5
  
  return SDMMC_ERROR_NONE;
 801b1ea:	2000      	movs	r0, #0
}
 801b1ec:	bc30      	pop	{r4, r5}
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 801b1ee:	638b      	str	r3, [r1, #56]	@ 0x38
}
 801b1f0:	4770      	bx	lr
 801b1f2:	bf00      	nop
 801b1f4:	2000000c 	.word	0x2000000c
 801b1f8:	fffff000 	.word	0xfffff000
 801b1fc:	10624dd3 	.word	0x10624dd3

0801b200 <SDMMC_CmdOperCond>:
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 801b200:	4b1b      	ldr	r3, [pc, #108]	@ (801b270 <SDMMC_CmdOperCond+0x70>)
{
 801b202:	4601      	mov	r1, r0
 801b204:	b430      	push	{r4, r5}
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 801b206:	681a      	ldr	r2, [r3, #0]
  SDMMCx->ARG = Command->Argument;
 801b208:	f44f 75d5 	mov.w	r5, #426	@ 0x1aa
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 801b20c:	4c19      	ldr	r4, [pc, #100]	@ (801b274 <SDMMC_CmdOperCond+0x74>)
  SDMMCx->ARG = Command->Argument;
 801b20e:	6085      	str	r5, [r0, #8]
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 801b210:	fba4 4202 	umull	r4, r2, r4, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801b214:	4b18      	ldr	r3, [pc, #96]	@ (801b278 <SDMMC_CmdOperCond+0x78>)
 801b216:	68c4      	ldr	r4, [r0, #12]
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 801b218:	f241 3088 	movw	r0, #5000	@ 0x1388
 801b21c:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801b21e:	4023      	ands	r3, r4
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 801b220:	fb00 f202 	mul.w	r2, r0, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801b224:	f443 6089 	orr.w	r0, r3, #1096	@ 0x448
 801b228:	60c8      	str	r0, [r1, #12]
    if (count-- == 0U)
 801b22a:	b14a      	cbz	r2, 801b240 <SDMMC_CmdOperCond+0x40>
 801b22c:	1e53      	subs	r3, r2, #1
    sta_reg = SDMMCx->STA;
 801b22e:	6b4a      	ldr	r2, [r1, #52]	@ 0x34
    if (count-- == 0U)
 801b230:	3b01      	subs	r3, #1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 801b232:	f012 0f45 	tst.w	r2, #69	@ 0x45
 801b236:	d001      	beq.n	801b23c <SDMMC_CmdOperCond+0x3c>
 801b238:	0510      	lsls	r0, r2, #20
 801b23a:	d505      	bpl.n	801b248 <SDMMC_CmdOperCond+0x48>
    if (count-- == 0U)
 801b23c:	1c5c      	adds	r4, r3, #1
 801b23e:	d1f6      	bne.n	801b22e <SDMMC_CmdOperCond+0x2e>
      return SDMMC_ERROR_TIMEOUT;
 801b240:	f04f 4000 	mov.w	r0, #2147483648	@ 0x80000000
}
 801b244:	bc30      	pop	{r4, r5}
 801b246:	4770      	bx	lr
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 801b248:	6b4b      	ldr	r3, [r1, #52]	@ 0x34
 801b24a:	075a      	lsls	r2, r3, #29
 801b24c:	d40c      	bmi.n	801b268 <SDMMC_CmdOperCond+0x68>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 801b24e:	6b48      	ldr	r0, [r1, #52]	@ 0x34
 801b250:	f010 0001 	ands.w	r0, r0, #1
 801b254:	d105      	bne.n	801b262 <SDMMC_CmdOperCond+0x62>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CMDREND))
 801b256:	6b4b      	ldr	r3, [r1, #52]	@ 0x34
 801b258:	065b      	lsls	r3, r3, #25
 801b25a:	d5f3      	bpl.n	801b244 <SDMMC_CmdOperCond+0x44>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CMDREND);
 801b25c:	2340      	movs	r3, #64	@ 0x40
 801b25e:	638b      	str	r3, [r1, #56]	@ 0x38
 801b260:	e7f0      	b.n	801b244 <SDMMC_CmdOperCond+0x44>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 801b262:	2301      	movs	r3, #1
 801b264:	638b      	str	r3, [r1, #56]	@ 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 801b266:	e7ed      	b.n	801b244 <SDMMC_CmdOperCond+0x44>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 801b268:	2304      	movs	r3, #4
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 801b26a:	4618      	mov	r0, r3
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 801b26c:	638b      	str	r3, [r1, #56]	@ 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 801b26e:	e7e9      	b.n	801b244 <SDMMC_CmdOperCond+0x44>
 801b270:	2000000c 	.word	0x2000000c
 801b274:	10624dd3 	.word	0x10624dd3
 801b278:	fffff000 	.word	0xfffff000

0801b27c <SDMMC_CmdAppCommand>:
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801b27c:	4a4f      	ldr	r2, [pc, #316]	@ (801b3bc <SDMMC_CmdAppCommand+0x140>)
{
 801b27e:	4684      	mov	ip, r0
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801b280:	4b4f      	ldr	r3, [pc, #316]	@ (801b3c0 <SDMMC_CmdAppCommand+0x144>)
 801b282:	6812      	ldr	r2, [r2, #0]
  SDMMCx->ARG = Command->Argument;
 801b284:	f8cc 1008 	str.w	r1, [ip, #8]
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801b288:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801b28c:	f8dc 100c 	ldr.w	r1, [ip, #12]
 801b290:	484c      	ldr	r0, [pc, #304]	@ (801b3c4 <SDMMC_CmdAppCommand+0x148>)
 801b292:	f240 4377 	movw	r3, #1143	@ 0x477
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801b296:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801b298:	4008      	ands	r0, r1
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801b29a:	f241 3188 	movw	r1, #5000	@ 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801b29e:	4303      	orrs	r3, r0
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801b2a0:	fb01 f202 	mul.w	r2, r1, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801b2a4:	f8cc 300c 	str.w	r3, [ip, #12]
    if (count-- == 0U)
 801b2a8:	1e53      	subs	r3, r2, #1
 801b2aa:	b14a      	cbz	r2, 801b2c0 <SDMMC_CmdAppCommand+0x44>
    sta_reg = SDMMCx->STA;
 801b2ac:	f8dc 2034 	ldr.w	r2, [ip, #52]	@ 0x34
    if (count-- == 0U)
 801b2b0:	3b01      	subs	r3, #1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 801b2b2:	f012 0f45 	tst.w	r2, #69	@ 0x45
 801b2b6:	d001      	beq.n	801b2bc <SDMMC_CmdAppCommand+0x40>
 801b2b8:	0512      	lsls	r2, r2, #20
 801b2ba:	d504      	bpl.n	801b2c6 <SDMMC_CmdAppCommand+0x4a>
    if (count-- == 0U)
 801b2bc:	1c59      	adds	r1, r3, #1
 801b2be:	d1f5      	bne.n	801b2ac <SDMMC_CmdAppCommand+0x30>
      return SDMMC_ERROR_TIMEOUT;
 801b2c0:	f04f 4000 	mov.w	r0, #2147483648	@ 0x80000000
 801b2c4:	4770      	bx	lr
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 801b2c6:	f8dc 3034 	ldr.w	r3, [ip, #52]	@ 0x34
 801b2ca:	075b      	lsls	r3, r3, #29
 801b2cc:	d443      	bmi.n	801b356 <SDMMC_CmdAppCommand+0xda>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 801b2ce:	f8dc 3034 	ldr.w	r3, [ip, #52]	@ 0x34
 801b2d2:	07d8      	lsls	r0, r3, #31
 801b2d4:	d409      	bmi.n	801b2ea <SDMMC_CmdAppCommand+0x6e>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 801b2d6:	23c5      	movs	r3, #197	@ 0xc5
 801b2d8:	f8cc 3038 	str.w	r3, [ip, #56]	@ 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 801b2dc:	f8dc 3010 	ldr.w	r3, [ip, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 801b2e0:	b2db      	uxtb	r3, r3
 801b2e2:	2b37      	cmp	r3, #55	@ 0x37
 801b2e4:	d005      	beq.n	801b2f2 <SDMMC_CmdAppCommand+0x76>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 801b2e6:	2001      	movs	r0, #1
 801b2e8:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 801b2ea:	2301      	movs	r3, #1
 801b2ec:	f8cc 3038 	str.w	r3, [ip, #56]	@ 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 801b2f0:	e7f9      	b.n	801b2e6 <SDMMC_CmdAppCommand+0x6a>
  return (*(__IO uint32_t *) tmp);
 801b2f2:	f8dc 3014 	ldr.w	r3, [ip, #20]
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 801b2f6:	4834      	ldr	r0, [pc, #208]	@ (801b3c8 <SDMMC_CmdAppCommand+0x14c>)
 801b2f8:	4018      	ands	r0, r3
 801b2fa:	b358      	cbz	r0, 801b354 <SDMMC_CmdAppCommand+0xd8>
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
 801b2fc:	2b00      	cmp	r3, #0
 801b2fe:	db2f      	blt.n	801b360 <SDMMC_CmdAppCommand+0xe4>
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
 801b300:	0059      	lsls	r1, r3, #1
 801b302:	d430      	bmi.n	801b366 <SDMMC_CmdAppCommand+0xea>
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
 801b304:	009a      	lsls	r2, r3, #2
 801b306:	d430      	bmi.n	801b36a <SDMMC_CmdAppCommand+0xee>
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
 801b308:	00d9      	lsls	r1, r3, #3
 801b30a:	d430      	bmi.n	801b36e <SDMMC_CmdAppCommand+0xf2>
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
 801b30c:	011a      	lsls	r2, r3, #4
 801b30e:	d431      	bmi.n	801b374 <SDMMC_CmdAppCommand+0xf8>
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
 801b310:	0159      	lsls	r1, r3, #5
 801b312:	d432      	bmi.n	801b37a <SDMMC_CmdAppCommand+0xfe>
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
 801b314:	01da      	lsls	r2, r3, #7
 801b316:	d433      	bmi.n	801b380 <SDMMC_CmdAppCommand+0x104>
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
 801b318:	0219      	lsls	r1, r3, #8
 801b31a:	d434      	bmi.n	801b386 <SDMMC_CmdAppCommand+0x10a>
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
 801b31c:	025a      	lsls	r2, r3, #9
 801b31e:	d435      	bmi.n	801b38c <SDMMC_CmdAppCommand+0x110>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
 801b320:	0299      	lsls	r1, r3, #10
 801b322:	d43f      	bmi.n	801b3a4 <SDMMC_CmdAppCommand+0x128>
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
 801b324:	02da      	lsls	r2, r3, #11
 801b326:	d43a      	bmi.n	801b39e <SDMMC_CmdAppCommand+0x122>
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
 801b328:	0359      	lsls	r1, r3, #13
 801b32a:	d435      	bmi.n	801b398 <SDMMC_CmdAppCommand+0x11c>
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
 801b32c:	039a      	lsls	r2, r3, #14
 801b32e:	d430      	bmi.n	801b392 <SDMMC_CmdAppCommand+0x116>
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
 801b330:	03d9      	lsls	r1, r3, #15
 801b332:	d440      	bmi.n	801b3b6 <SDMMC_CmdAppCommand+0x13a>
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
 801b334:	041a      	lsls	r2, r3, #16
 801b336:	d43b      	bmi.n	801b3b0 <SDMMC_CmdAppCommand+0x134>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
 801b338:	0459      	lsls	r1, r3, #17
 801b33a:	d436      	bmi.n	801b3aa <SDMMC_CmdAppCommand+0x12e>
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
 801b33c:	049a      	lsls	r2, r3, #18
 801b33e:	d407      	bmi.n	801b350 <SDMMC_CmdAppCommand+0xd4>
    return SDMMC_ERROR_AKE_SEQ_ERR;
 801b340:	f013 0f08 	tst.w	r3, #8
 801b344:	bf0c      	ite	eq
 801b346:	f44f 3080 	moveq.w	r0, #65536	@ 0x10000
 801b34a:	f44f 0000 	movne.w	r0, #8388608	@ 0x800000
 801b34e:	4770      	bx	lr
    return SDMMC_ERROR_ERASE_RESET;
 801b350:	f44f 0080 	mov.w	r0, #4194304	@ 0x400000
}
 801b354:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 801b356:	2304      	movs	r3, #4
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 801b358:	4618      	mov	r0, r3
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 801b35a:	f8cc 3038 	str.w	r3, [ip, #56]	@ 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 801b35e:	4770      	bx	lr
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
 801b360:	f04f 7000 	mov.w	r0, #33554432	@ 0x2000000
 801b364:	4770      	bx	lr
    return SDMMC_ERROR_ADDR_MISALIGNED;
 801b366:	2040      	movs	r0, #64	@ 0x40
 801b368:	4770      	bx	lr
    return SDMMC_ERROR_BLOCK_LEN_ERR;
 801b36a:	2080      	movs	r0, #128	@ 0x80
 801b36c:	4770      	bx	lr
    return SDMMC_ERROR_ERASE_SEQ_ERR;
 801b36e:	f44f 7080 	mov.w	r0, #256	@ 0x100
 801b372:	4770      	bx	lr
    return SDMMC_ERROR_BAD_ERASE_PARAM;
 801b374:	f44f 7000 	mov.w	r0, #512	@ 0x200
 801b378:	4770      	bx	lr
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
 801b37a:	f44f 6080 	mov.w	r0, #1024	@ 0x400
 801b37e:	4770      	bx	lr
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
 801b380:	f44f 6000 	mov.w	r0, #2048	@ 0x800
 801b384:	4770      	bx	lr
    return SDMMC_ERROR_COM_CRC_FAILED;
 801b386:	f44f 5080 	mov.w	r0, #4096	@ 0x1000
 801b38a:	4770      	bx	lr
    return SDMMC_ERROR_ILLEGAL_CMD;
 801b38c:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
 801b390:	4770      	bx	lr
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
 801b392:	f44f 2080 	mov.w	r0, #262144	@ 0x40000
 801b396:	4770      	bx	lr
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
 801b398:	f44f 3000 	mov.w	r0, #131072	@ 0x20000
 801b39c:	4770      	bx	lr
    return SDMMC_ERROR_CC_ERR;
 801b39e:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
 801b3a2:	4770      	bx	lr
    return SDMMC_ERROR_CARD_ECC_FAILED;
 801b3a4:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
 801b3a8:	4770      	bx	lr
    return SDMMC_ERROR_CARD_ECC_DISABLED;
 801b3aa:	f44f 1000 	mov.w	r0, #2097152	@ 0x200000
 801b3ae:	4770      	bx	lr
    return SDMMC_ERROR_WP_ERASE_SKIP;
 801b3b0:	f44f 1080 	mov.w	r0, #1048576	@ 0x100000
 801b3b4:	4770      	bx	lr
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
 801b3b6:	f44f 2000 	mov.w	r0, #524288	@ 0x80000
 801b3ba:	4770      	bx	lr
 801b3bc:	2000000c 	.word	0x2000000c
 801b3c0:	10624dd3 	.word	0x10624dd3
 801b3c4:	fffff000 	.word	0xfffff000
 801b3c8:	fdffe008 	.word	0xfdffe008

0801b3cc <SDMMC_CmdAppOperCommand>:
{
 801b3cc:	b410      	push	{r4}
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 801b3ce:	4b1c      	ldr	r3, [pc, #112]	@ (801b440 <SDMMC_CmdAppOperCommand+0x74>)
{
 801b3d0:	4684      	mov	ip, r0
  sdmmc_cmdinit.Argument         = SDMMC_VOLTAGE_WINDOW_SD | Argument;
 801b3d2:	4c1c      	ldr	r4, [pc, #112]	@ (801b444 <SDMMC_CmdAppOperCommand+0x78>)
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 801b3d4:	481c      	ldr	r0, [pc, #112]	@ (801b448 <SDMMC_CmdAppOperCommand+0x7c>)
  sdmmc_cmdinit.Argument         = SDMMC_VOLTAGE_WINDOW_SD | Argument;
 801b3d6:	430c      	orrs	r4, r1
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 801b3d8:	681a      	ldr	r2, [r3, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801b3da:	4b1c      	ldr	r3, [pc, #112]	@ (801b44c <SDMMC_CmdAppOperCommand+0x80>)
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 801b3dc:	fba0 0202 	umull	r0, r2, r0, r2
 801b3e0:	f241 3088 	movw	r0, #5000	@ 0x1388
  SDMMCx->ARG = Command->Argument;
 801b3e4:	f8cc 4008 	str.w	r4, [ip, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801b3e8:	f8dc 100c 	ldr.w	r1, [ip, #12]
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 801b3ec:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801b3ee:	400b      	ands	r3, r1
 801b3f0:	f240 4169 	movw	r1, #1129	@ 0x469
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 801b3f4:	fb00 f202 	mul.w	r2, r0, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801b3f8:	4319      	orrs	r1, r3
 801b3fa:	f8cc 100c 	str.w	r1, [ip, #12]
    if (count-- == 0U)
 801b3fe:	b152      	cbz	r2, 801b416 <SDMMC_CmdAppOperCommand+0x4a>
 801b400:	1e53      	subs	r3, r2, #1
    sta_reg = SDMMCx->STA;
 801b402:	f8dc 2034 	ldr.w	r2, [ip, #52]	@ 0x34
    if (count-- == 0U)
 801b406:	3b01      	subs	r3, #1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 801b408:	f012 0f45 	tst.w	r2, #69	@ 0x45
 801b40c:	d001      	beq.n	801b412 <SDMMC_CmdAppOperCommand+0x46>
 801b40e:	0512      	lsls	r2, r2, #20
 801b410:	d506      	bpl.n	801b420 <SDMMC_CmdAppOperCommand+0x54>
    if (count-- == 0U)
 801b412:	1c59      	adds	r1, r3, #1
 801b414:	d1f5      	bne.n	801b402 <SDMMC_CmdAppOperCommand+0x36>
      return SDMMC_ERROR_TIMEOUT;
 801b416:	f04f 4000 	mov.w	r0, #2147483648	@ 0x80000000
}
 801b41a:	f85d 4b04 	ldr.w	r4, [sp], #4
 801b41e:	4770      	bx	lr
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 801b420:	f8dc 0034 	ldr.w	r0, [ip, #52]	@ 0x34
 801b424:	f010 0004 	ands.w	r0, r0, #4
 801b428:	d105      	bne.n	801b436 <SDMMC_CmdAppOperCommand+0x6a>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 801b42a:	23c5      	movs	r3, #197	@ 0xc5
}
 801b42c:	f85d 4b04 	ldr.w	r4, [sp], #4
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 801b430:	f8cc 3038 	str.w	r3, [ip, #56]	@ 0x38
}
 801b434:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 801b436:	2304      	movs	r3, #4
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 801b438:	4618      	mov	r0, r3
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 801b43a:	f8cc 3038 	str.w	r3, [ip, #56]	@ 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 801b43e:	e7ec      	b.n	801b41a <SDMMC_CmdAppOperCommand+0x4e>
 801b440:	2000000c 	.word	0x2000000c
 801b444:	80100000 	.word	0x80100000
 801b448:	10624dd3 	.word	0x10624dd3
 801b44c:	fffff000 	.word	0xfffff000

0801b450 <SDMMC_CmdBusWidth>:
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801b450:	4a4f      	ldr	r2, [pc, #316]	@ (801b590 <SDMMC_CmdBusWidth+0x140>)
{
 801b452:	4684      	mov	ip, r0
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801b454:	4b4f      	ldr	r3, [pc, #316]	@ (801b594 <SDMMC_CmdBusWidth+0x144>)
 801b456:	6812      	ldr	r2, [r2, #0]
  SDMMCx->ARG = Command->Argument;
 801b458:	f8cc 1008 	str.w	r1, [ip, #8]
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801b45c:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801b460:	f8dc 100c 	ldr.w	r1, [ip, #12]
 801b464:	484c      	ldr	r0, [pc, #304]	@ (801b598 <SDMMC_CmdBusWidth+0x148>)
 801b466:	f240 4346 	movw	r3, #1094	@ 0x446
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801b46a:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801b46c:	4008      	ands	r0, r1
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801b46e:	f241 3188 	movw	r1, #5000	@ 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801b472:	4303      	orrs	r3, r0
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801b474:	fb01 f202 	mul.w	r2, r1, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801b478:	f8cc 300c 	str.w	r3, [ip, #12]
    if (count-- == 0U)
 801b47c:	1e53      	subs	r3, r2, #1
 801b47e:	b14a      	cbz	r2, 801b494 <SDMMC_CmdBusWidth+0x44>
    sta_reg = SDMMCx->STA;
 801b480:	f8dc 2034 	ldr.w	r2, [ip, #52]	@ 0x34
    if (count-- == 0U)
 801b484:	3b01      	subs	r3, #1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 801b486:	f012 0f45 	tst.w	r2, #69	@ 0x45
 801b48a:	d001      	beq.n	801b490 <SDMMC_CmdBusWidth+0x40>
 801b48c:	0512      	lsls	r2, r2, #20
 801b48e:	d504      	bpl.n	801b49a <SDMMC_CmdBusWidth+0x4a>
    if (count-- == 0U)
 801b490:	1c59      	adds	r1, r3, #1
 801b492:	d1f5      	bne.n	801b480 <SDMMC_CmdBusWidth+0x30>
      return SDMMC_ERROR_TIMEOUT;
 801b494:	f04f 4000 	mov.w	r0, #2147483648	@ 0x80000000
 801b498:	4770      	bx	lr
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 801b49a:	f8dc 3034 	ldr.w	r3, [ip, #52]	@ 0x34
 801b49e:	075b      	lsls	r3, r3, #29
 801b4a0:	d443      	bmi.n	801b52a <SDMMC_CmdBusWidth+0xda>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 801b4a2:	f8dc 3034 	ldr.w	r3, [ip, #52]	@ 0x34
 801b4a6:	07d8      	lsls	r0, r3, #31
 801b4a8:	d409      	bmi.n	801b4be <SDMMC_CmdBusWidth+0x6e>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 801b4aa:	23c5      	movs	r3, #197	@ 0xc5
 801b4ac:	f8cc 3038 	str.w	r3, [ip, #56]	@ 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 801b4b0:	f8dc 3010 	ldr.w	r3, [ip, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 801b4b4:	b2db      	uxtb	r3, r3
 801b4b6:	2b06      	cmp	r3, #6
 801b4b8:	d005      	beq.n	801b4c6 <SDMMC_CmdBusWidth+0x76>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 801b4ba:	2001      	movs	r0, #1
 801b4bc:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 801b4be:	2301      	movs	r3, #1
 801b4c0:	f8cc 3038 	str.w	r3, [ip, #56]	@ 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 801b4c4:	e7f9      	b.n	801b4ba <SDMMC_CmdBusWidth+0x6a>
  return (*(__IO uint32_t *) tmp);
 801b4c6:	f8dc 3014 	ldr.w	r3, [ip, #20]
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 801b4ca:	4834      	ldr	r0, [pc, #208]	@ (801b59c <SDMMC_CmdBusWidth+0x14c>)
 801b4cc:	4018      	ands	r0, r3
 801b4ce:	b358      	cbz	r0, 801b528 <SDMMC_CmdBusWidth+0xd8>
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
 801b4d0:	2b00      	cmp	r3, #0
 801b4d2:	db2f      	blt.n	801b534 <SDMMC_CmdBusWidth+0xe4>
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
 801b4d4:	0059      	lsls	r1, r3, #1
 801b4d6:	d430      	bmi.n	801b53a <SDMMC_CmdBusWidth+0xea>
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
 801b4d8:	009a      	lsls	r2, r3, #2
 801b4da:	d430      	bmi.n	801b53e <SDMMC_CmdBusWidth+0xee>
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
 801b4dc:	00d9      	lsls	r1, r3, #3
 801b4de:	d430      	bmi.n	801b542 <SDMMC_CmdBusWidth+0xf2>
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
 801b4e0:	011a      	lsls	r2, r3, #4
 801b4e2:	d431      	bmi.n	801b548 <SDMMC_CmdBusWidth+0xf8>
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
 801b4e4:	0159      	lsls	r1, r3, #5
 801b4e6:	d432      	bmi.n	801b54e <SDMMC_CmdBusWidth+0xfe>
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
 801b4e8:	01da      	lsls	r2, r3, #7
 801b4ea:	d433      	bmi.n	801b554 <SDMMC_CmdBusWidth+0x104>
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
 801b4ec:	0219      	lsls	r1, r3, #8
 801b4ee:	d434      	bmi.n	801b55a <SDMMC_CmdBusWidth+0x10a>
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
 801b4f0:	025a      	lsls	r2, r3, #9
 801b4f2:	d435      	bmi.n	801b560 <SDMMC_CmdBusWidth+0x110>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
 801b4f4:	0299      	lsls	r1, r3, #10
 801b4f6:	d43f      	bmi.n	801b578 <SDMMC_CmdBusWidth+0x128>
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
 801b4f8:	02da      	lsls	r2, r3, #11
 801b4fa:	d43a      	bmi.n	801b572 <SDMMC_CmdBusWidth+0x122>
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
 801b4fc:	0359      	lsls	r1, r3, #13
 801b4fe:	d435      	bmi.n	801b56c <SDMMC_CmdBusWidth+0x11c>
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
 801b500:	039a      	lsls	r2, r3, #14
 801b502:	d430      	bmi.n	801b566 <SDMMC_CmdBusWidth+0x116>
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
 801b504:	03d9      	lsls	r1, r3, #15
 801b506:	d440      	bmi.n	801b58a <SDMMC_CmdBusWidth+0x13a>
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
 801b508:	041a      	lsls	r2, r3, #16
 801b50a:	d43b      	bmi.n	801b584 <SDMMC_CmdBusWidth+0x134>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
 801b50c:	0459      	lsls	r1, r3, #17
 801b50e:	d436      	bmi.n	801b57e <SDMMC_CmdBusWidth+0x12e>
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
 801b510:	049a      	lsls	r2, r3, #18
 801b512:	d407      	bmi.n	801b524 <SDMMC_CmdBusWidth+0xd4>
    return SDMMC_ERROR_AKE_SEQ_ERR;
 801b514:	f013 0f08 	tst.w	r3, #8
 801b518:	bf0c      	ite	eq
 801b51a:	f44f 3080 	moveq.w	r0, #65536	@ 0x10000
 801b51e:	f44f 0000 	movne.w	r0, #8388608	@ 0x800000
 801b522:	4770      	bx	lr
    return SDMMC_ERROR_ERASE_RESET;
 801b524:	f44f 0080 	mov.w	r0, #4194304	@ 0x400000
}
 801b528:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 801b52a:	2304      	movs	r3, #4
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 801b52c:	4618      	mov	r0, r3
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 801b52e:	f8cc 3038 	str.w	r3, [ip, #56]	@ 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 801b532:	4770      	bx	lr
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
 801b534:	f04f 7000 	mov.w	r0, #33554432	@ 0x2000000
 801b538:	4770      	bx	lr
    return SDMMC_ERROR_ADDR_MISALIGNED;
 801b53a:	2040      	movs	r0, #64	@ 0x40
 801b53c:	4770      	bx	lr
    return SDMMC_ERROR_BLOCK_LEN_ERR;
 801b53e:	2080      	movs	r0, #128	@ 0x80
 801b540:	4770      	bx	lr
    return SDMMC_ERROR_ERASE_SEQ_ERR;
 801b542:	f44f 7080 	mov.w	r0, #256	@ 0x100
 801b546:	4770      	bx	lr
    return SDMMC_ERROR_BAD_ERASE_PARAM;
 801b548:	f44f 7000 	mov.w	r0, #512	@ 0x200
 801b54c:	4770      	bx	lr
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
 801b54e:	f44f 6080 	mov.w	r0, #1024	@ 0x400
 801b552:	4770      	bx	lr
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
 801b554:	f44f 6000 	mov.w	r0, #2048	@ 0x800
 801b558:	4770      	bx	lr
    return SDMMC_ERROR_COM_CRC_FAILED;
 801b55a:	f44f 5080 	mov.w	r0, #4096	@ 0x1000
 801b55e:	4770      	bx	lr
    return SDMMC_ERROR_ILLEGAL_CMD;
 801b560:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
 801b564:	4770      	bx	lr
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
 801b566:	f44f 2080 	mov.w	r0, #262144	@ 0x40000
 801b56a:	4770      	bx	lr
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
 801b56c:	f44f 3000 	mov.w	r0, #131072	@ 0x20000
 801b570:	4770      	bx	lr
    return SDMMC_ERROR_CC_ERR;
 801b572:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
 801b576:	4770      	bx	lr
    return SDMMC_ERROR_CARD_ECC_FAILED;
 801b578:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
 801b57c:	4770      	bx	lr
    return SDMMC_ERROR_CARD_ECC_DISABLED;
 801b57e:	f44f 1000 	mov.w	r0, #2097152	@ 0x200000
 801b582:	4770      	bx	lr
    return SDMMC_ERROR_WP_ERASE_SKIP;
 801b584:	f44f 1080 	mov.w	r0, #1048576	@ 0x100000
 801b588:	4770      	bx	lr
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
 801b58a:	f44f 2000 	mov.w	r0, #524288	@ 0x80000
 801b58e:	4770      	bx	lr
 801b590:	2000000c 	.word	0x2000000c
 801b594:	10624dd3 	.word	0x10624dd3
 801b598:	fffff000 	.word	0xfffff000
 801b59c:	fdffe008 	.word	0xfdffe008

0801b5a0 <SDMMC_CmdSendSCR>:
{
 801b5a0:	4601      	mov	r1, r0
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801b5a2:	4a4c      	ldr	r2, [pc, #304]	@ (801b6d4 <SDMMC_CmdSendSCR+0x134>)
 801b5a4:	4b4c      	ldr	r3, [pc, #304]	@ (801b6d8 <SDMMC_CmdSendSCR+0x138>)
 801b5a6:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801b5a8:	484c      	ldr	r0, [pc, #304]	@ (801b6dc <SDMMC_CmdSendSCR+0x13c>)
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801b5aa:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801b5ae:	f240 4373 	movw	r3, #1139	@ 0x473
{
 801b5b2:	b410      	push	{r4}
  SDMMCx->ARG = Command->Argument;
 801b5b4:	2400      	movs	r4, #0
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801b5b6:	0a52      	lsrs	r2, r2, #9
  SDMMCx->ARG = Command->Argument;
 801b5b8:	608c      	str	r4, [r1, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801b5ba:	68cc      	ldr	r4, [r1, #12]
 801b5bc:	4020      	ands	r0, r4
 801b5be:	4303      	orrs	r3, r0
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801b5c0:	f241 3088 	movw	r0, #5000	@ 0x1388
 801b5c4:	fb00 f202 	mul.w	r2, r0, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801b5c8:	60cb      	str	r3, [r1, #12]
    if (count-- == 0U)
 801b5ca:	b14a      	cbz	r2, 801b5e0 <SDMMC_CmdSendSCR+0x40>
 801b5cc:	1e53      	subs	r3, r2, #1
    sta_reg = SDMMCx->STA;
 801b5ce:	6b4a      	ldr	r2, [r1, #52]	@ 0x34
    if (count-- == 0U)
 801b5d0:	3b01      	subs	r3, #1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 801b5d2:	f012 0f45 	tst.w	r2, #69	@ 0x45
 801b5d6:	d001      	beq.n	801b5dc <SDMMC_CmdSendSCR+0x3c>
 801b5d8:	0512      	lsls	r2, r2, #20
 801b5da:	d506      	bpl.n	801b5ea <SDMMC_CmdSendSCR+0x4a>
    if (count-- == 0U)
 801b5dc:	1c58      	adds	r0, r3, #1
 801b5de:	d1f6      	bne.n	801b5ce <SDMMC_CmdSendSCR+0x2e>
      return SDMMC_ERROR_TIMEOUT;
 801b5e0:	f04f 4000 	mov.w	r0, #2147483648	@ 0x80000000
}
 801b5e4:	f85d 4b04 	ldr.w	r4, [sp], #4
 801b5e8:	4770      	bx	lr
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 801b5ea:	6b4b      	ldr	r3, [r1, #52]	@ 0x34
 801b5ec:	075c      	lsls	r4, r3, #29
 801b5ee:	d43c      	bmi.n	801b66a <SDMMC_CmdSendSCR+0xca>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 801b5f0:	6b4b      	ldr	r3, [r1, #52]	@ 0x34
 801b5f2:	07d8      	lsls	r0, r3, #31
 801b5f4:	d407      	bmi.n	801b606 <SDMMC_CmdSendSCR+0x66>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 801b5f6:	23c5      	movs	r3, #197	@ 0xc5
 801b5f8:	638b      	str	r3, [r1, #56]	@ 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 801b5fa:	690b      	ldr	r3, [r1, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 801b5fc:	b2db      	uxtb	r3, r3
 801b5fe:	2b33      	cmp	r3, #51	@ 0x33
 801b600:	d004      	beq.n	801b60c <SDMMC_CmdSendSCR+0x6c>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 801b602:	2001      	movs	r0, #1
 801b604:	e7ee      	b.n	801b5e4 <SDMMC_CmdSendSCR+0x44>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 801b606:	2301      	movs	r3, #1
 801b608:	638b      	str	r3, [r1, #56]	@ 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 801b60a:	e7fa      	b.n	801b602 <SDMMC_CmdSendSCR+0x62>
  return (*(__IO uint32_t *) tmp);
 801b60c:	694b      	ldr	r3, [r1, #20]
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 801b60e:	4834      	ldr	r0, [pc, #208]	@ (801b6e0 <SDMMC_CmdSendSCR+0x140>)
 801b610:	4018      	ands	r0, r3
 801b612:	2800      	cmp	r0, #0
 801b614:	d0e6      	beq.n	801b5e4 <SDMMC_CmdSendSCR+0x44>
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
 801b616:	2b00      	cmp	r3, #0
 801b618:	db2b      	blt.n	801b672 <SDMMC_CmdSendSCR+0xd2>
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
 801b61a:	005a      	lsls	r2, r3, #1
 801b61c:	d42c      	bmi.n	801b678 <SDMMC_CmdSendSCR+0xd8>
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
 801b61e:	009c      	lsls	r4, r3, #2
 801b620:	d42c      	bmi.n	801b67c <SDMMC_CmdSendSCR+0xdc>
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
 801b622:	00d9      	lsls	r1, r3, #3
 801b624:	d42c      	bmi.n	801b680 <SDMMC_CmdSendSCR+0xe0>
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
 801b626:	011a      	lsls	r2, r3, #4
 801b628:	d42d      	bmi.n	801b686 <SDMMC_CmdSendSCR+0xe6>
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
 801b62a:	015c      	lsls	r4, r3, #5
 801b62c:	d42e      	bmi.n	801b68c <SDMMC_CmdSendSCR+0xec>
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
 801b62e:	01d9      	lsls	r1, r3, #7
 801b630:	d42f      	bmi.n	801b692 <SDMMC_CmdSendSCR+0xf2>
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
 801b632:	021a      	lsls	r2, r3, #8
 801b634:	d430      	bmi.n	801b698 <SDMMC_CmdSendSCR+0xf8>
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
 801b636:	025c      	lsls	r4, r3, #9
 801b638:	d431      	bmi.n	801b69e <SDMMC_CmdSendSCR+0xfe>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
 801b63a:	0299      	lsls	r1, r3, #10
 801b63c:	d43b      	bmi.n	801b6b6 <SDMMC_CmdSendSCR+0x116>
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
 801b63e:	02da      	lsls	r2, r3, #11
 801b640:	d436      	bmi.n	801b6b0 <SDMMC_CmdSendSCR+0x110>
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
 801b642:	035c      	lsls	r4, r3, #13
 801b644:	d431      	bmi.n	801b6aa <SDMMC_CmdSendSCR+0x10a>
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
 801b646:	0399      	lsls	r1, r3, #14
 801b648:	d42c      	bmi.n	801b6a4 <SDMMC_CmdSendSCR+0x104>
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
 801b64a:	03da      	lsls	r2, r3, #15
 801b64c:	d43f      	bmi.n	801b6ce <SDMMC_CmdSendSCR+0x12e>
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
 801b64e:	041c      	lsls	r4, r3, #16
 801b650:	d43a      	bmi.n	801b6c8 <SDMMC_CmdSendSCR+0x128>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
 801b652:	0459      	lsls	r1, r3, #17
 801b654:	d435      	bmi.n	801b6c2 <SDMMC_CmdSendSCR+0x122>
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
 801b656:	049a      	lsls	r2, r3, #18
 801b658:	d430      	bmi.n	801b6bc <SDMMC_CmdSendSCR+0x11c>
    return SDMMC_ERROR_AKE_SEQ_ERR;
 801b65a:	f013 0f08 	tst.w	r3, #8
 801b65e:	bf0c      	ite	eq
 801b660:	f44f 3080 	moveq.w	r0, #65536	@ 0x10000
 801b664:	f44f 0000 	movne.w	r0, #8388608	@ 0x800000
 801b668:	e7bc      	b.n	801b5e4 <SDMMC_CmdSendSCR+0x44>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 801b66a:	2304      	movs	r3, #4
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 801b66c:	4618      	mov	r0, r3
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 801b66e:	638b      	str	r3, [r1, #56]	@ 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 801b670:	e7b8      	b.n	801b5e4 <SDMMC_CmdSendSCR+0x44>
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
 801b672:	f04f 7000 	mov.w	r0, #33554432	@ 0x2000000
 801b676:	e7b5      	b.n	801b5e4 <SDMMC_CmdSendSCR+0x44>
    return SDMMC_ERROR_ADDR_MISALIGNED;
 801b678:	2040      	movs	r0, #64	@ 0x40
 801b67a:	e7b3      	b.n	801b5e4 <SDMMC_CmdSendSCR+0x44>
    return SDMMC_ERROR_BLOCK_LEN_ERR;
 801b67c:	2080      	movs	r0, #128	@ 0x80
 801b67e:	e7b1      	b.n	801b5e4 <SDMMC_CmdSendSCR+0x44>
    return SDMMC_ERROR_ERASE_SEQ_ERR;
 801b680:	f44f 7080 	mov.w	r0, #256	@ 0x100
 801b684:	e7ae      	b.n	801b5e4 <SDMMC_CmdSendSCR+0x44>
    return SDMMC_ERROR_BAD_ERASE_PARAM;
 801b686:	f44f 7000 	mov.w	r0, #512	@ 0x200
 801b68a:	e7ab      	b.n	801b5e4 <SDMMC_CmdSendSCR+0x44>
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
 801b68c:	f44f 6080 	mov.w	r0, #1024	@ 0x400
 801b690:	e7a8      	b.n	801b5e4 <SDMMC_CmdSendSCR+0x44>
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
 801b692:	f44f 6000 	mov.w	r0, #2048	@ 0x800
 801b696:	e7a5      	b.n	801b5e4 <SDMMC_CmdSendSCR+0x44>
    return SDMMC_ERROR_COM_CRC_FAILED;
 801b698:	f44f 5080 	mov.w	r0, #4096	@ 0x1000
 801b69c:	e7a2      	b.n	801b5e4 <SDMMC_CmdSendSCR+0x44>
    return SDMMC_ERROR_ILLEGAL_CMD;
 801b69e:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
 801b6a2:	e79f      	b.n	801b5e4 <SDMMC_CmdSendSCR+0x44>
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
 801b6a4:	f44f 2080 	mov.w	r0, #262144	@ 0x40000
 801b6a8:	e79c      	b.n	801b5e4 <SDMMC_CmdSendSCR+0x44>
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
 801b6aa:	f44f 3000 	mov.w	r0, #131072	@ 0x20000
 801b6ae:	e799      	b.n	801b5e4 <SDMMC_CmdSendSCR+0x44>
    return SDMMC_ERROR_CC_ERR;
 801b6b0:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
 801b6b4:	e796      	b.n	801b5e4 <SDMMC_CmdSendSCR+0x44>
    return SDMMC_ERROR_CARD_ECC_FAILED;
 801b6b6:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
 801b6ba:	e793      	b.n	801b5e4 <SDMMC_CmdSendSCR+0x44>
    return SDMMC_ERROR_ERASE_RESET;
 801b6bc:	f44f 0080 	mov.w	r0, #4194304	@ 0x400000
 801b6c0:	e790      	b.n	801b5e4 <SDMMC_CmdSendSCR+0x44>
    return SDMMC_ERROR_CARD_ECC_DISABLED;
 801b6c2:	f44f 1000 	mov.w	r0, #2097152	@ 0x200000
 801b6c6:	e78d      	b.n	801b5e4 <SDMMC_CmdSendSCR+0x44>
    return SDMMC_ERROR_WP_ERASE_SKIP;
 801b6c8:	f44f 1080 	mov.w	r0, #1048576	@ 0x100000
 801b6cc:	e78a      	b.n	801b5e4 <SDMMC_CmdSendSCR+0x44>
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
 801b6ce:	f44f 2000 	mov.w	r0, #524288	@ 0x80000
 801b6d2:	e787      	b.n	801b5e4 <SDMMC_CmdSendSCR+0x44>
 801b6d4:	2000000c 	.word	0x2000000c
 801b6d8:	10624dd3 	.word	0x10624dd3
 801b6dc:	fffff000 	.word	0xfffff000
 801b6e0:	fdffe008 	.word	0xfdffe008

0801b6e4 <SDMMC_CmdSendCID>:
{
 801b6e4:	4601      	mov	r1, r0
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 801b6e6:	4a1a      	ldr	r2, [pc, #104]	@ (801b750 <SDMMC_CmdSendCID+0x6c>)
 801b6e8:	4b1a      	ldr	r3, [pc, #104]	@ (801b754 <SDMMC_CmdSendCID+0x70>)
 801b6ea:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801b6ec:	481a      	ldr	r0, [pc, #104]	@ (801b758 <SDMMC_CmdSendCID+0x74>)
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 801b6ee:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801b6f2:	f240 43c2 	movw	r3, #1218	@ 0x4c2
{
 801b6f6:	b410      	push	{r4}
  SDMMCx->ARG = Command->Argument;
 801b6f8:	2400      	movs	r4, #0
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 801b6fa:	0a52      	lsrs	r2, r2, #9
  SDMMCx->ARG = Command->Argument;
 801b6fc:	608c      	str	r4, [r1, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801b6fe:	68cc      	ldr	r4, [r1, #12]
 801b700:	4020      	ands	r0, r4
 801b702:	4303      	orrs	r3, r0
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 801b704:	f241 3088 	movw	r0, #5000	@ 0x1388
 801b708:	fb00 f202 	mul.w	r2, r0, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801b70c:	60cb      	str	r3, [r1, #12]
    if (count-- == 0U)
 801b70e:	b14a      	cbz	r2, 801b724 <SDMMC_CmdSendCID+0x40>
 801b710:	1e53      	subs	r3, r2, #1
    sta_reg = SDMMCx->STA;
 801b712:	6b4a      	ldr	r2, [r1, #52]	@ 0x34
    if (count-- == 0U)
 801b714:	3b01      	subs	r3, #1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 801b716:	f012 0f45 	tst.w	r2, #69	@ 0x45
 801b71a:	d001      	beq.n	801b720 <SDMMC_CmdSendCID+0x3c>
 801b71c:	0512      	lsls	r2, r2, #20
 801b71e:	d506      	bpl.n	801b72e <SDMMC_CmdSendCID+0x4a>
    if (count-- == 0U)
 801b720:	1c58      	adds	r0, r3, #1
 801b722:	d1f6      	bne.n	801b712 <SDMMC_CmdSendCID+0x2e>
      return SDMMC_ERROR_TIMEOUT;
 801b724:	f04f 4000 	mov.w	r0, #2147483648	@ 0x80000000
}
 801b728:	f85d 4b04 	ldr.w	r4, [sp], #4
 801b72c:	4770      	bx	lr
  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 801b72e:	6b4b      	ldr	r3, [r1, #52]	@ 0x34
 801b730:	075b      	lsls	r3, r3, #29
 801b732:	d409      	bmi.n	801b748 <SDMMC_CmdSendCID+0x64>
  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 801b734:	6b48      	ldr	r0, [r1, #52]	@ 0x34
}
 801b736:	f85d 4b04 	ldr.w	r4, [sp], #4
  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 801b73a:	f010 0001 	ands.w	r0, r0, #1
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 801b73e:	bf14      	ite	ne
 801b740:	2301      	movne	r3, #1
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 801b742:	23c5      	moveq	r3, #197	@ 0xc5
 801b744:	638b      	str	r3, [r1, #56]	@ 0x38
}
 801b746:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 801b748:	2304      	movs	r3, #4
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 801b74a:	4618      	mov	r0, r3
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 801b74c:	638b      	str	r3, [r1, #56]	@ 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 801b74e:	e7eb      	b.n	801b728 <SDMMC_CmdSendCID+0x44>
 801b750:	2000000c 	.word	0x2000000c
 801b754:	10624dd3 	.word	0x10624dd3
 801b758:	fffff000 	.word	0xfffff000

0801b75c <SDMMC_CmdSendCSD>:
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 801b75c:	4a1b      	ldr	r2, [pc, #108]	@ (801b7cc <SDMMC_CmdSendCSD+0x70>)
{
 801b75e:	4684      	mov	ip, r0
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 801b760:	4b1b      	ldr	r3, [pc, #108]	@ (801b7d0 <SDMMC_CmdSendCSD+0x74>)
 801b762:	6812      	ldr	r2, [r2, #0]
  SDMMCx->ARG = Command->Argument;
 801b764:	f8cc 1008 	str.w	r1, [ip, #8]
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 801b768:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801b76c:	f8dc 100c 	ldr.w	r1, [ip, #12]
 801b770:	4818      	ldr	r0, [pc, #96]	@ (801b7d4 <SDMMC_CmdSendCSD+0x78>)
 801b772:	f240 43c9 	movw	r3, #1225	@ 0x4c9
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 801b776:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801b778:	4008      	ands	r0, r1
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 801b77a:	f241 3188 	movw	r1, #5000	@ 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801b77e:	4303      	orrs	r3, r0
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 801b780:	fb01 f202 	mul.w	r2, r1, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801b784:	f8cc 300c 	str.w	r3, [ip, #12]
    if (count-- == 0U)
 801b788:	1e53      	subs	r3, r2, #1
 801b78a:	b14a      	cbz	r2, 801b7a0 <SDMMC_CmdSendCSD+0x44>
    sta_reg = SDMMCx->STA;
 801b78c:	f8dc 2034 	ldr.w	r2, [ip, #52]	@ 0x34
    if (count-- == 0U)
 801b790:	3b01      	subs	r3, #1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 801b792:	f012 0f45 	tst.w	r2, #69	@ 0x45
 801b796:	d001      	beq.n	801b79c <SDMMC_CmdSendCSD+0x40>
 801b798:	0512      	lsls	r2, r2, #20
 801b79a:	d504      	bpl.n	801b7a6 <SDMMC_CmdSendCSD+0x4a>
    if (count-- == 0U)
 801b79c:	1c59      	adds	r1, r3, #1
 801b79e:	d1f5      	bne.n	801b78c <SDMMC_CmdSendCSD+0x30>
      return SDMMC_ERROR_TIMEOUT;
 801b7a0:	f04f 4000 	mov.w	r0, #2147483648	@ 0x80000000
}
 801b7a4:	4770      	bx	lr
  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 801b7a6:	f8dc 3034 	ldr.w	r3, [ip, #52]	@ 0x34
 801b7aa:	075b      	lsls	r3, r3, #29
 801b7ac:	d409      	bmi.n	801b7c2 <SDMMC_CmdSendCSD+0x66>
  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 801b7ae:	f8dc 0034 	ldr.w	r0, [ip, #52]	@ 0x34
 801b7b2:	f010 0001 	ands.w	r0, r0, #1
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 801b7b6:	bf14      	ite	ne
 801b7b8:	2301      	movne	r3, #1
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 801b7ba:	23c5      	moveq	r3, #197	@ 0xc5
 801b7bc:	f8cc 3038 	str.w	r3, [ip, #56]	@ 0x38
  return SDMMC_ERROR_NONE;
 801b7c0:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 801b7c2:	2304      	movs	r3, #4
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 801b7c4:	4618      	mov	r0, r3
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 801b7c6:	f8cc 3038 	str.w	r3, [ip, #56]	@ 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 801b7ca:	4770      	bx	lr
 801b7cc:	2000000c 	.word	0x2000000c
 801b7d0:	10624dd3 	.word	0x10624dd3
 801b7d4:	fffff000 	.word	0xfffff000

0801b7d8 <SDMMC_CmdSetRelAdd>:
  SDMMCx->ARG = Command->Argument;
 801b7d8:	2300      	movs	r3, #0
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 801b7da:	4a2b      	ldr	r2, [pc, #172]	@ (801b888 <SDMMC_CmdSetRelAdd+0xb0>)
{
 801b7dc:	4684      	mov	ip, r0
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 801b7de:	6812      	ldr	r2, [r2, #0]
{
 801b7e0:	b410      	push	{r4}
  SDMMCx->ARG = Command->Argument;
 801b7e2:	6083      	str	r3, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801b7e4:	68c3      	ldr	r3, [r0, #12]
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 801b7e6:	4829      	ldr	r0, [pc, #164]	@ (801b88c <SDMMC_CmdSetRelAdd+0xb4>)
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801b7e8:	4c29      	ldr	r4, [pc, #164]	@ (801b890 <SDMMC_CmdSetRelAdd+0xb8>)
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 801b7ea:	fba0 0202 	umull	r0, r2, r0, r2
 801b7ee:	f241 3088 	movw	r0, #5000	@ 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801b7f2:	401c      	ands	r4, r3
 801b7f4:	f240 4343 	movw	r3, #1091	@ 0x443
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 801b7f8:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801b7fa:	4323      	orrs	r3, r4
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 801b7fc:	fb00 f202 	mul.w	r2, r0, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801b800:	f8cc 300c 	str.w	r3, [ip, #12]
    if (count-- == 0U)
 801b804:	b152      	cbz	r2, 801b81c <SDMMC_CmdSetRelAdd+0x44>
 801b806:	1e53      	subs	r3, r2, #1
    sta_reg = SDMMCx->STA;
 801b808:	f8dc 2034 	ldr.w	r2, [ip, #52]	@ 0x34
    if (count-- == 0U)
 801b80c:	3b01      	subs	r3, #1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 801b80e:	f012 0f45 	tst.w	r2, #69	@ 0x45
 801b812:	d001      	beq.n	801b818 <SDMMC_CmdSetRelAdd+0x40>
 801b814:	0512      	lsls	r2, r2, #20
 801b816:	d506      	bpl.n	801b826 <SDMMC_CmdSetRelAdd+0x4e>
    if (count-- == 0U)
 801b818:	1c58      	adds	r0, r3, #1
 801b81a:	d1f5      	bne.n	801b808 <SDMMC_CmdSetRelAdd+0x30>
      return SDMMC_ERROR_TIMEOUT;
 801b81c:	f04f 4000 	mov.w	r0, #2147483648	@ 0x80000000
}
 801b820:	f85d 4b04 	ldr.w	r4, [sp], #4
 801b824:	4770      	bx	lr
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 801b826:	f8dc 3034 	ldr.w	r3, [ip, #52]	@ 0x34
 801b82a:	075c      	lsls	r4, r3, #29
 801b82c:	d420      	bmi.n	801b870 <SDMMC_CmdSetRelAdd+0x98>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 801b82e:	f8dc 3034 	ldr.w	r3, [ip, #52]	@ 0x34
 801b832:	07d8      	lsls	r0, r3, #31
 801b834:	d406      	bmi.n	801b844 <SDMMC_CmdSetRelAdd+0x6c>
  return (uint8_t)(SDMMCx->RESPCMD);
 801b836:	f8dc 3010 	ldr.w	r3, [ip, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 801b83a:	b2db      	uxtb	r3, r3
 801b83c:	2b03      	cmp	r3, #3
 801b83e:	d005      	beq.n	801b84c <SDMMC_CmdSetRelAdd+0x74>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 801b840:	2001      	movs	r0, #1
 801b842:	e7ed      	b.n	801b820 <SDMMC_CmdSetRelAdd+0x48>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 801b844:	2301      	movs	r3, #1
 801b846:	f8cc 3038 	str.w	r3, [ip, #56]	@ 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 801b84a:	e7f9      	b.n	801b840 <SDMMC_CmdSetRelAdd+0x68>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 801b84c:	23c5      	movs	r3, #197	@ 0xc5
 801b84e:	f8cc 3038 	str.w	r3, [ip, #56]	@ 0x38
  return (*(__IO uint32_t *) tmp);
 801b852:	f8dc 3014 	ldr.w	r3, [ip, #20]
  if((response_r1 & (SDMMC_R6_GENERAL_UNKNOWN_ERROR | SDMMC_R6_ILLEGAL_CMD | SDMMC_R6_COM_CRC_FAILED)) == SDMMC_ALLZERO)
 801b856:	f413 4060 	ands.w	r0, r3, #57344	@ 0xe000
 801b85a:	d011      	beq.n	801b880 <SDMMC_CmdSetRelAdd+0xa8>
  else if((response_r1 & SDMMC_R6_ILLEGAL_CMD) == SDMMC_R6_ILLEGAL_CMD)
 801b85c:	045a      	lsls	r2, r3, #17
 801b85e:	d40c      	bmi.n	801b87a <SDMMC_CmdSetRelAdd+0xa2>
    return SDMMC_ERROR_COM_CRC_FAILED;
 801b860:	f413 4f00 	tst.w	r3, #32768	@ 0x8000
 801b864:	bf0c      	ite	eq
 801b866:	f44f 3080 	moveq.w	r0, #65536	@ 0x10000
 801b86a:	f44f 5080 	movne.w	r0, #4096	@ 0x1000
 801b86e:	e7d7      	b.n	801b820 <SDMMC_CmdSetRelAdd+0x48>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 801b870:	2304      	movs	r3, #4
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 801b872:	4618      	mov	r0, r3
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 801b874:	f8cc 3038 	str.w	r3, [ip, #56]	@ 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 801b878:	e7d2      	b.n	801b820 <SDMMC_CmdSetRelAdd+0x48>
    return SDMMC_ERROR_ILLEGAL_CMD;
 801b87a:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
 801b87e:	e7cf      	b.n	801b820 <SDMMC_CmdSetRelAdd+0x48>
    *pRCA = (uint16_t) (response_r1 >> 16);
 801b880:	0c1b      	lsrs	r3, r3, #16
 801b882:	800b      	strh	r3, [r1, #0]
    return SDMMC_ERROR_NONE;
 801b884:	e7cc      	b.n	801b820 <SDMMC_CmdSetRelAdd+0x48>
 801b886:	bf00      	nop
 801b888:	2000000c 	.word	0x2000000c
 801b88c:	10624dd3 	.word	0x10624dd3
 801b890:	fffff000 	.word	0xfffff000

0801b894 <SDMMC_CmdSendStatus>:
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801b894:	4a4f      	ldr	r2, [pc, #316]	@ (801b9d4 <SDMMC_CmdSendStatus+0x140>)
{
 801b896:	4684      	mov	ip, r0
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801b898:	4b4f      	ldr	r3, [pc, #316]	@ (801b9d8 <SDMMC_CmdSendStatus+0x144>)
 801b89a:	6812      	ldr	r2, [r2, #0]
  SDMMCx->ARG = Command->Argument;
 801b89c:	f8cc 1008 	str.w	r1, [ip, #8]
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801b8a0:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801b8a4:	f8dc 100c 	ldr.w	r1, [ip, #12]
 801b8a8:	484c      	ldr	r0, [pc, #304]	@ (801b9dc <SDMMC_CmdSendStatus+0x148>)
 801b8aa:	f240 434d 	movw	r3, #1101	@ 0x44d
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801b8ae:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801b8b0:	4008      	ands	r0, r1
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801b8b2:	f241 3188 	movw	r1, #5000	@ 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801b8b6:	4303      	orrs	r3, r0
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801b8b8:	fb01 f202 	mul.w	r2, r1, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801b8bc:	f8cc 300c 	str.w	r3, [ip, #12]
    if (count-- == 0U)
 801b8c0:	1e53      	subs	r3, r2, #1
 801b8c2:	b14a      	cbz	r2, 801b8d8 <SDMMC_CmdSendStatus+0x44>
    sta_reg = SDMMCx->STA;
 801b8c4:	f8dc 2034 	ldr.w	r2, [ip, #52]	@ 0x34
    if (count-- == 0U)
 801b8c8:	3b01      	subs	r3, #1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 801b8ca:	f012 0f45 	tst.w	r2, #69	@ 0x45
 801b8ce:	d001      	beq.n	801b8d4 <SDMMC_CmdSendStatus+0x40>
 801b8d0:	0512      	lsls	r2, r2, #20
 801b8d2:	d504      	bpl.n	801b8de <SDMMC_CmdSendStatus+0x4a>
    if (count-- == 0U)
 801b8d4:	1c59      	adds	r1, r3, #1
 801b8d6:	d1f5      	bne.n	801b8c4 <SDMMC_CmdSendStatus+0x30>
      return SDMMC_ERROR_TIMEOUT;
 801b8d8:	f04f 4000 	mov.w	r0, #2147483648	@ 0x80000000
 801b8dc:	4770      	bx	lr
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 801b8de:	f8dc 3034 	ldr.w	r3, [ip, #52]	@ 0x34
 801b8e2:	075b      	lsls	r3, r3, #29
 801b8e4:	d443      	bmi.n	801b96e <SDMMC_CmdSendStatus+0xda>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 801b8e6:	f8dc 3034 	ldr.w	r3, [ip, #52]	@ 0x34
 801b8ea:	07d8      	lsls	r0, r3, #31
 801b8ec:	d409      	bmi.n	801b902 <SDMMC_CmdSendStatus+0x6e>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 801b8ee:	23c5      	movs	r3, #197	@ 0xc5
 801b8f0:	f8cc 3038 	str.w	r3, [ip, #56]	@ 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 801b8f4:	f8dc 3010 	ldr.w	r3, [ip, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 801b8f8:	b2db      	uxtb	r3, r3
 801b8fa:	2b0d      	cmp	r3, #13
 801b8fc:	d005      	beq.n	801b90a <SDMMC_CmdSendStatus+0x76>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 801b8fe:	2001      	movs	r0, #1
 801b900:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 801b902:	2301      	movs	r3, #1
 801b904:	f8cc 3038 	str.w	r3, [ip, #56]	@ 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 801b908:	e7f9      	b.n	801b8fe <SDMMC_CmdSendStatus+0x6a>
  return (*(__IO uint32_t *) tmp);
 801b90a:	f8dc 3014 	ldr.w	r3, [ip, #20]
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 801b90e:	4834      	ldr	r0, [pc, #208]	@ (801b9e0 <SDMMC_CmdSendStatus+0x14c>)
 801b910:	4018      	ands	r0, r3
 801b912:	b358      	cbz	r0, 801b96c <SDMMC_CmdSendStatus+0xd8>
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
 801b914:	2b00      	cmp	r3, #0
 801b916:	db2f      	blt.n	801b978 <SDMMC_CmdSendStatus+0xe4>
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
 801b918:	0059      	lsls	r1, r3, #1
 801b91a:	d430      	bmi.n	801b97e <SDMMC_CmdSendStatus+0xea>
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
 801b91c:	009a      	lsls	r2, r3, #2
 801b91e:	d430      	bmi.n	801b982 <SDMMC_CmdSendStatus+0xee>
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
 801b920:	00d9      	lsls	r1, r3, #3
 801b922:	d430      	bmi.n	801b986 <SDMMC_CmdSendStatus+0xf2>
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
 801b924:	011a      	lsls	r2, r3, #4
 801b926:	d431      	bmi.n	801b98c <SDMMC_CmdSendStatus+0xf8>
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
 801b928:	0159      	lsls	r1, r3, #5
 801b92a:	d432      	bmi.n	801b992 <SDMMC_CmdSendStatus+0xfe>
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
 801b92c:	01da      	lsls	r2, r3, #7
 801b92e:	d433      	bmi.n	801b998 <SDMMC_CmdSendStatus+0x104>
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
 801b930:	0219      	lsls	r1, r3, #8
 801b932:	d434      	bmi.n	801b99e <SDMMC_CmdSendStatus+0x10a>
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
 801b934:	025a      	lsls	r2, r3, #9
 801b936:	d435      	bmi.n	801b9a4 <SDMMC_CmdSendStatus+0x110>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
 801b938:	0299      	lsls	r1, r3, #10
 801b93a:	d43f      	bmi.n	801b9bc <SDMMC_CmdSendStatus+0x128>
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
 801b93c:	02da      	lsls	r2, r3, #11
 801b93e:	d43a      	bmi.n	801b9b6 <SDMMC_CmdSendStatus+0x122>
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
 801b940:	0359      	lsls	r1, r3, #13
 801b942:	d435      	bmi.n	801b9b0 <SDMMC_CmdSendStatus+0x11c>
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
 801b944:	039a      	lsls	r2, r3, #14
 801b946:	d430      	bmi.n	801b9aa <SDMMC_CmdSendStatus+0x116>
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
 801b948:	03d9      	lsls	r1, r3, #15
 801b94a:	d440      	bmi.n	801b9ce <SDMMC_CmdSendStatus+0x13a>
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
 801b94c:	041a      	lsls	r2, r3, #16
 801b94e:	d43b      	bmi.n	801b9c8 <SDMMC_CmdSendStatus+0x134>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
 801b950:	0459      	lsls	r1, r3, #17
 801b952:	d436      	bmi.n	801b9c2 <SDMMC_CmdSendStatus+0x12e>
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
 801b954:	049a      	lsls	r2, r3, #18
 801b956:	d407      	bmi.n	801b968 <SDMMC_CmdSendStatus+0xd4>
    return SDMMC_ERROR_AKE_SEQ_ERR;
 801b958:	f013 0f08 	tst.w	r3, #8
 801b95c:	bf0c      	ite	eq
 801b95e:	f44f 3080 	moveq.w	r0, #65536	@ 0x10000
 801b962:	f44f 0000 	movne.w	r0, #8388608	@ 0x800000
 801b966:	4770      	bx	lr
    return SDMMC_ERROR_ERASE_RESET;
 801b968:	f44f 0080 	mov.w	r0, #4194304	@ 0x400000
}
 801b96c:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 801b96e:	2304      	movs	r3, #4
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 801b970:	4618      	mov	r0, r3
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 801b972:	f8cc 3038 	str.w	r3, [ip, #56]	@ 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 801b976:	4770      	bx	lr
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
 801b978:	f04f 7000 	mov.w	r0, #33554432	@ 0x2000000
 801b97c:	4770      	bx	lr
    return SDMMC_ERROR_ADDR_MISALIGNED;
 801b97e:	2040      	movs	r0, #64	@ 0x40
 801b980:	4770      	bx	lr
    return SDMMC_ERROR_BLOCK_LEN_ERR;
 801b982:	2080      	movs	r0, #128	@ 0x80
 801b984:	4770      	bx	lr
    return SDMMC_ERROR_ERASE_SEQ_ERR;
 801b986:	f44f 7080 	mov.w	r0, #256	@ 0x100
 801b98a:	4770      	bx	lr
    return SDMMC_ERROR_BAD_ERASE_PARAM;
 801b98c:	f44f 7000 	mov.w	r0, #512	@ 0x200
 801b990:	4770      	bx	lr
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
 801b992:	f44f 6080 	mov.w	r0, #1024	@ 0x400
 801b996:	4770      	bx	lr
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
 801b998:	f44f 6000 	mov.w	r0, #2048	@ 0x800
 801b99c:	4770      	bx	lr
    return SDMMC_ERROR_COM_CRC_FAILED;
 801b99e:	f44f 5080 	mov.w	r0, #4096	@ 0x1000
 801b9a2:	4770      	bx	lr
    return SDMMC_ERROR_ILLEGAL_CMD;
 801b9a4:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
 801b9a8:	4770      	bx	lr
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
 801b9aa:	f44f 2080 	mov.w	r0, #262144	@ 0x40000
 801b9ae:	4770      	bx	lr
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
 801b9b0:	f44f 3000 	mov.w	r0, #131072	@ 0x20000
 801b9b4:	4770      	bx	lr
    return SDMMC_ERROR_CC_ERR;
 801b9b6:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
 801b9ba:	4770      	bx	lr
    return SDMMC_ERROR_CARD_ECC_FAILED;
 801b9bc:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
 801b9c0:	4770      	bx	lr
    return SDMMC_ERROR_CARD_ECC_DISABLED;
 801b9c2:	f44f 1000 	mov.w	r0, #2097152	@ 0x200000
 801b9c6:	4770      	bx	lr
    return SDMMC_ERROR_WP_ERASE_SKIP;
 801b9c8:	f44f 1080 	mov.w	r0, #1048576	@ 0x100000
 801b9cc:	4770      	bx	lr
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
 801b9ce:	f44f 2000 	mov.w	r0, #524288	@ 0x80000
 801b9d2:	4770      	bx	lr
 801b9d4:	2000000c 	.word	0x2000000c
 801b9d8:	10624dd3 	.word	0x10624dd3
 801b9dc:	fffff000 	.word	0xfffff000
 801b9e0:	fdffe008 	.word	0xfdffe008

0801b9e4 <USB_CoreInit>:
  * @param  cfg pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 801b9e4:	b084      	sub	sp, #16
 801b9e6:	b082      	sub	sp, #8
 801b9e8:	f10d 0c0c 	add.w	ip, sp, #12
 801b9ec:	e88c 000e 	stmia.w	ip, {r1, r2, r3}
  HAL_StatusTypeDef ret;

  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 801b9f0:	f89d 2011 	ldrb.w	r2, [sp, #17]
{
 801b9f4:	4603      	mov	r3, r0
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 801b9f6:	2a01      	cmp	r2, #1
 801b9f8:	d12e      	bne.n	801ba58 <USB_CoreInit+0x74>
  {
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 801b9fa:	6b81      	ldr	r1, [r0, #56]	@ 0x38

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
 801b9fc:	f1a2 1242 	sub.w	r2, r2, #4325442	@ 0x420042
#endif /* defined(STM32F722xx) || defined(STM32F723xx) || defined(STM32F730xx) ||
          defined(STM32F732xx) || defined(STM32F733xx) */

    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
    if (cfg.use_external_vbus == 1U)
 801ba00:	f89d 0018 	ldrb.w	r0, [sp, #24]
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 801ba04:	f421 3180 	bic.w	r1, r1, #65536	@ 0x10000
    if (cfg.use_external_vbus == 1U)
 801ba08:	2801      	cmp	r0, #1
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 801ba0a:	6399      	str	r1, [r3, #56]	@ 0x38
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
 801ba0c:	68d9      	ldr	r1, [r3, #12]
 801ba0e:	ea02 0201 	and.w	r2, r2, r1
 801ba12:	60da      	str	r2, [r3, #12]
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
 801ba14:	68da      	ldr	r2, [r3, #12]
 801ba16:	f422 1240 	bic.w	r2, r2, #3145728	@ 0x300000
 801ba1a:	60da      	str	r2, [r3, #12]
    if (cfg.use_external_vbus == 1U)
 801ba1c:	d059      	beq.n	801bad2 <USB_CoreInit+0xee>
  * @param  USBx  Selected device
  * @retval HAL status
  */
static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx)
{
  __IO uint32_t count = 0U;
 801ba1e:	2200      	movs	r2, #0
 801ba20:	9200      	str	r2, [sp, #0]
 801ba22:	e002      	b.n	801ba2a <USB_CoreInit+0x46>

    if (count > HAL_USB_TIMEOUT)
    {
      return HAL_TIMEOUT;
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 801ba24:	691a      	ldr	r2, [r3, #16]
 801ba26:	2a00      	cmp	r2, #0
 801ba28:	db2d      	blt.n	801ba86 <USB_CoreInit+0xa2>
    count++;
 801ba2a:	9a00      	ldr	r2, [sp, #0]
 801ba2c:	3201      	adds	r2, #1
 801ba2e:	9200      	str	r2, [sp, #0]
    if (count > HAL_USB_TIMEOUT)
 801ba30:	9a00      	ldr	r2, [sp, #0]
 801ba32:	f1b2 6f70 	cmp.w	r2, #251658240	@ 0xf000000
 801ba36:	d9f5      	bls.n	801ba24 <USB_CoreInit+0x40>
      return HAL_TIMEOUT;
 801ba38:	2003      	movs	r0, #3
  if (cfg.dma_enable == 1U)
 801ba3a:	f89d 200e 	ldrb.w	r2, [sp, #14]
 801ba3e:	2a01      	cmp	r2, #1
 801ba40:	d107      	bne.n	801ba52 <USB_CoreInit+0x6e>
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_HBSTLEN_2;
 801ba42:	689a      	ldr	r2, [r3, #8]
 801ba44:	f042 0206 	orr.w	r2, r2, #6
 801ba48:	609a      	str	r2, [r3, #8]
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
 801ba4a:	689a      	ldr	r2, [r3, #8]
 801ba4c:	f042 0220 	orr.w	r2, r2, #32
 801ba50:	609a      	str	r2, [r3, #8]
}
 801ba52:	b002      	add	sp, #8
 801ba54:	b004      	add	sp, #16
 801ba56:	4770      	bx	lr
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
 801ba58:	68c2      	ldr	r2, [r0, #12]
  __IO uint32_t count = 0U;
 801ba5a:	2100      	movs	r1, #0
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
 801ba5c:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 801ba60:	60c2      	str	r2, [r0, #12]
  __IO uint32_t count = 0U;
 801ba62:	9101      	str	r1, [sp, #4]
 801ba64:	e002      	b.n	801ba6c <USB_CoreInit+0x88>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 801ba66:	691a      	ldr	r2, [r3, #16]
 801ba68:	2a00      	cmp	r2, #0
 801ba6a:	db1f      	blt.n	801baac <USB_CoreInit+0xc8>
    count++;
 801ba6c:	9a01      	ldr	r2, [sp, #4]
 801ba6e:	3201      	adds	r2, #1
 801ba70:	9201      	str	r2, [sp, #4]
    if (count > HAL_USB_TIMEOUT)
 801ba72:	9a01      	ldr	r2, [sp, #4]
 801ba74:	f1b2 6f70 	cmp.w	r2, #251658240	@ 0xf000000
 801ba78:	d9f5      	bls.n	801ba66 <USB_CoreInit+0x82>
      return HAL_TIMEOUT;
 801ba7a:	2003      	movs	r0, #3
    USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
 801ba7c:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 801ba7e:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
 801ba82:	639a      	str	r2, [r3, #56]	@ 0x38
 801ba84:	e7d9      	b.n	801ba3a <USB_CoreInit+0x56>

  /* Core Soft Reset */
  count = 0U;
 801ba86:	2200      	movs	r2, #0
 801ba88:	9200      	str	r2, [sp, #0]
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 801ba8a:	691a      	ldr	r2, [r3, #16]
 801ba8c:	f042 0201 	orr.w	r2, r2, #1
 801ba90:	611a      	str	r2, [r3, #16]
 801ba92:	e003      	b.n	801ba9c <USB_CoreInit+0xb8>

    if (count > HAL_USB_TIMEOUT)
    {
      return HAL_TIMEOUT;
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
 801ba94:	6918      	ldr	r0, [r3, #16]
 801ba96:	f010 0001 	ands.w	r0, r0, #1
 801ba9a:	d0ce      	beq.n	801ba3a <USB_CoreInit+0x56>
    count++;
 801ba9c:	9a00      	ldr	r2, [sp, #0]
 801ba9e:	3201      	adds	r2, #1
 801baa0:	9200      	str	r2, [sp, #0]
    if (count > HAL_USB_TIMEOUT)
 801baa2:	9a00      	ldr	r2, [sp, #0]
 801baa4:	f1b2 6f70 	cmp.w	r2, #251658240	@ 0xf000000
 801baa8:	d9f4      	bls.n	801ba94 <USB_CoreInit+0xb0>
 801baaa:	e7c5      	b.n	801ba38 <USB_CoreInit+0x54>
  count = 0U;
 801baac:	2200      	movs	r2, #0
 801baae:	9201      	str	r2, [sp, #4]
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 801bab0:	691a      	ldr	r2, [r3, #16]
 801bab2:	f042 0201 	orr.w	r2, r2, #1
 801bab6:	611a      	str	r2, [r3, #16]
 801bab8:	e003      	b.n	801bac2 <USB_CoreInit+0xde>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
 801baba:	6918      	ldr	r0, [r3, #16]
 801babc:	f010 0001 	ands.w	r0, r0, #1
 801bac0:	d0dc      	beq.n	801ba7c <USB_CoreInit+0x98>
    count++;
 801bac2:	9a01      	ldr	r2, [sp, #4]
 801bac4:	3201      	adds	r2, #1
 801bac6:	9201      	str	r2, [sp, #4]
    if (count > HAL_USB_TIMEOUT)
 801bac8:	9a01      	ldr	r2, [sp, #4]
 801baca:	f1b2 6f70 	cmp.w	r2, #251658240	@ 0xf000000
 801bace:	d9f4      	bls.n	801baba <USB_CoreInit+0xd6>
 801bad0:	e7d3      	b.n	801ba7a <USB_CoreInit+0x96>
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
 801bad2:	68da      	ldr	r2, [r3, #12]
 801bad4:	f442 1280 	orr.w	r2, r2, #1048576	@ 0x100000
 801bad8:	60da      	str	r2, [r3, #12]
 801bada:	e7a0      	b.n	801ba1e <USB_CoreInit+0x3a>

0801badc <USB_SetTurnaroundTime>:
  if (speed == USBD_FS_SPEED)
 801badc:	2a02      	cmp	r2, #2
{
 801bade:	4603      	mov	r3, r0
  if (speed == USBD_FS_SPEED)
 801bae0:	d00a      	beq.n	801baf8 <USB_SetTurnaroundTime+0x1c>
 801bae2:	f44f 5110 	mov.w	r1, #9216	@ 0x2400
  USBx->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
 801bae6:	68da      	ldr	r2, [r3, #12]
}
 801bae8:	2000      	movs	r0, #0
  USBx->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
 801baea:	f422 5270 	bic.w	r2, r2, #15360	@ 0x3c00
 801baee:	60da      	str	r2, [r3, #12]
  USBx->GUSBCFG |= (uint32_t)((UsbTrd << 10) & USB_OTG_GUSBCFG_TRDT);
 801baf0:	68da      	ldr	r2, [r3, #12]
 801baf2:	430a      	orrs	r2, r1
 801baf4:	60da      	str	r2, [r3, #12]
}
 801baf6:	4770      	bx	lr
    if ((hclk >= 14200000U) && (hclk < 15000000U))
 801baf8:	4a23      	ldr	r2, [pc, #140]	@ (801bb88 <USB_SetTurnaroundTime+0xac>)
 801bafa:	4824      	ldr	r0, [pc, #144]	@ (801bb8c <USB_SetTurnaroundTime+0xb0>)
 801bafc:	440a      	add	r2, r1
 801bafe:	4282      	cmp	r2, r0
 801bb00:	d92c      	bls.n	801bb5c <USB_SetTurnaroundTime+0x80>
    else if ((hclk >= 15000000U) && (hclk < 16000000U))
 801bb02:	4a23      	ldr	r2, [pc, #140]	@ (801bb90 <USB_SetTurnaroundTime+0xb4>)
 801bb04:	4823      	ldr	r0, [pc, #140]	@ (801bb94 <USB_SetTurnaroundTime+0xb8>)
 801bb06:	440a      	add	r2, r1
 801bb08:	4282      	cmp	r2, r0
 801bb0a:	d92a      	bls.n	801bb62 <USB_SetTurnaroundTime+0x86>
    else if ((hclk >= 16000000U) && (hclk < 17200000U))
 801bb0c:	4a22      	ldr	r2, [pc, #136]	@ (801bb98 <USB_SetTurnaroundTime+0xbc>)
 801bb0e:	4823      	ldr	r0, [pc, #140]	@ (801bb9c <USB_SetTurnaroundTime+0xc0>)
 801bb10:	440a      	add	r2, r1
 801bb12:	4282      	cmp	r2, r0
 801bb14:	d928      	bls.n	801bb68 <USB_SetTurnaroundTime+0x8c>
    else if ((hclk >= 17200000U) && (hclk < 18500000U))
 801bb16:	4a22      	ldr	r2, [pc, #136]	@ (801bba0 <USB_SetTurnaroundTime+0xc4>)
 801bb18:	4822      	ldr	r0, [pc, #136]	@ (801bba4 <USB_SetTurnaroundTime+0xc8>)
 801bb1a:	440a      	add	r2, r1
 801bb1c:	4282      	cmp	r2, r0
 801bb1e:	d326      	bcc.n	801bb6e <USB_SetTurnaroundTime+0x92>
    else if ((hclk >= 18500000U) && (hclk < 20000000U))
 801bb20:	4a21      	ldr	r2, [pc, #132]	@ (801bba8 <USB_SetTurnaroundTime+0xcc>)
 801bb22:	4822      	ldr	r0, [pc, #136]	@ (801bbac <USB_SetTurnaroundTime+0xd0>)
 801bb24:	440a      	add	r2, r1
 801bb26:	4282      	cmp	r2, r0
 801bb28:	d924      	bls.n	801bb74 <USB_SetTurnaroundTime+0x98>
    else if ((hclk >= 20000000U) && (hclk < 21800000U))
 801bb2a:	4a21      	ldr	r2, [pc, #132]	@ (801bbb0 <USB_SetTurnaroundTime+0xd4>)
 801bb2c:	4821      	ldr	r0, [pc, #132]	@ (801bbb4 <USB_SetTurnaroundTime+0xd8>)
 801bb2e:	440a      	add	r2, r1
 801bb30:	4282      	cmp	r2, r0
 801bb32:	d322      	bcc.n	801bb7a <USB_SetTurnaroundTime+0x9e>
    else if ((hclk >= 21800000U) && (hclk < 24000000U))
 801bb34:	4a20      	ldr	r2, [pc, #128]	@ (801bbb8 <USB_SetTurnaroundTime+0xdc>)
 801bb36:	4821      	ldr	r0, [pc, #132]	@ (801bbbc <USB_SetTurnaroundTime+0xe0>)
 801bb38:	440a      	add	r2, r1
 801bb3a:	4282      	cmp	r2, r0
 801bb3c:	d3d1      	bcc.n	801bae2 <USB_SetTurnaroundTime+0x6>
    else if ((hclk >= 24000000U) && (hclk < 27700000U))
 801bb3e:	4a20      	ldr	r2, [pc, #128]	@ (801bbc0 <USB_SetTurnaroundTime+0xe4>)
 801bb40:	4820      	ldr	r0, [pc, #128]	@ (801bbc4 <USB_SetTurnaroundTime+0xe8>)
 801bb42:	440a      	add	r2, r1
 801bb44:	4282      	cmp	r2, r0
 801bb46:	d31b      	bcc.n	801bb80 <USB_SetTurnaroundTime+0xa4>
    else if ((hclk >= 27700000U) && (hclk < 32000000U))
 801bb48:	4a1f      	ldr	r2, [pc, #124]	@ (801bbc8 <USB_SetTurnaroundTime+0xec>)
 801bb4a:	4820      	ldr	r0, [pc, #128]	@ (801bbcc <USB_SetTurnaroundTime+0xf0>)
 801bb4c:	440a      	add	r2, r1
 801bb4e:	4282      	cmp	r2, r0
 801bb50:	bf2c      	ite	cs
 801bb52:	f44f 51c0 	movcs.w	r1, #6144	@ 0x1800
 801bb56:	f44f 51e0 	movcc.w	r1, #7168	@ 0x1c00
 801bb5a:	e7c4      	b.n	801bae6 <USB_SetTurnaroundTime+0xa>
 801bb5c:	f44f 5170 	mov.w	r1, #15360	@ 0x3c00
 801bb60:	e7c1      	b.n	801bae6 <USB_SetTurnaroundTime+0xa>
 801bb62:	f44f 5160 	mov.w	r1, #14336	@ 0x3800
 801bb66:	e7be      	b.n	801bae6 <USB_SetTurnaroundTime+0xa>
 801bb68:	f44f 5150 	mov.w	r1, #13312	@ 0x3400
 801bb6c:	e7bb      	b.n	801bae6 <USB_SetTurnaroundTime+0xa>
 801bb6e:	f44f 5140 	mov.w	r1, #12288	@ 0x3000
 801bb72:	e7b8      	b.n	801bae6 <USB_SetTurnaroundTime+0xa>
 801bb74:	f44f 5130 	mov.w	r1, #11264	@ 0x2c00
 801bb78:	e7b5      	b.n	801bae6 <USB_SetTurnaroundTime+0xa>
 801bb7a:	f44f 5120 	mov.w	r1, #10240	@ 0x2800
 801bb7e:	e7b2      	b.n	801bae6 <USB_SetTurnaroundTime+0xa>
 801bb80:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
 801bb84:	e7af      	b.n	801bae6 <USB_SetTurnaroundTime+0xa>
 801bb86:	bf00      	nop
 801bb88:	ff275340 	.word	0xff275340
 801bb8c:	000c34ff 	.word	0x000c34ff
 801bb90:	ff1b1e40 	.word	0xff1b1e40
 801bb94:	000f423f 	.word	0x000f423f
 801bb98:	ff0bdc00 	.word	0xff0bdc00
 801bb9c:	00124f7f 	.word	0x00124f7f
 801bba0:	fef98c80 	.word	0xfef98c80
 801bba4:	0013d620 	.word	0x0013d620
 801bba8:	fee5b660 	.word	0xfee5b660
 801bbac:	0016e35f 	.word	0x0016e35f
 801bbb0:	feced300 	.word	0xfeced300
 801bbb4:	001b7740 	.word	0x001b7740
 801bbb8:	feb35bc0 	.word	0xfeb35bc0
 801bbbc:	002191c0 	.word	0x002191c0
 801bbc0:	fe91ca00 	.word	0xfe91ca00
 801bbc4:	00387520 	.word	0x00387520
 801bbc8:	fe5954e0 	.word	0xfe5954e0
 801bbcc:	00419ce0 	.word	0x00419ce0

0801bbd0 <USB_EnableGlobalInt>:
{
 801bbd0:	4603      	mov	r3, r0
}
 801bbd2:	2000      	movs	r0, #0
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
 801bbd4:	689a      	ldr	r2, [r3, #8]
 801bbd6:	f042 0201 	orr.w	r2, r2, #1
 801bbda:	609a      	str	r2, [r3, #8]
}
 801bbdc:	4770      	bx	lr
 801bbde:	bf00      	nop

0801bbe0 <USB_DisableGlobalInt>:
{
 801bbe0:	4603      	mov	r3, r0
}
 801bbe2:	2000      	movs	r0, #0
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
 801bbe4:	689a      	ldr	r2, [r3, #8]
 801bbe6:	f022 0201 	bic.w	r2, r2, #1
 801bbea:	609a      	str	r2, [r3, #8]
}
 801bbec:	4770      	bx	lr
 801bbee:	bf00      	nop

0801bbf0 <USB_SetCurrentMode>:
{
 801bbf0:	b538      	push	{r3, r4, r5, lr}
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
 801bbf2:	68c3      	ldr	r3, [r0, #12]
  if (mode == USB_HOST_MODE)
 801bbf4:	2901      	cmp	r1, #1
{
 801bbf6:	4605      	mov	r5, r0
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
 801bbf8:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 801bbfc:	60c3      	str	r3, [r0, #12]
  if (mode == USB_HOST_MODE)
 801bbfe:	d017      	beq.n	801bc30 <USB_SetCurrentMode+0x40>
  else if (mode == USB_DEVICE_MODE)
 801bc00:	b9a1      	cbnz	r1, 801bc2c <USB_SetCurrentMode+0x3c>
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD;
 801bc02:	68c3      	ldr	r3, [r0, #12]
  uint32_t ms = 0U;
 801bc04:	460c      	mov	r4, r1
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD;
 801bc06:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 801bc0a:	60c3      	str	r3, [r0, #12]
 801bc0c:	e001      	b.n	801bc12 <USB_SetCurrentMode+0x22>
    } while ((USB_GetMode(USBx) != (uint32_t)USB_DEVICE_MODE) && (ms < HAL_USB_CURRENT_MODE_MAX_DELAY_MS));
 801bc0e:	2cc8      	cmp	r4, #200	@ 0xc8
 801bc10:	d00c      	beq.n	801bc2c <USB_SetCurrentMode+0x3c>
      HAL_Delay(10U);
 801bc12:	200a      	movs	r0, #10
      ms += 10U;
 801bc14:	4404      	add	r4, r0
      HAL_Delay(10U);
 801bc16:	f7f7 f92f 	bl	8012e78 <HAL_Delay>
  return ((USBx->GINTSTS) & 0x1U);
 801bc1a:	696b      	ldr	r3, [r5, #20]
    } while ((USB_GetMode(USBx) != (uint32_t)USB_DEVICE_MODE) && (ms < HAL_USB_CURRENT_MODE_MAX_DELAY_MS));
 801bc1c:	07db      	lsls	r3, r3, #31
 801bc1e:	d4f6      	bmi.n	801bc0e <USB_SetCurrentMode+0x1e>
  if (ms == HAL_USB_CURRENT_MODE_MAX_DELAY_MS)
 801bc20:	f1a4 00c8 	sub.w	r0, r4, #200	@ 0xc8
 801bc24:	fab0 f080 	clz	r0, r0
 801bc28:	0940      	lsrs	r0, r0, #5
}
 801bc2a:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 801bc2c:	2001      	movs	r0, #1
}
 801bc2e:	bd38      	pop	{r3, r4, r5, pc}
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD;
 801bc30:	68c3      	ldr	r3, [r0, #12]
  uint32_t ms = 0U;
 801bc32:	2400      	movs	r4, #0
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD;
 801bc34:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
 801bc38:	60c3      	str	r3, [r0, #12]
 801bc3a:	e001      	b.n	801bc40 <USB_SetCurrentMode+0x50>
    } while ((USB_GetMode(USBx) != (uint32_t)USB_HOST_MODE) && (ms < HAL_USB_CURRENT_MODE_MAX_DELAY_MS));
 801bc3c:	2cc8      	cmp	r4, #200	@ 0xc8
 801bc3e:	d0f5      	beq.n	801bc2c <USB_SetCurrentMode+0x3c>
      HAL_Delay(10U);
 801bc40:	200a      	movs	r0, #10
      ms += 10U;
 801bc42:	4404      	add	r4, r0
      HAL_Delay(10U);
 801bc44:	f7f7 f918 	bl	8012e78 <HAL_Delay>
  return ((USBx->GINTSTS) & 0x1U);
 801bc48:	696b      	ldr	r3, [r5, #20]
    } while ((USB_GetMode(USBx) != (uint32_t)USB_HOST_MODE) && (ms < HAL_USB_CURRENT_MODE_MAX_DELAY_MS));
 801bc4a:	07da      	lsls	r2, r3, #31
 801bc4c:	d5f6      	bpl.n	801bc3c <USB_SetCurrentMode+0x4c>
  if (ms == HAL_USB_CURRENT_MODE_MAX_DELAY_MS)
 801bc4e:	f1a4 00c8 	sub.w	r0, r4, #200	@ 0xc8
 801bc52:	fab0 f080 	clz	r0, r0
 801bc56:	0940      	lsrs	r0, r0, #5
 801bc58:	e7e7      	b.n	801bc2a <USB_SetCurrentMode+0x3a>
 801bc5a:	bf00      	nop

0801bc5c <USB_DevInit>:
{
 801bc5c:	b084      	sub	sp, #16
 801bc5e:	4684      	mov	ip, r0
 801bc60:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801bc64:	b082      	sub	sp, #8
    USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
 801bc66:	f500 6e00 	add.w	lr, r0, #2048	@ 0x800
{
 801bc6a:	ac09      	add	r4, sp, #36	@ 0x24
 801bc6c:	e884 000e 	stmia.w	r4, {r1, r2, r3}
    USBx->DIEPTXF[i] = 0U;
 801bc70:	2300      	movs	r3, #0
 801bc72:	f89d 402e 	ldrb.w	r4, [sp, #46]	@ 0x2e
 801bc76:	f89d 5024 	ldrb.w	r5, [sp, #36]	@ 0x24
 801bc7a:	f8c0 3104 	str.w	r3, [r0, #260]	@ 0x104
 801bc7e:	f8c0 3108 	str.w	r3, [r0, #264]	@ 0x108
 801bc82:	f8c0 310c 	str.w	r3, [r0, #268]	@ 0x10c
 801bc86:	f8c0 3110 	str.w	r3, [r0, #272]	@ 0x110
 801bc8a:	f8c0 3114 	str.w	r3, [r0, #276]	@ 0x114
 801bc8e:	f8c0 3118 	str.w	r3, [r0, #280]	@ 0x118
 801bc92:	f8c0 311c 	str.w	r3, [r0, #284]	@ 0x11c
 801bc96:	f8c0 3120 	str.w	r3, [r0, #288]	@ 0x120
 801bc9a:	f8c0 3124 	str.w	r3, [r0, #292]	@ 0x124
 801bc9e:	f8c0 3128 	str.w	r3, [r0, #296]	@ 0x128
 801bca2:	f8c0 312c 	str.w	r3, [r0, #300]	@ 0x12c
 801bca6:	f8c0 3130 	str.w	r3, [r0, #304]	@ 0x130
 801bcaa:	f8c0 3134 	str.w	r3, [r0, #308]	@ 0x134
 801bcae:	f8c0 3138 	str.w	r3, [r0, #312]	@ 0x138
 801bcb2:	f8c0 313c 	str.w	r3, [r0, #316]	@ 0x13c
  if (cfg.vbus_sensing_enable == 0U)
 801bcb6:	2c00      	cmp	r4, #0
 801bcb8:	f040 80bf 	bne.w	801be3a <USB_DevInit+0x1de>
    USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
 801bcbc:	f8de 3004 	ldr.w	r3, [lr, #4]
 801bcc0:	f043 0302 	orr.w	r3, r3, #2
 801bcc4:	f8ce 3004 	str.w	r3, [lr, #4]
    USBx->GCCFG &= ~USB_OTG_GCCFG_VBDEN;
 801bcc8:	6b83      	ldr	r3, [r0, #56]	@ 0x38
 801bcca:	f423 1300 	bic.w	r3, r3, #2097152	@ 0x200000
 801bcce:	6383      	str	r3, [r0, #56]	@ 0x38
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOEN;
 801bcd0:	6803      	ldr	r3, [r0, #0]
 801bcd2:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 801bcd6:	6003      	str	r3, [r0, #0]
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOVAL;
 801bcd8:	6803      	ldr	r3, [r0, #0]
 801bcda:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 801bcde:	6003      	str	r3, [r0, #0]
  USBx_PCGCCTL = 0U;
 801bce0:	2300      	movs	r3, #0
 801bce2:	f8cc 3e00 	str.w	r3, [ip, #3584]	@ 0xe00
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 801bce6:	f89d 3029 	ldrb.w	r3, [sp, #41]	@ 0x29
 801bcea:	2b01      	cmp	r3, #1
 801bcec:	f000 80b1 	beq.w	801be52 <USB_DevInit+0x1f6>
  USBx_DEVICE->DCFG |= speed;
 801bcf0:	f8dc 3800 	ldr.w	r3, [ip, #2048]	@ 0x800
 801bcf4:	f043 0303 	orr.w	r3, r3, #3
 801bcf8:	f8cc 3800 	str.w	r3, [ip, #2048]	@ 0x800
  __IO uint32_t count = 0U;
 801bcfc:	2300      	movs	r3, #0
 801bcfe:	9300      	str	r3, [sp, #0]
 801bd00:	e004      	b.n	801bd0c <USB_DevInit+0xb0>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 801bd02:	f8dc 3010 	ldr.w	r3, [ip, #16]
 801bd06:	2b00      	cmp	r3, #0
 801bd08:	f2c0 80be 	blt.w	801be88 <USB_DevInit+0x22c>
    count++;
 801bd0c:	9b00      	ldr	r3, [sp, #0]
 801bd0e:	3301      	adds	r3, #1
 801bd10:	9300      	str	r3, [sp, #0]
    if (count > HAL_USB_TIMEOUT)
 801bd12:	9b00      	ldr	r3, [sp, #0]
 801bd14:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 801bd18:	d9f3      	bls.n	801bd02 <USB_DevInit+0xa6>
 801bd1a:	2001      	movs	r0, #1
  __IO uint32_t count = 0U;
 801bd1c:	2300      	movs	r3, #0
 801bd1e:	9301      	str	r3, [sp, #4]
 801bd20:	e004      	b.n	801bd2c <USB_DevInit+0xd0>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 801bd22:	f8dc 3010 	ldr.w	r3, [ip, #16]
 801bd26:	2b00      	cmp	r3, #0
 801bd28:	f2c0 809b 	blt.w	801be62 <USB_DevInit+0x206>
    count++;
 801bd2c:	9b01      	ldr	r3, [sp, #4]
 801bd2e:	3301      	adds	r3, #1
 801bd30:	9301      	str	r3, [sp, #4]
    if (count > HAL_USB_TIMEOUT)
 801bd32:	9b01      	ldr	r3, [sp, #4]
 801bd34:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 801bd38:	d9f3      	bls.n	801bd22 <USB_DevInit+0xc6>
    ret = HAL_ERROR;
 801bd3a:	2001      	movs	r0, #1
  USBx_DEVICE->DIEPMSK = 0U;
 801bd3c:	2200      	movs	r2, #0
 801bd3e:	f8ce 2010 	str.w	r2, [lr, #16]
  USBx_DEVICE->DOEPMSK = 0U;
 801bd42:	f8ce 2014 	str.w	r2, [lr, #20]
  USBx_DEVICE->DAINTMSK = 0U;
 801bd46:	f8ce 201c 	str.w	r2, [lr, #28]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 801bd4a:	b305      	cbz	r5, 801bd8e <USB_DevInit+0x132>
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 801bd4c:	f8dc 1900 	ldr.w	r1, [ip, #2304]	@ 0x900
 801bd50:	f50c 6310 	add.w	r3, ip, #2304	@ 0x900
 801bd54:	2900      	cmp	r1, #0
 801bd56:	db14      	blt.n	801bd82 <USB_DevInit+0x126>
      USBx_INEP(i)->DIEPCTL = 0U;
 801bd58:	2600      	movs	r6, #0
 801bd5a:	4611      	mov	r1, r2
 801bd5c:	601e      	str	r6, [r3, #0]
    USBx_INEP(i)->DIEPTSIZ = 0U;
 801bd5e:	2700      	movs	r7, #0
    USBx_INEP(i)->DIEPINT  = 0xFB7FU;
 801bd60:	f64f 367f 	movw	r6, #64383	@ 0xfb7f
  for (i = 0U; i < cfg.dev_endpoints; i++)
 801bd64:	1c4a      	adds	r2, r1, #1
    USBx_INEP(i)->DIEPTSIZ = 0U;
 801bd66:	611f      	str	r7, [r3, #16]
    USBx_INEP(i)->DIEPINT  = 0xFB7FU;
 801bd68:	609e      	str	r6, [r3, #8]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 801bd6a:	3320      	adds	r3, #32
 801bd6c:	4295      	cmp	r5, r2
 801bd6e:	d040      	beq.n	801bdf2 <USB_DevInit+0x196>
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 801bd70:	6819      	ldr	r1, [r3, #0]
 801bd72:	2900      	cmp	r1, #0
 801bd74:	daf0      	bge.n	801bd58 <USB_DevInit+0xfc>
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK;
 801bd76:	f04f 4890 	mov.w	r8, #1207959552	@ 0x48000000
  for (i = 0U; i < cfg.dev_endpoints; i++)
 801bd7a:	4611      	mov	r1, r2
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK;
 801bd7c:	f8c3 8000 	str.w	r8, [r3]
 801bd80:	e7f0      	b.n	801bd64 <USB_DevInit+0x108>
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_SNAK;
 801bd82:	f04f 6600 	mov.w	r6, #134217728	@ 0x8000000
  for (i = 0U; i < cfg.dev_endpoints; i++)
 801bd86:	4611      	mov	r1, r2
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_SNAK;
 801bd88:	f8cc 6900 	str.w	r6, [ip, #2304]	@ 0x900
 801bd8c:	e7e7      	b.n	801bd5e <USB_DevInit+0x102>
  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
 801bd8e:	f8de 3010 	ldr.w	r3, [lr, #16]
  USBx->GINTMSK = 0U;
 801bd92:	2200      	movs	r2, #0
  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
 801bd94:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 801bd98:	f8ce 3010 	str.w	r3, [lr, #16]
  USBx->GINTSTS = 0xBFFFFFFFU;
 801bd9c:	f06f 4380 	mvn.w	r3, #1073741824	@ 0x40000000
  USBx->GINTMSK = 0U;
 801bda0:	f8cc 2018 	str.w	r2, [ip, #24]
  USBx->GINTSTS = 0xBFFFFFFFU;
 801bda4:	f8cc 3014 	str.w	r3, [ip, #20]
  if (cfg.dma_enable == 0U)
 801bda8:	f89d 3026 	ldrb.w	r3, [sp, #38]	@ 0x26
 801bdac:	b92b      	cbnz	r3, 801bdba <USB_DevInit+0x15e>
    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM;
 801bdae:	f8dc 3018 	ldr.w	r3, [ip, #24]
 801bdb2:	f043 0310 	orr.w	r3, r3, #16
 801bdb6:	f8cc 3018 	str.w	r3, [ip, #24]
  USBx->GINTMSK |= USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |
 801bdba:	f8dc 2018 	ldr.w	r2, [ip, #24]
 801bdbe:	4b40      	ldr	r3, [pc, #256]	@ (801bec0 <USB_DevInit+0x264>)
 801bdc0:	4313      	orrs	r3, r2
  if (cfg.Sof_enable != 0U)
 801bdc2:	f89d 202a 	ldrb.w	r2, [sp, #42]	@ 0x2a
  USBx->GINTMSK |= USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |
 801bdc6:	f8cc 3018 	str.w	r3, [ip, #24]
  if (cfg.Sof_enable != 0U)
 801bdca:	b12a      	cbz	r2, 801bdd8 <USB_DevInit+0x17c>
    USBx->GINTMSK |= USB_OTG_GINTMSK_SOFM;
 801bdcc:	f8dc 3018 	ldr.w	r3, [ip, #24]
 801bdd0:	f043 0308 	orr.w	r3, r3, #8
 801bdd4:	f8cc 3018 	str.w	r3, [ip, #24]
  if (cfg.vbus_sensing_enable == 1U)
 801bdd8:	2c01      	cmp	r4, #1
 801bdda:	d105      	bne.n	801bde8 <USB_DevInit+0x18c>
    USBx->GINTMSK |= (USB_OTG_GINTMSK_SRQIM | USB_OTG_GINTMSK_OTGINT);
 801bddc:	f8dc 2018 	ldr.w	r2, [ip, #24]
 801bde0:	4b38      	ldr	r3, [pc, #224]	@ (801bec4 <USB_DevInit+0x268>)
 801bde2:	4313      	orrs	r3, r2
 801bde4:	f8cc 3018 	str.w	r3, [ip, #24]
}
 801bde8:	b002      	add	sp, #8
 801bdea:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 801bdee:	b004      	add	sp, #16
 801bdf0:	4770      	bx	lr
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 801bdf2:	f8dc 2b00 	ldr.w	r2, [ip, #2816]	@ 0xb00
 801bdf6:	f50c 6330 	add.w	r3, ip, #2816	@ 0xb00
 801bdfa:	2a00      	cmp	r2, #0
 801bdfc:	db17      	blt.n	801be2e <USB_DevInit+0x1d2>
  for (i = 0U; i < cfg.dev_endpoints; i++)
 801bdfe:	2500      	movs	r5, #0
      USBx_OUTEP(i)->DOEPCTL = 0U;
 801be00:	2600      	movs	r6, #0
 801be02:	462a      	mov	r2, r5
 801be04:	601e      	str	r6, [r3, #0]
    USBx_OUTEP(i)->DOEPTSIZ = 0U;
 801be06:	2700      	movs	r7, #0
    USBx_OUTEP(i)->DOEPINT  = 0xFB7FU;
 801be08:	f64f 367f 	movw	r6, #64383	@ 0xfb7f
  for (i = 0U; i < cfg.dev_endpoints; i++)
 801be0c:	4291      	cmp	r1, r2
    USBx_OUTEP(i)->DOEPTSIZ = 0U;
 801be0e:	611f      	str	r7, [r3, #16]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 801be10:	f102 0501 	add.w	r5, r2, #1
    USBx_OUTEP(i)->DOEPINT  = 0xFB7FU;
 801be14:	609e      	str	r6, [r3, #8]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 801be16:	f103 0320 	add.w	r3, r3, #32
 801be1a:	d0b8      	beq.n	801bd8e <USB_DevInit+0x132>
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 801be1c:	681a      	ldr	r2, [r3, #0]
 801be1e:	2a00      	cmp	r2, #0
 801be20:	daee      	bge.n	801be00 <USB_DevInit+0x1a4>
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK;
 801be22:	f04f 4890 	mov.w	r8, #1207959552	@ 0x48000000
 801be26:	462a      	mov	r2, r5
 801be28:	f8c3 8000 	str.w	r8, [r3]
 801be2c:	e7ee      	b.n	801be0c <USB_DevInit+0x1b0>
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_SNAK;
 801be2e:	f04f 6200 	mov.w	r2, #134217728	@ 0x8000000
 801be32:	f8cc 2b00 	str.w	r2, [ip, #2816]	@ 0xb00
  for (i = 0U; i < cfg.dev_endpoints; i++)
 801be36:	2200      	movs	r2, #0
 801be38:	e7e5      	b.n	801be06 <USB_DevInit+0x1aa>
    USBx->GCCFG |= USB_OTG_GCCFG_VBDEN;
 801be3a:	6b83      	ldr	r3, [r0, #56]	@ 0x38
 801be3c:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 801be40:	6383      	str	r3, [r0, #56]	@ 0x38
  USBx_PCGCCTL = 0U;
 801be42:	2300      	movs	r3, #0
 801be44:	f8cc 3e00 	str.w	r3, [ip, #3584]	@ 0xe00
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 801be48:	f89d 3029 	ldrb.w	r3, [sp, #41]	@ 0x29
 801be4c:	2b01      	cmp	r3, #1
 801be4e:	f47f af4f 	bne.w	801bcf0 <USB_DevInit+0x94>
    if (cfg.speed == USBD_HS_SPEED)
 801be52:	f89d 3027 	ldrb.w	r3, [sp, #39]	@ 0x27
 801be56:	bb63      	cbnz	r3, 801beb2 <USB_DevInit+0x256>
  USBx_DEVICE->DCFG |= speed;
 801be58:	f8dc 3800 	ldr.w	r3, [ip, #2048]	@ 0x800
 801be5c:	f8cc 3800 	str.w	r3, [ip, #2048]	@ 0x800
  return HAL_OK;
 801be60:	e74c      	b.n	801bcfc <USB_DevInit+0xa0>
  count = 0U;
 801be62:	2300      	movs	r3, #0
 801be64:	9301      	str	r3, [sp, #4]
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 801be66:	2310      	movs	r3, #16
 801be68:	f8cc 3010 	str.w	r3, [ip, #16]
 801be6c:	e004      	b.n	801be78 <USB_DevInit+0x21c>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 801be6e:	f8dc 3010 	ldr.w	r3, [ip, #16]
 801be72:	06db      	lsls	r3, r3, #27
 801be74:	f57f af62 	bpl.w	801bd3c <USB_DevInit+0xe0>
    count++;
 801be78:	9b01      	ldr	r3, [sp, #4]
 801be7a:	3301      	adds	r3, #1
 801be7c:	9301      	str	r3, [sp, #4]
    if (count > HAL_USB_TIMEOUT)
 801be7e:	9b01      	ldr	r3, [sp, #4]
 801be80:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 801be84:	d9f3      	bls.n	801be6e <USB_DevInit+0x212>
 801be86:	e758      	b.n	801bd3a <USB_DevInit+0xde>
  count = 0U;
 801be88:	2300      	movs	r3, #0
 801be8a:	9300      	str	r3, [sp, #0]
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 801be8c:	f44f 6384 	mov.w	r3, #1056	@ 0x420
 801be90:	f8cc 3010 	str.w	r3, [ip, #16]
 801be94:	e005      	b.n	801bea2 <USB_DevInit+0x246>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 801be96:	f8dc 0010 	ldr.w	r0, [ip, #16]
 801be9a:	f010 0020 	ands.w	r0, r0, #32
 801be9e:	f43f af3d 	beq.w	801bd1c <USB_DevInit+0xc0>
    count++;
 801bea2:	9b00      	ldr	r3, [sp, #0]
 801bea4:	3301      	adds	r3, #1
 801bea6:	9300      	str	r3, [sp, #0]
    if (count > HAL_USB_TIMEOUT)
 801bea8:	9b00      	ldr	r3, [sp, #0]
 801beaa:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 801beae:	d9f2      	bls.n	801be96 <USB_DevInit+0x23a>
 801beb0:	e733      	b.n	801bd1a <USB_DevInit+0xbe>
  USBx_DEVICE->DCFG |= speed;
 801beb2:	f8dc 3800 	ldr.w	r3, [ip, #2048]	@ 0x800
 801beb6:	f043 0301 	orr.w	r3, r3, #1
 801beba:	f8cc 3800 	str.w	r3, [ip, #2048]	@ 0x800
  return HAL_OK;
 801bebe:	e71d      	b.n	801bcfc <USB_DevInit+0xa0>
 801bec0:	803c3800 	.word	0x803c3800
 801bec4:	40000004 	.word	0x40000004

0801bec8 <USB_FlushTxFifo>:
{
 801bec8:	b082      	sub	sp, #8
  __IO uint32_t count = 0U;
 801beca:	2300      	movs	r3, #0
 801becc:	9301      	str	r3, [sp, #4]
 801bece:	e002      	b.n	801bed6 <USB_FlushTxFifo+0xe>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 801bed0:	6903      	ldr	r3, [r0, #16]
 801bed2:	2b00      	cmp	r3, #0
 801bed4:	db09      	blt.n	801beea <USB_FlushTxFifo+0x22>
    count++;
 801bed6:	9b01      	ldr	r3, [sp, #4]
 801bed8:	3301      	adds	r3, #1
 801beda:	9301      	str	r3, [sp, #4]
    if (count > HAL_USB_TIMEOUT)
 801bedc:	9b01      	ldr	r3, [sp, #4]
 801bede:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 801bee2:	d9f5      	bls.n	801bed0 <USB_FlushTxFifo+0x8>
      return HAL_TIMEOUT;
 801bee4:	2003      	movs	r0, #3
}
 801bee6:	b002      	add	sp, #8
 801bee8:	4770      	bx	lr
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 801beea:	0189      	lsls	r1, r1, #6
  count = 0U;
 801beec:	2300      	movs	r3, #0
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 801beee:	f041 0120 	orr.w	r1, r1, #32
  count = 0U;
 801bef2:	9301      	str	r3, [sp, #4]
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 801bef4:	6101      	str	r1, [r0, #16]
 801bef6:	e003      	b.n	801bf00 <USB_FlushTxFifo+0x38>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 801bef8:	6903      	ldr	r3, [r0, #16]
 801befa:	f013 0320 	ands.w	r3, r3, #32
 801befe:	d007      	beq.n	801bf10 <USB_FlushTxFifo+0x48>
    count++;
 801bf00:	9b01      	ldr	r3, [sp, #4]
 801bf02:	3301      	adds	r3, #1
 801bf04:	9301      	str	r3, [sp, #4]
    if (count > HAL_USB_TIMEOUT)
 801bf06:	9b01      	ldr	r3, [sp, #4]
 801bf08:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 801bf0c:	d9f4      	bls.n	801bef8 <USB_FlushTxFifo+0x30>
 801bf0e:	e7e9      	b.n	801bee4 <USB_FlushTxFifo+0x1c>
  return HAL_OK;
 801bf10:	4618      	mov	r0, r3
}
 801bf12:	b002      	add	sp, #8
 801bf14:	4770      	bx	lr
 801bf16:	bf00      	nop

0801bf18 <USB_GetDevSpeed>:
  uint32_t DevEnumSpeed = USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD;
 801bf18:	f8d0 3808 	ldr.w	r3, [r0, #2056]	@ 0x808
  if (DevEnumSpeed == DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ)
 801bf1c:	f013 0006 	ands.w	r0, r3, #6
 801bf20:	d004      	beq.n	801bf2c <USB_GetDevSpeed+0x14>
    speed = USBD_FS_SPEED;
 801bf22:	f013 0f02 	tst.w	r3, #2
 801bf26:	bf0c      	ite	eq
 801bf28:	200f      	moveq	r0, #15
 801bf2a:	2002      	movne	r0, #2
}
 801bf2c:	4770      	bx	lr
 801bf2e:	bf00      	nop

0801bf30 <USB_ActivateEndpoint>:
{
 801bf30:	b530      	push	{r4, r5, lr}
  uint32_t epnum = (uint32_t)ep->num;
 801bf32:	780a      	ldrb	r2, [r1, #0]
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK));
 801bf34:	2301      	movs	r3, #1
 801bf36:	f500 6c00 	add.w	ip, r0, #2048	@ 0x800
 801bf3a:	f002 0e0f 	and.w	lr, r2, #15
    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_USBAEP) == 0U)
 801bf3e:	eb00 1042 	add.w	r0, r0, r2, lsl #5
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK));
 801bf42:	fa03 f30e 	lsl.w	r3, r3, lr
  if (ep->is_in == 1U)
 801bf46:	f891 e001 	ldrb.w	lr, [r1, #1]
 801bf4a:	f1be 0f01 	cmp.w	lr, #1
 801bf4e:	d018      	beq.n	801bf82 <USB_ActivateEndpoint+0x52>
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16);
 801bf50:	f8dc 201c 	ldr.w	r2, [ip, #28]
 801bf54:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
 801bf58:	f8cc 301c 	str.w	r3, [ip, #28]
    if (((USBx_OUTEP(epnum)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0U)
 801bf5c:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	@ 0xb00
 801bf60:	041b      	lsls	r3, r3, #16
 801bf62:	d40c      	bmi.n	801bf7e <USB_ActivateEndpoint+0x4e>
      USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
 801bf64:	688b      	ldr	r3, [r1, #8]
 801bf66:	f8d0 4b00 	ldr.w	r4, [r0, #2816]	@ 0xb00
 801bf6a:	f3c3 030a 	ubfx	r3, r3, #0, #11
                                    ((uint32_t)ep->type << 18) |
 801bf6e:	7909      	ldrb	r1, [r1, #4]
      USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
 801bf70:	4a11      	ldr	r2, [pc, #68]	@ (801bfb8 <USB_ActivateEndpoint+0x88>)
 801bf72:	4323      	orrs	r3, r4
 801bf74:	ea43 4381 	orr.w	r3, r3, r1, lsl #18
 801bf78:	431a      	orrs	r2, r3
 801bf7a:	f8c0 2b00 	str.w	r2, [r0, #2816]	@ 0xb00
}
 801bf7e:	2000      	movs	r0, #0
 801bf80:	bd30      	pop	{r4, r5, pc}
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK));
 801bf82:	f8dc 401c 	ldr.w	r4, [ip, #28]
 801bf86:	4323      	orrs	r3, r4
 801bf88:	f8cc 301c 	str.w	r3, [ip, #28]
    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_USBAEP) == 0U)
 801bf8c:	f8d0 3900 	ldr.w	r3, [r0, #2304]	@ 0x900
 801bf90:	041c      	lsls	r4, r3, #16
 801bf92:	d4f4      	bmi.n	801bf7e <USB_ActivateEndpoint+0x4e>
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 801bf94:	688b      	ldr	r3, [r1, #8]
 801bf96:	f8d0 5900 	ldr.w	r5, [r0, #2304]	@ 0x900
 801bf9a:	f3c3 030a 	ubfx	r3, r3, #0, #11
                                   ((uint32_t)ep->type << 18) | (epnum << 22) |
 801bf9e:	790c      	ldrb	r4, [r1, #4]
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 801bfa0:	4905      	ldr	r1, [pc, #20]	@ (801bfb8 <USB_ActivateEndpoint+0x88>)
 801bfa2:	432b      	orrs	r3, r5
 801bfa4:	ea43 4384 	orr.w	r3, r3, r4, lsl #18
 801bfa8:	ea43 5382 	orr.w	r3, r3, r2, lsl #22
 801bfac:	4319      	orrs	r1, r3
 801bfae:	f8c0 1900 	str.w	r1, [r0, #2304]	@ 0x900
}
 801bfb2:	2000      	movs	r0, #0
 801bfb4:	bd30      	pop	{r4, r5, pc}
 801bfb6:	bf00      	nop
 801bfb8:	10008000 	.word	0x10008000

0801bfbc <USB_DeactivateEndpoint>:
  if (ep->is_in == 1U)
 801bfbc:	784a      	ldrb	r2, [r1, #1]
  uint32_t epnum = (uint32_t)ep->num;
 801bfbe:	780b      	ldrb	r3, [r1, #0]
  if (ep->is_in == 1U)
 801bfc0:	2a01      	cmp	r2, #1
    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 801bfc2:	eb00 1c43 	add.w	ip, r0, r3, lsl #5
  if (ep->is_in == 1U)
 801bfc6:	d02a      	beq.n	801c01e <USB_DeactivateEndpoint+0x62>
    if ((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 801bfc8:	f8dc 2b00 	ldr.w	r2, [ip, #2816]	@ 0xb00
 801bfcc:	2a00      	cmp	r2, #0
 801bfce:	db19      	blt.n	801c004 <USB_DeactivateEndpoint+0x48>
    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
 801bfd0:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
 801bfd4:	f003 030f 	and.w	r3, r3, #15
 801bfd8:	f8d0 183c 	ldr.w	r1, [r0, #2108]	@ 0x83c
 801bfdc:	fa02 f303 	lsl.w	r3, r2, r3
    USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_USBAEP |
 801bfe0:	4a23      	ldr	r2, [pc, #140]	@ (801c070 <USB_DeactivateEndpoint+0xb4>)
    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
 801bfe2:	ea21 0103 	bic.w	r1, r1, r3
 801bfe6:	f8c0 183c 	str.w	r1, [r0, #2108]	@ 0x83c
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
 801bfea:	f8d0 181c 	ldr.w	r1, [r0, #2076]	@ 0x81c
 801bfee:	ea21 0303 	bic.w	r3, r1, r3
 801bff2:	f8c0 381c 	str.w	r3, [r0, #2076]	@ 0x81c
}
 801bff6:	2000      	movs	r0, #0
    USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_USBAEP |
 801bff8:	f8dc 3b00 	ldr.w	r3, [ip, #2816]	@ 0xb00
 801bffc:	401a      	ands	r2, r3
 801bffe:	f8cc 2b00 	str.w	r2, [ip, #2816]	@ 0xb00
}
 801c002:	4770      	bx	lr
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SNAK;
 801c004:	f8dc 2b00 	ldr.w	r2, [ip, #2816]	@ 0xb00
 801c008:	f042 6200 	orr.w	r2, r2, #134217728	@ 0x8000000
 801c00c:	f8cc 2b00 	str.w	r2, [ip, #2816]	@ 0xb00
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_EPDIS;
 801c010:	f8dc 2b00 	ldr.w	r2, [ip, #2816]	@ 0xb00
 801c014:	f042 4280 	orr.w	r2, r2, #1073741824	@ 0x40000000
 801c018:	f8cc 2b00 	str.w	r2, [ip, #2816]	@ 0xb00
 801c01c:	e7d8      	b.n	801bfd0 <USB_DeactivateEndpoint+0x14>
    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 801c01e:	f8dc 2900 	ldr.w	r2, [ip, #2304]	@ 0x900
 801c022:	2a00      	cmp	r2, #0
 801c024:	da0b      	bge.n	801c03e <USB_DeactivateEndpoint+0x82>
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SNAK;
 801c026:	f8dc 2900 	ldr.w	r2, [ip, #2304]	@ 0x900
 801c02a:	f042 6200 	orr.w	r2, r2, #134217728	@ 0x8000000
 801c02e:	f8cc 2900 	str.w	r2, [ip, #2304]	@ 0x900
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_EPDIS;
 801c032:	f8dc 2900 	ldr.w	r2, [ip, #2304]	@ 0x900
 801c036:	f042 4280 	orr.w	r2, r2, #1073741824	@ 0x40000000
 801c03a:	f8cc 2900 	str.w	r2, [ip, #2304]	@ 0x900
    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
 801c03e:	f003 020f 	and.w	r2, r3, #15
 801c042:	2301      	movs	r3, #1
 801c044:	f8d0 183c 	ldr.w	r1, [r0, #2108]	@ 0x83c
 801c048:	4093      	lsls	r3, r2
    USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_USBAEP |
 801c04a:	4a0a      	ldr	r2, [pc, #40]	@ (801c074 <USB_DeactivateEndpoint+0xb8>)
    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
 801c04c:	ea21 0103 	bic.w	r1, r1, r3
 801c050:	f8c0 183c 	str.w	r1, [r0, #2108]	@ 0x83c
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
 801c054:	f8d0 181c 	ldr.w	r1, [r0, #2076]	@ 0x81c
 801c058:	ea21 0303 	bic.w	r3, r1, r3
 801c05c:	f8c0 381c 	str.w	r3, [r0, #2076]	@ 0x81c
}
 801c060:	2000      	movs	r0, #0
    USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_USBAEP |
 801c062:	f8dc 3900 	ldr.w	r3, [ip, #2304]	@ 0x900
 801c066:	401a      	ands	r2, r3
 801c068:	f8cc 2900 	str.w	r2, [ip, #2304]	@ 0x900
}
 801c06c:	4770      	bx	lr
 801c06e:	bf00      	nop
 801c070:	eff37800 	.word	0xeff37800
 801c074:	ec337800 	.word	0xec337800

0801c078 <USB_EPStartXfer>:
{
 801c078:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (ep->is_in == 1U)
 801c07a:	784c      	ldrb	r4, [r1, #1]
  uint32_t epnum = (uint32_t)ep->num;
 801c07c:	780e      	ldrb	r6, [r1, #0]
  if (ep->is_in == 1U)
 801c07e:	2c01      	cmp	r4, #1
    if (ep->xfer_len == 0U)
 801c080:	690d      	ldr	r5, [r1, #16]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 801c082:	eb00 1346 	add.w	r3, r0, r6, lsl #5
      if (ep->type == EP_TYPE_ISOC)
 801c086:	f891 e004 	ldrb.w	lr, [r1, #4]
  if (ep->is_in == 1U)
 801c08a:	d05e      	beq.n	801c14a <USB_EPStartXfer+0xd2>
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);
 801c08c:	f8d3 7b10 	ldr.w	r7, [r3, #2832]	@ 0xb10
 801c090:	f503 6c30 	add.w	ip, r3, #2816	@ 0xb00
 801c094:	4c88      	ldr	r4, [pc, #544]	@ (801c2b8 <USB_EPStartXfer+0x240>)
 801c096:	403c      	ands	r4, r7
 801c098:	f8c3 4b10 	str.w	r4, [r3, #2832]	@ 0xb10
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT);
 801c09c:	4c87      	ldr	r4, [pc, #540]	@ (801c2bc <USB_EPStartXfer+0x244>)
 801c09e:	f8d3 7b10 	ldr.w	r7, [r3, #2832]	@ 0xb10
 801c0a2:	403c      	ands	r4, r7
 801c0a4:	f8c3 4b10 	str.w	r4, [r3, #2832]	@ 0xb10
        ep->xfer_len = ep->maxpacket;
 801c0a8:	688c      	ldr	r4, [r1, #8]
    if (epnum == 0U)
 801c0aa:	bb56      	cbnz	r6, 801c102 <USB_EPStartXfer+0x8a>
      if (ep->xfer_len > 0U)
 801c0ac:	b105      	cbz	r5, 801c0b0 <USB_EPStartXfer+0x38>
        ep->xfer_len = ep->maxpacket;
 801c0ae:	610c      	str	r4, [r1, #16]
      ep->xfer_size = ep->maxpacket;
 801c0b0:	620c      	str	r4, [r1, #32]
        USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
 801c0b2:	f8dc 5010 	ldr.w	r5, [ip, #16]
 801c0b6:	f3c4 0412 	ubfx	r4, r4, #0, #19
    if (dma == 1U)
 801c0ba:	2a01      	cmp	r2, #1
        USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
 801c0bc:	ea44 0405 	orr.w	r4, r4, r5
 801c0c0:	f8cc 4010 	str.w	r4, [ip, #16]
        USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 801c0c4:	f8dc 4010 	ldr.w	r4, [ip, #16]
 801c0c8:	f444 2400 	orr.w	r4, r4, #524288	@ 0x80000
 801c0cc:	f8cc 4010 	str.w	r4, [ip, #16]
    if (dma == 1U)
 801c0d0:	d035      	beq.n	801c13e <USB_EPStartXfer+0xc6>
    if (ep->type == EP_TYPE_ISOC)
 801c0d2:	f1be 0f01 	cmp.w	lr, #1
 801c0d6:	d10c      	bne.n	801c0f2 <USB_EPStartXfer+0x7a>
      if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 801c0d8:	f8d0 2808 	ldr.w	r2, [r0, #2056]	@ 0x808
 801c0dc:	f412 7f80 	tst.w	r2, #256	@ 0x100
        USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SODDFRM;
 801c0e0:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	@ 0xb00
 801c0e4:	bf0c      	ite	eq
 801c0e6:	f042 5200 	orreq.w	r2, r2, #536870912	@ 0x20000000
        USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM;
 801c0ea:	f042 5280 	orrne.w	r2, r2, #268435456	@ 0x10000000
 801c0ee:	f8c3 2b00 	str.w	r2, [r3, #2816]	@ 0xb00
    USBx_OUTEP(epnum)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
 801c0f2:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	@ 0xb00
 801c0f6:	f042 4204 	orr.w	r2, r2, #2214592512	@ 0x84000000
 801c0fa:	f8c3 2b00 	str.w	r2, [r3, #2816]	@ 0xb00
}
 801c0fe:	2000      	movs	r0, #0
 801c100:	bdf0      	pop	{r4, r5, r6, r7, pc}
      if (ep->xfer_len == 0U)
 801c102:	2d00      	cmp	r5, #0
 801c104:	d0d5      	beq.n	801c0b2 <USB_EPStartXfer+0x3a>
        pktcnt = (uint16_t)((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket);
 801c106:	4425      	add	r5, r4
        USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19);
 801c108:	4e6d      	ldr	r6, [pc, #436]	@ (801c2c0 <USB_EPStartXfer+0x248>)
    if (dma == 1U)
 801c10a:	2a01      	cmp	r2, #1
        pktcnt = (uint16_t)((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket);
 801c10c:	f105 35ff 	add.w	r5, r5, #4294967295
 801c110:	fbb5 f5f4 	udiv	r5, r5, r4
 801c114:	b2ad      	uxth	r5, r5
        ep->xfer_size = ep->maxpacket * pktcnt;
 801c116:	fb05 f404 	mul.w	r4, r5, r4
        USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19);
 801c11a:	ea06 45c5 	and.w	r5, r6, r5, lsl #19
 801c11e:	f8dc 6010 	ldr.w	r6, [ip, #16]
        ep->xfer_size = ep->maxpacket * pktcnt;
 801c122:	620c      	str	r4, [r1, #32]
        USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_XFRSIZ & ep->xfer_size;
 801c124:	f3c4 0412 	ubfx	r4, r4, #0, #19
        USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19);
 801c128:	ea45 0506 	orr.w	r5, r5, r6
 801c12c:	f8cc 5010 	str.w	r5, [ip, #16]
        USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_XFRSIZ & ep->xfer_size;
 801c130:	f8dc 5010 	ldr.w	r5, [ip, #16]
 801c134:	ea44 0405 	orr.w	r4, r4, r5
 801c138:	f8cc 4010 	str.w	r4, [ip, #16]
    if (dma == 1U)
 801c13c:	d1c9      	bne.n	801c0d2 <USB_EPStartXfer+0x5a>
      if ((uint32_t)ep->xfer_buff != 0U)
 801c13e:	68ca      	ldr	r2, [r1, #12]
 801c140:	2a00      	cmp	r2, #0
 801c142:	d0c6      	beq.n	801c0d2 <USB_EPStartXfer+0x5a>
        USBx_OUTEP(epnum)->DOEPDMA = (uint32_t)(ep->xfer_buff);
 801c144:	f8cc 2014 	str.w	r2, [ip, #20]
 801c148:	e7c3      	b.n	801c0d2 <USB_EPStartXfer+0x5a>
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 801c14a:	f503 6410 	add.w	r4, r3, #2304	@ 0x900
 801c14e:	f8d4 c010 	ldr.w	ip, [r4, #16]
    if (ep->xfer_len == 0U)
 801c152:	2d00      	cmp	r5, #0
 801c154:	d138      	bne.n	801c1c8 <USB_EPStartXfer+0x150>
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 801c156:	4f59      	ldr	r7, [pc, #356]	@ (801c2bc <USB_EPStartXfer+0x244>)
    if (dma == 1U)
 801c158:	2a01      	cmp	r2, #1
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 801c15a:	ea0c 0707 	and.w	r7, ip, r7
 801c15e:	6127      	str	r7, [r4, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 801c160:	6927      	ldr	r7, [r4, #16]
 801c162:	f447 2700 	orr.w	r7, r7, #524288	@ 0x80000
 801c166:	6127      	str	r7, [r4, #16]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 801c168:	4f53      	ldr	r7, [pc, #332]	@ (801c2b8 <USB_EPStartXfer+0x240>)
 801c16a:	f8d4 c010 	ldr.w	ip, [r4, #16]
 801c16e:	ea0c 0707 	and.w	r7, ip, r7
 801c172:	6127      	str	r7, [r4, #16]
    if (dma == 1U)
 801c174:	d068      	beq.n	801c248 <USB_EPStartXfer+0x1d0>
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 801c176:	f8d3 4900 	ldr.w	r4, [r3, #2304]	@ 0x900
      if (ep->type != EP_TYPE_ISOC)
 801c17a:	f1be 0f01 	cmp.w	lr, #1
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 801c17e:	f044 4404 	orr.w	r4, r4, #2214592512	@ 0x84000000
 801c182:	f8c3 4900 	str.w	r4, [r3, #2304]	@ 0x900
      if (ep->type != EP_TYPE_ISOC)
 801c186:	d1ba      	bne.n	801c0fe <USB_EPStartXfer+0x86>
        if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 801c188:	f8d0 4808 	ldr.w	r4, [r0, #2056]	@ 0x808
 801c18c:	f414 7f80 	tst.w	r4, #256	@ 0x100
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
 801c190:	f8d3 4900 	ldr.w	r4, [r3, #2304]	@ 0x900
 801c194:	bf0c      	ite	eq
 801c196:	f044 5400 	orreq.w	r4, r4, #536870912	@ 0x20000000
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
 801c19a:	f044 5480 	orrne.w	r4, r4, #268435456	@ 0x10000000
 801c19e:	f8c3 4900 	str.w	r4, [r3, #2304]	@ 0x900
  if (dma == 0U)
 801c1a2:	2a00      	cmp	r2, #0
 801c1a4:	d1ab      	bne.n	801c0fe <USB_EPStartXfer+0x86>
    count32b = ((uint32_t)len + 3U) / 4U;
 801c1a6:	b2ad      	uxth	r5, r5
 801c1a8:	3503      	adds	r5, #3
    for (i = 0U; i < count32b; i++)
 801c1aa:	08ad      	lsrs	r5, r5, #2
 801c1ac:	d0a7      	beq.n	801c0fe <USB_EPStartXfer+0x86>
        (void)USB_WritePacket(USBx, ep->xfer_buff, ep->num, (uint16_t)ep->xfer_len, dma);
 801c1ae:	68cb      	ldr	r3, [r1, #12]
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
 801c1b0:	eb00 3606 	add.w	r6, r0, r6, lsl #12
 801c1b4:	eb03 0185 	add.w	r1, r3, r5, lsl #2
 801c1b8:	f506 5680 	add.w	r6, r6, #4096	@ 0x1000
 801c1bc:	f853 2b04 	ldr.w	r2, [r3], #4
    for (i = 0U; i < count32b; i++)
 801c1c0:	4299      	cmp	r1, r3
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
 801c1c2:	6032      	str	r2, [r6, #0]
    for (i = 0U; i < count32b; i++)
 801c1c4:	d1fa      	bne.n	801c1bc <USB_EPStartXfer+0x144>
 801c1c6:	e79a      	b.n	801c0fe <USB_EPStartXfer+0x86>
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 801c1c8:	4f3b      	ldr	r7, [pc, #236]	@ (801c2b8 <USB_EPStartXfer+0x240>)
 801c1ca:	ea0c 0707 	and.w	r7, ip, r7
 801c1ce:	6127      	str	r7, [r4, #16]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 801c1d0:	4f3a      	ldr	r7, [pc, #232]	@ (801c2bc <USB_EPStartXfer+0x244>)
 801c1d2:	f8d4 c010 	ldr.w	ip, [r4, #16]
 801c1d6:	ea0c 0707 	and.w	r7, ip, r7
 801c1da:	6127      	str	r7, [r4, #16]
        if (ep->xfer_len > ep->maxpacket)
 801c1dc:	688f      	ldr	r7, [r1, #8]
      if (epnum == 0U)
 801c1de:	bb26      	cbnz	r6, 801c22a <USB_EPStartXfer+0x1b2>
        if (ep->xfer_len > ep->maxpacket)
 801c1e0:	42bd      	cmp	r5, r7
 801c1e2:	d850      	bhi.n	801c286 <USB_EPStartXfer+0x20e>
        USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 801c1e4:	6927      	ldr	r7, [r4, #16]
 801c1e6:	f447 2700 	orr.w	r7, r7, #524288	@ 0x80000
 801c1ea:	6127      	str	r7, [r4, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
 801c1ec:	f8d4 c010 	ldr.w	ip, [r4, #16]
 801c1f0:	f3c5 0712 	ubfx	r7, r5, #0, #19
      if (ep->type == EP_TYPE_ISOC)
 801c1f4:	f1be 0f01 	cmp.w	lr, #1
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
 801c1f8:	ea47 070c 	orr.w	r7, r7, ip
 801c1fc:	6127      	str	r7, [r4, #16]
      if (ep->type == EP_TYPE_ISOC)
 801c1fe:	d031      	beq.n	801c264 <USB_EPStartXfer+0x1ec>
    if (dma == 1U)
 801c200:	2a01      	cmp	r2, #1
 801c202:	d054      	beq.n	801c2ae <USB_EPStartXfer+0x236>
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 801c204:	f8d3 2900 	ldr.w	r2, [r3, #2304]	@ 0x900
 801c208:	f042 4204 	orr.w	r2, r2, #2214592512	@ 0x84000000
 801c20c:	f8c3 2900 	str.w	r2, [r3, #2304]	@ 0x900
        if (ep->xfer_len > 0U)
 801c210:	2d00      	cmp	r5, #0
 801c212:	f43f af74 	beq.w	801c0fe <USB_EPStartXfer+0x86>
          USBx_DEVICE->DIEPEMPMSK |= 1UL << (ep->num & EP_ADDR_MSK);
 801c216:	f006 060f 	and.w	r6, r6, #15
 801c21a:	2301      	movs	r3, #1
 801c21c:	f8d0 2834 	ldr.w	r2, [r0, #2100]	@ 0x834
 801c220:	40b3      	lsls	r3, r6
 801c222:	4313      	orrs	r3, r2
 801c224:	f8c0 3834 	str.w	r3, [r0, #2100]	@ 0x834
 801c228:	e769      	b.n	801c0fe <USB_EPStartXfer+0x86>
                                       (((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket) << 19));
 801c22a:	eb05 0c07 	add.w	ip, r5, r7
 801c22e:	f10c 3cff 	add.w	ip, ip, #4294967295
 801c232:	fbbc fcf7 	udiv	ip, ip, r7
        USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT &
 801c236:	4f22      	ldr	r7, [pc, #136]	@ (801c2c0 <USB_EPStartXfer+0x248>)
 801c238:	ea07 47cc 	and.w	r7, r7, ip, lsl #19
 801c23c:	f8d4 c010 	ldr.w	ip, [r4, #16]
 801c240:	ea47 070c 	orr.w	r7, r7, ip
 801c244:	6127      	str	r7, [r4, #16]
 801c246:	e7d1      	b.n	801c1ec <USB_EPStartXfer+0x174>
      if ((uint32_t)ep->dma_addr != 0U)
 801c248:	69ca      	ldr	r2, [r1, #28]
 801c24a:	b102      	cbz	r2, 801c24e <USB_EPStartXfer+0x1d6>
        USBx_INEP(epnum)->DIEPDMA = (uint32_t)(ep->dma_addr);
 801c24c:	6162      	str	r2, [r4, #20]
      if (ep->type == EP_TYPE_ISOC)
 801c24e:	f1be 0f01 	cmp.w	lr, #1
 801c252:	d01e      	beq.n	801c292 <USB_EPStartXfer+0x21a>
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 801c254:	f8d3 2900 	ldr.w	r2, [r3, #2304]	@ 0x900
}
 801c258:	2000      	movs	r0, #0
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 801c25a:	f042 4204 	orr.w	r2, r2, #2214592512	@ 0x84000000
 801c25e:	f8c3 2900 	str.w	r2, [r3, #2304]	@ 0x900
}
 801c262:	bdf0      	pop	{r4, r5, r6, r7, pc}
        USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT);
 801c264:	6927      	ldr	r7, [r4, #16]
    if (dma == 1U)
 801c266:	2a01      	cmp	r2, #1
        USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT);
 801c268:	f027 47c0 	bic.w	r7, r7, #1610612736	@ 0x60000000
 801c26c:	6127      	str	r7, [r4, #16]
        USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & (1U << 29));
 801c26e:	6927      	ldr	r7, [r4, #16]
 801c270:	f047 5700 	orr.w	r7, r7, #536870912	@ 0x20000000
 801c274:	6127      	str	r7, [r4, #16]
    if (dma == 1U)
 801c276:	d009      	beq.n	801c28c <USB_EPStartXfer+0x214>
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 801c278:	f8d3 4900 	ldr.w	r4, [r3, #2304]	@ 0x900
 801c27c:	f044 4404 	orr.w	r4, r4, #2214592512	@ 0x84000000
 801c280:	f8c3 4900 	str.w	r4, [r3, #2304]	@ 0x900
      if (ep->type != EP_TYPE_ISOC)
 801c284:	e780      	b.n	801c188 <USB_EPStartXfer+0x110>
          ep->xfer_len = ep->maxpacket;
 801c286:	463d      	mov	r5, r7
 801c288:	610f      	str	r7, [r1, #16]
 801c28a:	e7ab      	b.n	801c1e4 <USB_EPStartXfer+0x16c>
      if ((uint32_t)ep->dma_addr != 0U)
 801c28c:	69ca      	ldr	r2, [r1, #28]
 801c28e:	b102      	cbz	r2, 801c292 <USB_EPStartXfer+0x21a>
        USBx_INEP(epnum)->DIEPDMA = (uint32_t)(ep->dma_addr);
 801c290:	6162      	str	r2, [r4, #20]
        if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 801c292:	f8d0 2808 	ldr.w	r2, [r0, #2056]	@ 0x808
 801c296:	f412 7f80 	tst.w	r2, #256	@ 0x100
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
 801c29a:	f8d3 2900 	ldr.w	r2, [r3, #2304]	@ 0x900
 801c29e:	bf0c      	ite	eq
 801c2a0:	f042 5200 	orreq.w	r2, r2, #536870912	@ 0x20000000
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
 801c2a4:	f042 5280 	orrne.w	r2, r2, #268435456	@ 0x10000000
 801c2a8:	f8c3 2900 	str.w	r2, [r3, #2304]	@ 0x900
 801c2ac:	e7d2      	b.n	801c254 <USB_EPStartXfer+0x1dc>
      if ((uint32_t)ep->dma_addr != 0U)
 801c2ae:	69ca      	ldr	r2, [r1, #28]
 801c2b0:	2a00      	cmp	r2, #0
 801c2b2:	d0cf      	beq.n	801c254 <USB_EPStartXfer+0x1dc>
        USBx_INEP(epnum)->DIEPDMA = (uint32_t)(ep->dma_addr);
 801c2b4:	6162      	str	r2, [r4, #20]
      if (ep->type == EP_TYPE_ISOC)
 801c2b6:	e7cd      	b.n	801c254 <USB_EPStartXfer+0x1dc>
 801c2b8:	fff80000 	.word	0xfff80000
 801c2bc:	e007ffff 	.word	0xe007ffff
 801c2c0:	1ff80000 	.word	0x1ff80000

0801c2c4 <USB_EPStopXfer>:
{
 801c2c4:	b410      	push	{r4}
  __IO uint32_t count = 0U;
 801c2c6:	2300      	movs	r3, #0
{
 801c2c8:	b083      	sub	sp, #12
  if (ep->is_in == 1U)
 801c2ca:	784a      	ldrb	r2, [r1, #1]
  __IO uint32_t count = 0U;
 801c2cc:	9301      	str	r3, [sp, #4]
  if (ep->is_in == 1U)
 801c2ce:	2a01      	cmp	r2, #1
    if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 801c2d0:	780b      	ldrb	r3, [r1, #0]
 801c2d2:	ea4f 1343 	mov.w	r3, r3, lsl #5
  if (ep->is_in == 1U)
 801c2d6:	d023      	beq.n	801c320 <USB_EPStopXfer+0x5c>
    if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 801c2d8:	f500 6030 	add.w	r0, r0, #2816	@ 0xb00
 801c2dc:	58c1      	ldr	r1, [r0, r3]
 801c2de:	18c2      	adds	r2, r0, r3
 801c2e0:	2900      	cmp	r1, #0
 801c2e2:	db04      	blt.n	801c2ee <USB_EPStopXfer+0x2a>
  HAL_StatusTypeDef ret = HAL_OK;
 801c2e4:	2000      	movs	r0, #0
}
 801c2e6:	b003      	add	sp, #12
 801c2e8:	f85d 4b04 	ldr.w	r4, [sp], #4
 801c2ec:	4770      	bx	lr
      USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_SNAK);
 801c2ee:	58c4      	ldr	r4, [r0, r3]
        if (count > 10000U)
 801c2f0:	f242 7110 	movw	r1, #10000	@ 0x2710
      USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_SNAK);
 801c2f4:	f044 6400 	orr.w	r4, r4, #134217728	@ 0x8000000
 801c2f8:	50c4      	str	r4, [r0, r3]
      USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_EPDIS);
 801c2fa:	58c4      	ldr	r4, [r0, r3]
 801c2fc:	f044 4480 	orr.w	r4, r4, #1073741824	@ 0x40000000
 801c300:	50c4      	str	r4, [r0, r3]
 801c302:	e002      	b.n	801c30a <USB_EPStopXfer+0x46>
      } while (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_EPENA) ==  USB_OTG_DOEPCTL_EPENA);
 801c304:	6813      	ldr	r3, [r2, #0]
 801c306:	2b00      	cmp	r3, #0
 801c308:	daec      	bge.n	801c2e4 <USB_EPStopXfer+0x20>
        count++;
 801c30a:	9b01      	ldr	r3, [sp, #4]
 801c30c:	3301      	adds	r3, #1
 801c30e:	9301      	str	r3, [sp, #4]
        if (count > 10000U)
 801c310:	9b01      	ldr	r3, [sp, #4]
 801c312:	428b      	cmp	r3, r1
 801c314:	d9f6      	bls.n	801c304 <USB_EPStopXfer+0x40>
          ret = HAL_ERROR;
 801c316:	2001      	movs	r0, #1
}
 801c318:	b003      	add	sp, #12
 801c31a:	f85d 4b04 	ldr.w	r4, [sp], #4
 801c31e:	4770      	bx	lr
    if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 801c320:	f500 6010 	add.w	r0, r0, #2304	@ 0x900
 801c324:	58c1      	ldr	r1, [r0, r3]
 801c326:	18c2      	adds	r2, r0, r3
 801c328:	2900      	cmp	r1, #0
 801c32a:	dadb      	bge.n	801c2e4 <USB_EPStopXfer+0x20>
      USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_SNAK);
 801c32c:	58c4      	ldr	r4, [r0, r3]
        if (count > 10000U)
 801c32e:	f242 7110 	movw	r1, #10000	@ 0x2710
      USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_SNAK);
 801c332:	f044 6400 	orr.w	r4, r4, #134217728	@ 0x8000000
 801c336:	50c4      	str	r4, [r0, r3]
      USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_EPDIS);
 801c338:	58c4      	ldr	r4, [r0, r3]
 801c33a:	f044 4480 	orr.w	r4, r4, #1073741824	@ 0x40000000
 801c33e:	50c4      	str	r4, [r0, r3]
 801c340:	e002      	b.n	801c348 <USB_EPStopXfer+0x84>
      } while (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) ==  USB_OTG_DIEPCTL_EPENA);
 801c342:	6813      	ldr	r3, [r2, #0]
 801c344:	2b00      	cmp	r3, #0
 801c346:	dacd      	bge.n	801c2e4 <USB_EPStopXfer+0x20>
        count++;
 801c348:	9b01      	ldr	r3, [sp, #4]
 801c34a:	3301      	adds	r3, #1
 801c34c:	9301      	str	r3, [sp, #4]
        if (count > 10000U)
 801c34e:	9b01      	ldr	r3, [sp, #4]
 801c350:	428b      	cmp	r3, r1
 801c352:	d9f6      	bls.n	801c342 <USB_EPStopXfer+0x7e>
 801c354:	e7df      	b.n	801c316 <USB_EPStopXfer+0x52>
 801c356:	bf00      	nop

0801c358 <USB_WritePacket>:
{
 801c358:	b410      	push	{r4}
 801c35a:	f89d 4004 	ldrb.w	r4, [sp, #4]
  if (dma == 0U)
 801c35e:	b964      	cbnz	r4, 801c37a <USB_WritePacket+0x22>
    count32b = ((uint32_t)len + 3U) / 4U;
 801c360:	3303      	adds	r3, #3
    for (i = 0U; i < count32b; i++)
 801c362:	089b      	lsrs	r3, r3, #2
 801c364:	d009      	beq.n	801c37a <USB_WritePacket+0x22>
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
 801c366:	3201      	adds	r2, #1
 801c368:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 801c36c:	eb00 3002 	add.w	r0, r0, r2, lsl #12
 801c370:	f851 2b04 	ldr.w	r2, [r1], #4
    for (i = 0U; i < count32b; i++)
 801c374:	428b      	cmp	r3, r1
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
 801c376:	6002      	str	r2, [r0, #0]
    for (i = 0U; i < count32b; i++)
 801c378:	d1fa      	bne.n	801c370 <USB_WritePacket+0x18>
}
 801c37a:	2000      	movs	r0, #0
 801c37c:	f85d 4b04 	ldr.w	r4, [sp], #4
 801c380:	4770      	bx	lr
 801c382:	bf00      	nop

0801c384 <USB_ReadPacket>:
{
 801c384:	b570      	push	{r4, r5, r6, lr}
  for (i = 0U; i < count32b; i++)
 801c386:	ea5f 0e92 	movs.w	lr, r2, lsr #2
{
 801c38a:	4605      	mov	r5, r0
  uint16_t remaining_bytes = len % 4U;
 801c38c:	f002 0603 	and.w	r6, r2, #3
  for (i = 0U; i < count32b; i++)
 801c390:	d01a      	beq.n	801c3c8 <USB_ReadPacket+0x44>
    __UNALIGNED_UINT32_WRITE(&pData, USBx_DFIFO(0U));
 801c392:	f500 5480 	add.w	r4, r0, #4096	@ 0x1000
  uint8_t *pDest = dest;
 801c396:	468c      	mov	ip, r1
  for (i = 0U; i < count32b; i++)
 801c398:	2300      	movs	r3, #0
 801c39a:	3301      	adds	r3, #1
    __UNALIGNED_UINT32_WRITE(pDest, USBx_DFIFO(0U));
 801c39c:	6822      	ldr	r2, [r4, #0]
  for (i = 0U; i < count32b; i++)
 801c39e:	459e      	cmp	lr, r3
    __UNALIGNED_UINT32_WRITE(pDest, USBx_DFIFO(0U));
 801c3a0:	f84c 2b04 	str.w	r2, [ip], #4
  for (i = 0U; i < count32b; i++)
 801c3a4:	d1f9      	bne.n	801c39a <USB_ReadPacket+0x16>
    pDest++;
 801c3a6:	eb01 008e 	add.w	r0, r1, lr, lsl #2
  if (remaining_bytes != 0U)
 801c3aa:	b166      	cbz	r6, 801c3c6 <USB_ReadPacket+0x42>
    __UNALIGNED_UINT32_WRITE(&pData, USBx_DFIFO(0U));
 801c3ac:	f505 5580 	add.w	r5, r5, #4096	@ 0x1000
    } while (remaining_bytes != 0U);
 801c3b0:	2e01      	cmp	r6, #1
    __UNALIGNED_UINT32_WRITE(&pData, USBx_DFIFO(0U));
 801c3b2:	682b      	ldr	r3, [r5, #0]
      *(uint8_t *)pDest = (uint8_t)(pData >> (8U * (uint8_t)(i)));
 801c3b4:	7003      	strb	r3, [r0, #0]
    } while (remaining_bytes != 0U);
 801c3b6:	d005      	beq.n	801c3c4 <USB_ReadPacket+0x40>
      *(uint8_t *)pDest = (uint8_t)(pData >> (8U * (uint8_t)(i)));
 801c3b8:	0a1a      	lsrs	r2, r3, #8
    } while (remaining_bytes != 0U);
 801c3ba:	2e02      	cmp	r6, #2
      *(uint8_t *)pDest = (uint8_t)(pData >> (8U * (uint8_t)(i)));
 801c3bc:	7042      	strb	r2, [r0, #1]
    } while (remaining_bytes != 0U);
 801c3be:	d001      	beq.n	801c3c4 <USB_ReadPacket+0x40>
      *(uint8_t *)pDest = (uint8_t)(pData >> (8U * (uint8_t)(i)));
 801c3c0:	0c1b      	lsrs	r3, r3, #16
 801c3c2:	7083      	strb	r3, [r0, #2]
      pDest++;
 801c3c4:	4430      	add	r0, r6
}
 801c3c6:	bd70      	pop	{r4, r5, r6, pc}
  uint8_t *pDest = dest;
 801c3c8:	4608      	mov	r0, r1
 801c3ca:	e7ee      	b.n	801c3aa <USB_ReadPacket+0x26>

0801c3cc <USB_EPSetStall>:
  uint32_t epnum = (uint32_t)ep->num;
 801c3cc:	780b      	ldrb	r3, [r1, #0]
  if (ep->is_in == 1U)
 801c3ce:	784a      	ldrb	r2, [r1, #1]
    if (((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == 0U) && (epnum != 0U))
 801c3d0:	eb00 1043 	add.w	r0, r0, r3, lsl #5
 801c3d4:	3b00      	subs	r3, #0
 801c3d6:	bf18      	it	ne
 801c3d8:	2301      	movne	r3, #1
  if (ep->is_in == 1U)
 801c3da:	2a01      	cmp	r2, #1
 801c3dc:	d00c      	beq.n	801c3f8 <USB_EPSetStall+0x2c>
    if (((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == 0U) && (epnum != 0U))
 801c3de:	f8d0 2b00 	ldr.w	r2, [r0, #2816]	@ 0xb00
 801c3e2:	2a00      	cmp	r2, #0
 801c3e4:	db00      	blt.n	801c3e8 <USB_EPSetStall+0x1c>
 801c3e6:	b9a3      	cbnz	r3, 801c412 <USB_EPSetStall+0x46>
    USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_STALL;
 801c3e8:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	@ 0xb00
 801c3ec:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 801c3f0:	f8c0 3b00 	str.w	r3, [r0, #2816]	@ 0xb00
}
 801c3f4:	2000      	movs	r0, #0
 801c3f6:	4770      	bx	lr
    if (((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == 0U) && (epnum != 0U))
 801c3f8:	f8d0 2900 	ldr.w	r2, [r0, #2304]	@ 0x900
 801c3fc:	2a00      	cmp	r2, #0
 801c3fe:	db00      	blt.n	801c402 <USB_EPSetStall+0x36>
 801c400:	b973      	cbnz	r3, 801c420 <USB_EPSetStall+0x54>
    USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
 801c402:	f8d0 3900 	ldr.w	r3, [r0, #2304]	@ 0x900
 801c406:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 801c40a:	f8c0 3900 	str.w	r3, [r0, #2304]	@ 0x900
}
 801c40e:	2000      	movs	r0, #0
 801c410:	4770      	bx	lr
      USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_EPDIS);
 801c412:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	@ 0xb00
 801c416:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
 801c41a:	f8c0 3b00 	str.w	r3, [r0, #2816]	@ 0xb00
 801c41e:	e7e3      	b.n	801c3e8 <USB_EPSetStall+0x1c>
      USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_EPDIS);
 801c420:	f8d0 3900 	ldr.w	r3, [r0, #2304]	@ 0x900
 801c424:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
 801c428:	f8c0 3900 	str.w	r3, [r0, #2304]	@ 0x900
    USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
 801c42c:	f8d0 3900 	ldr.w	r3, [r0, #2304]	@ 0x900
 801c430:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 801c434:	f8c0 3900 	str.w	r3, [r0, #2304]	@ 0x900
 801c438:	e7e9      	b.n	801c40e <USB_EPSetStall+0x42>
 801c43a:	bf00      	nop

0801c43c <USB_EPClearStall>:
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 801c43c:	790b      	ldrb	r3, [r1, #4]
  if (ep->is_in == 1U)
 801c43e:	784a      	ldrb	r2, [r1, #1]
    USBx_INEP(epnum)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 801c440:	f891 c000 	ldrb.w	ip, [r1]
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 801c444:	3b02      	subs	r3, #2
  if (ep->is_in == 1U)
 801c446:	2a01      	cmp	r2, #1
    USBx_INEP(epnum)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 801c448:	eb00 104c 	add.w	r0, r0, ip, lsl #5
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 801c44c:	b2db      	uxtb	r3, r3
  if (ep->is_in == 1U)
 801c44e:	d011      	beq.n	801c474 <USB_EPClearStall+0x38>
    USBx_OUTEP(epnum)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 801c450:	f8d0 2b00 	ldr.w	r2, [r0, #2816]	@ 0xb00
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 801c454:	2b01      	cmp	r3, #1
    USBx_OUTEP(epnum)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 801c456:	f422 1200 	bic.w	r2, r2, #2097152	@ 0x200000
 801c45a:	f8c0 2b00 	str.w	r2, [r0, #2816]	@ 0xb00
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 801c45e:	d901      	bls.n	801c464 <USB_EPClearStall+0x28>
}
 801c460:	2000      	movs	r0, #0
 801c462:	4770      	bx	lr
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 801c464:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	@ 0xb00
 801c468:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 801c46c:	f8c0 3b00 	str.w	r3, [r0, #2816]	@ 0xb00
}
 801c470:	2000      	movs	r0, #0
 801c472:	4770      	bx	lr
    USBx_INEP(epnum)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 801c474:	f8d0 2900 	ldr.w	r2, [r0, #2304]	@ 0x900
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 801c478:	2b01      	cmp	r3, #1
    USBx_INEP(epnum)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 801c47a:	f422 1200 	bic.w	r2, r2, #2097152	@ 0x200000
 801c47e:	f8c0 2900 	str.w	r2, [r0, #2304]	@ 0x900
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 801c482:	d8ed      	bhi.n	801c460 <USB_EPClearStall+0x24>
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 801c484:	f8d0 3900 	ldr.w	r3, [r0, #2304]	@ 0x900
 801c488:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 801c48c:	f8c0 3900 	str.w	r3, [r0, #2304]	@ 0x900
}
 801c490:	2000      	movs	r0, #0
 801c492:	4770      	bx	lr

0801c494 <USB_SetDevAddress>:
{
 801c494:	4603      	mov	r3, r0
  USBx_DEVICE->DCFG |= ((uint32_t)address << 4) & USB_OTG_DCFG_DAD;
 801c496:	0109      	lsls	r1, r1, #4
}
 801c498:	2000      	movs	r0, #0
  USBx_DEVICE->DCFG &= ~(USB_OTG_DCFG_DAD);
 801c49a:	f8d3 2800 	ldr.w	r2, [r3, #2048]	@ 0x800
  USBx_DEVICE->DCFG |= ((uint32_t)address << 4) & USB_OTG_DCFG_DAD;
 801c49e:	f401 61fe 	and.w	r1, r1, #2032	@ 0x7f0
  USBx_DEVICE->DCFG &= ~(USB_OTG_DCFG_DAD);
 801c4a2:	f422 62fe 	bic.w	r2, r2, #2032	@ 0x7f0
 801c4a6:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
  USBx_DEVICE->DCFG |= ((uint32_t)address << 4) & USB_OTG_DCFG_DAD;
 801c4aa:	f8d3 2800 	ldr.w	r2, [r3, #2048]	@ 0x800
 801c4ae:	4311      	orrs	r1, r2
 801c4b0:	f8c3 1800 	str.w	r1, [r3, #2048]	@ 0x800
}
 801c4b4:	4770      	bx	lr
 801c4b6:	bf00      	nop

0801c4b8 <USB_DevConnect>:
{
 801c4b8:	4603      	mov	r3, r0
}
 801c4ba:	2000      	movs	r0, #0
  USBx_PCGCCTL &= ~(USB_OTG_PCGCCTL_STOPCLK | USB_OTG_PCGCCTL_GATECLK);
 801c4bc:	f8d3 2e00 	ldr.w	r2, [r3, #3584]	@ 0xe00
  USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_SDIS;
 801c4c0:	f503 6100 	add.w	r1, r3, #2048	@ 0x800
  USBx_PCGCCTL &= ~(USB_OTG_PCGCCTL_STOPCLK | USB_OTG_PCGCCTL_GATECLK);
 801c4c4:	f022 0203 	bic.w	r2, r2, #3
 801c4c8:	f8c3 2e00 	str.w	r2, [r3, #3584]	@ 0xe00
  USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_SDIS;
 801c4cc:	f8d3 3804 	ldr.w	r3, [r3, #2052]	@ 0x804
 801c4d0:	f023 0302 	bic.w	r3, r3, #2
 801c4d4:	604b      	str	r3, [r1, #4]
}
 801c4d6:	4770      	bx	lr

0801c4d8 <USB_DevDisconnect>:
{
 801c4d8:	4603      	mov	r3, r0
}
 801c4da:	2000      	movs	r0, #0
  USBx_PCGCCTL &= ~(USB_OTG_PCGCCTL_STOPCLK | USB_OTG_PCGCCTL_GATECLK);
 801c4dc:	f8d3 2e00 	ldr.w	r2, [r3, #3584]	@ 0xe00
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
 801c4e0:	f503 6100 	add.w	r1, r3, #2048	@ 0x800
  USBx_PCGCCTL &= ~(USB_OTG_PCGCCTL_STOPCLK | USB_OTG_PCGCCTL_GATECLK);
 801c4e4:	f022 0203 	bic.w	r2, r2, #3
 801c4e8:	f8c3 2e00 	str.w	r2, [r3, #3584]	@ 0xe00
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
 801c4ec:	f8d3 3804 	ldr.w	r3, [r3, #2052]	@ 0x804
 801c4f0:	f043 0302 	orr.w	r3, r3, #2
 801c4f4:	604b      	str	r3, [r1, #4]
}
 801c4f6:	4770      	bx	lr

0801c4f8 <USB_ReadInterrupts>:
  tmpreg = USBx->GINTSTS;
 801c4f8:	6942      	ldr	r2, [r0, #20]
  tmpreg &= USBx->GINTMSK;
 801c4fa:	6980      	ldr	r0, [r0, #24]
}
 801c4fc:	4010      	ands	r0, r2
 801c4fe:	4770      	bx	lr

0801c500 <USB_ReadDevAllOutEpInterrupt>:
  tmpreg  = USBx_DEVICE->DAINT;
 801c500:	f8d0 3818 	ldr.w	r3, [r0, #2072]	@ 0x818
  tmpreg &= USBx_DEVICE->DAINTMSK;
 801c504:	f8d0 081c 	ldr.w	r0, [r0, #2076]	@ 0x81c
 801c508:	4018      	ands	r0, r3
}
 801c50a:	0c00      	lsrs	r0, r0, #16
 801c50c:	4770      	bx	lr
 801c50e:	bf00      	nop

0801c510 <USB_ReadDevAllInEpInterrupt>:
  tmpreg  = USBx_DEVICE->DAINT;
 801c510:	f8d0 3818 	ldr.w	r3, [r0, #2072]	@ 0x818
  tmpreg &= USBx_DEVICE->DAINTMSK;
 801c514:	f8d0 081c 	ldr.w	r0, [r0, #2076]	@ 0x81c
 801c518:	4018      	ands	r0, r3
}
 801c51a:	b280      	uxth	r0, r0
 801c51c:	4770      	bx	lr
 801c51e:	bf00      	nop

0801c520 <USB_ReadDevOutEPInterrupt>:
  tmpreg  = USBx_OUTEP((uint32_t)epnum)->DOEPINT;
 801c520:	eb00 1141 	add.w	r1, r0, r1, lsl #5
  tmpreg &= USBx_DEVICE->DOEPMSK;
 801c524:	f500 6000 	add.w	r0, r0, #2048	@ 0x800
  tmpreg  = USBx_OUTEP((uint32_t)epnum)->DOEPINT;
 801c528:	f8d1 2b08 	ldr.w	r2, [r1, #2824]	@ 0xb08
  tmpreg &= USBx_DEVICE->DOEPMSK;
 801c52c:	6940      	ldr	r0, [r0, #20]
}
 801c52e:	4010      	ands	r0, r2
 801c530:	4770      	bx	lr
 801c532:	bf00      	nop

0801c534 <USB_ReadDevInEPInterrupt>:
  msk = USBx_DEVICE->DIEPMSK;
 801c534:	f8d0 2810 	ldr.w	r2, [r0, #2064]	@ 0x810
  emp = USBx_DEVICE->DIEPEMPMSK;
 801c538:	f8d0 3834 	ldr.w	r3, [r0, #2100]	@ 0x834
  tmpreg = USBx_INEP((uint32_t)epnum)->DIEPINT & msk;
 801c53c:	eb00 1041 	add.w	r0, r0, r1, lsl #5
  msk |= ((emp >> (epnum & EP_ADDR_MSK)) & 0x1U) << 7;
 801c540:	f001 010f 	and.w	r1, r1, #15
  tmpreg = USBx_INEP((uint32_t)epnum)->DIEPINT & msk;
 801c544:	f8d0 0908 	ldr.w	r0, [r0, #2312]	@ 0x908
  msk |= ((emp >> (epnum & EP_ADDR_MSK)) & 0x1U) << 7;
 801c548:	40cb      	lsrs	r3, r1
 801c54a:	01db      	lsls	r3, r3, #7
 801c54c:	b2db      	uxtb	r3, r3
 801c54e:	4313      	orrs	r3, r2
}
 801c550:	4018      	ands	r0, r3
 801c552:	4770      	bx	lr

0801c554 <USB_GetMode>:
  return ((USBx->GINTSTS) & 0x1U);
 801c554:	6940      	ldr	r0, [r0, #20]
}
 801c556:	f000 0001 	and.w	r0, r0, #1
 801c55a:	4770      	bx	lr

0801c55c <USB_ActivateSetup>:
{
 801c55c:	4603      	mov	r3, r0
  USBx_INEP(0U)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
 801c55e:	4a09      	ldr	r2, [pc, #36]	@ (801c584 <USB_ActivateSetup+0x28>)
}
 801c560:	2000      	movs	r0, #0
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;
 801c562:	f503 6100 	add.w	r1, r3, #2048	@ 0x800
{
 801c566:	b410      	push	{r4}
  USBx_INEP(0U)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
 801c568:	f8d3 4900 	ldr.w	r4, [r3, #2304]	@ 0x900
 801c56c:	4022      	ands	r2, r4
}
 801c56e:	f85d 4b04 	ldr.w	r4, [sp], #4
  USBx_INEP(0U)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
 801c572:	f8c3 2900 	str.w	r2, [r3, #2304]	@ 0x900
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;
 801c576:	f8d3 3804 	ldr.w	r3, [r3, #2052]	@ 0x804
 801c57a:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 801c57e:	604b      	str	r3, [r1, #4]
}
 801c580:	4770      	bx	lr
 801c582:	bf00      	nop
 801c584:	fffff800 	.word	0xfffff800

0801c588 <USB_EP0_OutStart>:
{
 801c588:	b430      	push	{r4, r5}
  uint32_t gSNPSiD = *(__IO const uint32_t *)(&USBx->CID + 0x1U);
 801c58a:	6c05      	ldr	r5, [r0, #64]	@ 0x40
    if ((USBx_OUTEP(0U)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 801c58c:	f500 6330 	add.w	r3, r0, #2816	@ 0xb00
  if (gSNPSiD > USB_OTG_CORE_ID_300A)
 801c590:	4c10      	ldr	r4, [pc, #64]	@ (801c5d4 <USB_EP0_OutStart+0x4c>)
 801c592:	42a5      	cmp	r5, r4
 801c594:	d903      	bls.n	801c59e <USB_EP0_OutStart+0x16>
    if ((USBx_OUTEP(0U)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 801c596:	f8d0 4b00 	ldr.w	r4, [r0, #2816]	@ 0xb00
 801c59a:	2c00      	cmp	r4, #0
 801c59c:	db16      	blt.n	801c5cc <USB_EP0_OutStart+0x44>
  USBx_OUTEP(0U)->DOEPTSIZ = 0U;
 801c59e:	2400      	movs	r4, #0
  if (dma == 1U)
 801c5a0:	2901      	cmp	r1, #1
  USBx_OUTEP(0U)->DOEPTSIZ = 0U;
 801c5a2:	611c      	str	r4, [r3, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 801c5a4:	691c      	ldr	r4, [r3, #16]
 801c5a6:	f444 2400 	orr.w	r4, r4, #524288	@ 0x80000
 801c5aa:	611c      	str	r4, [r3, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |= (3U * 8U);
 801c5ac:	691c      	ldr	r4, [r3, #16]
 801c5ae:	f044 0418 	orr.w	r4, r4, #24
 801c5b2:	611c      	str	r4, [r3, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;
 801c5b4:	691c      	ldr	r4, [r3, #16]
 801c5b6:	f044 44c0 	orr.w	r4, r4, #1610612736	@ 0x60000000
 801c5ba:	611c      	str	r4, [r3, #16]
  if (dma == 1U)
 801c5bc:	d106      	bne.n	801c5cc <USB_EP0_OutStart+0x44>
    USBx_OUTEP(0U)->DOEPDMA = (uint32_t)psetup;
 801c5be:	615a      	str	r2, [r3, #20]
    USBx_OUTEP(0U)->DOEPCTL |= USB_OTG_DOEPCTL_EPENA | USB_OTG_DOEPCTL_USBAEP;
 801c5c0:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	@ 0xb00
 801c5c4:	f043 2380 	orr.w	r3, r3, #2147516416	@ 0x80008000
 801c5c8:	f8c0 3b00 	str.w	r3, [r0, #2816]	@ 0xb00
}
 801c5cc:	2000      	movs	r0, #0
 801c5ce:	bc30      	pop	{r4, r5}
 801c5d0:	4770      	bx	lr
 801c5d2:	bf00      	nop
 801c5d4:	4f54300a 	.word	0x4f54300a

0801c5d8 <MX_FATFS_Init>:
/* USER CODE BEGIN Variables */

/* USER CODE END Variables */

void MX_FATFS_Init(void)
{
 801c5d8:	b508      	push	{r3, lr}
  /*## FatFS: Link the SD driver ###########################*/
  retSD = FATFS_LinkDriver(&SD_Driver, SDPath);
 801c5da:	4903      	ldr	r1, [pc, #12]	@ (801c5e8 <MX_FATFS_Init+0x10>)
 801c5dc:	4803      	ldr	r0, [pc, #12]	@ (801c5ec <MX_FATFS_Init+0x14>)
 801c5de:	f001 f8b9 	bl	801d754 <FATFS_LinkDriver>
 801c5e2:	4b03      	ldr	r3, [pc, #12]	@ (801c5f0 <MX_FATFS_Init+0x18>)
 801c5e4:	7018      	strb	r0, [r3, #0]

  /* USER CODE BEGIN Init */
  /* additional user code for init */
  /* USER CODE END Init */
}
 801c5e6:	bd08      	pop	{r3, pc}
 801c5e8:	20002bcc 	.word	0x20002bcc
 801c5ec:	08034c30 	.word	0x08034c30
 801c5f0:	20002bd0 	.word	0x20002bd0

0801c5f4 <BSP_SD_ReadBlocks_DMA>:
  * @param  ReadAddr: Address from where data is to be read
  * @param  NumOfBlocks: Number of SD blocks to read
  * @retval SD status
  */
__weak uint8_t BSP_SD_ReadBlocks_DMA(uint32_t *pData, uint32_t ReadAddr, uint32_t NumOfBlocks)
{
 801c5f4:	4684      	mov	ip, r0
  uint8_t sd_state = MSD_OK;

  /* Read block(s) in DMA transfer mode */
  if (HAL_SD_ReadBlocks_DMA(&hsd1, (uint8_t *)pData, ReadAddr, NumOfBlocks) != HAL_OK)
 801c5f6:	4805      	ldr	r0, [pc, #20]	@ (801c60c <BSP_SD_ReadBlocks_DMA+0x18>)
{
 801c5f8:	b508      	push	{r3, lr}
 801c5fa:	4613      	mov	r3, r2
  if (HAL_SD_ReadBlocks_DMA(&hsd1, (uint8_t *)pData, ReadAddr, NumOfBlocks) != HAL_OK)
 801c5fc:	460a      	mov	r2, r1
 801c5fe:	4661      	mov	r1, ip
 801c600:	f7fc fb92 	bl	8018d28 <HAL_SD_ReadBlocks_DMA>
  {
    sd_state = MSD_ERROR;
  }

  return sd_state;
}
 801c604:	3800      	subs	r0, #0
 801c606:	bf18      	it	ne
 801c608:	2001      	movne	r0, #1
 801c60a:	bd08      	pop	{r3, pc}
 801c60c:	200025e4 	.word	0x200025e4

0801c610 <BSP_SD_WriteBlocks_DMA>:
  * @param  WriteAddr: Address from where data is to be written
  * @param  NumOfBlocks: Number of SD blocks to write
  * @retval SD status
  */
__weak uint8_t BSP_SD_WriteBlocks_DMA(uint32_t *pData, uint32_t WriteAddr, uint32_t NumOfBlocks)
{
 801c610:	4684      	mov	ip, r0
  uint8_t sd_state = MSD_OK;

  /* Write block(s) in DMA transfer mode */
  if (HAL_SD_WriteBlocks_DMA(&hsd1, (uint8_t *)pData, WriteAddr, NumOfBlocks) != HAL_OK)
 801c612:	4805      	ldr	r0, [pc, #20]	@ (801c628 <BSP_SD_WriteBlocks_DMA+0x18>)
{
 801c614:	b508      	push	{r3, lr}
 801c616:	4613      	mov	r3, r2
  if (HAL_SD_WriteBlocks_DMA(&hsd1, (uint8_t *)pData, WriteAddr, NumOfBlocks) != HAL_OK)
 801c618:	460a      	mov	r2, r1
 801c61a:	4661      	mov	r1, ip
 801c61c:	f7fc fc1a 	bl	8018e54 <HAL_SD_WriteBlocks_DMA>
  {
    sd_state = MSD_ERROR;
  }

  return sd_state;
}
 801c620:	3800      	subs	r0, #0
 801c622:	bf18      	it	ne
 801c624:	2001      	movne	r0, #1
 801c626:	bd08      	pop	{r3, pc}
 801c628:	200025e4 	.word	0x200025e4

0801c62c <BSP_SD_GetCardState>:
  *          This value can be one of the following values:
  *            @arg  SD_TRANSFER_OK: No data transfer is acting
  *            @arg  SD_TRANSFER_BUSY: Data transfer is acting
  */
__weak uint8_t BSP_SD_GetCardState(void)
{
 801c62c:	b508      	push	{r3, lr}
  return ((HAL_SD_GetCardState(&hsd1) == HAL_SD_CARD_TRANSFER ) ? SD_TRANSFER_OK : SD_TRANSFER_BUSY);
 801c62e:	4803      	ldr	r0, [pc, #12]	@ (801c63c <BSP_SD_GetCardState+0x10>)
 801c630:	f7fc ffac 	bl	801958c <HAL_SD_GetCardState>
}
 801c634:	3804      	subs	r0, #4
 801c636:	bf18      	it	ne
 801c638:	2001      	movne	r0, #1
 801c63a:	bd08      	pop	{r3, pc}
 801c63c:	200025e4 	.word	0x200025e4

0801c640 <BSP_SD_GetCardInfo>:
  * @brief  Get SD information about specific SD card.
  * @param  CardInfo: Pointer to HAL_SD_CardInfoTypedef structure
  * @retval None
  */
__weak void BSP_SD_GetCardInfo(HAL_SD_CardInfoTypeDef *CardInfo)
{
 801c640:	4601      	mov	r1, r0
  /* Get SD card Information */
  HAL_SD_GetCardInfo(&hsd1, CardInfo);
 801c642:	4801      	ldr	r0, [pc, #4]	@ (801c648 <BSP_SD_GetCardInfo+0x8>)
 801c644:	f7fc beee 	b.w	8019424 <HAL_SD_GetCardInfo>
 801c648:	200025e4 	.word	0x200025e4

0801c64c <HAL_SD_RxCpltCallback>:
  * @brief Rx Transfer completed callback
  * @param hsd: SD handle
  * @retval None
  */
void HAL_SD_RxCpltCallback(SD_HandleTypeDef *hsd)
{
 801c64c:	b508      	push	{r3, lr}
  BSP_SD_ReadCpltCallback();
 801c64e:	f000 f925 	bl	801c89c <BSP_SD_ReadCpltCallback>
}
 801c652:	bd08      	pop	{r3, pc}

0801c654 <BSP_SD_IsDetected>:
 * @brief  Detects if SD card is correctly plugged in the memory slot or not.
 * @param  None
 * @retval Returns if SD is detected or not
 */
__weak uint8_t BSP_SD_IsDetected(void)
{
 801c654:	b500      	push	{lr}
  __IO uint8_t status = SD_PRESENT;
 801c656:	2301      	movs	r3, #1
{
 801c658:	b083      	sub	sp, #12
  __IO uint8_t status = SD_PRESENT;
 801c65a:	f88d 3007 	strb.w	r3, [sp, #7]

  if (BSP_PlatformIsDetected() == 0x0)
 801c65e:	f000 f821 	bl	801c6a4 <BSP_PlatformIsDetected>
 801c662:	b908      	cbnz	r0, 801c668 <BSP_SD_IsDetected+0x14>
  {
    status = SD_NOT_PRESENT;
 801c664:	f88d 0007 	strb.w	r0, [sp, #7]
  }

  return status;
 801c668:	f89d 0007 	ldrb.w	r0, [sp, #7]
}
 801c66c:	b003      	add	sp, #12
 801c66e:	f85d fb04 	ldr.w	pc, [sp], #4
 801c672:	bf00      	nop

0801c674 <BSP_SD_Init>:
{
 801c674:	b508      	push	{r3, lr}
  if (BSP_SD_IsDetected() != SD_PRESENT)
 801c676:	f7ff ffed 	bl	801c654 <BSP_SD_IsDetected>
 801c67a:	2801      	cmp	r0, #1
 801c67c:	d001      	beq.n	801c682 <BSP_SD_Init+0xe>
    return MSD_ERROR_SD_NOT_PRESENT;
 801c67e:	2002      	movs	r0, #2
}
 801c680:	bd08      	pop	{r3, pc}
  sd_state = HAL_SD_Init(&hsd1);
 801c682:	4807      	ldr	r0, [pc, #28]	@ (801c6a0 <BSP_SD_Init+0x2c>)
 801c684:	f7fc feb0 	bl	80193e8 <HAL_SD_Init>
  if (sd_state == MSD_OK)
 801c688:	2800      	cmp	r0, #0
 801c68a:	d1f9      	bne.n	801c680 <BSP_SD_Init+0xc>
    if (HAL_SD_ConfigWideBusOperation(&hsd1, SDMMC_BUS_WIDE_4B) != HAL_OK)
 801c68c:	f44f 6100 	mov.w	r1, #2048	@ 0x800
 801c690:	4803      	ldr	r0, [pc, #12]	@ (801c6a0 <BSP_SD_Init+0x2c>)
 801c692:	f7fc fedd 	bl	8019450 <HAL_SD_ConfigWideBusOperation>
 801c696:	3800      	subs	r0, #0
 801c698:	bf18      	it	ne
 801c69a:	2001      	movne	r0, #1
}
 801c69c:	bd08      	pop	{r3, pc}
 801c69e:	bf00      	nop
 801c6a0:	200025e4 	.word	0x200025e4

0801c6a4 <BSP_PlatformIsDetected>:
#include "fatfs_platform.h"

uint8_t	BSP_PlatformIsDetected(void) {
    uint8_t status = SD_PRESENT;
    /* Check SD card detect pin */
    if(HAL_GPIO_ReadPin(SD_DETECT_GPIO_PORT, SD_DETECT_PIN) != GPIO_PIN_RESET)
 801c6a4:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
 801c6a8:	4803      	ldr	r0, [pc, #12]	@ (801c6b8 <BSP_PlatformIsDetected+0x14>)
uint8_t	BSP_PlatformIsDetected(void) {
 801c6aa:	b508      	push	{r3, lr}
    if(HAL_GPIO_ReadPin(SD_DETECT_GPIO_PORT, SD_DETECT_PIN) != GPIO_PIN_RESET)
 801c6ac:	f7f8 fe20 	bl	80152f0 <HAL_GPIO_ReadPin>
    }
    /* USER CODE BEGIN 1 */
    /* user code can be inserted here */
    /* USER CODE END 1 */
    return status;
}
 801c6b0:	fab0 f080 	clz	r0, r0
 801c6b4:	0940      	lsrs	r0, r0, #5
 801c6b6:	bd08      	pop	{r3, pc}
 801c6b8:	40020800 	.word	0x40020800

0801c6bc <SD_initialize>:
  * @brief  Initializes a Drive
  * @param  lun : not used
  * @retval DSTATUS: Operation status
  */
DSTATUS SD_initialize(BYTE lun)
{
 801c6bc:	b538      	push	{r3, r4, r5, lr}
Stat = STA_NOINIT;
 801c6be:	4c15      	ldr	r4, [pc, #84]	@ (801c714 <SD_initialize+0x58>)
 801c6c0:	2501      	movs	r5, #1
 801c6c2:	7025      	strb	r5, [r4, #0]
   * as the osMessage API will fail otherwise
   */
#if (osCMSIS <= 0x20000U)
  if(osKernelRunning())
#else
  if(osKernelGetState() == osKernelRunning)
 801c6c4:	f001 f886 	bl	801d7d4 <osKernelGetState>
 801c6c8:	2802      	cmp	r0, #2
 801c6ca:	d001      	beq.n	801c6d0 <SD_initialize+0x14>
        Stat |= STA_NOINIT;
      }
    }
  }

  return Stat;
 801c6cc:	7820      	ldrb	r0, [r4, #0]
}
 801c6ce:	bd38      	pop	{r3, r4, r5, pc}
    if(BSP_SD_Init() == MSD_OK)
 801c6d0:	f7ff ffd0 	bl	801c674 <BSP_SD_Init>
 801c6d4:	b190      	cbz	r0, 801c6fc <SD_initialize+0x40>
    if (Stat != STA_NOINIT)
 801c6d6:	7823      	ldrb	r3, [r4, #0]
 801c6d8:	2b01      	cmp	r3, #1
 801c6da:	d0f7      	beq.n	801c6cc <SD_initialize+0x10>
      if (SDQueueID == NULL)
 801c6dc:	4d0e      	ldr	r5, [pc, #56]	@ (801c718 <SD_initialize+0x5c>)
 801c6de:	682a      	ldr	r2, [r5, #0]
 801c6e0:	2a00      	cmp	r2, #0
 801c6e2:	d1f3      	bne.n	801c6cc <SD_initialize+0x10>
      SDQueueID = osMessageQueueNew(QUEUE_SIZE, 2, NULL);
 801c6e4:	2102      	movs	r1, #2
 801c6e6:	200a      	movs	r0, #10
 801c6e8:	f001 f932 	bl	801d950 <osMessageQueueNew>
 801c6ec:	6028      	str	r0, [r5, #0]
      if (SDQueueID == NULL)
 801c6ee:	2800      	cmp	r0, #0
 801c6f0:	d1ec      	bne.n	801c6cc <SD_initialize+0x10>
        Stat |= STA_NOINIT;
 801c6f2:	7823      	ldrb	r3, [r4, #0]
 801c6f4:	f043 0301 	orr.w	r3, r3, #1
 801c6f8:	7023      	strb	r3, [r4, #0]
 801c6fa:	e7e7      	b.n	801c6cc <SD_initialize+0x10>
  Stat = STA_NOINIT;
 801c6fc:	7025      	strb	r5, [r4, #0]
  if(BSP_SD_GetCardState() == SD_TRANSFER_OK)
 801c6fe:	f7ff ff95 	bl	801c62c <BSP_SD_GetCardState>
 801c702:	b918      	cbnz	r0, 801c70c <SD_initialize+0x50>
    Stat &= ~STA_NOINIT;
 801c704:	7823      	ldrb	r3, [r4, #0]
 801c706:	f003 03fe 	and.w	r3, r3, #254	@ 0xfe
 801c70a:	7023      	strb	r3, [r4, #0]
  return Stat;
 801c70c:	7823      	ldrb	r3, [r4, #0]
 801c70e:	b2db      	uxtb	r3, r3
      Stat = SD_CheckStatus(lun);
 801c710:	7023      	strb	r3, [r4, #0]
 801c712:	e7e0      	b.n	801c6d6 <SD_initialize+0x1a>
 801c714:	20000018 	.word	0x20000018
 801c718:	20002bd4 	.word	0x20002bd4

0801c71c <SD_status>:
  * @brief  Gets Disk Status
  * @param  lun : not used
  * @retval DSTATUS: Operation status
  */
DSTATUS SD_status(BYTE lun)
{
 801c71c:	b510      	push	{r4, lr}
  Stat = STA_NOINIT;
 801c71e:	2301      	movs	r3, #1
 801c720:	4c05      	ldr	r4, [pc, #20]	@ (801c738 <SD_status+0x1c>)
 801c722:	7023      	strb	r3, [r4, #0]
  if(BSP_SD_GetCardState() == SD_TRANSFER_OK)
 801c724:	f7ff ff82 	bl	801c62c <BSP_SD_GetCardState>
 801c728:	b918      	cbnz	r0, 801c732 <SD_status+0x16>
    Stat &= ~STA_NOINIT;
 801c72a:	7823      	ldrb	r3, [r4, #0]
 801c72c:	f003 03fe 	and.w	r3, r3, #254	@ 0xfe
 801c730:	7023      	strb	r3, [r4, #0]
  return Stat;
 801c732:	7820      	ldrb	r0, [r4, #0]
  return SD_CheckStatus(lun);
}
 801c734:	bd10      	pop	{r4, pc}
 801c736:	bf00      	nop
 801c738:	20000018 	.word	0x20000018

0801c73c <SD_ioctl>:
DRESULT SD_ioctl(BYTE lun, BYTE cmd, void *buff)
{
  DRESULT res = RES_ERROR;
  BSP_SD_CardInfo CardInfo;

  if (Stat & STA_NOINIT) return RES_NOTRDY;
 801c73c:	4b16      	ldr	r3, [pc, #88]	@ (801c798 <SD_ioctl+0x5c>)
{
 801c73e:	b530      	push	{r4, r5, lr}
  if (Stat & STA_NOINIT) return RES_NOTRDY;
 801c740:	7818      	ldrb	r0, [r3, #0]
{
 801c742:	b089      	sub	sp, #36	@ 0x24
  if (Stat & STA_NOINIT) return RES_NOTRDY;
 801c744:	f010 0401 	ands.w	r4, r0, #1
 801c748:	d106      	bne.n	801c758 <SD_ioctl+0x1c>
 801c74a:	4615      	mov	r5, r2

  switch (cmd)
 801c74c:	2903      	cmp	r1, #3
 801c74e:	d820      	bhi.n	801c792 <SD_ioctl+0x56>
 801c750:	e8df f001 	tbb	[pc, r1]
 801c754:	06170f03 	.word	0x06170f03
  if (Stat & STA_NOINIT) return RES_NOTRDY;
 801c758:	2403      	movs	r4, #3
  default:
    res = RES_PARERR;
  }

  return res;
}
 801c75a:	4620      	mov	r0, r4
 801c75c:	b009      	add	sp, #36	@ 0x24
 801c75e:	bd30      	pop	{r4, r5, pc}
    BSP_SD_GetCardInfo(&CardInfo);
 801c760:	4668      	mov	r0, sp
 801c762:	f7ff ff6d 	bl	801c640 <BSP_SD_GetCardInfo>
    *(DWORD*)buff = CardInfo.LogBlockSize / SD_DEFAULT_BLOCK_SIZE;
 801c766:	9b07      	ldr	r3, [sp, #28]
}
 801c768:	4620      	mov	r0, r4
    *(DWORD*)buff = CardInfo.LogBlockSize / SD_DEFAULT_BLOCK_SIZE;
 801c76a:	0a5b      	lsrs	r3, r3, #9
 801c76c:	602b      	str	r3, [r5, #0]
}
 801c76e:	b009      	add	sp, #36	@ 0x24
 801c770:	bd30      	pop	{r4, r5, pc}
    BSP_SD_GetCardInfo(&CardInfo);
 801c772:	4668      	mov	r0, sp
 801c774:	f7ff ff64 	bl	801c640 <BSP_SD_GetCardInfo>
    *(DWORD*)buff = CardInfo.LogBlockNbr;
 801c778:	9b06      	ldr	r3, [sp, #24]
}
 801c77a:	4620      	mov	r0, r4
    *(DWORD*)buff = CardInfo.LogBlockNbr;
 801c77c:	602b      	str	r3, [r5, #0]
}
 801c77e:	b009      	add	sp, #36	@ 0x24
 801c780:	bd30      	pop	{r4, r5, pc}
    BSP_SD_GetCardInfo(&CardInfo);
 801c782:	4668      	mov	r0, sp
 801c784:	f7ff ff5c 	bl	801c640 <BSP_SD_GetCardInfo>
    *(WORD*)buff = CardInfo.LogBlockSize;
 801c788:	9b07      	ldr	r3, [sp, #28]
}
 801c78a:	4620      	mov	r0, r4
    *(WORD*)buff = CardInfo.LogBlockSize;
 801c78c:	802b      	strh	r3, [r5, #0]
}
 801c78e:	b009      	add	sp, #36	@ 0x24
 801c790:	bd30      	pop	{r4, r5, pc}
    res = RES_PARERR;
 801c792:	2404      	movs	r4, #4
 801c794:	e7e1      	b.n	801c75a <SD_ioctl+0x1e>
 801c796:	bf00      	nop
 801c798:	20000018 	.word	0x20000018

0801c79c <SD_read>:
{
 801c79c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801c7a0:	b082      	sub	sp, #8
 801c7a2:	460e      	mov	r6, r1
 801c7a4:	4617      	mov	r7, r2
 801c7a6:	4698      	mov	r8, r3
  while( osKernelGetTickCount() - timer < timeout)
 801c7a8:	f247 552f 	movw	r5, #29999	@ 0x752f
  timer = osKernelGetTickCount();
 801c7ac:	f001 f846 	bl	801d83c <osKernelGetTickCount>
 801c7b0:	4604      	mov	r4, r0
  while( osKernelGetTickCount() - timer < timeout)
 801c7b2:	e002      	b.n	801c7ba <SD_read+0x1e>
    if (BSP_SD_GetCardState() == SD_TRANSFER_OK)
 801c7b4:	f7ff ff3a 	bl	801c62c <BSP_SD_GetCardState>
 801c7b8:	b140      	cbz	r0, 801c7cc <SD_read+0x30>
  while( osKernelGetTickCount() - timer < timeout)
 801c7ba:	f001 f83f 	bl	801d83c <osKernelGetTickCount>
 801c7be:	1b00      	subs	r0, r0, r4
 801c7c0:	42a8      	cmp	r0, r5
 801c7c2:	d9f7      	bls.n	801c7b4 <SD_read+0x18>
    return res;
 801c7c4:	2001      	movs	r0, #1
}
 801c7c6:	b002      	add	sp, #8
 801c7c8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    ret = BSP_SD_ReadBlocks_DMA((uint32_t*)buff, (uint32_t)(sector), count);
 801c7cc:	4642      	mov	r2, r8
 801c7ce:	4639      	mov	r1, r7
 801c7d0:	4630      	mov	r0, r6
 801c7d2:	f7ff ff0f 	bl	801c5f4 <BSP_SD_ReadBlocks_DMA>
    if (ret == MSD_OK) {
 801c7d6:	4602      	mov	r2, r0
 801c7d8:	2800      	cmp	r0, #0
 801c7da:	d1f3      	bne.n	801c7c4 <SD_read+0x28>
          status = osMessageQueueGet(SDQueueID, (void *)&event, NULL, SD_TIMEOUT);
 801c7dc:	480e      	ldr	r0, [pc, #56]	@ (801c818 <SD_read+0x7c>)
 801c7de:	f247 5330 	movw	r3, #30000	@ 0x7530
 801c7e2:	f10d 0106 	add.w	r1, sp, #6
 801c7e6:	6800      	ldr	r0, [r0, #0]
 801c7e8:	f001 f94e 	bl	801da88 <osMessageQueueGet>
          if ((status == osOK) && (event == READ_CPLT_MSG))
 801c7ec:	2800      	cmp	r0, #0
 801c7ee:	d1e9      	bne.n	801c7c4 <SD_read+0x28>
 801c7f0:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 801c7f4:	2b01      	cmp	r3, #1
 801c7f6:	d1e5      	bne.n	801c7c4 <SD_read+0x28>
            timer = osKernelGetTickCount();
 801c7f8:	f001 f820 	bl	801d83c <osKernelGetTickCount>
            while(osKernelGetTickCount() - timer <SD_TIMEOUT)
 801c7fc:	f247 552f 	movw	r5, #29999	@ 0x752f
            timer = osKernelGetTickCount();
 801c800:	4604      	mov	r4, r0
            while(osKernelGetTickCount() - timer <SD_TIMEOUT)
 801c802:	e003      	b.n	801c80c <SD_read+0x70>
              if (BSP_SD_GetCardState() == SD_TRANSFER_OK)
 801c804:	f7ff ff12 	bl	801c62c <BSP_SD_GetCardState>
 801c808:	2800      	cmp	r0, #0
 801c80a:	d0dc      	beq.n	801c7c6 <SD_read+0x2a>
            while(osKernelGetTickCount() - timer <SD_TIMEOUT)
 801c80c:	f001 f816 	bl	801d83c <osKernelGetTickCount>
 801c810:	1b00      	subs	r0, r0, r4
 801c812:	42a8      	cmp	r0, r5
 801c814:	d9f6      	bls.n	801c804 <SD_read+0x68>
 801c816:	e7d5      	b.n	801c7c4 <SD_read+0x28>
 801c818:	20002bd4 	.word	0x20002bd4

0801c81c <SD_write>:
{
 801c81c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801c820:	b082      	sub	sp, #8
 801c822:	460e      	mov	r6, r1
 801c824:	4617      	mov	r7, r2
 801c826:	4698      	mov	r8, r3
  while( osKernelGetTickCount() - timer < timeout)
 801c828:	f247 552f 	movw	r5, #29999	@ 0x752f
  timer = osKernelGetTickCount();
 801c82c:	f001 f806 	bl	801d83c <osKernelGetTickCount>
 801c830:	4604      	mov	r4, r0
  while( osKernelGetTickCount() - timer < timeout)
 801c832:	e002      	b.n	801c83a <SD_write+0x1e>
    if (BSP_SD_GetCardState() == SD_TRANSFER_OK)
 801c834:	f7ff fefa 	bl	801c62c <BSP_SD_GetCardState>
 801c838:	b140      	cbz	r0, 801c84c <SD_write+0x30>
  while( osKernelGetTickCount() - timer < timeout)
 801c83a:	f000 ffff 	bl	801d83c <osKernelGetTickCount>
 801c83e:	1b00      	subs	r0, r0, r4
 801c840:	42a8      	cmp	r0, r5
 801c842:	d9f7      	bls.n	801c834 <SD_write+0x18>
    return res;
 801c844:	2001      	movs	r0, #1
}
 801c846:	b002      	add	sp, #8
 801c848:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if(BSP_SD_WriteBlocks_DMA((uint32_t*)buff,
 801c84c:	4642      	mov	r2, r8
 801c84e:	4639      	mov	r1, r7
 801c850:	4630      	mov	r0, r6
 801c852:	f7ff fedd 	bl	801c610 <BSP_SD_WriteBlocks_DMA>
 801c856:	4602      	mov	r2, r0
 801c858:	2800      	cmp	r0, #0
 801c85a:	d1f3      	bne.n	801c844 <SD_write+0x28>
    status = osMessageQueueGet(SDQueueID, (void *)&event, NULL, SD_TIMEOUT);
 801c85c:	480e      	ldr	r0, [pc, #56]	@ (801c898 <SD_write+0x7c>)
 801c85e:	f247 5330 	movw	r3, #30000	@ 0x7530
 801c862:	f10d 0106 	add.w	r1, sp, #6
 801c866:	6800      	ldr	r0, [r0, #0]
 801c868:	f001 f90e 	bl	801da88 <osMessageQueueGet>
    if ((status == osOK) && (event == WRITE_CPLT_MSG))
 801c86c:	2800      	cmp	r0, #0
 801c86e:	d1e9      	bne.n	801c844 <SD_write+0x28>
 801c870:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 801c874:	2b02      	cmp	r3, #2
 801c876:	d1e5      	bne.n	801c844 <SD_write+0x28>
        timer = osKernelGetTickCount();
 801c878:	f000 ffe0 	bl	801d83c <osKernelGetTickCount>
        while(osKernelGetTickCount() - timer  < SD_TIMEOUT)
 801c87c:	f247 552f 	movw	r5, #29999	@ 0x752f
        timer = osKernelGetTickCount();
 801c880:	4604      	mov	r4, r0
        while(osKernelGetTickCount() - timer  < SD_TIMEOUT)
 801c882:	e003      	b.n	801c88c <SD_write+0x70>
          if (BSP_SD_GetCardState() == SD_TRANSFER_OK)
 801c884:	f7ff fed2 	bl	801c62c <BSP_SD_GetCardState>
 801c888:	2800      	cmp	r0, #0
 801c88a:	d0dc      	beq.n	801c846 <SD_write+0x2a>
        while(osKernelGetTickCount() - timer  < SD_TIMEOUT)
 801c88c:	f000 ffd6 	bl	801d83c <osKernelGetTickCount>
 801c890:	1b00      	subs	r0, r0, r4
 801c892:	42a8      	cmp	r0, r5
 801c894:	d9f6      	bls.n	801c884 <SD_write+0x68>
 801c896:	e7d5      	b.n	801c844 <SD_write+0x28>
 801c898:	20002bd4 	.word	0x20002bd4

0801c89c <BSP_SD_ReadCpltCallback>:
  * @brief Rx Transfer completed callbacks
  * @param hsd: SD handle
  * @retval None
  */
void BSP_SD_ReadCpltCallback(void)
{
 801c89c:	b500      	push	{lr}
   */
#if (osCMSIS < 0x20000U)
   osMessagePut(SDQueueID, READ_CPLT_MSG, 0);
#else
   const uint16_t msg = READ_CPLT_MSG;
   osMessageQueuePut(SDQueueID, (const void *)&msg, 0, 0);
 801c89e:	2300      	movs	r3, #0
{
 801c8a0:	b083      	sub	sp, #12
   osMessageQueuePut(SDQueueID, (const void *)&msg, 0, 0);
 801c8a2:	4807      	ldr	r0, [pc, #28]	@ (801c8c0 <BSP_SD_ReadCpltCallback+0x24>)
   const uint16_t msg = READ_CPLT_MSG;
 801c8a4:	f04f 0c01 	mov.w	ip, #1
   osMessageQueuePut(SDQueueID, (const void *)&msg, 0, 0);
 801c8a8:	f10d 0106 	add.w	r1, sp, #6
 801c8ac:	461a      	mov	r2, r3
 801c8ae:	6800      	ldr	r0, [r0, #0]
   const uint16_t msg = READ_CPLT_MSG;
 801c8b0:	f8ad c006 	strh.w	ip, [sp, #6]
   osMessageQueuePut(SDQueueID, (const void *)&msg, 0, 0);
 801c8b4:	f001 f894 	bl	801d9e0 <osMessageQueuePut>
#endif
}
 801c8b8:	b003      	add	sp, #12
 801c8ba:	f85d fb04 	ldr.w	pc, [sp], #4
 801c8be:	bf00      	nop
 801c8c0:	20002bd4 	.word	0x20002bd4

0801c8c4 <USBD_CDC_EP0_RxReady>:
  * @param  pdev: device instance
  * @retval status
  */
static uint8_t USBD_CDC_EP0_RxReady(USBD_HandleTypeDef *pdev)
{
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 801c8c4:	f8d0 32d4 	ldr.w	r3, [r0, #724]	@ 0x2d4
 801c8c8:	eb00 0083 	add.w	r0, r0, r3, lsl #2
{
 801c8cc:	b510      	push	{r4, lr}
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 801c8ce:	f8d0 42c0 	ldr.w	r4, [r0, #704]	@ 0x2c0

  if (hcdc == NULL)
 801c8d2:	b184      	cbz	r4, 801c8f6 <USBD_CDC_EP0_RxReady+0x32>
  {
    return (uint8_t)USBD_FAIL;
  }

  if ((pdev->pUserData[pdev->classId] != NULL) && (hcdc->CmdOpCode != 0xFFU))
 801c8d4:	f8d0 32c4 	ldr.w	r3, [r0, #708]	@ 0x2c4
 801c8d8:	b15b      	cbz	r3, 801c8f2 <USBD_CDC_EP0_RxReady+0x2e>
 801c8da:	f894 0200 	ldrb.w	r0, [r4, #512]	@ 0x200
 801c8de:	28ff      	cmp	r0, #255	@ 0xff
 801c8e0:	d007      	beq.n	801c8f2 <USBD_CDC_EP0_RxReady+0x2e>
  {
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(hcdc->CmdOpCode,
 801c8e2:	689b      	ldr	r3, [r3, #8]
 801c8e4:	4621      	mov	r1, r4
 801c8e6:	f894 2201 	ldrb.w	r2, [r4, #513]	@ 0x201
 801c8ea:	4798      	blx	r3
                                                                     (uint8_t *)hcdc->data,
                                                                     (uint16_t)hcdc->CmdLength);
    hcdc->CmdOpCode = 0xFFU;
 801c8ec:	23ff      	movs	r3, #255	@ 0xff
 801c8ee:	f884 3200 	strb.w	r3, [r4, #512]	@ 0x200
  }

  return (uint8_t)USBD_OK;
 801c8f2:	2000      	movs	r0, #0
}
 801c8f4:	bd10      	pop	{r4, pc}
    return (uint8_t)USBD_FAIL;
 801c8f6:	2003      	movs	r0, #3
}
 801c8f8:	bd10      	pop	{r4, pc}
 801c8fa:	bf00      	nop

0801c8fc <USBD_CDC_GetDeviceQualifierDescriptor>:
  *         return Device Qualifier descriptor
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
uint8_t *USBD_CDC_GetDeviceQualifierDescriptor(uint16_t *length)
{
 801c8fc:	4603      	mov	r3, r0
  *length = (uint16_t)sizeof(USBD_CDC_DeviceQualifierDesc);
 801c8fe:	220a      	movs	r2, #10

  return USBD_CDC_DeviceQualifierDesc;
}
 801c900:	4801      	ldr	r0, [pc, #4]	@ (801c908 <USBD_CDC_GetDeviceQualifierDescriptor+0xc>)
  *length = (uint16_t)sizeof(USBD_CDC_DeviceQualifierDesc);
 801c902:	801a      	strh	r2, [r3, #0]
}
 801c904:	4770      	bx	lr
 801c906:	bf00      	nop
 801c908:	20000098 	.word	0x20000098

0801c90c <USBD_CDC_GetFSCfgDesc>:
{
 801c90c:	b570      	push	{r4, r5, r6, lr}
  USBD_EpDescTypeDef *pEpCmdDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_CMD_EP);
 801c90e:	2182      	movs	r1, #130	@ 0x82
{
 801c910:	4606      	mov	r6, r0
  USBD_EpDescTypeDef *pEpCmdDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_CMD_EP);
 801c912:	480f      	ldr	r0, [pc, #60]	@ (801c950 <USBD_CDC_GetFSCfgDesc+0x44>)
 801c914:	f000 fbd2 	bl	801d0bc <USBD_GetEpDesc>
  USBD_EpDescTypeDef *pEpOutDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_OUT_EP);
 801c918:	2101      	movs	r1, #1
  USBD_EpDescTypeDef *pEpCmdDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_CMD_EP);
 801c91a:	4605      	mov	r5, r0
  USBD_EpDescTypeDef *pEpOutDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_OUT_EP);
 801c91c:	480c      	ldr	r0, [pc, #48]	@ (801c950 <USBD_CDC_GetFSCfgDesc+0x44>)
 801c91e:	f000 fbcd 	bl	801d0bc <USBD_GetEpDesc>
  USBD_EpDescTypeDef *pEpInDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_IN_EP);
 801c922:	2181      	movs	r1, #129	@ 0x81
  USBD_EpDescTypeDef *pEpOutDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_OUT_EP);
 801c924:	4604      	mov	r4, r0
  USBD_EpDescTypeDef *pEpInDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_IN_EP);
 801c926:	480a      	ldr	r0, [pc, #40]	@ (801c950 <USBD_CDC_GetFSCfgDesc+0x44>)
 801c928:	f000 fbc8 	bl	801d0bc <USBD_GetEpDesc>
  if (pEpCmdDesc != NULL)
 801c92c:	b10d      	cbz	r5, 801c932 <USBD_CDC_GetFSCfgDesc+0x26>
    pEpCmdDesc->bInterval = CDC_FS_BINTERVAL;
 801c92e:	2210      	movs	r2, #16
 801c930:	71aa      	strb	r2, [r5, #6]
  if (pEpOutDesc != NULL)
 801c932:	b11c      	cbz	r4, 801c93c <USBD_CDC_GetFSCfgDesc+0x30>
    pEpOutDesc->wMaxPacketSize = CDC_DATA_FS_MAX_PACKET_SIZE;
 801c934:	2100      	movs	r1, #0
 801c936:	2240      	movs	r2, #64	@ 0x40
 801c938:	7161      	strb	r1, [r4, #5]
 801c93a:	7122      	strb	r2, [r4, #4]
  if (pEpInDesc != NULL)
 801c93c:	b118      	cbz	r0, 801c946 <USBD_CDC_GetFSCfgDesc+0x3a>
    pEpInDesc->wMaxPacketSize = CDC_DATA_FS_MAX_PACKET_SIZE;
 801c93e:	2100      	movs	r1, #0
 801c940:	2240      	movs	r2, #64	@ 0x40
 801c942:	7141      	strb	r1, [r0, #5]
 801c944:	7102      	strb	r2, [r0, #4]
  *length = (uint16_t)sizeof(USBD_CDC_CfgDesc);
 801c946:	2343      	movs	r3, #67	@ 0x43
}
 801c948:	4801      	ldr	r0, [pc, #4]	@ (801c950 <USBD_CDC_GetFSCfgDesc+0x44>)
  *length = (uint16_t)sizeof(USBD_CDC_CfgDesc);
 801c94a:	8033      	strh	r3, [r6, #0]
}
 801c94c:	bd70      	pop	{r4, r5, r6, pc}
 801c94e:	bf00      	nop
 801c950:	2000001c 	.word	0x2000001c

0801c954 <USBD_CDC_GetHSCfgDesc>:
{
 801c954:	b570      	push	{r4, r5, r6, lr}
  USBD_EpDescTypeDef *pEpCmdDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_CMD_EP);
 801c956:	2182      	movs	r1, #130	@ 0x82
{
 801c958:	4606      	mov	r6, r0
  USBD_EpDescTypeDef *pEpCmdDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_CMD_EP);
 801c95a:	480f      	ldr	r0, [pc, #60]	@ (801c998 <USBD_CDC_GetHSCfgDesc+0x44>)
 801c95c:	f000 fbae 	bl	801d0bc <USBD_GetEpDesc>
  USBD_EpDescTypeDef *pEpOutDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_OUT_EP);
 801c960:	2101      	movs	r1, #1
  USBD_EpDescTypeDef *pEpCmdDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_CMD_EP);
 801c962:	4605      	mov	r5, r0
  USBD_EpDescTypeDef *pEpOutDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_OUT_EP);
 801c964:	480c      	ldr	r0, [pc, #48]	@ (801c998 <USBD_CDC_GetHSCfgDesc+0x44>)
 801c966:	f000 fba9 	bl	801d0bc <USBD_GetEpDesc>
  USBD_EpDescTypeDef *pEpInDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_IN_EP);
 801c96a:	2181      	movs	r1, #129	@ 0x81
  USBD_EpDescTypeDef *pEpOutDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_OUT_EP);
 801c96c:	4604      	mov	r4, r0
  USBD_EpDescTypeDef *pEpInDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_IN_EP);
 801c96e:	480a      	ldr	r0, [pc, #40]	@ (801c998 <USBD_CDC_GetHSCfgDesc+0x44>)
 801c970:	f000 fba4 	bl	801d0bc <USBD_GetEpDesc>
  if (pEpCmdDesc != NULL)
 801c974:	b10d      	cbz	r5, 801c97a <USBD_CDC_GetHSCfgDesc+0x26>
    pEpCmdDesc->bInterval = CDC_HS_BINTERVAL;
 801c976:	2210      	movs	r2, #16
 801c978:	71aa      	strb	r2, [r5, #6]
  if (pEpOutDesc != NULL)
 801c97a:	b11c      	cbz	r4, 801c984 <USBD_CDC_GetHSCfgDesc+0x30>
    pEpOutDesc->wMaxPacketSize = CDC_DATA_HS_MAX_PACKET_SIZE;
 801c97c:	2100      	movs	r1, #0
 801c97e:	2202      	movs	r2, #2
 801c980:	7121      	strb	r1, [r4, #4]
 801c982:	7162      	strb	r2, [r4, #5]
  if (pEpInDesc != NULL)
 801c984:	b118      	cbz	r0, 801c98e <USBD_CDC_GetHSCfgDesc+0x3a>
    pEpInDesc->wMaxPacketSize = CDC_DATA_HS_MAX_PACKET_SIZE;
 801c986:	2100      	movs	r1, #0
 801c988:	2202      	movs	r2, #2
 801c98a:	7101      	strb	r1, [r0, #4]
 801c98c:	7142      	strb	r2, [r0, #5]
  *length = (uint16_t)sizeof(USBD_CDC_CfgDesc);
 801c98e:	2343      	movs	r3, #67	@ 0x43
}
 801c990:	4801      	ldr	r0, [pc, #4]	@ (801c998 <USBD_CDC_GetHSCfgDesc+0x44>)
  *length = (uint16_t)sizeof(USBD_CDC_CfgDesc);
 801c992:	8033      	strh	r3, [r6, #0]
}
 801c994:	bd70      	pop	{r4, r5, r6, pc}
 801c996:	bf00      	nop
 801c998:	2000001c 	.word	0x2000001c

0801c99c <USBD_CDC_DataOut>:
{
 801c99c:	b538      	push	{r3, r4, r5, lr}
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 801c99e:	f8d0 32d4 	ldr.w	r3, [r0, #724]	@ 0x2d4
 801c9a2:	33b0      	adds	r3, #176	@ 0xb0
 801c9a4:	f850 5023 	ldr.w	r5, [r0, r3, lsl #2]
  if (pdev->pClassDataCmsit[pdev->classId] == NULL)
 801c9a8:	b195      	cbz	r5, 801c9d0 <USBD_CDC_DataOut+0x34>
  hcdc->RxLength = USBD_LL_GetRxDataSize(pdev, epnum);
 801c9aa:	4604      	mov	r4, r0
 801c9ac:	f003 fc90 	bl	80202d0 <USBD_LL_GetRxDataSize>
  ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Receive(hcdc->RxBuffer, &hcdc->RxLength);
 801c9b0:	f505 7103 	add.w	r1, r5, #524	@ 0x20c
 801c9b4:	f8d4 32d4 	ldr.w	r3, [r4, #724]	@ 0x2d4
  hcdc->RxLength = USBD_LL_GetRxDataSize(pdev, epnum);
 801c9b8:	f8c5 020c 	str.w	r0, [r5, #524]	@ 0x20c
  ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Receive(hcdc->RxBuffer, &hcdc->RxLength);
 801c9bc:	eb04 0483 	add.w	r4, r4, r3, lsl #2
 801c9c0:	f8d5 0204 	ldr.w	r0, [r5, #516]	@ 0x204
 801c9c4:	f8d4 32c4 	ldr.w	r3, [r4, #708]	@ 0x2c4
 801c9c8:	68db      	ldr	r3, [r3, #12]
 801c9ca:	4798      	blx	r3
  return (uint8_t)USBD_OK;
 801c9cc:	2000      	movs	r0, #0
}
 801c9ce:	bd38      	pop	{r3, r4, r5, pc}
    return (uint8_t)USBD_FAIL;
 801c9d0:	2003      	movs	r0, #3
}
 801c9d2:	bd38      	pop	{r3, r4, r5, pc}

0801c9d4 <USBD_CDC_DataIn>:
{
 801c9d4:	b570      	push	{r4, r5, r6, lr}
 801c9d6:	f8d0 42d4 	ldr.w	r4, [r0, #724]	@ 0x2d4
  PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef *)pdev->pData;
 801c9da:	f8d0 62c8 	ldr.w	r6, [r0, #712]	@ 0x2c8
  if (pdev->pClassDataCmsit[pdev->classId] == NULL)
 801c9de:	eb00 0e84 	add.w	lr, r0, r4, lsl #2
 801c9e2:	f8de 52c0 	ldr.w	r5, [lr, #704]	@ 0x2c0
 801c9e6:	b345      	cbz	r5, 801ca3a <USBD_CDC_DataIn+0x66>
  if ((pdev->ep_in[epnum & 0xFU].total_length > 0U) &&
 801c9e8:	f001 040f 	and.w	r4, r1, #15
 801c9ec:	460a      	mov	r2, r1
 801c9ee:	eb04 0c84 	add.w	ip, r4, r4, lsl #2
 801c9f2:	eb00 0c8c 	add.w	ip, r0, ip, lsl #2
 801c9f6:	f8dc 3018 	ldr.w	r3, [ip, #24]
 801c9fa:	b96b      	cbnz	r3, 801ca18 <USBD_CDC_DataIn+0x44>
    if (((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->TransmitCplt != NULL)
 801c9fc:	f8de 32c4 	ldr.w	r3, [lr, #708]	@ 0x2c4
    hcdc->TxState = 0U;
 801ca00:	2100      	movs	r1, #0
    if (((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->TransmitCplt != NULL)
 801ca02:	691b      	ldr	r3, [r3, #16]
    hcdc->TxState = 0U;
 801ca04:	f8c5 1214 	str.w	r1, [r5, #532]	@ 0x214
    if (((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->TransmitCplt != NULL)
 801ca08:	b123      	cbz	r3, 801ca14 <USBD_CDC_DataIn+0x40>
      ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->TransmitCplt(hcdc->TxBuffer, &hcdc->TxLength, epnum);
 801ca0a:	f505 7104 	add.w	r1, r5, #528	@ 0x210
 801ca0e:	f8d5 0208 	ldr.w	r0, [r5, #520]	@ 0x208
 801ca12:	4798      	blx	r3
  return (uint8_t)USBD_OK;
 801ca14:	2000      	movs	r0, #0
}
 801ca16:	bd70      	pop	{r4, r5, r6, pc}
      ((pdev->ep_in[epnum & 0xFU].total_length % hpcd->IN_ep[epnum & 0xFU].maxpacket) == 0U))
 801ca18:	eb04 04c4 	add.w	r4, r4, r4, lsl #3
 801ca1c:	eb06 0684 	add.w	r6, r6, r4, lsl #2
 801ca20:	69f4      	ldr	r4, [r6, #28]
 801ca22:	fbb3 f6f4 	udiv	r6, r3, r4
 801ca26:	fb04 3316 	mls	r3, r4, r6, r3
  if ((pdev->ep_in[epnum & 0xFU].total_length > 0U) &&
 801ca2a:	2b00      	cmp	r3, #0
 801ca2c:	d1e6      	bne.n	801c9fc <USBD_CDC_DataIn+0x28>
    (void)USBD_LL_Transmit(pdev, epnum, NULL, 0U);
 801ca2e:	461a      	mov	r2, r3
    pdev->ep_in[epnum & 0xFU].total_length = 0U;
 801ca30:	f8cc 3018 	str.w	r3, [ip, #24]
    (void)USBD_LL_Transmit(pdev, epnum, NULL, 0U);
 801ca34:	f003 fc34 	bl	80202a0 <USBD_LL_Transmit>
 801ca38:	e7ec      	b.n	801ca14 <USBD_CDC_DataIn+0x40>
    return (uint8_t)USBD_FAIL;
 801ca3a:	2003      	movs	r0, #3
}
 801ca3c:	bd70      	pop	{r4, r5, r6, pc}
 801ca3e:	bf00      	nop

0801ca40 <USBD_CDC_Setup>:
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 801ca40:	f8d0 32d4 	ldr.w	r3, [r0, #724]	@ 0x2d4
  uint8_t ifalt = 0U;
 801ca44:	2200      	movs	r2, #0
 801ca46:	eb00 0383 	add.w	r3, r0, r3, lsl #2
{
 801ca4a:	b570      	push	{r4, r5, r6, lr}
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 801ca4c:	f8d3 62c0 	ldr.w	r6, [r3, #704]	@ 0x2c0
{
 801ca50:	b082      	sub	sp, #8
  uint8_t ifalt = 0U;
 801ca52:	f88d 2005 	strb.w	r2, [sp, #5]
  uint16_t status_info = 0U;
 801ca56:	f8ad 2006 	strh.w	r2, [sp, #6]
  if (hcdc == NULL)
 801ca5a:	b166      	cbz	r6, 801ca76 <USBD_CDC_Setup+0x36>
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 801ca5c:	f891 c000 	ldrb.w	ip, [r1]
 801ca60:	4604      	mov	r4, r0
 801ca62:	460d      	mov	r5, r1
 801ca64:	f01c 0260 	ands.w	r2, ip, #96	@ 0x60
 801ca68:	d01e      	beq.n	801caa8 <USBD_CDC_Setup+0x68>
 801ca6a:	2a20      	cmp	r2, #32
 801ca6c:	d006      	beq.n	801ca7c <USBD_CDC_Setup+0x3c>
          USBD_CtlError(pdev, req);
 801ca6e:	4629      	mov	r1, r5
 801ca70:	4620      	mov	r0, r4
 801ca72:	f000 fdef 	bl	801d654 <USBD_CtlError>
    return (uint8_t)USBD_FAIL;
 801ca76:	2003      	movs	r0, #3
}
 801ca78:	b002      	add	sp, #8
 801ca7a:	bd70      	pop	{r4, r5, r6, pc}
      if (req->wLength != 0U)
 801ca7c:	88ca      	ldrh	r2, [r1, #6]
          ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(req->bRequest,
 801ca7e:	f891 e001 	ldrb.w	lr, [r1, #1]
      if (req->wLength != 0U)
 801ca82:	b37a      	cbz	r2, 801cae4 <USBD_CDC_Setup+0xa4>
        if ((req->bmRequest & 0x80U) != 0U)
 801ca84:	f01c 0f80 	tst.w	ip, #128	@ 0x80
 801ca88:	d04c      	beq.n	801cb24 <USBD_CDC_Setup+0xe4>
          ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(req->bRequest,
 801ca8a:	f8d3 32c4 	ldr.w	r3, [r3, #708]	@ 0x2c4
 801ca8e:	4631      	mov	r1, r6
 801ca90:	4670      	mov	r0, lr
 801ca92:	689b      	ldr	r3, [r3, #8]
 801ca94:	4798      	blx	r3
          len = MIN(CDC_REQ_MAX_DATA_SIZE, req->wLength);
 801ca96:	88ea      	ldrh	r2, [r5, #6]
          (void)USBD_CtlSendData(pdev, (uint8_t *)hcdc->data, len);
 801ca98:	4631      	mov	r1, r6
 801ca9a:	4620      	mov	r0, r4
 801ca9c:	2a07      	cmp	r2, #7
 801ca9e:	bf28      	it	cs
 801caa0:	2207      	movcs	r2, #7
 801caa2:	f000 fe0f 	bl	801d6c4 <USBD_CtlSendData>
 801caa6:	e022      	b.n	801caee <USBD_CDC_Setup+0xae>
      switch (req->bRequest)
 801caa8:	784b      	ldrb	r3, [r1, #1]
 801caaa:	2b0b      	cmp	r3, #11
 801caac:	d8df      	bhi.n	801ca6e <USBD_CDC_Setup+0x2e>
 801caae:	a201      	add	r2, pc, #4	@ (adr r2, 801cab4 <USBD_CDC_Setup+0x74>)
 801cab0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801cab4:	0801cafd 	.word	0x0801cafd
 801cab8:	0801caef 	.word	0x0801caef
 801cabc:	0801ca6f 	.word	0x0801ca6f
 801cac0:	0801ca6f 	.word	0x0801ca6f
 801cac4:	0801ca6f 	.word	0x0801ca6f
 801cac8:	0801ca6f 	.word	0x0801ca6f
 801cacc:	0801ca6f 	.word	0x0801ca6f
 801cad0:	0801ca6f 	.word	0x0801ca6f
 801cad4:	0801ca6f 	.word	0x0801ca6f
 801cad8:	0801ca6f 	.word	0x0801ca6f
 801cadc:	0801cb11 	.word	0x0801cb11
 801cae0:	0801caf3 	.word	0x0801caf3
        ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(req->bRequest,
 801cae4:	f8d3 32c4 	ldr.w	r3, [r3, #708]	@ 0x2c4
 801cae8:	4670      	mov	r0, lr
 801caea:	689b      	ldr	r3, [r3, #8]
 801caec:	4798      	blx	r3
    return (uint8_t)USBD_FAIL;
 801caee:	2000      	movs	r0, #0
 801caf0:	e7c2      	b.n	801ca78 <USBD_CDC_Setup+0x38>
          if (pdev->dev_state != USBD_STATE_CONFIGURED)
 801caf2:	f890 329c 	ldrb.w	r3, [r0, #668]	@ 0x29c
 801caf6:	2b03      	cmp	r3, #3
 801caf8:	d0f9      	beq.n	801caee <USBD_CDC_Setup+0xae>
 801cafa:	e7b8      	b.n	801ca6e <USBD_CDC_Setup+0x2e>
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 801cafc:	f890 329c 	ldrb.w	r3, [r0, #668]	@ 0x29c
 801cb00:	2b03      	cmp	r3, #3
 801cb02:	d1b4      	bne.n	801ca6e <USBD_CDC_Setup+0x2e>
            (void)USBD_CtlSendData(pdev, (uint8_t *)&status_info, 2U);
 801cb04:	2202      	movs	r2, #2
 801cb06:	f10d 0106 	add.w	r1, sp, #6
 801cb0a:	f000 fddb 	bl	801d6c4 <USBD_CtlSendData>
 801cb0e:	e7ee      	b.n	801caee <USBD_CDC_Setup+0xae>
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 801cb10:	f890 329c 	ldrb.w	r3, [r0, #668]	@ 0x29c
 801cb14:	2b03      	cmp	r3, #3
 801cb16:	d1aa      	bne.n	801ca6e <USBD_CDC_Setup+0x2e>
            (void)USBD_CtlSendData(pdev, &ifalt, 1U);
 801cb18:	2201      	movs	r2, #1
 801cb1a:	f10d 0105 	add.w	r1, sp, #5
 801cb1e:	f000 fdd1 	bl	801d6c4 <USBD_CtlSendData>
 801cb22:	e7e4      	b.n	801caee <USBD_CDC_Setup+0xae>
          hcdc->CmdLength = (uint8_t)MIN(req->wLength, USB_MAX_EP0_SIZE);
 801cb24:	2a40      	cmp	r2, #64	@ 0x40
          (void)USBD_CtlPrepareRx(pdev, (uint8_t *)hcdc->data, hcdc->CmdLength);
 801cb26:	4631      	mov	r1, r6
          hcdc->CmdOpCode = req->bRequest;
 801cb28:	f886 e200 	strb.w	lr, [r6, #512]	@ 0x200
          hcdc->CmdLength = (uint8_t)MIN(req->wLength, USB_MAX_EP0_SIZE);
 801cb2c:	bf28      	it	cs
 801cb2e:	2240      	movcs	r2, #64	@ 0x40
 801cb30:	f886 2201 	strb.w	r2, [r6, #513]	@ 0x201
          (void)USBD_CtlPrepareRx(pdev, (uint8_t *)hcdc->data, hcdc->CmdLength);
 801cb34:	f000 fdde 	bl	801d6f4 <USBD_CtlPrepareRx>
 801cb38:	e7d9      	b.n	801caee <USBD_CDC_Setup+0xae>
 801cb3a:	bf00      	nop

0801cb3c <USBD_CDC_DeInit>:
{
 801cb3c:	b538      	push	{r3, r4, r5, lr}
 801cb3e:	4604      	mov	r4, r0
  pdev->ep_in[CDCInEpAdd & 0xFU].is_used = 0U;
 801cb40:	2500      	movs	r5, #0
  (void)USBD_LL_CloseEP(pdev, CDCInEpAdd);
 801cb42:	2181      	movs	r1, #129	@ 0x81
 801cb44:	f003 fb68 	bl	8020218 <USBD_LL_CloseEP>
  (void)USBD_LL_CloseEP(pdev, CDCOutEpAdd);
 801cb48:	2101      	movs	r1, #1
 801cb4a:	4620      	mov	r0, r4
  pdev->ep_in[CDCInEpAdd & 0xFU].is_used = 0U;
 801cb4c:	8725      	strh	r5, [r4, #56]	@ 0x38
  (void)USBD_LL_CloseEP(pdev, CDCOutEpAdd);
 801cb4e:	f003 fb63 	bl	8020218 <USBD_LL_CloseEP>
  (void)USBD_LL_CloseEP(pdev, CDCCmdEpAdd);
 801cb52:	2182      	movs	r1, #130	@ 0x82
 801cb54:	4620      	mov	r0, r4
  pdev->ep_out[CDCOutEpAdd & 0xFU].is_used = 0U;
 801cb56:	f8a4 5178 	strh.w	r5, [r4, #376]	@ 0x178
  (void)USBD_LL_CloseEP(pdev, CDCCmdEpAdd);
 801cb5a:	f003 fb5d 	bl	8020218 <USBD_LL_CloseEP>
  pdev->ep_in[CDCCmdEpAdd & 0xFU].bInterval = 0U;
 801cb5e:	f8d4 32d4 	ldr.w	r3, [r4, #724]	@ 0x2d4
  pdev->ep_in[CDCCmdEpAdd & 0xFU].is_used = 0U;
 801cb62:	64e5      	str	r5, [r4, #76]	@ 0x4c
  if (pdev->pClassDataCmsit[pdev->classId] != NULL)
 801cb64:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 801cb68:	f8d3 22c0 	ldr.w	r2, [r3, #704]	@ 0x2c0
 801cb6c:	b18a      	cbz	r2, 801cb92 <USBD_CDC_DeInit+0x56>
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->DeInit();
 801cb6e:	f8d3 32c4 	ldr.w	r3, [r3, #708]	@ 0x2c4
 801cb72:	685b      	ldr	r3, [r3, #4]
 801cb74:	4798      	blx	r3
    (void)USBD_free(pdev->pClassDataCmsit[pdev->classId]);
 801cb76:	f8d4 32d4 	ldr.w	r3, [r4, #724]	@ 0x2d4
 801cb7a:	33b0      	adds	r3, #176	@ 0xb0
 801cb7c:	f854 0023 	ldr.w	r0, [r4, r3, lsl #2]
 801cb80:	f015 fb14 	bl	80321ac <free>
    pdev->pClassDataCmsit[pdev->classId] = NULL;
 801cb84:	f8d4 32d4 	ldr.w	r3, [r4, #724]	@ 0x2d4
 801cb88:	33b0      	adds	r3, #176	@ 0xb0
 801cb8a:	f844 5023 	str.w	r5, [r4, r3, lsl #2]
    pdev->pClassData = NULL;
 801cb8e:	f8c4 52bc 	str.w	r5, [r4, #700]	@ 0x2bc
}
 801cb92:	2000      	movs	r0, #0
 801cb94:	bd38      	pop	{r3, r4, r5, pc}
 801cb96:	bf00      	nop

0801cb98 <USBD_CDC_Init>:
{
 801cb98:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801cb9a:	4604      	mov	r4, r0
  hcdc = (USBD_CDC_HandleTypeDef *)USBD_malloc(sizeof(USBD_CDC_HandleTypeDef));
 801cb9c:	2101      	movs	r1, #1
 801cb9e:	f44f 7007 	mov.w	r0, #540	@ 0x21c
 801cba2:	f015 fadf 	bl	8032164 <calloc>
    pdev->pClassDataCmsit[pdev->classId] = NULL;
 801cba6:	f8d4 32d4 	ldr.w	r3, [r4, #724]	@ 0x2d4
  if (hcdc == NULL)
 801cbaa:	4605      	mov	r5, r0
    pdev->pClassDataCmsit[pdev->classId] = NULL;
 801cbac:	33b0      	adds	r3, #176	@ 0xb0
 801cbae:	f844 0023 	str.w	r0, [r4, r3, lsl #2]
  if (hcdc == NULL)
 801cbb2:	2800      	cmp	r0, #0
 801cbb4:	d050      	beq.n	801cc58 <USBD_CDC_Init+0xc0>
  if (pdev->dev_speed == USBD_SPEED_HIGH)
 801cbb6:	7c23      	ldrb	r3, [r4, #16]
  pdev->pClassData = pdev->pClassDataCmsit[pdev->classId];
 801cbb8:	f8c4 02bc 	str.w	r0, [r4, #700]	@ 0x2bc
  if (pdev->dev_speed == USBD_SPEED_HIGH)
 801cbbc:	b3b3      	cbz	r3, 801cc2c <USBD_CDC_Init+0x94>
    (void)USBD_LL_OpenEP(pdev, CDCInEpAdd, USBD_EP_TYPE_BULK,
 801cbbe:	2340      	movs	r3, #64	@ 0x40
 801cbc0:	2202      	movs	r2, #2
 801cbc2:	2181      	movs	r1, #129	@ 0x81
 801cbc4:	4620      	mov	r0, r4
 801cbc6:	f003 fb19 	bl	80201fc <USBD_LL_OpenEP>
    pdev->ep_in[CDCInEpAdd & 0xFU].is_used = 1U;
 801cbca:	2101      	movs	r1, #1
    (void)USBD_LL_OpenEP(pdev, CDCOutEpAdd, USBD_EP_TYPE_BULK,
 801cbcc:	2340      	movs	r3, #64	@ 0x40
 801cbce:	2202      	movs	r2, #2
 801cbd0:	4620      	mov	r0, r4
    pdev->ep_in[CDCInEpAdd & 0xFU].is_used = 1U;
 801cbd2:	8721      	strh	r1, [r4, #56]	@ 0x38
    (void)USBD_LL_OpenEP(pdev, CDCOutEpAdd, USBD_EP_TYPE_BULK,
 801cbd4:	f003 fb12 	bl	80201fc <USBD_LL_OpenEP>
    pdev->ep_out[CDCOutEpAdd & 0xFU].is_used = 1U;
 801cbd8:	2701      	movs	r7, #1
    pdev->ep_in[CDCCmdEpAdd & 0xFU].bInterval = CDC_HS_BINTERVAL;
 801cbda:	2210      	movs	r2, #16
  (void)USBD_LL_OpenEP(pdev, CDCCmdEpAdd, USBD_EP_TYPE_INTR, CDC_CMD_PACKET_SIZE);
 801cbdc:	2308      	movs	r3, #8
 801cbde:	2182      	movs	r1, #130	@ 0x82
    pdev->ep_in[CDCCmdEpAdd & 0xFU].bInterval = CDC_HS_BINTERVAL;
 801cbe0:	f8a4 204e 	strh.w	r2, [r4, #78]	@ 0x4e
  (void)USBD_LL_OpenEP(pdev, CDCCmdEpAdd, USBD_EP_TYPE_INTR, CDC_CMD_PACKET_SIZE);
 801cbe4:	4620      	mov	r0, r4
 801cbe6:	2203      	movs	r2, #3
    pdev->ep_out[CDCOutEpAdd & 0xFU].is_used = 1U;
 801cbe8:	f8a4 7178 	strh.w	r7, [r4, #376]	@ 0x178
  (void)USBD_LL_OpenEP(pdev, CDCCmdEpAdd, USBD_EP_TYPE_INTR, CDC_CMD_PACKET_SIZE);
 801cbec:	f003 fb06 	bl	80201fc <USBD_LL_OpenEP>
  ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Init();
 801cbf0:	f8d4 32d4 	ldr.w	r3, [r4, #724]	@ 0x2d4
  hcdc->RxBuffer = NULL;
 801cbf4:	2600      	movs	r6, #0
  pdev->ep_in[CDCCmdEpAdd & 0xFU].is_used = 1U;
 801cbf6:	f8a4 704c 	strh.w	r7, [r4, #76]	@ 0x4c
  ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Init();
 801cbfa:	eb04 0383 	add.w	r3, r4, r3, lsl #2
  hcdc->RxBuffer = NULL;
 801cbfe:	f8c5 6204 	str.w	r6, [r5, #516]	@ 0x204
  ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Init();
 801cc02:	f8d3 32c4 	ldr.w	r3, [r3, #708]	@ 0x2c4
 801cc06:	681b      	ldr	r3, [r3, #0]
 801cc08:	4798      	blx	r3
  if (hcdc->RxBuffer == NULL)
 801cc0a:	f8d5 2204 	ldr.w	r2, [r5, #516]	@ 0x204
  hcdc->TxState = 0U;
 801cc0e:	f8c5 6214 	str.w	r6, [r5, #532]	@ 0x214
  hcdc->RxState = 0U;
 801cc12:	f8c5 6218 	str.w	r6, [r5, #536]	@ 0x218
  if (hcdc->RxBuffer == NULL)
 801cc16:	b1fa      	cbz	r2, 801cc58 <USBD_CDC_Init+0xc0>
  if (pdev->dev_speed == USBD_SPEED_HIGH)
 801cc18:	7c23      	ldrb	r3, [r4, #16]
 801cc1a:	b9bb      	cbnz	r3, 801cc4c <USBD_CDC_Init+0xb4>
    (void)USBD_LL_PrepareReceive(pdev, CDCOutEpAdd, hcdc->RxBuffer,
 801cc1c:	f44f 7300 	mov.w	r3, #512	@ 0x200
 801cc20:	4639      	mov	r1, r7
 801cc22:	4620      	mov	r0, r4
 801cc24:	f003 fb48 	bl	80202b8 <USBD_LL_PrepareReceive>
  return (uint8_t)USBD_OK;
 801cc28:	2000      	movs	r0, #0
}
 801cc2a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    (void)USBD_LL_OpenEP(pdev, CDCInEpAdd, USBD_EP_TYPE_BULK,
 801cc2c:	f44f 7300 	mov.w	r3, #512	@ 0x200
 801cc30:	2202      	movs	r2, #2
 801cc32:	2181      	movs	r1, #129	@ 0x81
 801cc34:	4620      	mov	r0, r4
 801cc36:	f003 fae1 	bl	80201fc <USBD_LL_OpenEP>
    pdev->ep_in[CDCInEpAdd & 0xFU].is_used = 1U;
 801cc3a:	2101      	movs	r1, #1
    (void)USBD_LL_OpenEP(pdev, CDCOutEpAdd, USBD_EP_TYPE_BULK,
 801cc3c:	f44f 7300 	mov.w	r3, #512	@ 0x200
 801cc40:	2202      	movs	r2, #2
 801cc42:	4620      	mov	r0, r4
    pdev->ep_in[CDCInEpAdd & 0xFU].is_used = 1U;
 801cc44:	8721      	strh	r1, [r4, #56]	@ 0x38
    (void)USBD_LL_OpenEP(pdev, CDCOutEpAdd, USBD_EP_TYPE_BULK,
 801cc46:	f003 fad9 	bl	80201fc <USBD_LL_OpenEP>
    pdev->ep_in[CDCCmdEpAdd & 0xFU].bInterval = CDC_HS_BINTERVAL;
 801cc4a:	e7c5      	b.n	801cbd8 <USBD_CDC_Init+0x40>
    (void)USBD_LL_PrepareReceive(pdev, CDCOutEpAdd, hcdc->RxBuffer,
 801cc4c:	2340      	movs	r3, #64	@ 0x40
 801cc4e:	4639      	mov	r1, r7
 801cc50:	4620      	mov	r0, r4
 801cc52:	f003 fb31 	bl	80202b8 <USBD_LL_PrepareReceive>
 801cc56:	e7e7      	b.n	801cc28 <USBD_CDC_Init+0x90>
    return (uint8_t)USBD_EMEM;
 801cc58:	2002      	movs	r0, #2
}
 801cc5a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0801cc5c <USBD_CDC_GetOtherSpeedCfgDesc>:
static uint8_t *USBD_CDC_GetOtherSpeedCfgDesc(uint16_t *length)
 801cc5c:	b570      	push	{r4, r5, r6, lr}
 801cc5e:	2182      	movs	r1, #130	@ 0x82
 801cc60:	4606      	mov	r6, r0
 801cc62:	480f      	ldr	r0, [pc, #60]	@ (801cca0 <USBD_CDC_GetOtherSpeedCfgDesc+0x44>)
 801cc64:	f000 fa2a 	bl	801d0bc <USBD_GetEpDesc>
 801cc68:	2101      	movs	r1, #1
 801cc6a:	4605      	mov	r5, r0
 801cc6c:	480c      	ldr	r0, [pc, #48]	@ (801cca0 <USBD_CDC_GetOtherSpeedCfgDesc+0x44>)
 801cc6e:	f000 fa25 	bl	801d0bc <USBD_GetEpDesc>
 801cc72:	2181      	movs	r1, #129	@ 0x81
 801cc74:	4604      	mov	r4, r0
 801cc76:	480a      	ldr	r0, [pc, #40]	@ (801cca0 <USBD_CDC_GetOtherSpeedCfgDesc+0x44>)
 801cc78:	f000 fa20 	bl	801d0bc <USBD_GetEpDesc>
 801cc7c:	b10d      	cbz	r5, 801cc82 <USBD_CDC_GetOtherSpeedCfgDesc+0x26>
 801cc7e:	2210      	movs	r2, #16
 801cc80:	71aa      	strb	r2, [r5, #6]
 801cc82:	b11c      	cbz	r4, 801cc8c <USBD_CDC_GetOtherSpeedCfgDesc+0x30>
 801cc84:	2100      	movs	r1, #0
 801cc86:	2240      	movs	r2, #64	@ 0x40
 801cc88:	7161      	strb	r1, [r4, #5]
 801cc8a:	7122      	strb	r2, [r4, #4]
 801cc8c:	b118      	cbz	r0, 801cc96 <USBD_CDC_GetOtherSpeedCfgDesc+0x3a>
 801cc8e:	2100      	movs	r1, #0
 801cc90:	2240      	movs	r2, #64	@ 0x40
 801cc92:	7141      	strb	r1, [r0, #5]
 801cc94:	7102      	strb	r2, [r0, #4]
 801cc96:	2343      	movs	r3, #67	@ 0x43
 801cc98:	4801      	ldr	r0, [pc, #4]	@ (801cca0 <USBD_CDC_GetOtherSpeedCfgDesc+0x44>)
 801cc9a:	8033      	strh	r3, [r6, #0]
 801cc9c:	bd70      	pop	{r4, r5, r6, pc}
 801cc9e:	bf00      	nop
 801cca0:	2000001c 	.word	0x2000001c

0801cca4 <USBD_CDC_RegisterInterface>:
  * @param  fops: CD  Interface callback
  * @retval status
  */
uint8_t USBD_CDC_RegisterInterface(USBD_HandleTypeDef *pdev,
                                   USBD_CDC_ItfTypeDef *fops)
{
 801cca4:	4603      	mov	r3, r0
  if (fops == NULL)
 801cca6:	b139      	cbz	r1, 801ccb8 <USBD_CDC_RegisterInterface+0x14>
  {
    return (uint8_t)USBD_FAIL;
  }

  pdev->pUserData[pdev->classId] = fops;
 801cca8:	f8d0 22d4 	ldr.w	r2, [r0, #724]	@ 0x2d4

  return (uint8_t)USBD_OK;
 801ccac:	2000      	movs	r0, #0
  pdev->pUserData[pdev->classId] = fops;
 801ccae:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 801ccb2:	f8c3 12c4 	str.w	r1, [r3, #708]	@ 0x2c4
  return (uint8_t)USBD_OK;
 801ccb6:	4770      	bx	lr
    return (uint8_t)USBD_FAIL;
 801ccb8:	2003      	movs	r0, #3
}
 801ccba:	4770      	bx	lr

0801ccbc <USBD_CDC_SetTxBuffer>:
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[ClassId];
#else
uint8_t USBD_CDC_SetTxBuffer(USBD_HandleTypeDef *pdev,
                             uint8_t *pbuff, uint32_t length)
{
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 801ccbc:	f8d0 32d4 	ldr.w	r3, [r0, #724]	@ 0x2d4
 801ccc0:	33b0      	adds	r3, #176	@ 0xb0
 801ccc2:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
#endif /* USE_USBD_COMPOSITE */

  if (hcdc == NULL)
 801ccc6:	b12b      	cbz	r3, 801ccd4 <USBD_CDC_SetTxBuffer+0x18>
  }

  hcdc->TxBuffer = pbuff;
  hcdc->TxLength = length;

  return (uint8_t)USBD_OK;
 801ccc8:	2000      	movs	r0, #0
  hcdc->TxBuffer = pbuff;
 801ccca:	f8c3 1208 	str.w	r1, [r3, #520]	@ 0x208
  hcdc->TxLength = length;
 801ccce:	f8c3 2210 	str.w	r2, [r3, #528]	@ 0x210
  return (uint8_t)USBD_OK;
 801ccd2:	4770      	bx	lr
    return (uint8_t)USBD_FAIL;
 801ccd4:	2003      	movs	r0, #3
}
 801ccd6:	4770      	bx	lr

0801ccd8 <USBD_CDC_SetRxBuffer>:
  * @param  pbuff: Rx Buffer
  * @retval status
  */
uint8_t USBD_CDC_SetRxBuffer(USBD_HandleTypeDef *pdev, uint8_t *pbuff)
{
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 801ccd8:	f8d0 32d4 	ldr.w	r3, [r0, #724]	@ 0x2d4
 801ccdc:	33b0      	adds	r3, #176	@ 0xb0
 801ccde:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]

  if (hcdc == NULL)
 801cce2:	b11b      	cbz	r3, 801ccec <USBD_CDC_SetRxBuffer+0x14>
    return (uint8_t)USBD_FAIL;
  }

  hcdc->RxBuffer = pbuff;

  return (uint8_t)USBD_OK;
 801cce4:	2000      	movs	r0, #0
  hcdc->RxBuffer = pbuff;
 801cce6:	f8c3 1204 	str.w	r1, [r3, #516]	@ 0x204
  return (uint8_t)USBD_OK;
 801ccea:	4770      	bx	lr
    return (uint8_t)USBD_FAIL;
 801ccec:	2003      	movs	r0, #3
}
 801ccee:	4770      	bx	lr

0801ccf0 <USBD_CDC_TransmitPacket>:
{
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[ClassId];
#else
uint8_t USBD_CDC_TransmitPacket(USBD_HandleTypeDef *pdev)
{
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 801ccf0:	f8d0 32d4 	ldr.w	r3, [r0, #724]	@ 0x2d4
 801ccf4:	33b0      	adds	r3, #176	@ 0xb0
 801ccf6:	f850 2023 	ldr.w	r2, [r0, r3, lsl #2]
#ifdef USE_USBD_COMPOSITE
  /* Get the Endpoints addresses allocated for this class instance */
  CDCInEpAdd  = USBD_CoreGetEPAdd(pdev, USBD_EP_IN, USBD_EP_TYPE_BULK, ClassId);
#endif  /* USE_USBD_COMPOSITE */

  if (hcdc == NULL)
 801ccfa:	b192      	cbz	r2, 801cd22 <USBD_CDC_TransmitPacket+0x32>
{
 801ccfc:	b510      	push	{r4, lr}
  {
    return (uint8_t)USBD_FAIL;
  }

  if (hcdc->TxState == 0U)
 801ccfe:	f8d2 4214 	ldr.w	r4, [r2, #532]	@ 0x214
 801cd02:	b10c      	cbz	r4, 801cd08 <USBD_CDC_TransmitPacket+0x18>
  USBD_StatusTypeDef ret = USBD_BUSY;
 801cd04:	2001      	movs	r0, #1

    ret = USBD_OK;
  }

  return (uint8_t)ret;
}
 801cd06:	bd10      	pop	{r4, pc}
    hcdc->TxState = 1U;
 801cd08:	2301      	movs	r3, #1
    (void)USBD_LL_Transmit(pdev, CDCInEpAdd, hcdc->TxBuffer, hcdc->TxLength);
 801cd0a:	2181      	movs	r1, #129	@ 0x81
    hcdc->TxState = 1U;
 801cd0c:	f8c2 3214 	str.w	r3, [r2, #532]	@ 0x214
    pdev->ep_in[CDCInEpAdd & 0xFU].total_length = hcdc->TxLength;
 801cd10:	f8d2 3210 	ldr.w	r3, [r2, #528]	@ 0x210
    (void)USBD_LL_Transmit(pdev, CDCInEpAdd, hcdc->TxBuffer, hcdc->TxLength);
 801cd14:	f8d2 2208 	ldr.w	r2, [r2, #520]	@ 0x208
    pdev->ep_in[CDCInEpAdd & 0xFU].total_length = hcdc->TxLength;
 801cd18:	62c3      	str	r3, [r0, #44]	@ 0x2c
    (void)USBD_LL_Transmit(pdev, CDCInEpAdd, hcdc->TxBuffer, hcdc->TxLength);
 801cd1a:	f003 fac1 	bl	80202a0 <USBD_LL_Transmit>
    ret = USBD_OK;
 801cd1e:	4620      	mov	r0, r4
}
 801cd20:	bd10      	pop	{r4, pc}
    return (uint8_t)USBD_FAIL;
 801cd22:	2003      	movs	r0, #3
}
 801cd24:	4770      	bx	lr
 801cd26:	bf00      	nop

0801cd28 <USBD_CDC_ReceivePacket>:
  * @param  pdev: device instance
  * @retval status
  */
uint8_t USBD_CDC_ReceivePacket(USBD_HandleTypeDef *pdev)
{
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 801cd28:	f8d0 22d4 	ldr.w	r2, [r0, #724]	@ 0x2d4
 801cd2c:	32b0      	adds	r2, #176	@ 0xb0
 801cd2e:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
#ifdef USE_USBD_COMPOSITE
  /* Get the Endpoints addresses allocated for this class instance */
  CDCOutEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_OUT, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
#endif /* USE_USBD_COMPOSITE */

  if (pdev->pClassDataCmsit[pdev->classId] == NULL)
 801cd32:	b18a      	cbz	r2, 801cd58 <USBD_CDC_ReceivePacket+0x30>
  }

  if (pdev->dev_speed == USBD_SPEED_HIGH)
  {
    /* Prepare Out endpoint to receive next packet */
    (void)USBD_LL_PrepareReceive(pdev, CDCOutEpAdd, hcdc->RxBuffer,
 801cd34:	f8d2 2204 	ldr.w	r2, [r2, #516]	@ 0x204
{
 801cd38:	b508      	push	{r3, lr}
  if (pdev->dev_speed == USBD_SPEED_HIGH)
 801cd3a:	7c03      	ldrb	r3, [r0, #16]
 801cd3c:	b12b      	cbz	r3, 801cd4a <USBD_CDC_ReceivePacket+0x22>
                                 CDC_DATA_HS_OUT_PACKET_SIZE);
  }
  else
  {
    /* Prepare Out endpoint to receive next packet */
    (void)USBD_LL_PrepareReceive(pdev, CDCOutEpAdd, hcdc->RxBuffer,
 801cd3e:	2340      	movs	r3, #64	@ 0x40
 801cd40:	2101      	movs	r1, #1
 801cd42:	f003 fab9 	bl	80202b8 <USBD_LL_PrepareReceive>
                                 CDC_DATA_FS_OUT_PACKET_SIZE);
  }

  return (uint8_t)USBD_OK;
 801cd46:	2000      	movs	r0, #0
}
 801cd48:	bd08      	pop	{r3, pc}
    (void)USBD_LL_PrepareReceive(pdev, CDCOutEpAdd, hcdc->RxBuffer,
 801cd4a:	f44f 7300 	mov.w	r3, #512	@ 0x200
 801cd4e:	2101      	movs	r1, #1
 801cd50:	f003 fab2 	bl	80202b8 <USBD_LL_PrepareReceive>
  return (uint8_t)USBD_OK;
 801cd54:	2000      	movs	r0, #0
}
 801cd56:	bd08      	pop	{r3, pc}
    return (uint8_t)USBD_FAIL;
 801cd58:	2003      	movs	r0, #3
}
 801cd5a:	4770      	bx	lr

0801cd5c <USBD_Init>:
                             USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
  USBD_StatusTypeDef ret;

  /* Check whether the USB Host handle is valid */
  if (pdev == NULL)
 801cd5c:	b178      	cbz	r0, 801cd7e <USBD_Init+0x22>
    pdev->NumClasses = 0;
    pdev->classId = 0;
  }
#else
  /* Unlink previous class*/
  pdev->pClass[0] = NULL;
 801cd5e:	2300      	movs	r3, #0
 801cd60:	f8c0 32b8 	str.w	r3, [r0, #696]	@ 0x2b8
  pdev->pUserData[0] = NULL;
 801cd64:	f8c0 32c4 	str.w	r3, [r0, #708]	@ 0x2c4
#endif /* USE_USBD_COMPOSITE */

  pdev->pConfDesc = NULL;
 801cd68:	f8c0 32d0 	str.w	r3, [r0, #720]	@ 0x2d0

  /* Assign USBD Descriptors */
  if (pdesc != NULL)
 801cd6c:	b109      	cbz	r1, 801cd72 <USBD_Init+0x16>
  {
    pdev->pDesc = pdesc;
 801cd6e:	f8c0 12b4 	str.w	r1, [r0, #692]	@ 0x2b4
  }

  /* Set Device initial State */
  pdev->dev_state = USBD_STATE_DEFAULT;
 801cd72:	2301      	movs	r3, #1
  pdev->id = id;
 801cd74:	7002      	strb	r2, [r0, #0]
  pdev->dev_state = USBD_STATE_DEFAULT;
 801cd76:	f880 329c 	strb.w	r3, [r0, #668]	@ 0x29c

  /* Initialize low level driver */
  ret = USBD_LL_Init(pdev);
 801cd7a:	f003 ba01 	b.w	8020180 <USBD_LL_Init>

  return ret;
}
 801cd7e:	2003      	movs	r0, #3
 801cd80:	4770      	bx	lr
 801cd82:	bf00      	nop

0801cd84 <USBD_RegisterClass>:
  * @param  pdev: Device Handle
  * @param  pclass: Class handle
  * @retval USBD Status
  */
USBD_StatusTypeDef USBD_RegisterClass(USBD_HandleTypeDef *pdev, USBD_ClassTypeDef *pclass)
{
 801cd84:	b510      	push	{r4, lr}
  uint16_t len = 0U;
 801cd86:	2300      	movs	r3, #0
{
 801cd88:	b082      	sub	sp, #8
  uint16_t len = 0U;
 801cd8a:	f8ad 3006 	strh.w	r3, [sp, #6]

  if (pclass == NULL)
 801cd8e:	b189      	cbz	r1, 801cdb4 <USBD_RegisterClass+0x30>
  if (pdev->pClass[pdev->classId]->GetHSConfigDescriptor != NULL)
  {
    pdev->pConfDesc = (void *)pdev->pClass[pdev->classId]->GetHSConfigDescriptor(&len);
  }
#else /* Default USE_USB_FS */
  if (pdev->pClass[pdev->classId]->GetFSConfigDescriptor != NULL)
 801cd90:	6acb      	ldr	r3, [r1, #44]	@ 0x2c
 801cd92:	4604      	mov	r4, r0
  pdev->pClass[0] = pclass;
 801cd94:	f8c0 12b8 	str.w	r1, [r0, #696]	@ 0x2b8
  if (pdev->pClass[pdev->classId]->GetFSConfigDescriptor != NULL)
 801cd98:	b123      	cbz	r3, 801cda4 <USBD_RegisterClass+0x20>
  {
    pdev->pConfDesc = (void *)pdev->pClass[pdev->classId]->GetFSConfigDescriptor(&len);
 801cd9a:	f10d 0006 	add.w	r0, sp, #6
 801cd9e:	4798      	blx	r3
 801cda0:	f8c4 02d0 	str.w	r0, [r4, #720]	@ 0x2d0
  }
#endif /* USE_USB_FS */

  /* Increment the NumClasses */
  pdev->NumClasses++;
 801cda4:	f8d4 32d8 	ldr.w	r3, [r4, #728]	@ 0x2d8

  return USBD_OK;
 801cda8:	2000      	movs	r0, #0
  pdev->NumClasses++;
 801cdaa:	3301      	adds	r3, #1
 801cdac:	f8c4 32d8 	str.w	r3, [r4, #728]	@ 0x2d8
}
 801cdb0:	b002      	add	sp, #8
 801cdb2:	bd10      	pop	{r4, pc}
    return USBD_FAIL;
 801cdb4:	2003      	movs	r0, #3
}
 801cdb6:	b002      	add	sp, #8
 801cdb8:	bd10      	pop	{r4, pc}
 801cdba:	bf00      	nop

0801cdbc <USBD_Start>:
#ifdef USE_USBD_COMPOSITE
  pdev->classId = 0U;
#endif /* USE_USBD_COMPOSITE */

  /* Start the low level driver  */
  return USBD_LL_Start(pdev);
 801cdbc:	f003 ba12 	b.w	80201e4 <USBD_LL_Start>

0801cdc0 <USBD_SetClassConfig>:
        }
      }
    }
  }
#else
  if (pdev->pClass[0] != NULL)
 801cdc0:	f8d0 32b8 	ldr.w	r3, [r0, #696]	@ 0x2b8
 801cdc4:	b10b      	cbz	r3, 801cdca <USBD_SetClassConfig+0xa>
  {
    /* Set configuration and Start the Class */
    ret = (USBD_StatusTypeDef)pdev->pClass[0]->Init(pdev, cfgidx);
 801cdc6:	681b      	ldr	r3, [r3, #0]
 801cdc8:	4718      	bx	r3
  }
#endif /* USE_USBD_COMPOSITE */

  return ret;
}
 801cdca:	4618      	mov	r0, r3
 801cdcc:	4770      	bx	lr
 801cdce:	bf00      	nop

0801cdd0 <USBD_ClrClassConfig>:
  * @param  pdev: device instance
  * @param  cfgidx: configuration index
  * @retval status
  */
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 801cdd0:	b508      	push	{r3, lr}
      }
    }
  }
#else
  /* Clear configuration  and De-initialize the Class process */
  if (pdev->pClass[0]->DeInit(pdev, cfgidx) != 0U)
 801cdd2:	f8d0 32b8 	ldr.w	r3, [r0, #696]	@ 0x2b8
 801cdd6:	685b      	ldr	r3, [r3, #4]
 801cdd8:	4798      	blx	r3
  {
    ret = USBD_FAIL;
 801cdda:	2800      	cmp	r0, #0
  }
#endif /* USE_USBD_COMPOSITE */

  return ret;
}
 801cddc:	bf18      	it	ne
 801cdde:	2003      	movne	r0, #3
 801cde0:	bd08      	pop	{r3, pc}
 801cde2:	bf00      	nop

0801cde4 <USBD_LL_SetupStage>:
  * @param  pdev: device instance
  * @param  psetup: setup packet buffer pointer
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{
 801cde4:	b538      	push	{r3, r4, r5, lr}
  USBD_StatusTypeDef ret;

  USBD_ParseSetupRequest(&pdev->request, psetup);
 801cde6:	f200 25aa 	addw	r5, r0, #682	@ 0x2aa
{
 801cdea:	4604      	mov	r4, r0
  USBD_ParseSetupRequest(&pdev->request, psetup);
 801cdec:	4628      	mov	r0, r5
 801cdee:	f000 fc25 	bl	801d63c <USBD_ParseSetupRequest>

  pdev->ep0_state = USBD_EP0_SETUP;

  pdev->ep0_data_len = pdev->request.wLength;
 801cdf2:	f8b4 32b0 	ldrh.w	r3, [r4, #688]	@ 0x2b0

  switch (pdev->request.bmRequest & 0x1FU)
 801cdf6:	f894 12aa 	ldrb.w	r1, [r4, #682]	@ 0x2aa
  pdev->ep0_state = USBD_EP0_SETUP;
 801cdfa:	2201      	movs	r2, #1
  pdev->ep0_data_len = pdev->request.wLength;
 801cdfc:	f8c4 3298 	str.w	r3, [r4, #664]	@ 0x298
 801ce00:	f001 031f 	and.w	r3, r1, #31
  pdev->ep0_state = USBD_EP0_SETUP;
 801ce04:	f8c4 2294 	str.w	r2, [r4, #660]	@ 0x294
  switch (pdev->request.bmRequest & 0x1FU)
 801ce08:	4293      	cmp	r3, r2
 801ce0a:	d009      	beq.n	801ce20 <USBD_LL_SetupStage+0x3c>
 801ce0c:	2b02      	cmp	r3, #2
 801ce0e:	d013      	beq.n	801ce38 <USBD_LL_SetupStage+0x54>
 801ce10:	b163      	cbz	r3, 801ce2c <USBD_LL_SetupStage+0x48>
    case USB_REQ_RECIPIENT_ENDPOINT:
      ret = USBD_StdEPReq(pdev, &pdev->request);
      break;

    default:
      ret = USBD_LL_StallEP(pdev, (pdev->request.bmRequest & 0x80U));
 801ce12:	4620      	mov	r0, r4
 801ce14:	f001 0180 	and.w	r1, r1, #128	@ 0x80
      break;
  }

  return ret;
}
 801ce18:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      ret = USBD_LL_StallEP(pdev, (pdev->request.bmRequest & 0x80U));
 801ce1c:	f003 ba08 	b.w	8020230 <USBD_LL_StallEP>
      ret = USBD_StdItfReq(pdev, &pdev->request);
 801ce20:	4629      	mov	r1, r5
 801ce22:	4620      	mov	r0, r4
}
 801ce24:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      ret = USBD_StdItfReq(pdev, &pdev->request);
 801ce28:	f000 bb1c 	b.w	801d464 <USBD_StdItfReq>
      ret = USBD_StdDevReq(pdev, &pdev->request);
 801ce2c:	4629      	mov	r1, r5
 801ce2e:	4620      	mov	r0, r4
}
 801ce30:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      ret = USBD_StdDevReq(pdev, &pdev->request);
 801ce34:	f000 b958 	b.w	801d0e8 <USBD_StdDevReq>
      ret = USBD_StdEPReq(pdev, &pdev->request);
 801ce38:	4629      	mov	r1, r5
 801ce3a:	4620      	mov	r0, r4
}
 801ce3c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      ret = USBD_StdEPReq(pdev, &pdev->request);
 801ce40:	f000 bb4c 	b.w	801d4dc <USBD_StdEPReq>

0801ce44 <USBD_LL_DataOutStage>:
  * @param  pdata: data pointer
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev,
                                        uint8_t epnum, uint8_t *pdata)
{
 801ce44:	b570      	push	{r4, r5, r6, lr}
 801ce46:	4604      	mov	r4, r0
  USBD_EndpointTypeDef *pep;
  USBD_StatusTypeDef ret = USBD_OK;
  uint8_t idx;

  if (epnum == 0U)
 801ce48:	b931      	cbnz	r1, 801ce58 <USBD_LL_DataOutStage+0x14>
 801ce4a:	460b      	mov	r3, r1
  {
    pep = &pdev->ep_out[0];

    if (pdev->ep0_state == USBD_EP0_DATA_OUT)
 801ce4c:	f8d0 1294 	ldr.w	r1, [r0, #660]	@ 0x294
 801ce50:	2903      	cmp	r1, #3
 801ce52:	d010      	beq.n	801ce76 <USBD_LL_DataOutStage+0x32>
      }
    }
  }

  return USBD_OK;
}
 801ce54:	2000      	movs	r0, #0
 801ce56:	bd70      	pop	{r4, r5, r6, pc}
      if (pdev->dev_state == USBD_STATE_CONFIGURED)
 801ce58:	f890 329c 	ldrb.w	r3, [r0, #668]	@ 0x29c
 801ce5c:	2b03      	cmp	r3, #3
 801ce5e:	d1f9      	bne.n	801ce54 <USBD_LL_DataOutStage+0x10>
        if (pdev->pClass[idx]->DataOut != NULL)
 801ce60:	f8d0 32b8 	ldr.w	r3, [r0, #696]	@ 0x2b8
 801ce64:	699b      	ldr	r3, [r3, #24]
 801ce66:	2b00      	cmp	r3, #0
 801ce68:	d0f4      	beq.n	801ce54 <USBD_LL_DataOutStage+0x10>
          pdev->classId = idx;
 801ce6a:	2200      	movs	r2, #0
}
 801ce6c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
          pdev->classId = idx;
 801ce70:	f8c0 22d4 	str.w	r2, [r0, #724]	@ 0x2d4
          ret = (USBD_StatusTypeDef)pdev->pClass[idx]->DataOut(pdev, epnum);
 801ce74:	4718      	bx	r3
      if (pep->rem_length > pep->maxpacket)
 801ce76:	e9d0 1557 	ldrd	r1, r5, [r0, #348]	@ 0x15c
 801ce7a:	42a9      	cmp	r1, r5
 801ce7c:	d808      	bhi.n	801ce90 <USBD_LL_DataOutStage+0x4c>
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 801ce7e:	f890 229c 	ldrb.w	r2, [r0, #668]	@ 0x29c
 801ce82:	2a03      	cmp	r2, #3
 801ce84:	d00f      	beq.n	801cea6 <USBD_LL_DataOutStage+0x62>
        (void)USBD_CtlSendStatus(pdev);
 801ce86:	4620      	mov	r0, r4
 801ce88:	f000 fc4c 	bl	801d724 <USBD_CtlSendStatus>
}
 801ce8c:	2000      	movs	r0, #0
 801ce8e:	bd70      	pop	{r4, r5, r6, pc}
        pep->rem_length -= pep->maxpacket;
 801ce90:	1b4b      	subs	r3, r1, r5
        (void)USBD_CtlContinueRx(pdev, pdata, MIN(pep->rem_length, pep->maxpacket));
 801ce92:	4611      	mov	r1, r2
 801ce94:	462a      	mov	r2, r5
 801ce96:	429d      	cmp	r5, r3
        pep->rem_length -= pep->maxpacket;
 801ce98:	f8c0 315c 	str.w	r3, [r0, #348]	@ 0x15c
        (void)USBD_CtlContinueRx(pdev, pdata, MIN(pep->rem_length, pep->maxpacket));
 801ce9c:	bf28      	it	cs
 801ce9e:	461a      	movcs	r2, r3
 801cea0:	f000 fc36 	bl	801d710 <USBD_CtlContinueRx>
 801cea4:	e7d6      	b.n	801ce54 <USBD_LL_DataOutStage+0x10>
            if (pdev->pClass[idx]->EP0_RxReady != NULL)
 801cea6:	f8d0 22b8 	ldr.w	r2, [r0, #696]	@ 0x2b8
 801ceaa:	6912      	ldr	r2, [r2, #16]
 801ceac:	2a00      	cmp	r2, #0
 801ceae:	d0ea      	beq.n	801ce86 <USBD_LL_DataOutStage+0x42>
              pdev->classId = idx;
 801ceb0:	f8c0 32d4 	str.w	r3, [r0, #724]	@ 0x2d4
              pdev->pClass[idx]->EP0_RxReady(pdev);
 801ceb4:	4790      	blx	r2
 801ceb6:	e7e6      	b.n	801ce86 <USBD_LL_DataOutStage+0x42>

0801ceb8 <USBD_LL_DataInStage>:
  * @param  pdata: data pointer
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev,
                                       uint8_t epnum, uint8_t *pdata)
{
 801ceb8:	b570      	push	{r4, r5, r6, lr}
 801ceba:	4604      	mov	r4, r0
  USBD_EndpointTypeDef *pep;
  USBD_StatusTypeDef ret;
  uint8_t idx;

  if (epnum == 0U)
 801cebc:	b959      	cbnz	r1, 801ced6 <USBD_LL_DataInStage+0x1e>
  {
    pep = &pdev->ep_in[0];

    if (pdev->ep0_state == USBD_EP0_DATA_IN)
 801cebe:	f8d0 3294 	ldr.w	r3, [r0, #660]	@ 0x294
 801cec2:	2b02      	cmp	r3, #2
 801cec4:	d016      	beq.n	801cef4 <USBD_LL_DataInStage+0x3c>
          (void)USBD_CtlReceiveStatus(pdev);
        }
      }
    }

    if (pdev->dev_test_mode != 0U)
 801cec6:	f894 32a0 	ldrb.w	r3, [r4, #672]	@ 0x2a0
 801ceca:	b113      	cbz	r3, 801ced2 <USBD_LL_DataInStage+0x1a>
    {
      (void)USBD_RunTestMode(pdev);
      pdev->dev_test_mode = 0U;
 801cecc:	2300      	movs	r3, #0
 801cece:	f884 32a0 	strb.w	r3, [r4, #672]	@ 0x2a0
      }
    }
  }

  return USBD_OK;
}
 801ced2:	2000      	movs	r0, #0
 801ced4:	bd70      	pop	{r4, r5, r6, pc}
      if (pdev->dev_state == USBD_STATE_CONFIGURED)
 801ced6:	f890 329c 	ldrb.w	r3, [r0, #668]	@ 0x29c
 801ceda:	2b03      	cmp	r3, #3
 801cedc:	d1f9      	bne.n	801ced2 <USBD_LL_DataInStage+0x1a>
        if (pdev->pClass[idx]->DataIn != NULL)
 801cede:	f8d0 32b8 	ldr.w	r3, [r0, #696]	@ 0x2b8
 801cee2:	695b      	ldr	r3, [r3, #20]
 801cee4:	2b00      	cmp	r3, #0
 801cee6:	d0f4      	beq.n	801ced2 <USBD_LL_DataInStage+0x1a>
          pdev->classId = idx;
 801cee8:	2200      	movs	r2, #0
}
 801ceea:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
          pdev->classId = idx;
 801ceee:	f8c0 22d4 	str.w	r2, [r0, #724]	@ 0x2d4
          ret = (USBD_StatusTypeDef)pdev->pClass[idx]->DataIn(pdev, epnum);
 801cef2:	4718      	bx	r3
      if (pep->rem_length > pep->maxpacket)
 801cef4:	e9d0 3607 	ldrd	r3, r6, [r0, #28]
 801cef8:	460d      	mov	r5, r1
 801cefa:	42b3      	cmp	r3, r6
 801cefc:	d810      	bhi.n	801cf20 <USBD_LL_DataInStage+0x68>
        if ((pep->maxpacket == pep->rem_length) &&
 801cefe:	d01c      	beq.n	801cf3a <USBD_LL_DataInStage+0x82>
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 801cf00:	f894 329c 	ldrb.w	r3, [r4, #668]	@ 0x29c
 801cf04:	2b03      	cmp	r3, #3
 801cf06:	d02b      	beq.n	801cf60 <USBD_LL_DataInStage+0xa8>
          (void)USBD_LL_StallEP(pdev, 0x80U);
 801cf08:	2180      	movs	r1, #128	@ 0x80
 801cf0a:	4620      	mov	r0, r4
 801cf0c:	f003 f990 	bl	8020230 <USBD_LL_StallEP>
          (void)USBD_CtlReceiveStatus(pdev);
 801cf10:	4620      	mov	r0, r4
 801cf12:	f000 fc13 	bl	801d73c <USBD_CtlReceiveStatus>
    if (pdev->dev_test_mode != 0U)
 801cf16:	f894 32a0 	ldrb.w	r3, [r4, #672]	@ 0x2a0
 801cf1a:	2b00      	cmp	r3, #0
 801cf1c:	d0d9      	beq.n	801ced2 <USBD_LL_DataInStage+0x1a>
 801cf1e:	e7d5      	b.n	801cecc <USBD_LL_DataInStage+0x14>
        pep->rem_length -= pep->maxpacket;
 801cf20:	1b9b      	subs	r3, r3, r6
        (void)USBD_CtlContinueSendData(pdev, pdata, pep->rem_length);
 801cf22:	4611      	mov	r1, r2
        pep->rem_length -= pep->maxpacket;
 801cf24:	61c3      	str	r3, [r0, #28]
        (void)USBD_CtlContinueSendData(pdev, pdata, pep->rem_length);
 801cf26:	461a      	mov	r2, r3
 801cf28:	f000 fbda 	bl	801d6e0 <USBD_CtlContinueSendData>
        (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 801cf2c:	462b      	mov	r3, r5
 801cf2e:	462a      	mov	r2, r5
 801cf30:	4629      	mov	r1, r5
 801cf32:	4620      	mov	r0, r4
 801cf34:	f003 f9c0 	bl	80202b8 <USBD_LL_PrepareReceive>
 801cf38:	e7c5      	b.n	801cec6 <USBD_LL_DataInStage+0xe>
            (pep->total_length >= pep->maxpacket) &&
 801cf3a:	6982      	ldr	r2, [r0, #24]
        if ((pep->maxpacket == pep->rem_length) &&
 801cf3c:	4293      	cmp	r3, r2
 801cf3e:	d8df      	bhi.n	801cf00 <USBD_LL_DataInStage+0x48>
            (pep->total_length >= pep->maxpacket) &&
 801cf40:	f8d0 3298 	ldr.w	r3, [r0, #664]	@ 0x298
 801cf44:	429a      	cmp	r2, r3
 801cf46:	d2db      	bcs.n	801cf00 <USBD_LL_DataInStage+0x48>
          (void)USBD_CtlContinueSendData(pdev, NULL, 0U);
 801cf48:	460a      	mov	r2, r1
 801cf4a:	f000 fbc9 	bl	801d6e0 <USBD_CtlContinueSendData>
          (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 801cf4e:	462b      	mov	r3, r5
 801cf50:	462a      	mov	r2, r5
 801cf52:	4629      	mov	r1, r5
 801cf54:	4620      	mov	r0, r4
          pdev->ep0_data_len = 0U;
 801cf56:	f8c4 5298 	str.w	r5, [r4, #664]	@ 0x298
          (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 801cf5a:	f003 f9ad 	bl	80202b8 <USBD_LL_PrepareReceive>
 801cf5e:	e7b2      	b.n	801cec6 <USBD_LL_DataInStage+0xe>
            if (pdev->pClass[0]->EP0_TxSent != NULL)
 801cf60:	f8d4 32b8 	ldr.w	r3, [r4, #696]	@ 0x2b8
 801cf64:	68db      	ldr	r3, [r3, #12]
 801cf66:	2b00      	cmp	r3, #0
 801cf68:	d0ce      	beq.n	801cf08 <USBD_LL_DataInStage+0x50>
              pdev->classId = 0U;
 801cf6a:	2200      	movs	r2, #0
              pdev->pClass[0]->EP0_TxSent(pdev);
 801cf6c:	4620      	mov	r0, r4
              pdev->classId = 0U;
 801cf6e:	f8c4 22d4 	str.w	r2, [r4, #724]	@ 0x2d4
              pdev->pClass[0]->EP0_TxSent(pdev);
 801cf72:	4798      	blx	r3
 801cf74:	e7c8      	b.n	801cf08 <USBD_LL_DataInStage+0x50>
 801cf76:	bf00      	nop

0801cf78 <USBD_LL_Reset>:
  *         Handle Reset event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef *pdev)
{
 801cf78:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  USBD_StatusTypeDef ret = USBD_OK;

  /* Upon Reset call user call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
  pdev->ep0_state = USBD_EP0_IDLE;
 801cf7a:	2100      	movs	r1, #0
  pdev->dev_state = USBD_STATE_DEFAULT;
 801cf7c:	2201      	movs	r2, #1
      }
    }
  }
#else

  if (pdev->pClass[0] != NULL)
 801cf7e:	f8d0 32b8 	ldr.w	r3, [r0, #696]	@ 0x2b8
{
 801cf82:	4604      	mov	r4, r0
  pdev->dev_state = USBD_STATE_DEFAULT;
 801cf84:	f880 229c 	strb.w	r2, [r0, #668]	@ 0x29c
  pdev->dev_config = 0U;
 801cf88:	6041      	str	r1, [r0, #4]
  pdev->ep0_state = USBD_EP0_IDLE;
 801cf8a:	f8c0 1294 	str.w	r1, [r0, #660]	@ 0x294
  pdev->dev_remote_wakeup = 0U;
 801cf8e:	f8c0 12a4 	str.w	r1, [r0, #676]	@ 0x2a4
  pdev->dev_test_mode = 0U;
 801cf92:	f880 12a0 	strb.w	r1, [r0, #672]	@ 0x2a0
  if (pdev->pClass[0] != NULL)
 801cf96:	b11b      	cbz	r3, 801cfa0 <USBD_LL_Reset+0x28>
  {
    if (pdev->pClass[0]->DeInit != NULL)
 801cf98:	685b      	ldr	r3, [r3, #4]
 801cf9a:	b10b      	cbz	r3, 801cfa0 <USBD_LL_Reset+0x28>
    {
      if (pdev->pClass[0]->DeInit(pdev, (uint8_t)pdev->dev_config) != USBD_OK)
 801cf9c:	4798      	blx	r3
 801cf9e:	b9b0      	cbnz	r0, 801cfce <USBD_LL_Reset+0x56>
  USBD_StatusTypeDef ret = USBD_OK;
 801cfa0:	2700      	movs	r7, #0
    }
  }
#endif /* USE_USBD_COMPOSITE */

  /* Open EP0 OUT */
  (void)USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 801cfa2:	2340      	movs	r3, #64	@ 0x40
 801cfa4:	2200      	movs	r2, #0
  pdev->ep_out[0x00U & 0xFU].is_used = 1U;
 801cfa6:	2601      	movs	r6, #1
  (void)USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 801cfa8:	4620      	mov	r0, r4

  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 801cfaa:	461d      	mov	r5, r3
  (void)USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 801cfac:	4611      	mov	r1, r2
 801cfae:	f003 f925 	bl	80201fc <USBD_LL_OpenEP>

  /* Open EP0 IN */
  (void)USBD_LL_OpenEP(pdev, 0x80U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 801cfb2:	2200      	movs	r2, #0
 801cfb4:	462b      	mov	r3, r5
 801cfb6:	2180      	movs	r1, #128	@ 0x80
 801cfb8:	4620      	mov	r0, r4
  pdev->ep_out[0x00U & 0xFU].is_used = 1U;
 801cfba:	f8a4 6164 	strh.w	r6, [r4, #356]	@ 0x164
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 801cfbe:	f8c4 5160 	str.w	r5, [r4, #352]	@ 0x160
  (void)USBD_LL_OpenEP(pdev, 0x80U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 801cfc2:	f003 f91b 	bl	80201fc <USBD_LL_OpenEP>
  pdev->ep_in[0x80U & 0xFU].is_used = 1U;

  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;

  return ret;
}
 801cfc6:	4638      	mov	r0, r7
  pdev->ep_in[0x80U & 0xFU].is_used = 1U;
 801cfc8:	84a6      	strh	r6, [r4, #36]	@ 0x24
  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
 801cfca:	6225      	str	r5, [r4, #32]
}
 801cfcc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        ret = USBD_FAIL;
 801cfce:	2703      	movs	r7, #3
 801cfd0:	e7e7      	b.n	801cfa2 <USBD_LL_Reset+0x2a>
 801cfd2:	bf00      	nop

0801cfd4 <USBD_LL_SetSpeed>:
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef *pdev,
                                    USBD_SpeedTypeDef speed)
{
 801cfd4:	4603      	mov	r3, r0
  pdev->dev_speed = speed;

  return USBD_OK;
}
 801cfd6:	2000      	movs	r0, #0
  pdev->dev_speed = speed;
 801cfd8:	7419      	strb	r1, [r3, #16]
}
 801cfda:	4770      	bx	lr

0801cfdc <USBD_LL_Suspend>:
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef *pdev)
{
  if (pdev->dev_state != USBD_STATE_SUSPENDED)
 801cfdc:	f890 229c 	ldrb.w	r2, [r0, #668]	@ 0x29c
{
 801cfe0:	4603      	mov	r3, r0
  if (pdev->dev_state != USBD_STATE_SUSPENDED)
 801cfe2:	2a04      	cmp	r2, #4
 801cfe4:	d004      	beq.n	801cff0 <USBD_LL_Suspend+0x14>
  {
    pdev->dev_old_state = pdev->dev_state;
 801cfe6:	f890 229c 	ldrb.w	r2, [r0, #668]	@ 0x29c
 801cfea:	b2d2      	uxtb	r2, r2
 801cfec:	f880 229d 	strb.w	r2, [r0, #669]	@ 0x29d
  }

  pdev->dev_state = USBD_STATE_SUSPENDED;
 801cff0:	2204      	movs	r2, #4

  return USBD_OK;
}
 801cff2:	2000      	movs	r0, #0
  pdev->dev_state = USBD_STATE_SUSPENDED;
 801cff4:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
}
 801cff8:	4770      	bx	lr
 801cffa:	bf00      	nop

0801cffc <USBD_LL_Resume>:
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef *pdev)
{
  if (pdev->dev_state == USBD_STATE_SUSPENDED)
 801cffc:	f890 329c 	ldrb.w	r3, [r0, #668]	@ 0x29c
 801d000:	2b04      	cmp	r3, #4
 801d002:	d104      	bne.n	801d00e <USBD_LL_Resume+0x12>
  {
    pdev->dev_state = pdev->dev_old_state;
 801d004:	f890 329d 	ldrb.w	r3, [r0, #669]	@ 0x29d
 801d008:	b2db      	uxtb	r3, r3
 801d00a:	f880 329c 	strb.w	r3, [r0, #668]	@ 0x29c
  }

  return USBD_OK;
}
 801d00e:	2000      	movs	r0, #0
 801d010:	4770      	bx	lr
 801d012:	bf00      	nop

0801d014 <USBD_LL_SOF>:
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef *pdev)
{
  /* The SOF event can be distributed for all classes that support it */
  if (pdev->dev_state == USBD_STATE_CONFIGURED)
 801d014:	f890 229c 	ldrb.w	r2, [r0, #668]	@ 0x29c
 801d018:	2a03      	cmp	r2, #3
 801d01a:	d001      	beq.n	801d020 <USBD_LL_SOF+0xc>
    }
#endif /* USE_USBD_COMPOSITE */
  }

  return USBD_OK;
}
 801d01c:	2000      	movs	r0, #0
 801d01e:	4770      	bx	lr
{
 801d020:	b508      	push	{r3, lr}
    if (pdev->pClass[0] != NULL)
 801d022:	f8d0 32b8 	ldr.w	r3, [r0, #696]	@ 0x2b8
 801d026:	b113      	cbz	r3, 801d02e <USBD_LL_SOF+0x1a>
      if (pdev->pClass[0]->SOF != NULL)
 801d028:	69db      	ldr	r3, [r3, #28]
 801d02a:	b103      	cbz	r3, 801d02e <USBD_LL_SOF+0x1a>
        (void)pdev->pClass[0]->SOF(pdev);
 801d02c:	4798      	blx	r3
}
 801d02e:	2000      	movs	r0, #0
 801d030:	bd08      	pop	{r3, pc}
 801d032:	bf00      	nop

0801d034 <USBD_LL_IsoINIncomplete>:
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_IsoINIncomplete(USBD_HandleTypeDef *pdev,
                                           uint8_t epnum)
{
  if (pdev->pClass[pdev->classId] == NULL)
 801d034:	f8d0 22d4 	ldr.w	r2, [r0, #724]	@ 0x2d4
 801d038:	32ae      	adds	r2, #174	@ 0xae
 801d03a:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
 801d03e:	b162      	cbz	r2, 801d05a <USBD_LL_IsoINIncomplete+0x26>
{
 801d040:	b508      	push	{r3, lr}
  {
    return USBD_FAIL;
  }

  if (pdev->dev_state == USBD_STATE_CONFIGURED)
 801d042:	f890 329c 	ldrb.w	r3, [r0, #668]	@ 0x29c
 801d046:	2b03      	cmp	r3, #3
 801d048:	d001      	beq.n	801d04e <USBD_LL_IsoINIncomplete+0x1a>
    {
      (void)pdev->pClass[pdev->classId]->IsoINIncomplete(pdev, epnum);
    }
  }

  return USBD_OK;
 801d04a:	2000      	movs	r0, #0
}
 801d04c:	bd08      	pop	{r3, pc}
    if (pdev->pClass[pdev->classId]->IsoINIncomplete != NULL)
 801d04e:	6a13      	ldr	r3, [r2, #32]
 801d050:	2b00      	cmp	r3, #0
 801d052:	d0fa      	beq.n	801d04a <USBD_LL_IsoINIncomplete+0x16>
      (void)pdev->pClass[pdev->classId]->IsoINIncomplete(pdev, epnum);
 801d054:	4798      	blx	r3
  return USBD_OK;
 801d056:	2000      	movs	r0, #0
}
 801d058:	bd08      	pop	{r3, pc}
    return USBD_FAIL;
 801d05a:	2003      	movs	r0, #3
}
 801d05c:	4770      	bx	lr
 801d05e:	bf00      	nop

0801d060 <USBD_LL_IsoOUTIncomplete>:
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_IsoOUTIncomplete(USBD_HandleTypeDef *pdev,
                                            uint8_t epnum)
{
  if (pdev->pClass[pdev->classId] == NULL)
 801d060:	f8d0 22d4 	ldr.w	r2, [r0, #724]	@ 0x2d4
 801d064:	32ae      	adds	r2, #174	@ 0xae
 801d066:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
 801d06a:	b162      	cbz	r2, 801d086 <USBD_LL_IsoOUTIncomplete+0x26>
{
 801d06c:	b508      	push	{r3, lr}
  {
    return USBD_FAIL;
  }

  if (pdev->dev_state == USBD_STATE_CONFIGURED)
 801d06e:	f890 329c 	ldrb.w	r3, [r0, #668]	@ 0x29c
 801d072:	2b03      	cmp	r3, #3
 801d074:	d001      	beq.n	801d07a <USBD_LL_IsoOUTIncomplete+0x1a>
    {
      (void)pdev->pClass[pdev->classId]->IsoOUTIncomplete(pdev, epnum);
    }
  }

  return USBD_OK;
 801d076:	2000      	movs	r0, #0
}
 801d078:	bd08      	pop	{r3, pc}
    if (pdev->pClass[pdev->classId]->IsoOUTIncomplete != NULL)
 801d07a:	6a53      	ldr	r3, [r2, #36]	@ 0x24
 801d07c:	2b00      	cmp	r3, #0
 801d07e:	d0fa      	beq.n	801d076 <USBD_LL_IsoOUTIncomplete+0x16>
      (void)pdev->pClass[pdev->classId]->IsoOUTIncomplete(pdev, epnum);
 801d080:	4798      	blx	r3
  return USBD_OK;
 801d082:	2000      	movs	r0, #0
}
 801d084:	bd08      	pop	{r3, pc}
    return USBD_FAIL;
 801d086:	2003      	movs	r0, #3
}
 801d088:	4770      	bx	lr
 801d08a:	bf00      	nop

0801d08c <USBD_LL_DevConnected>:
  * @brief  USBD_LL_DevConnected
  *         Handle device connection event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DevConnected(USBD_HandleTypeDef *pdev)
 801d08c:	2000      	movs	r0, #0
 801d08e:	4770      	bx	lr

0801d090 <USBD_LL_DevDisconnected>:
USBD_StatusTypeDef USBD_LL_DevDisconnected(USBD_HandleTypeDef *pdev)
{
  USBD_StatusTypeDef   ret = USBD_OK;

  /* Free Class Resources */
  pdev->dev_state = USBD_STATE_DEFAULT;
 801d090:	2101      	movs	r1, #1
        }
      }
    }
  }
#else
  if (pdev->pClass[0] != NULL)
 801d092:	f8d0 22b8 	ldr.w	r2, [r0, #696]	@ 0x2b8
  pdev->dev_state = USBD_STATE_DEFAULT;
 801d096:	f880 129c 	strb.w	r1, [r0, #668]	@ 0x29c
  if (pdev->pClass[0] != NULL)
 801d09a:	b142      	cbz	r2, 801d0ae <USBD_LL_DevDisconnected+0x1e>
  {
    if (pdev->pClass[0]->DeInit(pdev, (uint8_t)pdev->dev_config) != 0U)
 801d09c:	6852      	ldr	r2, [r2, #4]
 801d09e:	7901      	ldrb	r1, [r0, #4]
{
 801d0a0:	b508      	push	{r3, lr}
    if (pdev->pClass[0]->DeInit(pdev, (uint8_t)pdev->dev_config) != 0U)
 801d0a2:	4790      	blx	r2
 801d0a4:	b908      	cbnz	r0, 801d0aa <USBD_LL_DevDisconnected+0x1a>
  USBD_StatusTypeDef   ret = USBD_OK;
 801d0a6:	2000      	movs	r0, #0
    }
  }
#endif /* USE_USBD_COMPOSITE */

  return ret;
}
 801d0a8:	bd08      	pop	{r3, pc}
      ret = USBD_FAIL;
 801d0aa:	2003      	movs	r0, #3
}
 801d0ac:	bd08      	pop	{r3, pc}
  USBD_StatusTypeDef   ret = USBD_OK;
 801d0ae:	2000      	movs	r0, #0
}
 801d0b0:	4770      	bx	lr
 801d0b2:	bf00      	nop

0801d0b4 <USBD_CoreFindIF>:
  UNUSED(pdev);
  UNUSED(index);

  return 0x00U;
#endif /* USE_USBD_COMPOSITE */
}
 801d0b4:	2000      	movs	r0, #0
 801d0b6:	4770      	bx	lr

0801d0b8 <USBD_CoreFindEP>:
  *         return the class index relative to the selected endpoint
  * @param  pdev: device instance
  * @param  index : selected endpoint number
  * @retval index of the class using the selected endpoint number. 0xFF if no class found.
  */
uint8_t USBD_CoreFindEP(USBD_HandleTypeDef *pdev, uint8_t index)
 801d0b8:	2000      	movs	r0, #0
 801d0ba:	4770      	bx	lr

0801d0bc <USBD_GetEpDesc>:
  USBD_DescHeaderTypeDef *pdesc = (USBD_DescHeaderTypeDef *)(void *)pConfDesc;
  USBD_ConfigDescTypeDef *desc = (USBD_ConfigDescTypeDef *)(void *)pConfDesc;
  USBD_EpDescTypeDef *pEpDesc = NULL;
  uint16_t ptr;

  if (desc->wTotalLength > desc->bLength)
 801d0bc:	7802      	ldrb	r2, [r0, #0]
 801d0be:	f8b0 c002 	ldrh.w	ip, [r0, #2]
 801d0c2:	4613      	mov	r3, r2
 801d0c4:	4594      	cmp	ip, r2
 801d0c6:	d803      	bhi.n	801d0d0 <USBD_GetEpDesc+0x14>
 801d0c8:	e00c      	b.n	801d0e4 <USBD_GetEpDesc+0x28>
  {
    ptr = desc->bLength;

    while (ptr < desc->wTotalLength)
 801d0ca:	459c      	cmp	ip, r3
 801d0cc:	d90a      	bls.n	801d0e4 <USBD_GetEpDesc+0x28>
  */
USBD_DescHeaderTypeDef *USBD_GetNextDesc(uint8_t *pbuf, uint16_t *ptr)
{
  USBD_DescHeaderTypeDef *pnext = (USBD_DescHeaderTypeDef *)(void *)pbuf;

  *ptr += pnext->bLength;
 801d0ce:	7802      	ldrb	r2, [r0, #0]
  pnext = (USBD_DescHeaderTypeDef *)(void *)(pbuf + pnext->bLength);
 801d0d0:	4410      	add	r0, r2
  *ptr += pnext->bLength;
 801d0d2:	4413      	add	r3, r2
      if (pdesc->bDescriptorType == USB_DESC_TYPE_ENDPOINT)
 801d0d4:	7842      	ldrb	r2, [r0, #1]
  *ptr += pnext->bLength;
 801d0d6:	b29b      	uxth	r3, r3
      if (pdesc->bDescriptorType == USB_DESC_TYPE_ENDPOINT)
 801d0d8:	2a05      	cmp	r2, #5
 801d0da:	d1f6      	bne.n	801d0ca <USBD_GetEpDesc+0xe>
        if (pEpDesc->bEndpointAddress == EpAddr)
 801d0dc:	7882      	ldrb	r2, [r0, #2]
 801d0de:	428a      	cmp	r2, r1
 801d0e0:	d1f3      	bne.n	801d0ca <USBD_GetEpDesc+0xe>
}
 801d0e2:	4770      	bx	lr
  USBD_EpDescTypeDef *pEpDesc = NULL;
 801d0e4:	2000      	movs	r0, #0
}
 801d0e6:	4770      	bx	lr

0801d0e8 <USBD_StdDevReq>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
USBD_StatusTypeDef USBD_StdDevReq(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 801d0e8:	b570      	push	{r4, r5, r6, lr}
 801d0ea:	780b      	ldrb	r3, [r1, #0]
 801d0ec:	b082      	sub	sp, #8
 801d0ee:	460d      	mov	r5, r1
 801d0f0:	4604      	mov	r4, r0
  USBD_StatusTypeDef ret = USBD_OK;

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 801d0f2:	f003 0360 	and.w	r3, r3, #96	@ 0x60
 801d0f6:	2b20      	cmp	r3, #32
 801d0f8:	d00e      	beq.n	801d118 <USBD_StdDevReq+0x30>
 801d0fa:	2b40      	cmp	r3, #64	@ 0x40
 801d0fc:	d00c      	beq.n	801d118 <USBD_StdDevReq+0x30>
 801d0fe:	b1bb      	cbz	r3, 801d130 <USBD_StdDevReq+0x48>
  */
void USBD_CtlError(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
  UNUSED(req);

  (void)USBD_LL_StallEP(pdev, 0x80U);
 801d100:	2180      	movs	r1, #128	@ 0x80
 801d102:	4620      	mov	r0, r4
 801d104:	f003 f894 	bl	8020230 <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 801d108:	2100      	movs	r1, #0
 801d10a:	4620      	mov	r0, r4
 801d10c:	f003 f890 	bl	8020230 <USBD_LL_StallEP>
  USBD_StatusTypeDef ret = USBD_OK;
 801d110:	2500      	movs	r5, #0
}
 801d112:	4628      	mov	r0, r5
 801d114:	b002      	add	sp, #8
 801d116:	bd70      	pop	{r4, r5, r6, pc}
      ret = (USBD_StatusTypeDef)pdev->pClass[pdev->classId]->Setup(pdev, req);
 801d118:	f8d4 32d4 	ldr.w	r3, [r4, #724]	@ 0x2d4
 801d11c:	4629      	mov	r1, r5
 801d11e:	4620      	mov	r0, r4
 801d120:	33ae      	adds	r3, #174	@ 0xae
 801d122:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 801d126:	689b      	ldr	r3, [r3, #8]
}
 801d128:	b002      	add	sp, #8
 801d12a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      ret = (USBD_StatusTypeDef)pdev->pClass[pdev->classId]->Setup(pdev, req);
 801d12e:	4718      	bx	r3
      switch (req->bRequest)
 801d130:	784b      	ldrb	r3, [r1, #1]
 801d132:	2b09      	cmp	r3, #9
 801d134:	d8e4      	bhi.n	801d100 <USBD_StdDevReq+0x18>
 801d136:	a201      	add	r2, pc, #4	@ (adr r2, 801d13c <USBD_StdDevReq+0x54>)
 801d138:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801d13c:	0801d19d 	.word	0x0801d19d
 801d140:	0801d1c5 	.word	0x0801d1c5
 801d144:	0801d101 	.word	0x0801d101
 801d148:	0801d1e3 	.word	0x0801d1e3
 801d14c:	0801d101 	.word	0x0801d101
 801d150:	0801d1fb 	.word	0x0801d1fb
 801d154:	0801d23b 	.word	0x0801d23b
 801d158:	0801d101 	.word	0x0801d101
 801d15c:	0801d291 	.word	0x0801d291
 801d160:	0801d165 	.word	0x0801d165
  cfgidx = (uint8_t)(req->wValue);
 801d164:	7889      	ldrb	r1, [r1, #2]
 801d166:	4db5      	ldr	r5, [pc, #724]	@ (801d43c <USBD_StdDevReq+0x354>)
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION)
 801d168:	2901      	cmp	r1, #1
  cfgidx = (uint8_t)(req->wValue);
 801d16a:	7029      	strb	r1, [r5, #0]
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION)
 801d16c:	f200 815e 	bhi.w	801d42c <USBD_StdDevReq+0x344>
  switch (pdev->dev_state)
 801d170:	f890 329c 	ldrb.w	r3, [r0, #668]	@ 0x29c
 801d174:	2b02      	cmp	r3, #2
 801d176:	b2de      	uxtb	r6, r3
 801d178:	f000 8145 	beq.w	801d406 <USBD_StdDevReq+0x31e>
 801d17c:	2e03      	cmp	r6, #3
 801d17e:	f000 8122 	beq.w	801d3c6 <USBD_StdDevReq+0x2de>
  (void)USBD_LL_StallEP(pdev, 0x80U);
 801d182:	2180      	movs	r1, #128	@ 0x80
 801d184:	f003 f854 	bl	8020230 <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 801d188:	2100      	movs	r1, #0
 801d18a:	4620      	mov	r0, r4
 801d18c:	f003 f850 	bl	8020230 <USBD_LL_StallEP>
      (void)USBD_ClrClassConfig(pdev, cfgidx);
 801d190:	7829      	ldrb	r1, [r5, #0]
 801d192:	4620      	mov	r0, r4
 801d194:	f7ff fe1c 	bl	801cdd0 <USBD_ClrClassConfig>
    return USBD_FAIL;
 801d198:	2503      	movs	r5, #3
 801d19a:	e7ba      	b.n	801d112 <USBD_StdDevReq+0x2a>
  switch (pdev->dev_state)
 801d19c:	f890 329c 	ldrb.w	r3, [r0, #668]	@ 0x29c
 801d1a0:	3b01      	subs	r3, #1
 801d1a2:	2b02      	cmp	r3, #2
 801d1a4:	d8ac      	bhi.n	801d100 <USBD_StdDevReq+0x18>
      if (req->wLength != 0x2U)
 801d1a6:	88ca      	ldrh	r2, [r1, #6]
 801d1a8:	2a02      	cmp	r2, #2
 801d1aa:	d1a9      	bne.n	801d100 <USBD_StdDevReq+0x18>
      if (pdev->dev_remote_wakeup != 0U)
 801d1ac:	f8d0 32a4 	ldr.w	r3, [r0, #676]	@ 0x2a4
 801d1b0:	4601      	mov	r1, r0
        pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;
 801d1b2:	2b00      	cmp	r3, #0
 801d1b4:	bf0c      	ite	eq
 801d1b6:	2301      	moveq	r3, #1
 801d1b8:	2303      	movne	r3, #3
 801d1ba:	f841 3f0c 	str.w	r3, [r1, #12]!
      (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_config_status, 2U);
 801d1be:	f000 fa81 	bl	801d6c4 <USBD_CtlSendData>
      break;
 801d1c2:	e7a5      	b.n	801d110 <USBD_StdDevReq+0x28>
  switch (pdev->dev_state)
 801d1c4:	f890 329c 	ldrb.w	r3, [r0, #668]	@ 0x29c
 801d1c8:	3b01      	subs	r3, #1
 801d1ca:	2b02      	cmp	r3, #2
 801d1cc:	d898      	bhi.n	801d100 <USBD_StdDevReq+0x18>
      if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 801d1ce:	884b      	ldrh	r3, [r1, #2]
 801d1d0:	2b01      	cmp	r3, #1
 801d1d2:	d19d      	bne.n	801d110 <USBD_StdDevReq+0x28>
        pdev->dev_remote_wakeup = 0U;
 801d1d4:	2300      	movs	r3, #0
        (void)USBD_CtlSendStatus(pdev);
 801d1d6:	4620      	mov	r0, r4
        pdev->dev_remote_wakeup = 0U;
 801d1d8:	f8c4 32a4 	str.w	r3, [r4, #676]	@ 0x2a4
        (void)USBD_CtlSendStatus(pdev);
 801d1dc:	f000 faa2 	bl	801d724 <USBD_CtlSendStatus>
 801d1e0:	e796      	b.n	801d110 <USBD_StdDevReq+0x28>
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 801d1e2:	884b      	ldrh	r3, [r1, #2]
 801d1e4:	2b01      	cmp	r3, #1
 801d1e6:	d0f6      	beq.n	801d1d6 <USBD_StdDevReq+0xee>
  else if (req->wValue == USB_FEATURE_TEST_MODE)
 801d1e8:	2b02      	cmp	r3, #2
 801d1ea:	d189      	bne.n	801d100 <USBD_StdDevReq+0x18>
    pdev->dev_test_mode = (uint8_t)(req->wIndex >> 8);
 801d1ec:	888b      	ldrh	r3, [r1, #4]
 801d1ee:	0a1b      	lsrs	r3, r3, #8
 801d1f0:	f880 32a0 	strb.w	r3, [r0, #672]	@ 0x2a0
    (void)USBD_CtlSendStatus(pdev);
 801d1f4:	f000 fa96 	bl	801d724 <USBD_CtlSendStatus>
 801d1f8:	e78a      	b.n	801d110 <USBD_StdDevReq+0x28>
  if ((req->wIndex == 0U) && (req->wLength == 0U) && (req->wValue < 128U))
 801d1fa:	888b      	ldrh	r3, [r1, #4]
 801d1fc:	2b00      	cmp	r3, #0
 801d1fe:	f47f af7f 	bne.w	801d100 <USBD_StdDevReq+0x18>
 801d202:	88cb      	ldrh	r3, [r1, #6]
 801d204:	2b00      	cmp	r3, #0
 801d206:	f47f af7b 	bne.w	801d100 <USBD_StdDevReq+0x18>
 801d20a:	884d      	ldrh	r5, [r1, #2]
 801d20c:	2d7f      	cmp	r5, #127	@ 0x7f
 801d20e:	f63f af77 	bhi.w	801d100 <USBD_StdDevReq+0x18>
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 801d212:	f890 329c 	ldrb.w	r3, [r0, #668]	@ 0x29c
 801d216:	2b03      	cmp	r3, #3
 801d218:	f43f af72 	beq.w	801d100 <USBD_StdDevReq+0x18>
    dev_addr = (uint8_t)(req->wValue) & 0x7FU;
 801d21c:	b2e9      	uxtb	r1, r5
      pdev->dev_address = dev_addr;
 801d21e:	f880 129e 	strb.w	r1, [r0, #670]	@ 0x29e
      (void)USBD_LL_SetUSBAddress(pdev, dev_addr);
 801d222:	f003 f831 	bl	8020288 <USBD_LL_SetUSBAddress>
      (void)USBD_CtlSendStatus(pdev);
 801d226:	4620      	mov	r0, r4
 801d228:	f000 fa7c 	bl	801d724 <USBD_CtlSendStatus>
      if (dev_addr != 0U)
 801d22c:	2d00      	cmp	r5, #0
 801d22e:	f000 8115 	beq.w	801d45c <USBD_StdDevReq+0x374>
        pdev->dev_state = USBD_STATE_ADDRESSED;
 801d232:	2302      	movs	r3, #2
 801d234:	f884 329c 	strb.w	r3, [r4, #668]	@ 0x29c
 801d238:	e76a      	b.n	801d110 <USBD_StdDevReq+0x28>
  switch (req->wValue >> 8)
 801d23a:	884a      	ldrh	r2, [r1, #2]
  uint16_t len = 0U;
 801d23c:	2100      	movs	r1, #0
  switch (req->wValue >> 8)
 801d23e:	0a13      	lsrs	r3, r2, #8
  uint16_t len = 0U;
 801d240:	f8ad 1006 	strh.w	r1, [sp, #6]
  switch (req->wValue >> 8)
 801d244:	3b01      	subs	r3, #1
 801d246:	2b0e      	cmp	r3, #14
 801d248:	f63f af5a 	bhi.w	801d100 <USBD_StdDevReq+0x18>
 801d24c:	a101      	add	r1, pc, #4	@ (adr r1, 801d254 <USBD_StdDevReq+0x16c>)
 801d24e:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 801d252:	bf00      	nop
 801d254:	0801d33b 	.word	0x0801d33b
 801d258:	0801d321 	.word	0x0801d321
 801d25c:	0801d34b 	.word	0x0801d34b
 801d260:	0801d101 	.word	0x0801d101
 801d264:	0801d101 	.word	0x0801d101
 801d268:	0801d2f1 	.word	0x0801d2f1
 801d26c:	0801d307 	.word	0x0801d307
 801d270:	0801d101 	.word	0x0801d101
 801d274:	0801d101 	.word	0x0801d101
 801d278:	0801d101 	.word	0x0801d101
 801d27c:	0801d101 	.word	0x0801d101
 801d280:	0801d101 	.word	0x0801d101
 801d284:	0801d101 	.word	0x0801d101
 801d288:	0801d101 	.word	0x0801d101
 801d28c:	0801d2b9 	.word	0x0801d2b9
  if (req->wLength != 1U)
 801d290:	88ca      	ldrh	r2, [r1, #6]
 801d292:	2a01      	cmp	r2, #1
 801d294:	f47f af34 	bne.w	801d100 <USBD_StdDevReq+0x18>
    switch (pdev->dev_state)
 801d298:	f890 129c 	ldrb.w	r1, [r0, #668]	@ 0x29c
 801d29c:	2902      	cmp	r1, #2
 801d29e:	b2cb      	uxtb	r3, r1
 801d2a0:	f200 808a 	bhi.w	801d3b8 <USBD_StdDevReq+0x2d0>
 801d2a4:	2b00      	cmp	r3, #0
 801d2a6:	f43f af2b 	beq.w	801d100 <USBD_StdDevReq+0x18>
        pdev->dev_default_config = 0U;
 801d2aa:	4601      	mov	r1, r0
 801d2ac:	2300      	movs	r3, #0
 801d2ae:	f841 3f08 	str.w	r3, [r1, #8]!
        (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_default_config, 1U);
 801d2b2:	f000 fa07 	bl	801d6c4 <USBD_CtlSendData>
        break;
 801d2b6:	e72b      	b.n	801d110 <USBD_StdDevReq+0x28>
      if (pdev->pDesc->GetBOSDescriptor != NULL)
 801d2b8:	f8d0 32b4 	ldr.w	r3, [r0, #692]	@ 0x2b4
 801d2bc:	69db      	ldr	r3, [r3, #28]
 801d2be:	2b00      	cmp	r3, #0
 801d2c0:	f43f af1e 	beq.w	801d100 <USBD_StdDevReq+0x18>
            pbuf = pdev->pDesc->GetInterfaceStrDescriptor(pdev->dev_speed, &len);
 801d2c4:	f10d 0106 	add.w	r1, sp, #6
 801d2c8:	7c20      	ldrb	r0, [r4, #16]
 801d2ca:	4798      	blx	r3
  if (req->wLength != 0U)
 801d2cc:	88eb      	ldrh	r3, [r5, #6]
 801d2ce:	2b00      	cmp	r3, #0
 801d2d0:	d06e      	beq.n	801d3b0 <USBD_StdDevReq+0x2c8>
    if (len != 0U)
 801d2d2:	f8bd 2006 	ldrh.w	r2, [sp, #6]
 801d2d6:	2a00      	cmp	r2, #0
 801d2d8:	f43f af12 	beq.w	801d100 <USBD_StdDevReq+0x18>
      len = MIN(len, req->wLength);
 801d2dc:	429a      	cmp	r2, r3
      (void)USBD_CtlSendData(pdev, pbuf, len);
 801d2de:	4601      	mov	r1, r0
 801d2e0:	4620      	mov	r0, r4
      len = MIN(len, req->wLength);
 801d2e2:	bf28      	it	cs
 801d2e4:	461a      	movcs	r2, r3
 801d2e6:	f8ad 2006 	strh.w	r2, [sp, #6]
      (void)USBD_CtlSendData(pdev, pbuf, len);
 801d2ea:	f000 f9eb 	bl	801d6c4 <USBD_CtlSendData>
 801d2ee:	e70f      	b.n	801d110 <USBD_StdDevReq+0x28>
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 801d2f0:	7c03      	ldrb	r3, [r0, #16]
 801d2f2:	2b00      	cmp	r3, #0
 801d2f4:	f47f af04 	bne.w	801d100 <USBD_StdDevReq+0x18>
          pbuf = (uint8_t *)pdev->pClass[0]->GetDeviceQualifierDescriptor(&len);
 801d2f8:	f8d0 32b8 	ldr.w	r3, [r0, #696]	@ 0x2b8
 801d2fc:	f10d 0006 	add.w	r0, sp, #6
 801d300:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 801d302:	4798      	blx	r3
  if (err != 0U)
 801d304:	e7e2      	b.n	801d2cc <USBD_StdDevReq+0x1e4>
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 801d306:	7c03      	ldrb	r3, [r0, #16]
 801d308:	2b00      	cmp	r3, #0
 801d30a:	f47f aef9 	bne.w	801d100 <USBD_StdDevReq+0x18>
          pbuf = (uint8_t *)pdev->pClass[0]->GetOtherSpeedConfigDescriptor(&len);
 801d30e:	f8d0 32b8 	ldr.w	r3, [r0, #696]	@ 0x2b8
 801d312:	f10d 0006 	add.w	r0, sp, #6
 801d316:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 801d318:	4798      	blx	r3
        pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 801d31a:	2307      	movs	r3, #7
 801d31c:	7043      	strb	r3, [r0, #1]
  if (err != 0U)
 801d31e:	e7d5      	b.n	801d2cc <USBD_StdDevReq+0x1e4>
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 801d320:	7c02      	ldrb	r2, [r0, #16]
          pbuf = (uint8_t *)pdev->pClass[0]->GetHSConfigDescriptor(&len);
 801d322:	f8d0 32b8 	ldr.w	r3, [r0, #696]	@ 0x2b8
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 801d326:	2a00      	cmp	r2, #0
 801d328:	f040 808a 	bne.w	801d440 <USBD_StdDevReq+0x358>
          pbuf = (uint8_t *)pdev->pClass[0]->GetHSConfigDescriptor(&len);
 801d32c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 801d32e:	f10d 0006 	add.w	r0, sp, #6
 801d332:	4798      	blx	r3
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 801d334:	2302      	movs	r3, #2
 801d336:	7043      	strb	r3, [r0, #1]
  if (err != 0U)
 801d338:	e7c8      	b.n	801d2cc <USBD_StdDevReq+0x1e4>
      pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
 801d33a:	f8d0 32b4 	ldr.w	r3, [r0, #692]	@ 0x2b4
 801d33e:	f10d 0106 	add.w	r1, sp, #6
 801d342:	7c00      	ldrb	r0, [r0, #16]
 801d344:	681b      	ldr	r3, [r3, #0]
 801d346:	4798      	blx	r3
  if (err != 0U)
 801d348:	e7c0      	b.n	801d2cc <USBD_StdDevReq+0x1e4>
      switch ((uint8_t)(req->wValue))
 801d34a:	b2d2      	uxtb	r2, r2
 801d34c:	2a05      	cmp	r2, #5
 801d34e:	f63f aed7 	bhi.w	801d100 <USBD_StdDevReq+0x18>
 801d352:	e8df f002 	tbb	[pc, r2]
 801d356:	1b21      	.short	0x1b21
 801d358:	03090f15 	.word	0x03090f15
          if (pdev->pDesc->GetInterfaceStrDescriptor != NULL)
 801d35c:	f8d0 32b4 	ldr.w	r3, [r0, #692]	@ 0x2b4
 801d360:	699b      	ldr	r3, [r3, #24]
 801d362:	2b00      	cmp	r3, #0
 801d364:	d1ae      	bne.n	801d2c4 <USBD_StdDevReq+0x1dc>
 801d366:	e6cb      	b.n	801d100 <USBD_StdDevReq+0x18>
          if (pdev->pDesc->GetConfigurationStrDescriptor != NULL)
 801d368:	f8d0 32b4 	ldr.w	r3, [r0, #692]	@ 0x2b4
 801d36c:	695b      	ldr	r3, [r3, #20]
 801d36e:	2b00      	cmp	r3, #0
 801d370:	d1a8      	bne.n	801d2c4 <USBD_StdDevReq+0x1dc>
 801d372:	e6c5      	b.n	801d100 <USBD_StdDevReq+0x18>
          if (pdev->pDesc->GetSerialStrDescriptor != NULL)
 801d374:	f8d0 32b4 	ldr.w	r3, [r0, #692]	@ 0x2b4
 801d378:	691b      	ldr	r3, [r3, #16]
 801d37a:	2b00      	cmp	r3, #0
 801d37c:	d1a2      	bne.n	801d2c4 <USBD_StdDevReq+0x1dc>
 801d37e:	e6bf      	b.n	801d100 <USBD_StdDevReq+0x18>
          if (pdev->pDesc->GetProductStrDescriptor != NULL)
 801d380:	f8d0 32b4 	ldr.w	r3, [r0, #692]	@ 0x2b4
 801d384:	68db      	ldr	r3, [r3, #12]
 801d386:	2b00      	cmp	r3, #0
 801d388:	d19c      	bne.n	801d2c4 <USBD_StdDevReq+0x1dc>
 801d38a:	e6b9      	b.n	801d100 <USBD_StdDevReq+0x18>
          if (pdev->pDesc->GetManufacturerStrDescriptor != NULL)
 801d38c:	f8d0 32b4 	ldr.w	r3, [r0, #692]	@ 0x2b4
 801d390:	689b      	ldr	r3, [r3, #8]
 801d392:	2b00      	cmp	r3, #0
 801d394:	d196      	bne.n	801d2c4 <USBD_StdDevReq+0x1dc>
 801d396:	e6b3      	b.n	801d100 <USBD_StdDevReq+0x18>
          if (pdev->pDesc->GetLangIDStrDescriptor != NULL)
 801d398:	f8d0 32b4 	ldr.w	r3, [r0, #692]	@ 0x2b4
 801d39c:	685b      	ldr	r3, [r3, #4]
 801d39e:	2b00      	cmp	r3, #0
 801d3a0:	d190      	bne.n	801d2c4 <USBD_StdDevReq+0x1dc>
 801d3a2:	e6ad      	b.n	801d100 <USBD_StdDevReq+0x18>
        pdev->dev_state = USBD_STATE_ADDRESSED;
 801d3a4:	2302      	movs	r3, #2
        pdev->dev_config = cfgidx;
 801d3a6:	6041      	str	r1, [r0, #4]
        pdev->dev_state = USBD_STATE_ADDRESSED;
 801d3a8:	f880 329c 	strb.w	r3, [r0, #668]	@ 0x29c
        (void)USBD_ClrClassConfig(pdev, cfgidx);
 801d3ac:	f7ff fd10 	bl	801cdd0 <USBD_ClrClassConfig>
        (void)USBD_CtlSendStatus(pdev);
 801d3b0:	4620      	mov	r0, r4
 801d3b2:	f000 f9b7 	bl	801d724 <USBD_CtlSendStatus>
 801d3b6:	e6ab      	b.n	801d110 <USBD_StdDevReq+0x28>
    switch (pdev->dev_state)
 801d3b8:	2b03      	cmp	r3, #3
 801d3ba:	f47f aea1 	bne.w	801d100 <USBD_StdDevReq+0x18>
        (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_config, 1U);
 801d3be:	1d01      	adds	r1, r0, #4
 801d3c0:	f000 f980 	bl	801d6c4 <USBD_CtlSendData>
        break;
 801d3c4:	e6a4      	b.n	801d110 <USBD_StdDevReq+0x28>
      if (cfgidx == 0U)
 801d3c6:	2900      	cmp	r1, #0
 801d3c8:	d0ec      	beq.n	801d3a4 <USBD_StdDevReq+0x2bc>
      else if (cfgidx != pdev->dev_config)
 801d3ca:	6841      	ldr	r1, [r0, #4]
 801d3cc:	2901      	cmp	r1, #1
 801d3ce:	d0ef      	beq.n	801d3b0 <USBD_StdDevReq+0x2c8>
        (void)USBD_ClrClassConfig(pdev, (uint8_t)pdev->dev_config);
 801d3d0:	b2c9      	uxtb	r1, r1
 801d3d2:	f7ff fcfd 	bl	801cdd0 <USBD_ClrClassConfig>
        pdev->dev_config = cfgidx;
 801d3d6:	7829      	ldrb	r1, [r5, #0]
        ret = USBD_SetClassConfig(pdev, cfgidx);
 801d3d8:	4620      	mov	r0, r4
        pdev->dev_config = cfgidx;
 801d3da:	6061      	str	r1, [r4, #4]
        ret = USBD_SetClassConfig(pdev, cfgidx);
 801d3dc:	f7ff fcf0 	bl	801cdc0 <USBD_SetClassConfig>
        if (ret != USBD_OK)
 801d3e0:	4605      	mov	r5, r0
 801d3e2:	2800      	cmp	r0, #0
 801d3e4:	d0e4      	beq.n	801d3b0 <USBD_StdDevReq+0x2c8>
  (void)USBD_LL_StallEP(pdev, 0x80U);
 801d3e6:	2180      	movs	r1, #128	@ 0x80
 801d3e8:	4620      	mov	r0, r4
 801d3ea:	f002 ff21 	bl	8020230 <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 801d3ee:	2100      	movs	r1, #0
 801d3f0:	4620      	mov	r0, r4
 801d3f2:	f002 ff1d 	bl	8020230 <USBD_LL_StallEP>
          (void)USBD_ClrClassConfig(pdev, (uint8_t)pdev->dev_config);
 801d3f6:	7921      	ldrb	r1, [r4, #4]
 801d3f8:	4620      	mov	r0, r4
 801d3fa:	f7ff fce9 	bl	801cdd0 <USBD_ClrClassConfig>
          pdev->dev_state = USBD_STATE_ADDRESSED;
 801d3fe:	2302      	movs	r3, #2
 801d400:	f884 329c 	strb.w	r3, [r4, #668]	@ 0x29c
 801d404:	e685      	b.n	801d112 <USBD_StdDevReq+0x2a>
      if (cfgidx != 0U)
 801d406:	2900      	cmp	r1, #0
 801d408:	d0d2      	beq.n	801d3b0 <USBD_StdDevReq+0x2c8>
        pdev->dev_config = cfgidx;
 801d40a:	2101      	movs	r1, #1
 801d40c:	6041      	str	r1, [r0, #4]
        ret = USBD_SetClassConfig(pdev, cfgidx);
 801d40e:	f7ff fcd7 	bl	801cdc0 <USBD_SetClassConfig>
        if (ret != USBD_OK)
 801d412:	4605      	mov	r5, r0
 801d414:	b1d8      	cbz	r0, 801d44e <USBD_StdDevReq+0x366>
  (void)USBD_LL_StallEP(pdev, 0x80U);
 801d416:	2180      	movs	r1, #128	@ 0x80
 801d418:	4620      	mov	r0, r4
 801d41a:	f002 ff09 	bl	8020230 <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 801d41e:	2100      	movs	r1, #0
 801d420:	4620      	mov	r0, r4
 801d422:	f002 ff05 	bl	8020230 <USBD_LL_StallEP>
          pdev->dev_state = USBD_STATE_ADDRESSED;
 801d426:	f884 629c 	strb.w	r6, [r4, #668]	@ 0x29c
 801d42a:	e672      	b.n	801d112 <USBD_StdDevReq+0x2a>
  (void)USBD_LL_StallEP(pdev, 0x80U);
 801d42c:	2180      	movs	r1, #128	@ 0x80
 801d42e:	f002 feff 	bl	8020230 <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 801d432:	2100      	movs	r1, #0
 801d434:	4620      	mov	r0, r4
 801d436:	f002 fefb 	bl	8020230 <USBD_LL_StallEP>
    return USBD_FAIL;
 801d43a:	e6ad      	b.n	801d198 <USBD_StdDevReq+0xb0>
 801d43c:	20002bd8 	.word	0x20002bd8
          pbuf = (uint8_t *)pdev->pClass[0]->GetFSConfigDescriptor(&len);
 801d440:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 801d442:	f10d 0006 	add.w	r0, sp, #6
 801d446:	4798      	blx	r3
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 801d448:	2302      	movs	r3, #2
 801d44a:	7043      	strb	r3, [r0, #1]
  if (err != 0U)
 801d44c:	e73e      	b.n	801d2cc <USBD_StdDevReq+0x1e4>
          (void)USBD_CtlSendStatus(pdev);
 801d44e:	4620      	mov	r0, r4
 801d450:	f000 f968 	bl	801d724 <USBD_CtlSendStatus>
          pdev->dev_state = USBD_STATE_CONFIGURED;
 801d454:	2303      	movs	r3, #3
 801d456:	f884 329c 	strb.w	r3, [r4, #668]	@ 0x29c
 801d45a:	e659      	b.n	801d110 <USBD_StdDevReq+0x28>
        pdev->dev_state = USBD_STATE_DEFAULT;
 801d45c:	2301      	movs	r3, #1
 801d45e:	f884 329c 	strb.w	r3, [r4, #668]	@ 0x29c
 801d462:	e655      	b.n	801d110 <USBD_StdDevReq+0x28>

0801d464 <USBD_StdItfReq>:
{
 801d464:	b538      	push	{r3, r4, r5, lr}
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 801d466:	780b      	ldrb	r3, [r1, #0]
{
 801d468:	460d      	mov	r5, r1
 801d46a:	4604      	mov	r4, r0
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 801d46c:	065a      	lsls	r2, r3, #25
 801d46e:	d50c      	bpl.n	801d48a <USBD_StdItfReq+0x26>
 801d470:	f003 0260 	and.w	r2, r3, #96	@ 0x60
 801d474:	2a40      	cmp	r2, #64	@ 0x40
 801d476:	d008      	beq.n	801d48a <USBD_StdItfReq+0x26>
  (void)USBD_LL_StallEP(pdev, 0x80U);
 801d478:	2180      	movs	r1, #128	@ 0x80
 801d47a:	f002 fed9 	bl	8020230 <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 801d47e:	2100      	movs	r1, #0
 801d480:	4620      	mov	r0, r4
 801d482:	f002 fed5 	bl	8020230 <USBD_LL_StallEP>
  USBD_StatusTypeDef ret = USBD_OK;
 801d486:	2000      	movs	r0, #0
}
 801d488:	bd38      	pop	{r3, r4, r5, pc}
      switch (pdev->dev_state)
 801d48a:	f894 329c 	ldrb.w	r3, [r4, #668]	@ 0x29c
 801d48e:	3b01      	subs	r3, #1
 801d490:	2b02      	cmp	r3, #2
 801d492:	d802      	bhi.n	801d49a <USBD_StdItfReq+0x36>
          if (LOBYTE(req->wIndex) <= USBD_MAX_NUM_INTERFACES)
 801d494:	7929      	ldrb	r1, [r5, #4]
 801d496:	2901      	cmp	r1, #1
 801d498:	d908      	bls.n	801d4ac <USBD_StdItfReq+0x48>
  (void)USBD_LL_StallEP(pdev, 0x80U);
 801d49a:	2180      	movs	r1, #128	@ 0x80
 801d49c:	4620      	mov	r0, r4
 801d49e:	f002 fec7 	bl	8020230 <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 801d4a2:	2100      	movs	r1, #0
 801d4a4:	4620      	mov	r0, r4
 801d4a6:	f002 fec3 	bl	8020230 <USBD_LL_StallEP>
}
 801d4aa:	e7ec      	b.n	801d486 <USBD_StdItfReq+0x22>
            idx = USBD_CoreFindIF(pdev, LOBYTE(req->wIndex));
 801d4ac:	4620      	mov	r0, r4
 801d4ae:	f7ff fe01 	bl	801d0b4 <USBD_CoreFindIF>
            if (((uint8_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 801d4b2:	b988      	cbnz	r0, 801d4d8 <USBD_StdItfReq+0x74>
              if (pdev->pClass[idx]->Setup != NULL)
 801d4b4:	f8d4 32b8 	ldr.w	r3, [r4, #696]	@ 0x2b8
 801d4b8:	689b      	ldr	r3, [r3, #8]
 801d4ba:	b16b      	cbz	r3, 801d4d8 <USBD_StdItfReq+0x74>
                pdev->classId = idx;
 801d4bc:	f8c4 02d4 	str.w	r0, [r4, #724]	@ 0x2d4
                ret = (USBD_StatusTypeDef)(pdev->pClass[idx]->Setup(pdev, req));
 801d4c0:	4629      	mov	r1, r5
 801d4c2:	4620      	mov	r0, r4
 801d4c4:	4798      	blx	r3
            if ((req->wLength == 0U) && (ret == USBD_OK))
 801d4c6:	88ea      	ldrh	r2, [r5, #6]
 801d4c8:	2a00      	cmp	r2, #0
 801d4ca:	d1dd      	bne.n	801d488 <USBD_StdItfReq+0x24>
 801d4cc:	2800      	cmp	r0, #0
 801d4ce:	d1db      	bne.n	801d488 <USBD_StdItfReq+0x24>
              (void)USBD_CtlSendStatus(pdev);
 801d4d0:	4620      	mov	r0, r4
 801d4d2:	f000 f927 	bl	801d724 <USBD_CtlSendStatus>
 801d4d6:	e7d6      	b.n	801d486 <USBD_StdItfReq+0x22>
                ret = USBD_FAIL;
 801d4d8:	2003      	movs	r0, #3
}
 801d4da:	bd38      	pop	{r3, r4, r5, pc}

0801d4dc <USBD_StdEPReq>:
{
 801d4dc:	b530      	push	{r4, r5, lr}
 801d4de:	460c      	mov	r4, r1
  ep_addr = LOBYTE(req->wIndex);
 801d4e0:	888a      	ldrh	r2, [r1, #4]
{
 801d4e2:	b083      	sub	sp, #12
 801d4e4:	4605      	mov	r5, r0
  ep_addr = LOBYTE(req->wIndex);
 801d4e6:	7823      	ldrb	r3, [r4, #0]
 801d4e8:	b2d1      	uxtb	r1, r2
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 801d4ea:	f003 0360 	and.w	r3, r3, #96	@ 0x60
 801d4ee:	2b20      	cmp	r3, #32
 801d4f0:	d01f      	beq.n	801d532 <USBD_StdEPReq+0x56>
 801d4f2:	2b40      	cmp	r3, #64	@ 0x40
 801d4f4:	d01d      	beq.n	801d532 <USBD_StdEPReq+0x56>
 801d4f6:	b373      	cbz	r3, 801d556 <USBD_StdEPReq+0x7a>
  (void)USBD_LL_StallEP(pdev, 0x80U);
 801d4f8:	2180      	movs	r1, #128	@ 0x80
 801d4fa:	4628      	mov	r0, r5
 801d4fc:	f002 fe98 	bl	8020230 <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 801d500:	2100      	movs	r1, #0
 801d502:	4628      	mov	r0, r5
 801d504:	f002 fe94 	bl	8020230 <USBD_LL_StallEP>
}
 801d508:	2000      	movs	r0, #0
 801d50a:	b003      	add	sp, #12
 801d50c:	bd30      	pop	{r4, r5, pc}
          switch (pdev->dev_state)
 801d50e:	f890 329c 	ldrb.w	r3, [r0, #668]	@ 0x29c
 801d512:	2b02      	cmp	r3, #2
 801d514:	b2da      	uxtb	r2, r3
 801d516:	d05b      	beq.n	801d5d0 <USBD_StdEPReq+0xf4>
 801d518:	2a03      	cmp	r2, #3
 801d51a:	d1ed      	bne.n	801d4f8 <USBD_StdEPReq+0x1c>
              if (req->wValue == USB_FEATURE_EP_HALT)
 801d51c:	8863      	ldrh	r3, [r4, #2]
 801d51e:	2b00      	cmp	r3, #0
 801d520:	d1f2      	bne.n	801d508 <USBD_StdEPReq+0x2c>
                if ((ep_addr & 0x7FU) != 0x00U)
 801d522:	064b      	lsls	r3, r1, #25
 801d524:	f040 8081 	bne.w	801d62a <USBD_StdEPReq+0x14e>
                (void)USBD_CtlSendStatus(pdev);
 801d528:	4628      	mov	r0, r5
 801d52a:	9101      	str	r1, [sp, #4]
 801d52c:	f000 f8fa 	bl	801d724 <USBD_CtlSendStatus>
                idx = USBD_CoreFindEP(pdev, ep_addr);
 801d530:	9901      	ldr	r1, [sp, #4]
 801d532:	4628      	mov	r0, r5
 801d534:	f7ff fdc0 	bl	801d0b8 <USBD_CoreFindEP>
                if (((uint8_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 801d538:	2800      	cmp	r0, #0
 801d53a:	d1e5      	bne.n	801d508 <USBD_StdEPReq+0x2c>
                  if (pdev->pClass[idx]->Setup != NULL)
 801d53c:	f8d5 32b8 	ldr.w	r3, [r5, #696]	@ 0x2b8
                  pdev->classId = idx;
 801d540:	f8c5 02d4 	str.w	r0, [r5, #724]	@ 0x2d4
                  if (pdev->pClass[idx]->Setup != NULL)
 801d544:	689b      	ldr	r3, [r3, #8]
 801d546:	2b00      	cmp	r3, #0
 801d548:	d0de      	beq.n	801d508 <USBD_StdEPReq+0x2c>
                    ret = (USBD_StatusTypeDef)(pdev->pClass[idx]->Setup(pdev, req));
 801d54a:	4621      	mov	r1, r4
 801d54c:	4628      	mov	r0, r5
}
 801d54e:	b003      	add	sp, #12
 801d550:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
                    ret = (USBD_StatusTypeDef)(pdev->pClass[idx]->Setup(pdev, req));
 801d554:	4718      	bx	r3
      switch (req->bRequest)
 801d556:	7863      	ldrb	r3, [r4, #1]
 801d558:	2b01      	cmp	r3, #1
 801d55a:	d0d8      	beq.n	801d50e <USBD_StdEPReq+0x32>
 801d55c:	2b03      	cmp	r3, #3
 801d55e:	d025      	beq.n	801d5ac <USBD_StdEPReq+0xd0>
 801d560:	2b00      	cmp	r3, #0
 801d562:	d1c9      	bne.n	801d4f8 <USBD_StdEPReq+0x1c>
          switch (pdev->dev_state)
 801d564:	f890 329c 	ldrb.w	r3, [r0, #668]	@ 0x29c
 801d568:	2b02      	cmp	r3, #2
 801d56a:	b2d8      	uxtb	r0, r3
 801d56c:	d039      	beq.n	801d5e2 <USBD_StdEPReq+0x106>
 801d56e:	2803      	cmp	r0, #3
 801d570:	d1c2      	bne.n	801d4f8 <USBD_StdEPReq+0x1c>
                if (pdev->ep_in[ep_addr & 0xFU].is_used == 0U)
 801d572:	f001 030f 	and.w	r3, r1, #15
              if ((ep_addr & 0x80U) == 0x80U)
 801d576:	0612      	lsls	r2, r2, #24
                if (pdev->ep_in[ep_addr & 0xFU].is_used == 0U)
 801d578:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 801d57c:	eb05 0383 	add.w	r3, r5, r3, lsl #2
              if ((ep_addr & 0x80U) == 0x80U)
 801d580:	d440      	bmi.n	801d604 <USBD_StdEPReq+0x128>
                if (pdev->ep_out[ep_addr & 0xFU].is_used == 0U)
 801d582:	f8b3 3164 	ldrh.w	r3, [r3, #356]	@ 0x164
 801d586:	2b00      	cmp	r3, #0
 801d588:	d0b6      	beq.n	801d4f8 <USBD_StdEPReq+0x1c>
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 801d58a:	f001 037f 	and.w	r3, r1, #127	@ 0x7f
 801d58e:	2414      	movs	r4, #20
 801d590:	fb04 5403 	mla	r4, r4, r3, r5
 801d594:	f504 74aa 	add.w	r4, r4, #340	@ 0x154
              if ((ep_addr == 0x00U) || (ep_addr == 0x80U))
 801d598:	2b00      	cmp	r3, #0
 801d59a:	d13f      	bne.n	801d61c <USBD_StdEPReq+0x140>
{
 801d59c:	2300      	movs	r3, #0
              (void)USBD_CtlSendData(pdev, (uint8_t *)&pep->status, 2U);
 801d59e:	2202      	movs	r2, #2
 801d5a0:	4621      	mov	r1, r4
 801d5a2:	4628      	mov	r0, r5
                pep->status = 0x0000U;
 801d5a4:	6023      	str	r3, [r4, #0]
              (void)USBD_CtlSendData(pdev, (uint8_t *)&pep->status, 2U);
 801d5a6:	f000 f88d 	bl	801d6c4 <USBD_CtlSendData>
              break;
 801d5aa:	e7ad      	b.n	801d508 <USBD_StdEPReq+0x2c>
          switch (pdev->dev_state)
 801d5ac:	f890 329c 	ldrb.w	r3, [r0, #668]	@ 0x29c
 801d5b0:	2b02      	cmp	r3, #2
 801d5b2:	b2da      	uxtb	r2, r3
 801d5b4:	d00c      	beq.n	801d5d0 <USBD_StdEPReq+0xf4>
 801d5b6:	2a03      	cmp	r2, #3
 801d5b8:	d19e      	bne.n	801d4f8 <USBD_StdEPReq+0x1c>
              if (req->wValue == USB_FEATURE_EP_HALT)
 801d5ba:	8863      	ldrh	r3, [r4, #2]
 801d5bc:	b923      	cbnz	r3, 801d5c8 <USBD_StdEPReq+0xec>
                if ((ep_addr != 0x00U) && (ep_addr != 0x80U) && (req->wLength == 0x00U))
 801d5be:	0648      	lsls	r0, r1, #25
 801d5c0:	d002      	beq.n	801d5c8 <USBD_StdEPReq+0xec>
 801d5c2:	88e3      	ldrh	r3, [r4, #6]
 801d5c4:	2b00      	cmp	r3, #0
 801d5c6:	d035      	beq.n	801d634 <USBD_StdEPReq+0x158>
              (void)USBD_CtlSendStatus(pdev);
 801d5c8:	4628      	mov	r0, r5
 801d5ca:	f000 f8ab 	bl	801d724 <USBD_CtlSendStatus>
              break;
 801d5ce:	e79b      	b.n	801d508 <USBD_StdEPReq+0x2c>
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 801d5d0:	064a      	lsls	r2, r1, #25
 801d5d2:	d091      	beq.n	801d4f8 <USBD_StdEPReq+0x1c>
                (void)USBD_LL_StallEP(pdev, ep_addr);
 801d5d4:	f002 fe2c 	bl	8020230 <USBD_LL_StallEP>
                (void)USBD_LL_StallEP(pdev, 0x80U);
 801d5d8:	2180      	movs	r1, #128	@ 0x80
 801d5da:	4628      	mov	r0, r5
 801d5dc:	f002 fe28 	bl	8020230 <USBD_LL_StallEP>
 801d5e0:	e792      	b.n	801d508 <USBD_StdEPReq+0x2c>
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 801d5e2:	0648      	lsls	r0, r1, #25
 801d5e4:	d188      	bne.n	801d4f8 <USBD_StdEPReq+0x1c>
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 801d5e6:	0611      	lsls	r1, r2, #24
              pep->status = 0x0000U;
 801d5e8:	f04f 0300 	mov.w	r3, #0
              (void)USBD_CtlSendData(pdev, (uint8_t *)&pep->status, 2U);
 801d5ec:	f04f 0202 	mov.w	r2, #2
 801d5f0:	4628      	mov	r0, r5
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 801d5f2:	bf4c      	ite	mi
 801d5f4:	f105 0114 	addmi.w	r1, r5, #20
 801d5f8:	f505 71aa 	addpl.w	r1, r5, #340	@ 0x154
              pep->status = 0x0000U;
 801d5fc:	600b      	str	r3, [r1, #0]
              (void)USBD_CtlSendData(pdev, (uint8_t *)&pep->status, 2U);
 801d5fe:	f000 f861 	bl	801d6c4 <USBD_CtlSendData>
              break;
 801d602:	e781      	b.n	801d508 <USBD_StdEPReq+0x2c>
                if (pdev->ep_in[ep_addr & 0xFU].is_used == 0U)
 801d604:	8c9b      	ldrh	r3, [r3, #36]	@ 0x24
 801d606:	2b00      	cmp	r3, #0
 801d608:	f43f af76 	beq.w	801d4f8 <USBD_StdEPReq+0x1c>
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 801d60c:	f001 037f 	and.w	r3, r1, #127	@ 0x7f
 801d610:	1c5c      	adds	r4, r3, #1
 801d612:	eb04 0484 	add.w	r4, r4, r4, lsl #2
 801d616:	eb05 0484 	add.w	r4, r5, r4, lsl #2
 801d61a:	e7bd      	b.n	801d598 <USBD_StdEPReq+0xbc>
              else if (USBD_LL_IsStallEP(pdev, ep_addr) != 0U)
 801d61c:	4628      	mov	r0, r5
 801d61e:	f002 fe1f 	bl	8020260 <USBD_LL_IsStallEP>
 801d622:	2800      	cmp	r0, #0
 801d624:	d0ba      	beq.n	801d59c <USBD_StdEPReq+0xc0>
 801d626:	2301      	movs	r3, #1
 801d628:	e7b9      	b.n	801d59e <USBD_StdEPReq+0xc2>
                  (void)USBD_LL_ClearStallEP(pdev, ep_addr);
 801d62a:	9101      	str	r1, [sp, #4]
 801d62c:	f002 fe0c 	bl	8020248 <USBD_LL_ClearStallEP>
 801d630:	9901      	ldr	r1, [sp, #4]
 801d632:	e779      	b.n	801d528 <USBD_StdEPReq+0x4c>
                  (void)USBD_LL_StallEP(pdev, ep_addr);
 801d634:	4628      	mov	r0, r5
 801d636:	f002 fdfb 	bl	8020230 <USBD_LL_StallEP>
 801d63a:	e7c5      	b.n	801d5c8 <USBD_StdEPReq+0xec>

0801d63c <USBD_ParseSetupRequest>:
  req->bmRequest = *(uint8_t *)(pbuff);
 801d63c:	780b      	ldrb	r3, [r1, #0]
 801d63e:	7003      	strb	r3, [r0, #0]
  req->bRequest = *(uint8_t *)(pbuff);
 801d640:	784b      	ldrb	r3, [r1, #1]
 801d642:	7043      	strb	r3, [r0, #1]
  req->wValue = SWAPBYTE(pbuff);
 801d644:	884b      	ldrh	r3, [r1, #2]
 801d646:	8043      	strh	r3, [r0, #2]
  req->wIndex = SWAPBYTE(pbuff);
 801d648:	888b      	ldrh	r3, [r1, #4]
 801d64a:	8083      	strh	r3, [r0, #4]
  req->wLength = SWAPBYTE(pbuff);
 801d64c:	88cb      	ldrh	r3, [r1, #6]
 801d64e:	80c3      	strh	r3, [r0, #6]
}
 801d650:	4770      	bx	lr
 801d652:	bf00      	nop

0801d654 <USBD_CtlError>:
{
 801d654:	b510      	push	{r4, lr}
 801d656:	4604      	mov	r4, r0
  (void)USBD_LL_StallEP(pdev, 0x80U);
 801d658:	2180      	movs	r1, #128	@ 0x80
 801d65a:	f002 fde9 	bl	8020230 <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 801d65e:	2100      	movs	r1, #0
 801d660:	4620      	mov	r0, r4
}
 801d662:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  (void)USBD_LL_StallEP(pdev, 0U);
 801d666:	f002 bde3 	b.w	8020230 <USBD_LL_StallEP>
 801d66a:	bf00      	nop

0801d66c <USBD_GetString>:
void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
{
  uint8_t idx = 0U;
  uint8_t *pdesc;

  if (desc == NULL)
 801d66c:	b330      	cbz	r0, 801d6bc <USBD_GetString+0x50>
{
 801d66e:	b570      	push	{r4, r5, r6, lr}
static uint8_t USBD_GetLen(uint8_t *buf)
{
  uint8_t  len = 0U;
  uint8_t *pbuff = buf;

  while (*pbuff != (uint8_t)'\0')
 801d670:	7803      	ldrb	r3, [r0, #0]
 801d672:	460e      	mov	r6, r1
 801d674:	4605      	mov	r5, r0
 801d676:	4614      	mov	r4, r2
 801d678:	b30b      	cbz	r3, 801d6be <USBD_GetString+0x52>
 801d67a:	4603      	mov	r3, r0
 801d67c:	f813 1f01 	ldrb.w	r1, [r3, #1]!
 801d680:	2900      	cmp	r1, #0
 801d682:	d1fb      	bne.n	801d67c <USBD_GetString+0x10>
 801d684:	1c68      	adds	r0, r5, #1
 801d686:	f7f2 fd2b 	bl	80100e0 <strlen>
  *len = MIN(USBD_MAX_STR_DESC_SIZ, ((uint16_t)USBD_GetLen(pdesc) * 2U) + 2U);
 801d68a:	1c43      	adds	r3, r0, #1
 801d68c:	b2db      	uxtb	r3, r3
 801d68e:	3301      	adds	r3, #1
 801d690:	005b      	lsls	r3, r3, #1
 801d692:	b2da      	uxtb	r2, r3
 801d694:	8023      	strh	r3, [r4, #0]
  unicode[idx] = USB_DESC_TYPE_STRING;
 801d696:	2303      	movs	r3, #3
  unicode[idx] = *(uint8_t *)len;
 801d698:	7032      	strb	r2, [r6, #0]
  unicode[idx] = USB_DESC_TYPE_STRING;
 801d69a:	7073      	strb	r3, [r6, #1]
  while (*pdesc != (uint8_t)'\0')
 801d69c:	782c      	ldrb	r4, [r5, #0]
 801d69e:	b164      	cbz	r4, 801d6ba <USBD_GetString+0x4e>
 801d6a0:	4628      	mov	r0, r5
  idx++;
 801d6a2:	2302      	movs	r3, #2
    unicode[idx] = 0U;
 801d6a4:	2100      	movs	r1, #0
    idx++;
 801d6a6:	1c5a      	adds	r2, r3, #1
    unicode[idx] = *pdesc;
 801d6a8:	54f4      	strb	r4, [r6, r3]
    idx++;
 801d6aa:	3302      	adds	r3, #2
    unicode[idx] = 0U;
 801d6ac:	b2d2      	uxtb	r2, r2
    idx++;
 801d6ae:	b2db      	uxtb	r3, r3
    unicode[idx] = 0U;
 801d6b0:	54b1      	strb	r1, [r6, r2]
  while (*pdesc != (uint8_t)'\0')
 801d6b2:	f810 4f01 	ldrb.w	r4, [r0, #1]!
 801d6b6:	2c00      	cmp	r4, #0
 801d6b8:	d1f5      	bne.n	801d6a6 <USBD_GetString+0x3a>
}
 801d6ba:	bd70      	pop	{r4, r5, r6, pc}
 801d6bc:	4770      	bx	lr
  while (*pbuff != (uint8_t)'\0')
 801d6be:	2202      	movs	r2, #2
 801d6c0:	4613      	mov	r3, r2
 801d6c2:	e7e7      	b.n	801d694 <USBD_GetString+0x28>

0801d6c4 <USBD_CtlSendData>:
  * @param  len: length of data to be sent
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlSendData(USBD_HandleTypeDef *pdev,
                                    uint8_t *pbuf, uint32_t len)
{
 801d6c4:	b510      	push	{r4, lr}
 801d6c6:	4613      	mov	r3, r2
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_IN;
 801d6c8:	2402      	movs	r4, #2
{
 801d6ca:	460a      	mov	r2, r1
#else
  pdev->ep_in[0].rem_length = len;
#endif /* USBD_AVOID_PACKET_SPLIT_MPS */

  /* Start the transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 801d6cc:	2100      	movs	r1, #0
  pdev->ep0_state = USBD_EP0_DATA_IN;
 801d6ce:	f8c0 4294 	str.w	r4, [r0, #660]	@ 0x294
  pdev->ep_in[0].total_length = len;
 801d6d2:	e9c0 3306 	strd	r3, r3, [r0, #24]
  (void)USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 801d6d6:	f002 fde3 	bl	80202a0 <USBD_LL_Transmit>

  return USBD_OK;
}
 801d6da:	2000      	movs	r0, #0
 801d6dc:	bd10      	pop	{r4, pc}
 801d6de:	bf00      	nop

0801d6e0 <USBD_CtlContinueSendData>:
  * @param  len: length of data to be sent
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlContinueSendData(USBD_HandleTypeDef *pdev,
                                            uint8_t *pbuf, uint32_t len)
{
 801d6e0:	468c      	mov	ip, r1
  /* Start the next transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 801d6e2:	2100      	movs	r1, #0
{
 801d6e4:	b508      	push	{r3, lr}
 801d6e6:	4613      	mov	r3, r2
  (void)USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 801d6e8:	4662      	mov	r2, ip
 801d6ea:	f002 fdd9 	bl	80202a0 <USBD_LL_Transmit>

  return USBD_OK;
}
 801d6ee:	2000      	movs	r0, #0
 801d6f0:	bd08      	pop	{r3, pc}
 801d6f2:	bf00      	nop

0801d6f4 <USBD_CtlPrepareRx>:
  * @param  len: length of data to be received
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlPrepareRx(USBD_HandleTypeDef *pdev,
                                     uint8_t *pbuf, uint32_t len)
{
 801d6f4:	b510      	push	{r4, lr}
 801d6f6:	4613      	mov	r3, r2
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_OUT;
 801d6f8:	2403      	movs	r4, #3
{
 801d6fa:	460a      	mov	r2, r1
#else
  pdev->ep_out[0].rem_length = len;
#endif /* USBD_AVOID_PACKET_SPLIT_MPS */

  /* Start the transfer */
  (void)USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 801d6fc:	2100      	movs	r1, #0
  pdev->ep0_state = USBD_EP0_DATA_OUT;
 801d6fe:	f8c0 4294 	str.w	r4, [r0, #660]	@ 0x294
  pdev->ep_out[0].total_length = len;
 801d702:	e9c0 3356 	strd	r3, r3, [r0, #344]	@ 0x158
  (void)USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 801d706:	f002 fdd7 	bl	80202b8 <USBD_LL_PrepareReceive>

  return USBD_OK;
}
 801d70a:	2000      	movs	r0, #0
 801d70c:	bd10      	pop	{r4, pc}
 801d70e:	bf00      	nop

0801d710 <USBD_CtlContinueRx>:
  * @param  len: length of data to be received
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlContinueRx(USBD_HandleTypeDef *pdev,
                                      uint8_t *pbuf, uint32_t len)
{
 801d710:	468c      	mov	ip, r1
  (void)USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 801d712:	2100      	movs	r1, #0
{
 801d714:	b508      	push	{r3, lr}
 801d716:	4613      	mov	r3, r2
  (void)USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 801d718:	4662      	mov	r2, ip
 801d71a:	f002 fdcd 	bl	80202b8 <USBD_LL_PrepareReceive>

  return USBD_OK;
}
 801d71e:	2000      	movs	r0, #0
 801d720:	bd08      	pop	{r3, pc}
 801d722:	bf00      	nop

0801d724 <USBD_CtlSendStatus>:
{
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;

  /* Start the transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, NULL, 0U);
 801d724:	2300      	movs	r3, #0
{
 801d726:	b510      	push	{r4, lr}
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 801d728:	2404      	movs	r4, #4
  (void)USBD_LL_Transmit(pdev, 0x00U, NULL, 0U);
 801d72a:	461a      	mov	r2, r3
 801d72c:	4619      	mov	r1, r3
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 801d72e:	f8c0 4294 	str.w	r4, [r0, #660]	@ 0x294
  (void)USBD_LL_Transmit(pdev, 0x00U, NULL, 0U);
 801d732:	f002 fdb5 	bl	80202a0 <USBD_LL_Transmit>

  return USBD_OK;
}
 801d736:	2000      	movs	r0, #0
 801d738:	bd10      	pop	{r4, pc}
 801d73a:	bf00      	nop

0801d73c <USBD_CtlReceiveStatus>:
{
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT;

  /* Start the transfer */
  (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 801d73c:	2300      	movs	r3, #0
{
 801d73e:	b510      	push	{r4, lr}
  pdev->ep0_state = USBD_EP0_STATUS_OUT;
 801d740:	2405      	movs	r4, #5
  (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 801d742:	461a      	mov	r2, r3
 801d744:	4619      	mov	r1, r3
  pdev->ep0_state = USBD_EP0_STATUS_OUT;
 801d746:	f8c0 4294 	str.w	r4, [r0, #660]	@ 0x294
  (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 801d74a:	f002 fdb5 	bl	80202b8 <USBD_LL_PrepareReceive>

  return USBD_OK;
}
 801d74e:	2000      	movs	r0, #0
 801d750:	bd10      	pop	{r4, pc}
 801d752:	bf00      	nop

0801d754 <FATFS_LinkDriver>:
uint8_t FATFS_LinkDriverEx(const Diskio_drvTypeDef *drv, char *path, uint8_t lun)
{
  uint8_t ret = 1;
  uint8_t DiskNum = 0;

  if(disk.nbr < _VOLUMES)
 801d754:	4b10      	ldr	r3, [pc, #64]	@ (801d798 <FATFS_LinkDriver+0x44>)
  * @param  drv: pointer to the disk IO Driver structure
  * @param  path: pointer to the logical drive path
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_LinkDriver(const Diskio_drvTypeDef *drv, char *path)
{
 801d756:	b410      	push	{r4}
  if(disk.nbr < _VOLUMES)
 801d758:	7a5c      	ldrb	r4, [r3, #9]
 801d75a:	b9cc      	cbnz	r4, 801d790 <FATFS_LinkDriver+0x3c>
 801d75c:	4602      	mov	r2, r0
    disk.is_initialized[disk.nbr] = 0;
 801d75e:	f004 00ff 	and.w	r0, r4, #255	@ 0xff
 801d762:	7a5c      	ldrb	r4, [r3, #9]
 801d764:	5518      	strb	r0, [r3, r4]
    disk.drv[disk.nbr] = drv;
 801d766:	7a5c      	ldrb	r4, [r3, #9]
 801d768:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 801d76c:	6062      	str	r2, [r4, #4]
    disk.lun[disk.nbr] = lun;
 801d76e:	7a5c      	ldrb	r4, [r3, #9]
    DiskNum = disk.nbr++;
 801d770:	7a5a      	ldrb	r2, [r3, #9]
    disk.lun[disk.nbr] = lun;
 801d772:	441c      	add	r4, r3
 801d774:	7220      	strb	r0, [r4, #8]
    DiskNum = disk.nbr++;
 801d776:	1c54      	adds	r4, r2, #1
    path[0] = DiskNum + '0';
 801d778:	3230      	adds	r2, #48	@ 0x30
    DiskNum = disk.nbr++;
 801d77a:	b2e4      	uxtb	r4, r4
 801d77c:	725c      	strb	r4, [r3, #9]
    path[1] = ':';
 801d77e:	243a      	movs	r4, #58	@ 0x3a
    path[2] = '/';
 801d780:	232f      	movs	r3, #47	@ 0x2f
    path[0] = DiskNum + '0';
 801d782:	700a      	strb	r2, [r1, #0]
    path[1] = ':';
 801d784:	704c      	strb	r4, [r1, #1]
    path[3] = 0;
 801d786:	70c8      	strb	r0, [r1, #3]
  return FATFS_LinkDriverEx(drv, path, 0);
}
 801d788:	f85d 4b04 	ldr.w	r4, [sp], #4
    path[2] = '/';
 801d78c:	708b      	strb	r3, [r1, #2]
}
 801d78e:	4770      	bx	lr
  uint8_t ret = 1;
 801d790:	2001      	movs	r0, #1
}
 801d792:	f85d 4b04 	ldr.w	r4, [sp], #4
 801d796:	4770      	bx	lr
 801d798:	20002bdc 	.word	0x20002bdc

0801d79c <osKernelInitialize>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 801d79c:	f3ef 8305 	mrs	r3, IPSR
/*---------------------------------------------------------------------------*/

osStatus_t osKernelInitialize (void) {
  osStatus_t stat;

  if (IS_IRQ()) {
 801d7a0:	b97b      	cbnz	r3, 801d7c2 <osKernelInitialize+0x26>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801d7a2:	f3ef 8310 	mrs	r3, PRIMASK
 801d7a6:	b943      	cbnz	r3, 801d7ba <osKernelInitialize+0x1e>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 801d7a8:	f3ef 8311 	mrs	r3, BASEPRI
 801d7ac:	b92b      	cbnz	r3, 801d7ba <osKernelInitialize+0x1e>
 801d7ae:	4b08      	ldr	r3, [pc, #32]	@ (801d7d0 <osKernelInitialize+0x34>)
 801d7b0:	6818      	ldr	r0, [r3, #0]
    stat = osErrorISR;
  }
  else {
    if (KernelState == osKernelInactive) {
 801d7b2:	b948      	cbnz	r0, 801d7c8 <osKernelInitialize+0x2c>
      #if defined(USE_FREERTOS_HEAP_5) && (HEAP_5_REGION_SETUP == 1)
        vPortDefineHeapRegions (configHEAP_5_REGIONS);
      #endif
      KernelState = osKernelReady;
 801d7b4:	2201      	movs	r2, #1
 801d7b6:	601a      	str	r2, [r3, #0]
      stat = osOK;
 801d7b8:	4770      	bx	lr
  if (IS_IRQ()) {
 801d7ba:	4b05      	ldr	r3, [pc, #20]	@ (801d7d0 <osKernelInitialize+0x34>)
 801d7bc:	6818      	ldr	r0, [r3, #0]
 801d7be:	2802      	cmp	r0, #2
 801d7c0:	d1f7      	bne.n	801d7b2 <osKernelInitialize+0x16>
    stat = osErrorISR;
 801d7c2:	f06f 0005 	mvn.w	r0, #5
 801d7c6:	4770      	bx	lr
    } else {
      stat = osError;
 801d7c8:	f04f 30ff 	mov.w	r0, #4294967295
    }
  }

  return (stat);
}
 801d7cc:	4770      	bx	lr
 801d7ce:	bf00      	nop
 801d7d0:	200032a8 	.word	0x200032a8

0801d7d4 <osKernelGetState>:
  }

  return (osOK);
}

osKernelState_t osKernelGetState (void) {
 801d7d4:	b508      	push	{r3, lr}
  osKernelState_t state;

  switch (xTaskGetSchedulerState()) {
 801d7d6:	f001 fd89 	bl	801f2ec <xTaskGetSchedulerState>
 801d7da:	b148      	cbz	r0, 801d7f0 <osKernelGetState+0x1c>
 801d7dc:	2802      	cmp	r0, #2
 801d7de:	d006      	beq.n	801d7ee <osKernelGetState+0x1a>
      state = osKernelLocked;
      break;

    case taskSCHEDULER_NOT_STARTED:
    default:
      if (KernelState == osKernelReady) {
 801d7e0:	4b04      	ldr	r3, [pc, #16]	@ (801d7f4 <osKernelGetState+0x20>)
 801d7e2:	6818      	ldr	r0, [r3, #0]
 801d7e4:	f1a0 0001 	sub.w	r0, r0, #1
 801d7e8:	fab0 f080 	clz	r0, r0
 801d7ec:	0940      	lsrs	r0, r0, #5
      }
      break;
  }

  return (state);
}
 801d7ee:	bd08      	pop	{r3, pc}
  switch (xTaskGetSchedulerState()) {
 801d7f0:	2003      	movs	r0, #3
}
 801d7f2:	bd08      	pop	{r3, pc}
 801d7f4:	200032a8 	.word	0x200032a8

0801d7f8 <osKernelStart>:

osStatus_t osKernelStart (void) {
 801d7f8:	b508      	push	{r3, lr}
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 801d7fa:	f3ef 8305 	mrs	r3, IPSR
  osStatus_t stat;

  if (IS_IRQ()) {
 801d7fe:	b9c3      	cbnz	r3, 801d832 <osKernelStart+0x3a>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801d800:	f3ef 8310 	mrs	r3, PRIMASK
 801d804:	b15b      	cbz	r3, 801d81e <osKernelStart+0x26>
 801d806:	4b0c      	ldr	r3, [pc, #48]	@ (801d838 <osKernelStart+0x40>)
 801d808:	681a      	ldr	r2, [r3, #0]
 801d80a:	2a02      	cmp	r2, #2
 801d80c:	d011      	beq.n	801d832 <osKernelStart+0x3a>
    stat = osErrorISR;
  }
  else {
    if (KernelState == osKernelReady) {
 801d80e:	2a01      	cmp	r2, #1
 801d810:	d10c      	bne.n	801d82c <osKernelStart+0x34>
      /* Ensure SVC priority is at the reset value */
      SVC_Setup();
      /* Change state to enable IRQ masking check */
      KernelState = osKernelRunning;
 801d812:	2202      	movs	r2, #2
 801d814:	601a      	str	r2, [r3, #0]
      /* Start the kernel scheduler */
      vTaskStartScheduler();
 801d816:	f001 f9c7 	bl	801eba8 <vTaskStartScheduler>
      stat = osOK;
 801d81a:	2000      	movs	r0, #0
      stat = osError;
    }
  }

  return (stat);
}
 801d81c:	bd08      	pop	{r3, pc}
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 801d81e:	f3ef 8311 	mrs	r3, BASEPRI
  if (IS_IRQ()) {
 801d822:	2b00      	cmp	r3, #0
 801d824:	d1ef      	bne.n	801d806 <osKernelStart+0xe>
 801d826:	4b04      	ldr	r3, [pc, #16]	@ (801d838 <osKernelStart+0x40>)
 801d828:	681a      	ldr	r2, [r3, #0]
 801d82a:	e7f0      	b.n	801d80e <osKernelStart+0x16>
      stat = osError;
 801d82c:	f04f 30ff 	mov.w	r0, #4294967295
}
 801d830:	bd08      	pop	{r3, pc}
    stat = osErrorISR;
 801d832:	f06f 0005 	mvn.w	r0, #5
}
 801d836:	bd08      	pop	{r3, pc}
 801d838:	200032a8 	.word	0x200032a8

0801d83c <osKernelGetTickCount>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 801d83c:	f3ef 8305 	mrs	r3, IPSR
}

uint32_t osKernelGetTickCount (void) {
  TickType_t ticks;

  if (IS_IRQ()) {
 801d840:	b943      	cbnz	r3, 801d854 <osKernelGetTickCount+0x18>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801d842:	f3ef 8310 	mrs	r3, PRIMASK
 801d846:	b13b      	cbz	r3, 801d858 <osKernelGetTickCount+0x1c>
 801d848:	4b08      	ldr	r3, [pc, #32]	@ (801d86c <osKernelGetTickCount+0x30>)
 801d84a:	681b      	ldr	r3, [r3, #0]
 801d84c:	2b02      	cmp	r3, #2
 801d84e:	d001      	beq.n	801d854 <osKernelGetTickCount+0x18>
    ticks = xTaskGetTickCountFromISR();
  } else {
    ticks = xTaskGetTickCount();
 801d850:	f001 ba4c 	b.w	801ecec <xTaskGetTickCount>
    ticks = xTaskGetTickCountFromISR();
 801d854:	f001 ba50 	b.w	801ecf8 <xTaskGetTickCountFromISR>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 801d858:	f3ef 8311 	mrs	r3, BASEPRI
  if (IS_IRQ()) {
 801d85c:	2b00      	cmp	r3, #0
 801d85e:	d0f7      	beq.n	801d850 <osKernelGetTickCount+0x14>
 801d860:	4b02      	ldr	r3, [pc, #8]	@ (801d86c <osKernelGetTickCount+0x30>)
 801d862:	681b      	ldr	r3, [r3, #0]
 801d864:	2b02      	cmp	r3, #2
 801d866:	d1f3      	bne.n	801d850 <osKernelGetTickCount+0x14>
 801d868:	e7f4      	b.n	801d854 <osKernelGetTickCount+0x18>
 801d86a:	bf00      	nop
 801d86c:	200032a8 	.word	0x200032a8

0801d870 <osThreadNew>:
  return (configCPU_CLOCK_HZ);
}

/*---------------------------------------------------------------------------*/

osThreadId_t osThreadNew (osThreadFunc_t func, void *argument, const osThreadAttr_t *attr) {
 801d870:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t stack;
  TaskHandle_t hTask;
  UBaseType_t prio;
  int32_t mem;

  hTask = NULL;
 801d872:	2500      	movs	r5, #0
osThreadId_t osThreadNew (osThreadFunc_t func, void *argument, const osThreadAttr_t *attr) {
 801d874:	b087      	sub	sp, #28
 801d876:	4614      	mov	r4, r2
  hTask = NULL;
 801d878:	9505      	str	r5, [sp, #20]
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 801d87a:	f3ef 8205 	mrs	r2, IPSR

  if (!IS_IRQ() && (func != NULL)) {
 801d87e:	bb7a      	cbnz	r2, 801d8e0 <osThreadNew+0x70>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801d880:	f3ef 8310 	mrs	r3, PRIMASK
 801d884:	bb7b      	cbnz	r3, 801d8e6 <osThreadNew+0x76>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 801d886:	f3ef 8311 	mrs	r3, BASEPRI
 801d88a:	bb63      	cbnz	r3, 801d8e6 <osThreadNew+0x76>
 801d88c:	b378      	cbz	r0, 801d8ee <osThreadNew+0x7e>
    prio  = (UBaseType_t)osPriorityNormal;

    name = NULL;
    mem  = -1;

    if (attr != NULL) {
 801d88e:	b1e4      	cbz	r4, 801d8ca <osThreadNew+0x5a>
      if (attr->name != NULL) {
        name = attr->name;
      }
      if (attr->priority != osPriorityNone) {
 801d890:	69a5      	ldr	r5, [r4, #24]
 801d892:	b37d      	cbz	r5, 801d8f4 <osThreadNew+0x84>
        prio = (UBaseType_t)attr->priority;
      }

      if ((prio < osPriorityIdle) || (prio > osPriorityISR) || ((attr->attr_bits & osThreadJoinable) == osThreadJoinable)) {
 801d894:	1e6b      	subs	r3, r5, #1
 801d896:	2b37      	cmp	r3, #55	@ 0x37
 801d898:	d822      	bhi.n	801d8e0 <osThreadNew+0x70>
 801d89a:	6863      	ldr	r3, [r4, #4]
 801d89c:	07db      	lsls	r3, r3, #31
 801d89e:	d41f      	bmi.n	801d8e0 <osThreadNew+0x70>
        return (NULL);
      }

      if (attr->stack_size > 0U) {
 801d8a0:	6963      	ldr	r3, [r4, #20]
 801d8a2:	b34b      	cbz	r3, 801d8f8 <osThreadNew+0x88>
        /* In FreeRTOS stack is not in bytes, but in sizeof(StackType_t) which is 4 on ARM ports.       */
        /* Stack size should be therefore 4 byte aligned in order to avoid division caused side effects */
        stack = attr->stack_size / sizeof(StackType_t);
 801d8a4:	089a      	lsrs	r2, r3, #2
      }

      if ((attr->cb_mem    != NULL) && (attr->cb_size    >= sizeof(StaticTask_t)) &&
 801d8a6:	68a6      	ldr	r6, [r4, #8]
      if (attr->name != NULL) {
 801d8a8:	f8d4 c000 	ldr.w	ip, [r4]
      if ((attr->cb_mem    != NULL) && (attr->cb_size    >= sizeof(StaticTask_t)) &&
 801d8ac:	68e7      	ldr	r7, [r4, #12]
 801d8ae:	b32e      	cbz	r6, 801d8fc <osThreadNew+0x8c>
 801d8b0:	2f5f      	cmp	r7, #95	@ 0x5f
 801d8b2:	d91c      	bls.n	801d8ee <osThreadNew+0x7e>
          (attr->stack_mem != NULL) && (attr->stack_size >  0U)) {
 801d8b4:	6924      	ldr	r4, [r4, #16]
 801d8b6:	b1d3      	cbz	r3, 801d8ee <osThreadNew+0x7e>
 801d8b8:	b1cc      	cbz	r4, 801d8ee <osThreadNew+0x7e>
    else {
      mem = 0;
    }

    if (mem == 1) {
      hTask = xTaskCreateStatic ((TaskFunction_t)func, name, stack, argument, prio, (StackType_t  *)attr->stack_mem,
 801d8ba:	460b      	mov	r3, r1
 801d8bc:	9500      	str	r5, [sp, #0]
 801d8be:	4661      	mov	r1, ip
 801d8c0:	e9cd 4601 	strd	r4, r6, [sp, #4]
 801d8c4:	f001 f82e 	bl	801e924 <xTaskCreateStatic>
 801d8c8:	e00b      	b.n	801d8e2 <osThreadNew+0x72>
 801d8ca:	2280      	movs	r2, #128	@ 0x80
    prio  = (UBaseType_t)osPriorityNormal;
 801d8cc:	2518      	movs	r5, #24
                                                                                    (StaticTask_t *)attr->cb_mem);
    }
    else {
      if (mem == 0) {
        if (xTaskCreate ((TaskFunction_t)func, name, (uint16_t)stack, argument, prio, &hTask) != pdPASS) {
 801d8ce:	460b      	mov	r3, r1
 801d8d0:	4621      	mov	r1, r4
 801d8d2:	ac05      	add	r4, sp, #20
 801d8d4:	9500      	str	r5, [sp, #0]
 801d8d6:	9401      	str	r4, [sp, #4]
 801d8d8:	f001 f8d4 	bl	801ea84 <xTaskCreate>
 801d8dc:	2801      	cmp	r0, #1
 801d8de:	d006      	beq.n	801d8ee <osThreadNew+0x7e>
        return (NULL);
 801d8e0:	2000      	movs	r0, #0
      }
    }
  }

  return ((osThreadId_t)hTask);
}
 801d8e2:	b007      	add	sp, #28
 801d8e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (!IS_IRQ() && (func != NULL)) {
 801d8e6:	4b09      	ldr	r3, [pc, #36]	@ (801d90c <osThreadNew+0x9c>)
 801d8e8:	681b      	ldr	r3, [r3, #0]
 801d8ea:	2b02      	cmp	r3, #2
 801d8ec:	d1ce      	bne.n	801d88c <osThreadNew+0x1c>
  return ((osThreadId_t)hTask);
 801d8ee:	9805      	ldr	r0, [sp, #20]
}
 801d8f0:	b007      	add	sp, #28
 801d8f2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801d8f4:	2518      	movs	r5, #24
 801d8f6:	e7d0      	b.n	801d89a <osThreadNew+0x2a>
    stack = configMINIMAL_STACK_SIZE;
 801d8f8:	2280      	movs	r2, #128	@ 0x80
 801d8fa:	e7d4      	b.n	801d8a6 <osThreadNew+0x36>
        if ((attr->cb_mem == NULL) && (attr->cb_size == 0U) && (attr->stack_mem == NULL)) {
 801d8fc:	2f00      	cmp	r7, #0
 801d8fe:	d1f6      	bne.n	801d8ee <osThreadNew+0x7e>
 801d900:	6923      	ldr	r3, [r4, #16]
 801d902:	2b00      	cmp	r3, #0
 801d904:	d1f3      	bne.n	801d8ee <osThreadNew+0x7e>
        if (xTaskCreate ((TaskFunction_t)func, name, (uint16_t)stack, argument, prio, &hTask) != pdPASS) {
 801d906:	b292      	uxth	r2, r2
 801d908:	4664      	mov	r4, ip
 801d90a:	e7e0      	b.n	801d8ce <osThreadNew+0x5e>
 801d90c:	200032a8 	.word	0x200032a8

0801d910 <osDelay>:

  /* Return flags before clearing */
  return (rflags);
}

osStatus_t osDelay (uint32_t ticks) {
 801d910:	b508      	push	{r3, lr}
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 801d912:	f3ef 8305 	mrs	r3, IPSR
  osStatus_t stat;

  if (IS_IRQ()) {
 801d916:	b9ab      	cbnz	r3, 801d944 <osDelay+0x34>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801d918:	f3ef 8310 	mrs	r3, PRIMASK
 801d91c:	b133      	cbz	r3, 801d92c <osDelay+0x1c>
 801d91e:	4b0b      	ldr	r3, [pc, #44]	@ (801d94c <osDelay+0x3c>)
 801d920:	681b      	ldr	r3, [r3, #0]
 801d922:	2b02      	cmp	r3, #2
 801d924:	d00e      	beq.n	801d944 <osDelay+0x34>
    stat = osErrorISR;
  }
  else {
    stat = osOK;

    if (ticks != 0U) {
 801d926:	b950      	cbnz	r0, 801d93e <osDelay+0x2e>
    stat = osOK;
 801d928:	2000      	movs	r0, #0
      vTaskDelay(ticks);
    }
  }

  return (stat);
}
 801d92a:	bd08      	pop	{r3, pc}
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 801d92c:	f3ef 8311 	mrs	r3, BASEPRI
  if (IS_IRQ()) {
 801d930:	2b00      	cmp	r3, #0
 801d932:	d0f8      	beq.n	801d926 <osDelay+0x16>
 801d934:	4b05      	ldr	r3, [pc, #20]	@ (801d94c <osDelay+0x3c>)
 801d936:	681b      	ldr	r3, [r3, #0]
 801d938:	2b02      	cmp	r3, #2
 801d93a:	d1f4      	bne.n	801d926 <osDelay+0x16>
 801d93c:	e002      	b.n	801d944 <osDelay+0x34>
      vTaskDelay(ticks);
 801d93e:	f001 fb3b 	bl	801efb8 <vTaskDelay>
 801d942:	e7f1      	b.n	801d928 <osDelay+0x18>
    stat = osErrorISR;
 801d944:	f06f 0005 	mvn.w	r0, #5
}
 801d948:	bd08      	pop	{r3, pc}
 801d94a:	bf00      	nop
 801d94c:	200032a8 	.word	0x200032a8

0801d950 <osMessageQueueNew>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 801d950:	f3ef 8305 	mrs	r3, IPSR
  const char *name;
  #endif

  hQueue = NULL;

  if (!IS_IRQ() && (msg_count > 0U) && (msg_size > 0U)) {
 801d954:	b9fb      	cbnz	r3, 801d996 <osMessageQueueNew+0x46>
osMessageQueueId_t osMessageQueueNew (uint32_t msg_count, uint32_t msg_size, const osMessageQueueAttr_t *attr) {
 801d956:	b530      	push	{r4, r5, lr}
 801d958:	4614      	mov	r4, r2
 801d95a:	b085      	sub	sp, #20
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801d95c:	f3ef 8310 	mrs	r3, PRIMASK
  if (!IS_IRQ() && (msg_count > 0U) && (msg_size > 0U)) {
 801d960:	b9a3      	cbnz	r3, 801d98c <osMessageQueueNew+0x3c>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 801d962:	f3ef 8311 	mrs	r3, BASEPRI
 801d966:	b98b      	cbnz	r3, 801d98c <osMessageQueueNew+0x3c>
 801d968:	b168      	cbz	r0, 801d986 <osMessageQueueNew+0x36>
 801d96a:	b161      	cbz	r1, 801d986 <osMessageQueueNew+0x36>
    mem = -1;

    if (attr != NULL) {
 801d96c:	b1ac      	cbz	r4, 801d99a <osMessageQueueNew+0x4a>
      if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(StaticQueue_t)) &&
 801d96e:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
 801d972:	b1f3      	cbz	r3, 801d9b2 <osMessageQueueNew+0x62>
 801d974:	2a4f      	cmp	r2, #79	@ 0x4f
 801d976:	d906      	bls.n	801d986 <osMessageQueueNew+0x36>
          (attr->mq_mem != NULL) && (attr->mq_size >= (msg_count * msg_size))) {
 801d978:	6922      	ldr	r2, [r4, #16]
      if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(StaticQueue_t)) &&
 801d97a:	b122      	cbz	r2, 801d986 <osMessageQueueNew+0x36>
          (attr->mq_mem != NULL) && (attr->mq_size >= (msg_count * msg_size))) {
 801d97c:	fb01 fc00 	mul.w	ip, r1, r0
 801d980:	6965      	ldr	r5, [r4, #20]
 801d982:	4565      	cmp	r5, ip
 801d984:	d223      	bcs.n	801d9ce <osMessageQueueNew+0x7e>
  hQueue = NULL;
 801d986:	2000      	movs	r0, #0
    #endif

  }

  return ((osMessageQueueId_t)hQueue);
}
 801d988:	b005      	add	sp, #20
 801d98a:	bd30      	pop	{r4, r5, pc}
  if (!IS_IRQ() && (msg_count > 0U) && (msg_size > 0U)) {
 801d98c:	4b13      	ldr	r3, [pc, #76]	@ (801d9dc <osMessageQueueNew+0x8c>)
 801d98e:	681b      	ldr	r3, [r3, #0]
 801d990:	2b02      	cmp	r3, #2
 801d992:	d1e9      	bne.n	801d968 <osMessageQueueNew+0x18>
 801d994:	e7f7      	b.n	801d986 <osMessageQueueNew+0x36>
  hQueue = NULL;
 801d996:	2000      	movs	r0, #0
}
 801d998:	4770      	bx	lr
        hQueue = xQueueCreate (msg_count, msg_size);
 801d99a:	4622      	mov	r2, r4
 801d99c:	f000 f9da 	bl	801dd54 <xQueueGenericCreate>
    if (hQueue != NULL) {
 801d9a0:	2800      	cmp	r0, #0
 801d9a2:	d0f0      	beq.n	801d986 <osMessageQueueNew+0x36>
      vQueueAddToRegistry (hQueue, name);
 801d9a4:	4621      	mov	r1, r4
 801d9a6:	9003      	str	r0, [sp, #12]
 801d9a8:	f000 fdfe 	bl	801e5a8 <vQueueAddToRegistry>
 801d9ac:	9803      	ldr	r0, [sp, #12]
}
 801d9ae:	b005      	add	sp, #20
 801d9b0:	bd30      	pop	{r4, r5, pc}
        if ((attr->cb_mem == NULL) && (attr->cb_size == 0U) &&
 801d9b2:	2a00      	cmp	r2, #0
 801d9b4:	d1e7      	bne.n	801d986 <osMessageQueueNew+0x36>
 801d9b6:	6923      	ldr	r3, [r4, #16]
 801d9b8:	2b00      	cmp	r3, #0
 801d9ba:	d1e4      	bne.n	801d986 <osMessageQueueNew+0x36>
            (attr->mq_mem == NULL) && (attr->mq_size == 0U)) {
 801d9bc:	6962      	ldr	r2, [r4, #20]
 801d9be:	2a00      	cmp	r2, #0
 801d9c0:	d1e1      	bne.n	801d986 <osMessageQueueNew+0x36>
        hQueue = xQueueCreate (msg_count, msg_size);
 801d9c2:	f000 f9c7 	bl	801dd54 <xQueueGenericCreate>
    if (hQueue != NULL) {
 801d9c6:	2800      	cmp	r0, #0
 801d9c8:	d0dd      	beq.n	801d986 <osMessageQueueNew+0x36>
        name = attr->name;
 801d9ca:	6824      	ldr	r4, [r4, #0]
 801d9cc:	e7ea      	b.n	801d9a4 <osMessageQueueNew+0x54>
      hQueue = xQueueCreateStatic (msg_count, msg_size, attr->mq_mem, attr->cb_mem);
 801d9ce:	2500      	movs	r5, #0
 801d9d0:	9500      	str	r5, [sp, #0]
 801d9d2:	f000 f949 	bl	801dc68 <xQueueGenericCreateStatic>
    if (hQueue != NULL) {
 801d9d6:	2800      	cmp	r0, #0
 801d9d8:	d1f7      	bne.n	801d9ca <osMessageQueueNew+0x7a>
 801d9da:	e7d4      	b.n	801d986 <osMessageQueueNew+0x36>
 801d9dc:	200032a8 	.word	0x200032a8

0801d9e0 <osMessageQueuePut>:

osStatus_t osMessageQueuePut (osMessageQueueId_t mq_id, const void *msg_ptr, uint8_t msg_prio, uint32_t timeout) {
 801d9e0:	b510      	push	{r4, lr}
 801d9e2:	461c      	mov	r4, r3
 801d9e4:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 801d9e6:	f3ef 8305 	mrs	r3, IPSR

  (void)msg_prio; /* Message priority is ignored */

  stat = osOK;

  if (IS_IRQ()) {
 801d9ea:	b9c3      	cbnz	r3, 801da1e <osMessageQueuePut+0x3e>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801d9ec:	f3ef 8310 	mrs	r3, PRIMASK
 801d9f0:	2b00      	cmp	r3, #0
 801d9f2:	d036      	beq.n	801da62 <osMessageQueuePut+0x82>
 801d9f4:	4b23      	ldr	r3, [pc, #140]	@ (801da84 <osMessageQueuePut+0xa4>)
 801d9f6:	681b      	ldr	r3, [r3, #0]
 801d9f8:	2b02      	cmp	r3, #2
 801d9fa:	d010      	beq.n	801da1e <osMessageQueuePut+0x3e>
        portYIELD_FROM_ISR (yield);
      }
    }
  }
  else {
    if ((hQueue == NULL) || (msg_ptr == NULL)) {
 801d9fc:	2800      	cmp	r0, #0
 801d9fe:	d03d      	beq.n	801da7c <osMessageQueuePut+0x9c>
 801da00:	fab1 f381 	clz	r3, r1
 801da04:	095b      	lsrs	r3, r3, #5
 801da06:	2900      	cmp	r1, #0
 801da08:	d038      	beq.n	801da7c <osMessageQueuePut+0x9c>
      stat = osErrorParameter;
    }
    else {
      if (xQueueSendToBack (hQueue, msg_ptr, (TickType_t)timeout) != pdPASS) {
 801da0a:	4622      	mov	r2, r4
 801da0c:	f000 f9e6 	bl	801dddc <xQueueGenericSend>
 801da10:	2801      	cmp	r0, #1
 801da12:	d018      	beq.n	801da46 <osMessageQueuePut+0x66>
        if (timeout != 0U) {
 801da14:	b374      	cbz	r4, 801da74 <osMessageQueuePut+0x94>
          stat = osErrorTimeout;
 801da16:	f06f 0001 	mvn.w	r0, #1
      }
    }
  }

  return (stat);
}
 801da1a:	b002      	add	sp, #8
 801da1c:	bd10      	pop	{r4, pc}
    if ((hQueue == NULL) || (msg_ptr == NULL) || (timeout != 0U)) {
 801da1e:	3c00      	subs	r4, #0
 801da20:	bf18      	it	ne
 801da22:	2401      	movne	r4, #1
 801da24:	2900      	cmp	r1, #0
 801da26:	bf08      	it	eq
 801da28:	f044 0401 	orreq.w	r4, r4, #1
 801da2c:	bb34      	cbnz	r4, 801da7c <osMessageQueuePut+0x9c>
 801da2e:	fab0 f380 	clz	r3, r0
 801da32:	095b      	lsrs	r3, r3, #5
 801da34:	b310      	cbz	r0, 801da7c <osMessageQueuePut+0x9c>
      if (xQueueSendToBackFromISR (hQueue, msg_ptr, &yield) != pdTRUE) {
 801da36:	aa01      	add	r2, sp, #4
      yield = pdFALSE;
 801da38:	9301      	str	r3, [sp, #4]
      if (xQueueSendToBackFromISR (hQueue, msg_ptr, &yield) != pdTRUE) {
 801da3a:	f000 fb59 	bl	801e0f0 <xQueueGenericSendFromISR>
 801da3e:	2801      	cmp	r0, #1
 801da40:	d118      	bne.n	801da74 <osMessageQueuePut+0x94>
        portYIELD_FROM_ISR (yield);
 801da42:	9b01      	ldr	r3, [sp, #4]
 801da44:	b913      	cbnz	r3, 801da4c <osMessageQueuePut+0x6c>
  stat = osOK;
 801da46:	2000      	movs	r0, #0
}
 801da48:	b002      	add	sp, #8
 801da4a:	bd10      	pop	{r4, pc}
        portYIELD_FROM_ISR (yield);
 801da4c:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 801da50:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 801da54:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 801da58:	f3bf 8f4f 	dsb	sy
 801da5c:	f3bf 8f6f 	isb	sy
 801da60:	e7f1      	b.n	801da46 <osMessageQueuePut+0x66>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 801da62:	f3ef 8311 	mrs	r3, BASEPRI
  if (IS_IRQ()) {
 801da66:	2b00      	cmp	r3, #0
 801da68:	d0c8      	beq.n	801d9fc <osMessageQueuePut+0x1c>
 801da6a:	4b06      	ldr	r3, [pc, #24]	@ (801da84 <osMessageQueuePut+0xa4>)
 801da6c:	681b      	ldr	r3, [r3, #0]
 801da6e:	2b02      	cmp	r3, #2
 801da70:	d1c4      	bne.n	801d9fc <osMessageQueuePut+0x1c>
 801da72:	e7d4      	b.n	801da1e <osMessageQueuePut+0x3e>
        stat = osErrorResource;
 801da74:	f06f 0002 	mvn.w	r0, #2
}
 801da78:	b002      	add	sp, #8
 801da7a:	bd10      	pop	{r4, pc}
      stat = osErrorParameter;
 801da7c:	f06f 0003 	mvn.w	r0, #3
 801da80:	e7e2      	b.n	801da48 <osMessageQueuePut+0x68>
 801da82:	bf00      	nop
 801da84:	200032a8 	.word	0x200032a8

0801da88 <osMessageQueueGet>:

osStatus_t osMessageQueueGet (osMessageQueueId_t mq_id, void *msg_ptr, uint8_t *msg_prio, uint32_t timeout) {
 801da88:	b510      	push	{r4, lr}
 801da8a:	461c      	mov	r4, r3
 801da8c:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 801da8e:	f3ef 8305 	mrs	r3, IPSR

  (void)msg_prio; /* Message priority is ignored */

  stat = osOK;

  if (IS_IRQ()) {
 801da92:	b9ab      	cbnz	r3, 801dac0 <osMessageQueueGet+0x38>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801da94:	f3ef 8310 	mrs	r3, PRIMASK
 801da98:	2b00      	cmp	r3, #0
 801da9a:	d033      	beq.n	801db04 <osMessageQueueGet+0x7c>
 801da9c:	4b21      	ldr	r3, [pc, #132]	@ (801db24 <osMessageQueueGet+0x9c>)
 801da9e:	681b      	ldr	r3, [r3, #0]
 801daa0:	2b02      	cmp	r3, #2
 801daa2:	d00d      	beq.n	801dac0 <osMessageQueueGet+0x38>
        portYIELD_FROM_ISR (yield);
      }
    }
  }
  else {
    if ((hQueue == NULL) || (msg_ptr == NULL)) {
 801daa4:	2800      	cmp	r0, #0
 801daa6:	d03a      	beq.n	801db1e <osMessageQueueGet+0x96>
 801daa8:	2900      	cmp	r1, #0
 801daaa:	d038      	beq.n	801db1e <osMessageQueueGet+0x96>
      stat = osErrorParameter;
    }
    else {
      if (xQueueReceive (hQueue, msg_ptr, (TickType_t)timeout) != pdPASS) {
 801daac:	4622      	mov	r2, r4
 801daae:	f000 fb8b 	bl	801e1c8 <xQueueReceive>
 801dab2:	2801      	cmp	r0, #1
 801dab4:	d018      	beq.n	801dae8 <osMessageQueueGet+0x60>
        if (timeout != 0U) {
 801dab6:	b374      	cbz	r4, 801db16 <osMessageQueueGet+0x8e>
          stat = osErrorTimeout;
 801dab8:	f06f 0001 	mvn.w	r0, #1
      }
    }
  }

  return (stat);
}
 801dabc:	b002      	add	sp, #8
 801dabe:	bd10      	pop	{r4, pc}
    if ((hQueue == NULL) || (msg_ptr == NULL) || (timeout != 0U)) {
 801dac0:	3c00      	subs	r4, #0
 801dac2:	bf18      	it	ne
 801dac4:	2401      	movne	r4, #1
 801dac6:	2900      	cmp	r1, #0
 801dac8:	bf08      	it	eq
 801daca:	f044 0401 	orreq.w	r4, r4, #1
 801dace:	bb34      	cbnz	r4, 801db1e <osMessageQueueGet+0x96>
 801dad0:	fab0 f380 	clz	r3, r0
 801dad4:	095b      	lsrs	r3, r3, #5
 801dad6:	b310      	cbz	r0, 801db1e <osMessageQueueGet+0x96>
      if (xQueueReceiveFromISR (hQueue, msg_ptr, &yield) != pdPASS) {
 801dad8:	aa01      	add	r2, sp, #4
      yield = pdFALSE;
 801dada:	9301      	str	r3, [sp, #4]
      if (xQueueReceiveFromISR (hQueue, msg_ptr, &yield) != pdPASS) {
 801dadc:	f000 fd02 	bl	801e4e4 <xQueueReceiveFromISR>
 801dae0:	2801      	cmp	r0, #1
 801dae2:	d118      	bne.n	801db16 <osMessageQueueGet+0x8e>
        portYIELD_FROM_ISR (yield);
 801dae4:	9b01      	ldr	r3, [sp, #4]
 801dae6:	b913      	cbnz	r3, 801daee <osMessageQueueGet+0x66>
  stat = osOK;
 801dae8:	2000      	movs	r0, #0
}
 801daea:	b002      	add	sp, #8
 801daec:	bd10      	pop	{r4, pc}
        portYIELD_FROM_ISR (yield);
 801daee:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 801daf2:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 801daf6:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 801dafa:	f3bf 8f4f 	dsb	sy
 801dafe:	f3bf 8f6f 	isb	sy
 801db02:	e7f1      	b.n	801dae8 <osMessageQueueGet+0x60>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 801db04:	f3ef 8311 	mrs	r3, BASEPRI
  if (IS_IRQ()) {
 801db08:	2b00      	cmp	r3, #0
 801db0a:	d0cb      	beq.n	801daa4 <osMessageQueueGet+0x1c>
 801db0c:	4b05      	ldr	r3, [pc, #20]	@ (801db24 <osMessageQueueGet+0x9c>)
 801db0e:	681b      	ldr	r3, [r3, #0]
 801db10:	2b02      	cmp	r3, #2
 801db12:	d1c7      	bne.n	801daa4 <osMessageQueueGet+0x1c>
 801db14:	e7d4      	b.n	801dac0 <osMessageQueueGet+0x38>
        stat = osErrorResource;
 801db16:	f06f 0002 	mvn.w	r0, #2
}
 801db1a:	b002      	add	sp, #8
 801db1c:	bd10      	pop	{r4, pc}
      stat = osErrorParameter;
 801db1e:	f06f 0003 	mvn.w	r0, #3
 801db22:	e7e2      	b.n	801daea <osMessageQueueGet+0x62>
 801db24:	200032a8 	.word	0x200032a8

0801db28 <vApplicationGetIdleTaskMemory>:
/*
  vApplicationGetIdleTaskMemory gets called when configSUPPORT_STATIC_ALLOCATION
  equals to 1 and is required for static memory allocation support.
*/
void vApplicationGetIdleTaskMemory (StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize) {
  *ppxIdleTaskTCBBuffer   = &Idle_TCB;
 801db28:	4b04      	ldr	r3, [pc, #16]	@ (801db3c <vApplicationGetIdleTaskMemory+0x14>)
void vApplicationGetIdleTaskMemory (StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize) {
 801db2a:	b410      	push	{r4}
  *ppxIdleTaskTCBBuffer   = &Idle_TCB;
 801db2c:	6003      	str	r3, [r0, #0]
  *ppxIdleTaskStackBuffer = &Idle_Stack[0];
  *pulIdleTaskStackSize   = (uint32_t)configMINIMAL_STACK_SIZE;
 801db2e:	2380      	movs	r3, #128	@ 0x80
  *ppxIdleTaskStackBuffer = &Idle_Stack[0];
 801db30:	4c03      	ldr	r4, [pc, #12]	@ (801db40 <vApplicationGetIdleTaskMemory+0x18>)
 801db32:	600c      	str	r4, [r1, #0]
}
 801db34:	f85d 4b04 	ldr.w	r4, [sp], #4
  *pulIdleTaskStackSize   = (uint32_t)configMINIMAL_STACK_SIZE;
 801db38:	6013      	str	r3, [r2, #0]
}
 801db3a:	4770      	bx	lr
 801db3c:	20003248 	.word	0x20003248
 801db40:	20003048 	.word	0x20003048

0801db44 <vApplicationGetTimerTaskMemory>:
/*
  vApplicationGetTimerTaskMemory gets called when configSUPPORT_STATIC_ALLOCATION
  equals to 1 and is required for static memory allocation support.
*/
void vApplicationGetTimerTaskMemory (StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize) {
  *ppxTimerTaskTCBBuffer   = &Timer_TCB;
 801db44:	4b05      	ldr	r3, [pc, #20]	@ (801db5c <vApplicationGetTimerTaskMemory+0x18>)
void vApplicationGetTimerTaskMemory (StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize) {
 801db46:	b410      	push	{r4}
  *ppxTimerTaskTCBBuffer   = &Timer_TCB;
 801db48:	6003      	str	r3, [r0, #0]
  *ppxTimerTaskStackBuffer = &Timer_Stack[0];
  *pulTimerTaskStackSize   = (uint32_t)configTIMER_TASK_STACK_DEPTH;
 801db4a:	f44f 7380 	mov.w	r3, #256	@ 0x100
  *ppxTimerTaskStackBuffer = &Timer_Stack[0];
 801db4e:	4c04      	ldr	r4, [pc, #16]	@ (801db60 <vApplicationGetTimerTaskMemory+0x1c>)
 801db50:	600c      	str	r4, [r1, #0]
}
 801db52:	f85d 4b04 	ldr.w	r4, [sp], #4
  *pulTimerTaskStackSize   = (uint32_t)configTIMER_TASK_STACK_DEPTH;
 801db56:	6013      	str	r3, [r2, #0]
}
 801db58:	4770      	bx	lr
 801db5a:	bf00      	nop
 801db5c:	20002fe8 	.word	0x20002fe8
 801db60:	20002be8 	.word	0x20002be8

0801db64 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 801db64:	f100 0308 	add.w	r3, r0, #8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 801db68:	f04f 31ff 	mov.w	r1, #4294967295
	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 801db6c:	2200      	movs	r2, #0
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 801db6e:	6081      	str	r1, [r0, #8]
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 801db70:	6002      	str	r2, [r0, #0]
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 801db72:	6043      	str	r3, [r0, #4]
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 801db74:	e9c0 3303 	strd	r3, r3, [r0, #12]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 801db78:	4770      	bx	lr
 801db7a:	bf00      	nop

0801db7c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
 801db7c:	2300      	movs	r3, #0
 801db7e:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 801db80:	4770      	bx	lr
 801db82:	bf00      	nop

0801db84 <vListInsertEnd>:
	pxIndex->pxPrevious = pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;

	( pxList->uxNumberOfItems )++;
 801db84:	6803      	ldr	r3, [r0, #0]
ListItem_t * const pxIndex = pxList->pxIndex;
 801db86:	6842      	ldr	r2, [r0, #4]
	( pxList->uxNumberOfItems )++;
 801db88:	3301      	adds	r3, #1
{
 801db8a:	b410      	push	{r4}
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 801db8c:	6894      	ldr	r4, [r2, #8]
 801db8e:	e9c1 2401 	strd	r2, r4, [r1, #4]
	pxIndex->pxPrevious->pxNext = pxNewListItem;
 801db92:	6061      	str	r1, [r4, #4]
	pxIndex->pxPrevious = pxNewListItem;
 801db94:	6091      	str	r1, [r2, #8]
}
 801db96:	f85d 4b04 	ldr.w	r4, [sp], #4
	pxNewListItem->pxContainer = pxList;
 801db9a:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 801db9c:	6003      	str	r3, [r0, #0]
}
 801db9e:	4770      	bx	lr

0801dba0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 801dba0:	b430      	push	{r4, r5}
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 801dba2:	680d      	ldr	r5, [r1, #0]
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 801dba4:	1c6b      	adds	r3, r5, #1
 801dba6:	d010      	beq.n	801dbca <vListInsert+0x2a>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 801dba8:	f100 0308 	add.w	r3, r0, #8
 801dbac:	461c      	mov	r4, r3
 801dbae:	685b      	ldr	r3, [r3, #4]
 801dbb0:	681a      	ldr	r2, [r3, #0]
 801dbb2:	42aa      	cmp	r2, r5
 801dbb4:	d9fa      	bls.n	801dbac <vListInsert+0xc>

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;

	( pxList->uxNumberOfItems )++;
 801dbb6:	6802      	ldr	r2, [r0, #0]
	pxNewListItem->pxNext = pxIterator->pxNext;
 801dbb8:	604b      	str	r3, [r1, #4]
	( pxList->uxNumberOfItems )++;
 801dbba:	3201      	adds	r2, #1
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 801dbbc:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
 801dbbe:	608c      	str	r4, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 801dbc0:	6061      	str	r1, [r4, #4]
	pxNewListItem->pxContainer = pxList;
 801dbc2:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 801dbc4:	6002      	str	r2, [r0, #0]
}
 801dbc6:	bc30      	pop	{r4, r5}
 801dbc8:	4770      	bx	lr
		pxIterator = pxList->xListEnd.pxPrevious;
 801dbca:	6904      	ldr	r4, [r0, #16]
	pxNewListItem->pxNext = pxIterator->pxNext;
 801dbcc:	6863      	ldr	r3, [r4, #4]
 801dbce:	e7f2      	b.n	801dbb6 <vListInsert+0x16>

0801dbd0 <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
 801dbd0:	6903      	ldr	r3, [r0, #16]
{
 801dbd2:	b410      	push	{r4}

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 801dbd4:	685c      	ldr	r4, [r3, #4]
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 801dbd6:	e9d0 1201 	ldrd	r1, r2, [r0, #4]
	if( pxList->pxIndex == pxItemToRemove )
 801dbda:	4284      	cmp	r4, r0

	pxItemToRemove->pxContainer = NULL;
	( pxList->uxNumberOfItems )--;

	return pxList->uxNumberOfItems;
}
 801dbdc:	f85d 4b04 	ldr.w	r4, [sp], #4
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 801dbe0:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 801dbe2:	6051      	str	r1, [r2, #4]
	pxItemToRemove->pxContainer = NULL;
 801dbe4:	f04f 0100 	mov.w	r1, #0
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 801dbe8:	bf08      	it	eq
 801dbea:	605a      	streq	r2, [r3, #4]
	( pxList->uxNumberOfItems )--;
 801dbec:	681a      	ldr	r2, [r3, #0]
	pxItemToRemove->pxContainer = NULL;
 801dbee:	6101      	str	r1, [r0, #16]
	( pxList->uxNumberOfItems )--;
 801dbf0:	3a01      	subs	r2, #1
 801dbf2:	601a      	str	r2, [r3, #0]
	return pxList->uxNumberOfItems;
 801dbf4:	6818      	ldr	r0, [r3, #0]
}
 801dbf6:	4770      	bx	lr

0801dbf8 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
 801dbf8:	b570      	push	{r4, r5, r6, lr}
 801dbfa:	4616      	mov	r6, r2

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 801dbfc:	6c02      	ldr	r2, [r0, #64]	@ 0x40
{
 801dbfe:	4604      	mov	r4, r0
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 801dc00:	6b85      	ldr	r5, [r0, #56]	@ 0x38
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 801dc02:	b92a      	cbnz	r2, 801dc10 <prvCopyDataToQueue+0x18>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 801dc04:	6806      	ldr	r6, [r0, #0]
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 801dc06:	3501      	adds	r5, #1
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 801dc08:	b34e      	cbz	r6, 801dc5e <prvCopyDataToQueue+0x66>
BaseType_t xReturn = pdFALSE;
 801dc0a:	4610      	mov	r0, r2
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 801dc0c:	63a5      	str	r5, [r4, #56]	@ 0x38

	return xReturn;
}
 801dc0e:	bd70      	pop	{r4, r5, r6, pc}
	else if( xPosition == queueSEND_TO_BACK )
 801dc10:	b97e      	cbnz	r6, 801dc32 <prvCopyDataToQueue+0x3a>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 801dc12:	6840      	ldr	r0, [r0, #4]
 801dc14:	f015 fac7 	bl	80331a6 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 801dc18:	6863      	ldr	r3, [r4, #4]
 801dc1a:	6c21      	ldr	r1, [r4, #64]	@ 0x40
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 801dc1c:	68a2      	ldr	r2, [r4, #8]
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 801dc1e:	440b      	add	r3, r1
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 801dc20:	4293      	cmp	r3, r2
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 801dc22:	6063      	str	r3, [r4, #4]
			pxQueue->pcWriteTo = pxQueue->pcHead;
 801dc24:	bf24      	itt	cs
 801dc26:	6823      	ldrcs	r3, [r4, #0]
 801dc28:	6063      	strcs	r3, [r4, #4]
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 801dc2a:	3501      	adds	r5, #1
BaseType_t xReturn = pdFALSE;
 801dc2c:	2000      	movs	r0, #0
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 801dc2e:	63a5      	str	r5, [r4, #56]	@ 0x38
}
 801dc30:	bd70      	pop	{r4, r5, r6, pc}
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
 801dc32:	68c0      	ldr	r0, [r0, #12]
 801dc34:	f015 fab7 	bl	80331a6 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 801dc38:	6c22      	ldr	r2, [r4, #64]	@ 0x40
 801dc3a:	68e3      	ldr	r3, [r4, #12]
 801dc3c:	4251      	negs	r1, r2
 801dc3e:	1a9b      	subs	r3, r3, r2
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 801dc40:	6822      	ldr	r2, [r4, #0]
 801dc42:	4293      	cmp	r3, r2
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 801dc44:	60e3      	str	r3, [r4, #12]
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 801dc46:	d202      	bcs.n	801dc4e <prvCopyDataToQueue+0x56>
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
 801dc48:	68a3      	ldr	r3, [r4, #8]
 801dc4a:	440b      	add	r3, r1
 801dc4c:	60e3      	str	r3, [r4, #12]
		if( xPosition == queueOVERWRITE )
 801dc4e:	2e02      	cmp	r6, #2
 801dc50:	d1eb      	bne.n	801dc2a <prvCopyDataToQueue+0x32>
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 801dc52:	2d01      	cmp	r5, #1
BaseType_t xReturn = pdFALSE;
 801dc54:	f04f 0000 	mov.w	r0, #0
 801dc58:	bf38      	it	cc
 801dc5a:	2501      	movcc	r5, #1
 801dc5c:	e7d6      	b.n	801dc0c <prvCopyDataToQueue+0x14>
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
 801dc5e:	6880      	ldr	r0, [r0, #8]
 801dc60:	f001 fb54 	bl	801f30c <xTaskPriorityDisinherit>
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
 801dc64:	60a6      	str	r6, [r4, #8]
 801dc66:	e7d1      	b.n	801dc0c <prvCopyDataToQueue+0x14>

0801dc68 <xQueueGenericCreateStatic>:
	{
 801dc68:	b530      	push	{r4, r5, lr}
 801dc6a:	b083      	sub	sp, #12
 801dc6c:	f89d 5018 	ldrb.w	r5, [sp, #24]
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 801dc70:	b950      	cbnz	r0, 801dc88 <xQueueGenericCreateStatic+0x20>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 801dc72:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801dc76:	b672      	cpsid	i
 801dc78:	f383 8811 	msr	BASEPRI, r3
 801dc7c:	f3bf 8f6f 	isb	sy
 801dc80:	f3bf 8f4f 	dsb	sy
 801dc84:	b662      	cpsie	i
 801dc86:	e7fe      	b.n	801dc86 <xQueueGenericCreateStatic+0x1e>
		configASSERT( pxStaticQueue != NULL );
 801dc88:	461c      	mov	r4, r3
 801dc8a:	b163      	cbz	r3, 801dca6 <xQueueGenericCreateStatic+0x3e>
		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
 801dc8c:	b33a      	cbz	r2, 801dcde <xQueueGenericCreateStatic+0x76>
 801dc8e:	b9a9      	cbnz	r1, 801dcbc <xQueueGenericCreateStatic+0x54>
 801dc90:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801dc94:	b672      	cpsid	i
 801dc96:	f383 8811 	msr	BASEPRI, r3
 801dc9a:	f3bf 8f6f 	isb	sy
 801dc9e:	f3bf 8f4f 	dsb	sy
 801dca2:	b662      	cpsie	i
 801dca4:	e7fe      	b.n	801dca4 <xQueueGenericCreateStatic+0x3c>
 801dca6:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801dcaa:	b672      	cpsid	i
 801dcac:	f383 8811 	msr	BASEPRI, r3
 801dcb0:	f3bf 8f6f 	isb	sy
 801dcb4:	f3bf 8f4f 	dsb	sy
 801dcb8:	b662      	cpsie	i
		configASSERT( pxStaticQueue != NULL );
 801dcba:	e7fe      	b.n	801dcba <xQueueGenericCreateStatic+0x52>
		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
 801dcbc:	b17a      	cbz	r2, 801dcde <xQueueGenericCreateStatic+0x76>
			volatile size_t xSize = sizeof( StaticQueue_t );
 801dcbe:	2350      	movs	r3, #80	@ 0x50
 801dcc0:	9301      	str	r3, [sp, #4]
			configASSERT( xSize == sizeof( Queue_t ) );
 801dcc2:	9b01      	ldr	r3, [sp, #4]
 801dcc4:	2b50      	cmp	r3, #80	@ 0x50
 801dcc6:	d017      	beq.n	801dcf8 <xQueueGenericCreateStatic+0x90>
 801dcc8:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801dccc:	b672      	cpsid	i
 801dcce:	f383 8811 	msr	BASEPRI, r3
 801dcd2:	f3bf 8f6f 	isb	sy
 801dcd6:	f3bf 8f4f 	dsb	sy
 801dcda:	b662      	cpsie	i
 801dcdc:	e7fe      	b.n	801dcdc <xQueueGenericCreateStatic+0x74>
		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
 801dcde:	2900      	cmp	r1, #0
 801dce0:	d0ed      	beq.n	801dcbe <xQueueGenericCreateStatic+0x56>
 801dce2:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801dce6:	b672      	cpsid	i
 801dce8:	f383 8811 	msr	BASEPRI, r3
 801dcec:	f3bf 8f6f 	isb	sy
 801dcf0:	f3bf 8f4f 	dsb	sy
 801dcf4:	b662      	cpsie	i
 801dcf6:	e7fe      	b.n	801dcf6 <xQueueGenericCreateStatic+0x8e>
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 801dcf8:	2900      	cmp	r1, #0
 801dcfa:	bf08      	it	eq
 801dcfc:	4622      	moveq	r2, r4
			( void ) xSize; /* Keeps lint quiet when configASSERT() is not defined. */
 801dcfe:	9b01      	ldr	r3, [sp, #4]
				pxNewQueue->ucStaticallyAllocated = pdTRUE;
 801dd00:	2301      	movs	r3, #1
	pxNewQueue->uxLength = uxQueueLength;
 801dd02:	63e0      	str	r0, [r4, #60]	@ 0x3c
 801dd04:	6022      	str	r2, [r4, #0]
	pxNewQueue->uxItemSize = uxItemSize;
 801dd06:	6421      	str	r1, [r4, #64]	@ 0x40
				pxNewQueue->ucStaticallyAllocated = pdTRUE;
 801dd08:	f884 3046 	strb.w	r3, [r4, #70]	@ 0x46
	taskENTER_CRITICAL();
 801dd0c:	f001 fdb2 	bl	801f874 <vPortEnterCritical>
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 801dd10:	6822      	ldr	r2, [r4, #0]
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 801dd12:	f104 0010 	add.w	r0, r4, #16
		pxQueue->pcWriteTo = pxQueue->pcHead;
 801dd16:	6062      	str	r2, [r4, #4]
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 801dd18:	e9d4 310f 	ldrd	r3, r1, [r4, #60]	@ 0x3c
 801dd1c:	fb01 f303 	mul.w	r3, r1, r3
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 801dd20:	1a59      	subs	r1, r3, r1
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 801dd22:	4413      	add	r3, r2
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 801dd24:	440a      	add	r2, r1
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 801dd26:	60a3      	str	r3, [r4, #8]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 801dd28:	2100      	movs	r1, #0
		pxQueue->cRxLock = queueUNLOCKED;
 801dd2a:	23ff      	movs	r3, #255	@ 0xff
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 801dd2c:	60e2      	str	r2, [r4, #12]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 801dd2e:	63a1      	str	r1, [r4, #56]	@ 0x38
		pxQueue->cRxLock = queueUNLOCKED;
 801dd30:	f884 3044 	strb.w	r3, [r4, #68]	@ 0x44
		pxQueue->cTxLock = queueUNLOCKED;
 801dd34:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 801dd38:	f7ff ff14 	bl	801db64 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 801dd3c:	f104 0024 	add.w	r0, r4, #36	@ 0x24
 801dd40:	f7ff ff10 	bl	801db64 <vListInitialise>
	taskEXIT_CRITICAL();
 801dd44:	f001 fdbc 	bl	801f8c0 <vPortExitCritical>
	}
 801dd48:	4620      	mov	r0, r4
		pxNewQueue->ucQueueType = ucQueueType;
 801dd4a:	f884 504c 	strb.w	r5, [r4, #76]	@ 0x4c
	}
 801dd4e:	b003      	add	sp, #12
 801dd50:	bd30      	pop	{r4, r5, pc}
 801dd52:	bf00      	nop

0801dd54 <xQueueGenericCreate>:
	{
 801dd54:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 801dd56:	b950      	cbnz	r0, 801dd6e <xQueueGenericCreate+0x1a>
 801dd58:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801dd5c:	b672      	cpsid	i
 801dd5e:	f383 8811 	msr	BASEPRI, r3
 801dd62:	f3bf 8f6f 	isb	sy
 801dd66:	f3bf 8f4f 	dsb	sy
 801dd6a:	b662      	cpsie	i
 801dd6c:	e7fe      	b.n	801dd6c <xQueueGenericCreate+0x18>
 801dd6e:	4605      	mov	r5, r0
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 801dd70:	fb01 f000 	mul.w	r0, r1, r0
 801dd74:	460e      	mov	r6, r1
 801dd76:	4617      	mov	r7, r2
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
 801dd78:	3050      	adds	r0, #80	@ 0x50
 801dd7a:	f001 fecd 	bl	801fb18 <pvPortMalloc>
		if( pxNewQueue != NULL )
 801dd7e:	4604      	mov	r4, r0
 801dd80:	b340      	cbz	r0, 801ddd4 <xQueueGenericCreate+0x80>
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
 801dd82:	2300      	movs	r3, #0
 801dd84:	f880 3046 	strb.w	r3, [r0, #70]	@ 0x46
	if( uxItemSize == ( UBaseType_t ) 0 )
 801dd88:	b336      	cbz	r6, 801ddd8 <xQueueGenericCreate+0x84>
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 801dd8a:	f100 0350 	add.w	r3, r0, #80	@ 0x50
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 801dd8e:	6023      	str	r3, [r4, #0]
	pxNewQueue->uxItemSize = uxItemSize;
 801dd90:	e9c4 560f 	strd	r5, r6, [r4, #60]	@ 0x3c
	taskENTER_CRITICAL();
 801dd94:	f001 fd6e 	bl	801f874 <vPortEnterCritical>
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 801dd98:	6822      	ldr	r2, [r4, #0]
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 801dd9a:	f104 0010 	add.w	r0, r4, #16
		pxQueue->pcWriteTo = pxQueue->pcHead;
 801dd9e:	6062      	str	r2, [r4, #4]
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 801dda0:	e9d4 310f 	ldrd	r3, r1, [r4, #60]	@ 0x3c
 801dda4:	fb01 f303 	mul.w	r3, r1, r3
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 801dda8:	1a59      	subs	r1, r3, r1
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 801ddaa:	4413      	add	r3, r2
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 801ddac:	440a      	add	r2, r1
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 801ddae:	60a3      	str	r3, [r4, #8]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 801ddb0:	2100      	movs	r1, #0
		pxQueue->cRxLock = queueUNLOCKED;
 801ddb2:	23ff      	movs	r3, #255	@ 0xff
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 801ddb4:	60e2      	str	r2, [r4, #12]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 801ddb6:	63a1      	str	r1, [r4, #56]	@ 0x38
		pxQueue->cRxLock = queueUNLOCKED;
 801ddb8:	f884 3044 	strb.w	r3, [r4, #68]	@ 0x44
		pxQueue->cTxLock = queueUNLOCKED;
 801ddbc:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 801ddc0:	f7ff fed0 	bl	801db64 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 801ddc4:	f104 0024 	add.w	r0, r4, #36	@ 0x24
 801ddc8:	f7ff fecc 	bl	801db64 <vListInitialise>
	taskEXIT_CRITICAL();
 801ddcc:	f001 fd78 	bl	801f8c0 <vPortExitCritical>
		pxNewQueue->ucQueueType = ucQueueType;
 801ddd0:	f884 704c 	strb.w	r7, [r4, #76]	@ 0x4c
	}
 801ddd4:	4620      	mov	r0, r4
 801ddd6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 801ddd8:	4603      	mov	r3, r0
 801ddda:	e7d8      	b.n	801dd8e <xQueueGenericCreate+0x3a>

0801dddc <xQueueGenericSend>:
{
 801dddc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 801dde0:	b084      	sub	sp, #16
 801dde2:	9201      	str	r2, [sp, #4]
	configASSERT( pxQueue );
 801dde4:	2800      	cmp	r0, #0
 801dde6:	f000 8107 	beq.w	801dff8 <xQueueGenericSend+0x21c>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 801ddea:	4688      	mov	r8, r1
 801ddec:	4604      	mov	r4, r0
 801ddee:	461f      	mov	r7, r3
 801ddf0:	2900      	cmp	r1, #0
 801ddf2:	f000 8099 	beq.w	801df28 <xQueueGenericSend+0x14c>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 801ddf6:	2f02      	cmp	r7, #2
 801ddf8:	d10d      	bne.n	801de16 <xQueueGenericSend+0x3a>
 801ddfa:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 801ddfc:	2b01      	cmp	r3, #1
 801ddfe:	d00a      	beq.n	801de16 <xQueueGenericSend+0x3a>
 801de00:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801de04:	b672      	cpsid	i
 801de06:	f383 8811 	msr	BASEPRI, r3
 801de0a:	f3bf 8f6f 	isb	sy
 801de0e:	f3bf 8f4f 	dsb	sy
 801de12:	b662      	cpsie	i
 801de14:	e7fe      	b.n	801de14 <xQueueGenericSend+0x38>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 801de16:	f001 fa69 	bl	801f2ec <xTaskGetSchedulerState>
 801de1a:	2800      	cmp	r0, #0
 801de1c:	f000 80f7 	beq.w	801e00e <xQueueGenericSend+0x232>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 801de20:	f1a7 0902 	sub.w	r9, r7, #2
 801de24:	2500      	movs	r5, #0
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 801de26:	f104 0624 	add.w	r6, r4, #36	@ 0x24
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 801de2a:	fab9 f989 	clz	r9, r9
 801de2e:	ea4f 1959 	mov.w	r9, r9, lsr #5
		taskENTER_CRITICAL();
 801de32:	f001 fd1f 	bl	801f874 <vPortEnterCritical>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 801de36:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
 801de38:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 801de3a:	429a      	cmp	r2, r3
 801de3c:	f0c0 80f6 	bcc.w	801e02c <xQueueGenericSend+0x250>
 801de40:	f1b9 0f00 	cmp.w	r9, #0
 801de44:	f040 80f2 	bne.w	801e02c <xQueueGenericSend+0x250>
				if( xTicksToWait == ( TickType_t ) 0 )
 801de48:	9b01      	ldr	r3, [sp, #4]
 801de4a:	2b00      	cmp	r3, #0
 801de4c:	f000 8107 	beq.w	801e05e <xQueueGenericSend+0x282>
				else if( xEntryTimeSet == pdFALSE )
 801de50:	2d00      	cmp	r5, #0
 801de52:	f000 80cd 	beq.w	801dff0 <xQueueGenericSend+0x214>
		taskEXIT_CRITICAL();
 801de56:	f001 fd33 	bl	801f8c0 <vPortExitCritical>
		vTaskSuspendAll();
 801de5a:	f000 ff3f 	bl	801ecdc <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 801de5e:	f001 fd09 	bl	801f874 <vPortEnterCritical>
 801de62:	f894 3044 	ldrb.w	r3, [r4, #68]	@ 0x44
 801de66:	2bff      	cmp	r3, #255	@ 0xff
 801de68:	d102      	bne.n	801de70 <xQueueGenericSend+0x94>
 801de6a:	2300      	movs	r3, #0
 801de6c:	f884 3044 	strb.w	r3, [r4, #68]	@ 0x44
 801de70:	f894 3045 	ldrb.w	r3, [r4, #69]	@ 0x45
 801de74:	2bff      	cmp	r3, #255	@ 0xff
 801de76:	d102      	bne.n	801de7e <xQueueGenericSend+0xa2>
 801de78:	2300      	movs	r3, #0
 801de7a:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
 801de7e:	f001 fd1f 	bl	801f8c0 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 801de82:	a901      	add	r1, sp, #4
 801de84:	a802      	add	r0, sp, #8
 801de86:	f001 f9e5 	bl	801f254 <xTaskCheckForTimeOut>
 801de8a:	2800      	cmp	r0, #0
 801de8c:	f040 80eb 	bne.w	801e066 <xQueueGenericSend+0x28a>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
 801de90:	f001 fcf0 	bl	801f874 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 801de94:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
 801de96:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 801de98:	429a      	cmp	r2, r3
 801de9a:	d054      	beq.n	801df46 <xQueueGenericSend+0x16a>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 801de9c:	f001 fd10 	bl	801f8c0 <vPortExitCritical>
	taskENTER_CRITICAL();
 801dea0:	f001 fce8 	bl	801f874 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 801dea4:	f894 2045 	ldrb.w	r2, [r4, #69]	@ 0x45
 801dea8:	b255      	sxtb	r5, r2
		while( cTxLock > queueLOCKED_UNMODIFIED )
 801deaa:	2d00      	cmp	r5, #0
 801deac:	dc04      	bgt.n	801deb8 <xQueueGenericSend+0xdc>
 801deae:	e011      	b.n	801ded4 <xQueueGenericSend+0xf8>
			--cTxLock;
 801deb0:	1e6a      	subs	r2, r5, #1
 801deb2:	b2d3      	uxtb	r3, r2
 801deb4:	b255      	sxtb	r5, r2
		while( cTxLock > queueLOCKED_UNMODIFIED )
 801deb6:	b16b      	cbz	r3, 801ded4 <xQueueGenericSend+0xf8>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 801deb8:	6a63      	ldr	r3, [r4, #36]	@ 0x24
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 801deba:	4630      	mov	r0, r6
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 801debc:	b153      	cbz	r3, 801ded4 <xQueueGenericSend+0xf8>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 801debe:	f001 f975 	bl	801f1ac <xTaskRemoveFromEventList>
 801dec2:	2800      	cmp	r0, #0
 801dec4:	d0f4      	beq.n	801deb0 <xQueueGenericSend+0xd4>
						vTaskMissedYield();
 801dec6:	f001 fa0b 	bl	801f2e0 <vTaskMissedYield>
			--cTxLock;
 801deca:	1e6a      	subs	r2, r5, #1
 801decc:	b2d3      	uxtb	r3, r2
 801dece:	b255      	sxtb	r5, r2
		while( cTxLock > queueLOCKED_UNMODIFIED )
 801ded0:	2b00      	cmp	r3, #0
 801ded2:	d1f1      	bne.n	801deb8 <xQueueGenericSend+0xdc>
		pxQueue->cTxLock = queueUNLOCKED;
 801ded4:	23ff      	movs	r3, #255	@ 0xff
 801ded6:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
	taskEXIT_CRITICAL();
 801deda:	f001 fcf1 	bl	801f8c0 <vPortExitCritical>
	taskENTER_CRITICAL();
 801dede:	f001 fcc9 	bl	801f874 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 801dee2:	f894 2044 	ldrb.w	r2, [r4, #68]	@ 0x44
 801dee6:	b255      	sxtb	r5, r2
		while( cRxLock > queueLOCKED_UNMODIFIED )
 801dee8:	2d00      	cmp	r5, #0
 801deea:	dd14      	ble.n	801df16 <xQueueGenericSend+0x13a>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 801deec:	f104 0a10 	add.w	sl, r4, #16
 801def0:	e003      	b.n	801defa <xQueueGenericSend+0x11e>
				--cRxLock;
 801def2:	1e6a      	subs	r2, r5, #1
 801def4:	b2d3      	uxtb	r3, r2
 801def6:	b255      	sxtb	r5, r2
		while( cRxLock > queueLOCKED_UNMODIFIED )
 801def8:	b16b      	cbz	r3, 801df16 <xQueueGenericSend+0x13a>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 801defa:	6923      	ldr	r3, [r4, #16]
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 801defc:	4650      	mov	r0, sl
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 801defe:	b153      	cbz	r3, 801df16 <xQueueGenericSend+0x13a>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 801df00:	f001 f954 	bl	801f1ac <xTaskRemoveFromEventList>
 801df04:	2800      	cmp	r0, #0
 801df06:	d0f4      	beq.n	801def2 <xQueueGenericSend+0x116>
					vTaskMissedYield();
 801df08:	f001 f9ea 	bl	801f2e0 <vTaskMissedYield>
				--cRxLock;
 801df0c:	1e6a      	subs	r2, r5, #1
 801df0e:	b2d3      	uxtb	r3, r2
 801df10:	b255      	sxtb	r5, r2
		while( cRxLock > queueLOCKED_UNMODIFIED )
 801df12:	2b00      	cmp	r3, #0
 801df14:	d1f1      	bne.n	801defa <xQueueGenericSend+0x11e>
		pxQueue->cRxLock = queueUNLOCKED;
 801df16:	23ff      	movs	r3, #255	@ 0xff
 801df18:	f884 3044 	strb.w	r3, [r4, #68]	@ 0x44
	taskEXIT_CRITICAL();
 801df1c:	f001 fcd0 	bl	801f8c0 <vPortExitCritical>
				( void ) xTaskResumeAll();
 801df20:	f001 f838 	bl	801ef94 <xTaskResumeAll>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 801df24:	2501      	movs	r5, #1
 801df26:	e784      	b.n	801de32 <xQueueGenericSend+0x56>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 801df28:	6c03      	ldr	r3, [r0, #64]	@ 0x40
 801df2a:	2b00      	cmp	r3, #0
 801df2c:	f43f af63 	beq.w	801ddf6 <xQueueGenericSend+0x1a>
 801df30:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801df34:	b672      	cpsid	i
 801df36:	f383 8811 	msr	BASEPRI, r3
 801df3a:	f3bf 8f6f 	isb	sy
 801df3e:	f3bf 8f4f 	dsb	sy
 801df42:	b662      	cpsie	i
 801df44:	e7fe      	b.n	801df44 <xQueueGenericSend+0x168>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 801df46:	f104 0a10 	add.w	sl, r4, #16
	taskEXIT_CRITICAL();
 801df4a:	f001 fcb9 	bl	801f8c0 <vPortExitCritical>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 801df4e:	9901      	ldr	r1, [sp, #4]
 801df50:	4650      	mov	r0, sl
 801df52:	f001 f899 	bl	801f088 <vTaskPlaceOnEventList>
	taskENTER_CRITICAL();
 801df56:	f001 fc8d 	bl	801f874 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 801df5a:	f894 3045 	ldrb.w	r3, [r4, #69]	@ 0x45
 801df5e:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 801df60:	2d00      	cmp	r5, #0
 801df62:	dc04      	bgt.n	801df6e <xQueueGenericSend+0x192>
 801df64:	e011      	b.n	801df8a <xQueueGenericSend+0x1ae>
			--cTxLock;
 801df66:	1e6b      	subs	r3, r5, #1
 801df68:	b2da      	uxtb	r2, r3
 801df6a:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 801df6c:	b16a      	cbz	r2, 801df8a <xQueueGenericSend+0x1ae>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 801df6e:	6a63      	ldr	r3, [r4, #36]	@ 0x24
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 801df70:	4630      	mov	r0, r6
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 801df72:	b153      	cbz	r3, 801df8a <xQueueGenericSend+0x1ae>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 801df74:	f001 f91a 	bl	801f1ac <xTaskRemoveFromEventList>
 801df78:	2800      	cmp	r0, #0
 801df7a:	d0f4      	beq.n	801df66 <xQueueGenericSend+0x18a>
						vTaskMissedYield();
 801df7c:	f001 f9b0 	bl	801f2e0 <vTaskMissedYield>
			--cTxLock;
 801df80:	1e6b      	subs	r3, r5, #1
 801df82:	b2da      	uxtb	r2, r3
 801df84:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 801df86:	2a00      	cmp	r2, #0
 801df88:	d1f1      	bne.n	801df6e <xQueueGenericSend+0x192>
		pxQueue->cTxLock = queueUNLOCKED;
 801df8a:	23ff      	movs	r3, #255	@ 0xff
 801df8c:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
	taskEXIT_CRITICAL();
 801df90:	f001 fc96 	bl	801f8c0 <vPortExitCritical>
	taskENTER_CRITICAL();
 801df94:	f001 fc6e 	bl	801f874 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 801df98:	f894 3044 	ldrb.w	r3, [r4, #68]	@ 0x44
 801df9c:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 801df9e:	2d00      	cmp	r5, #0
 801dfa0:	dc04      	bgt.n	801dfac <xQueueGenericSend+0x1d0>
 801dfa2:	e011      	b.n	801dfc8 <xQueueGenericSend+0x1ec>
				--cRxLock;
 801dfa4:	1e6b      	subs	r3, r5, #1
 801dfa6:	b2da      	uxtb	r2, r3
 801dfa8:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 801dfaa:	b16a      	cbz	r2, 801dfc8 <xQueueGenericSend+0x1ec>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 801dfac:	6923      	ldr	r3, [r4, #16]
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 801dfae:	4650      	mov	r0, sl
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 801dfb0:	b153      	cbz	r3, 801dfc8 <xQueueGenericSend+0x1ec>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 801dfb2:	f001 f8fb 	bl	801f1ac <xTaskRemoveFromEventList>
 801dfb6:	2800      	cmp	r0, #0
 801dfb8:	d0f4      	beq.n	801dfa4 <xQueueGenericSend+0x1c8>
					vTaskMissedYield();
 801dfba:	f001 f991 	bl	801f2e0 <vTaskMissedYield>
				--cRxLock;
 801dfbe:	1e6b      	subs	r3, r5, #1
 801dfc0:	b2da      	uxtb	r2, r3
 801dfc2:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 801dfc4:	2a00      	cmp	r2, #0
 801dfc6:	d1f1      	bne.n	801dfac <xQueueGenericSend+0x1d0>
		pxQueue->cRxLock = queueUNLOCKED;
 801dfc8:	23ff      	movs	r3, #255	@ 0xff
 801dfca:	f884 3044 	strb.w	r3, [r4, #68]	@ 0x44
	taskEXIT_CRITICAL();
 801dfce:	f001 fc77 	bl	801f8c0 <vPortExitCritical>
				if( xTaskResumeAll() == pdFALSE )
 801dfd2:	f000 ffdf 	bl	801ef94 <xTaskResumeAll>
 801dfd6:	2800      	cmp	r0, #0
 801dfd8:	d1a4      	bne.n	801df24 <xQueueGenericSend+0x148>
					portYIELD_WITHIN_API();
 801dfda:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 801dfde:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 801dfe2:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 801dfe6:	f3bf 8f4f 	dsb	sy
 801dfea:	f3bf 8f6f 	isb	sy
 801dfee:	e799      	b.n	801df24 <xQueueGenericSend+0x148>
					vTaskInternalSetTimeOutState( &xTimeOut );
 801dff0:	a802      	add	r0, sp, #8
 801dff2:	f001 f923 	bl	801f23c <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 801dff6:	e72e      	b.n	801de56 <xQueueGenericSend+0x7a>
 801dff8:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801dffc:	b672      	cpsid	i
 801dffe:	f383 8811 	msr	BASEPRI, r3
 801e002:	f3bf 8f6f 	isb	sy
 801e006:	f3bf 8f4f 	dsb	sy
 801e00a:	b662      	cpsie	i
	configASSERT( pxQueue );
 801e00c:	e7fe      	b.n	801e00c <xQueueGenericSend+0x230>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 801e00e:	9b01      	ldr	r3, [sp, #4]
 801e010:	2b00      	cmp	r3, #0
 801e012:	f43f af05 	beq.w	801de20 <xQueueGenericSend+0x44>
 801e016:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801e01a:	b672      	cpsid	i
 801e01c:	f383 8811 	msr	BASEPRI, r3
 801e020:	f3bf 8f6f 	isb	sy
 801e024:	f3bf 8f4f 	dsb	sy
 801e028:	b662      	cpsie	i
 801e02a:	e7fe      	b.n	801e02a <xQueueGenericSend+0x24e>
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 801e02c:	463a      	mov	r2, r7
 801e02e:	4641      	mov	r1, r8
 801e030:	4620      	mov	r0, r4
 801e032:	f7ff fde1 	bl	801dbf8 <prvCopyDataToQueue>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 801e036:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 801e038:	2b00      	cmp	r3, #0
 801e03a:	d151      	bne.n	801e0e0 <xQueueGenericSend+0x304>
					else if( xYieldRequired != pdFALSE )
 801e03c:	b148      	cbz	r0, 801e052 <xQueueGenericSend+0x276>
						queueYIELD_IF_USING_PREEMPTION();
 801e03e:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 801e042:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 801e046:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 801e04a:	f3bf 8f4f 	dsb	sy
 801e04e:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
 801e052:	f001 fc35 	bl	801f8c0 <vPortExitCritical>
				return pdPASS;
 801e056:	2001      	movs	r0, #1
}
 801e058:	b004      	add	sp, #16
 801e05a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
					taskEXIT_CRITICAL();
 801e05e:	f001 fc2f 	bl	801f8c0 <vPortExitCritical>
					return errQUEUE_FULL;
 801e062:	2000      	movs	r0, #0
 801e064:	e7f8      	b.n	801e058 <xQueueGenericSend+0x27c>
	taskENTER_CRITICAL();
 801e066:	f001 fc05 	bl	801f874 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 801e06a:	f894 3045 	ldrb.w	r3, [r4, #69]	@ 0x45
 801e06e:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 801e070:	2d00      	cmp	r5, #0
 801e072:	dd10      	ble.n	801e096 <xQueueGenericSend+0x2ba>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 801e074:	f104 0624 	add.w	r6, r4, #36	@ 0x24
 801e078:	e003      	b.n	801e082 <xQueueGenericSend+0x2a6>
			--cTxLock;
 801e07a:	1e6b      	subs	r3, r5, #1
 801e07c:	b2da      	uxtb	r2, r3
 801e07e:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 801e080:	b14a      	cbz	r2, 801e096 <xQueueGenericSend+0x2ba>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 801e082:	6a63      	ldr	r3, [r4, #36]	@ 0x24
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 801e084:	4630      	mov	r0, r6
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 801e086:	b133      	cbz	r3, 801e096 <xQueueGenericSend+0x2ba>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 801e088:	f001 f890 	bl	801f1ac <xTaskRemoveFromEventList>
 801e08c:	2800      	cmp	r0, #0
 801e08e:	d0f4      	beq.n	801e07a <xQueueGenericSend+0x29e>
						vTaskMissedYield();
 801e090:	f001 f926 	bl	801f2e0 <vTaskMissedYield>
 801e094:	e7f1      	b.n	801e07a <xQueueGenericSend+0x29e>
		pxQueue->cTxLock = queueUNLOCKED;
 801e096:	23ff      	movs	r3, #255	@ 0xff
 801e098:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
	taskEXIT_CRITICAL();
 801e09c:	f001 fc10 	bl	801f8c0 <vPortExitCritical>
	taskENTER_CRITICAL();
 801e0a0:	f001 fbe8 	bl	801f874 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 801e0a4:	f894 3044 	ldrb.w	r3, [r4, #68]	@ 0x44
 801e0a8:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 801e0aa:	2d00      	cmp	r5, #0
 801e0ac:	dd10      	ble.n	801e0d0 <xQueueGenericSend+0x2f4>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 801e0ae:	f104 0610 	add.w	r6, r4, #16
 801e0b2:	e003      	b.n	801e0bc <xQueueGenericSend+0x2e0>
				--cRxLock;
 801e0b4:	1e6b      	subs	r3, r5, #1
 801e0b6:	b2da      	uxtb	r2, r3
 801e0b8:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 801e0ba:	b14a      	cbz	r2, 801e0d0 <xQueueGenericSend+0x2f4>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 801e0bc:	6923      	ldr	r3, [r4, #16]
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 801e0be:	4630      	mov	r0, r6
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 801e0c0:	b133      	cbz	r3, 801e0d0 <xQueueGenericSend+0x2f4>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 801e0c2:	f001 f873 	bl	801f1ac <xTaskRemoveFromEventList>
 801e0c6:	2800      	cmp	r0, #0
 801e0c8:	d0f4      	beq.n	801e0b4 <xQueueGenericSend+0x2d8>
					vTaskMissedYield();
 801e0ca:	f001 f909 	bl	801f2e0 <vTaskMissedYield>
 801e0ce:	e7f1      	b.n	801e0b4 <xQueueGenericSend+0x2d8>
		pxQueue->cRxLock = queueUNLOCKED;
 801e0d0:	23ff      	movs	r3, #255	@ 0xff
 801e0d2:	f884 3044 	strb.w	r3, [r4, #68]	@ 0x44
	taskEXIT_CRITICAL();
 801e0d6:	f001 fbf3 	bl	801f8c0 <vPortExitCritical>
			( void ) xTaskResumeAll();
 801e0da:	f000 ff5b 	bl	801ef94 <xTaskResumeAll>
			return errQUEUE_FULL;
 801e0de:	e7c0      	b.n	801e062 <xQueueGenericSend+0x286>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 801e0e0:	f104 0024 	add.w	r0, r4, #36	@ 0x24
 801e0e4:	f001 f862 	bl	801f1ac <xTaskRemoveFromEventList>
 801e0e8:	2800      	cmp	r0, #0
 801e0ea:	d0b2      	beq.n	801e052 <xQueueGenericSend+0x276>
 801e0ec:	e7a7      	b.n	801e03e <xQueueGenericSend+0x262>
 801e0ee:	bf00      	nop

0801e0f0 <xQueueGenericSendFromISR>:
	configASSERT( pxQueue );
 801e0f0:	2800      	cmp	r0, #0
 801e0f2:	d050      	beq.n	801e196 <xQueueGenericSendFromISR+0xa6>
{
 801e0f4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801e0f8:	460e      	mov	r6, r1
 801e0fa:	4604      	mov	r4, r0
 801e0fc:	4617      	mov	r7, r2
 801e0fe:	461d      	mov	r5, r3
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 801e100:	b359      	cbz	r1, 801e15a <xQueueGenericSendFromISR+0x6a>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 801e102:	2d02      	cmp	r5, #2
 801e104:	d10d      	bne.n	801e122 <xQueueGenericSendFromISR+0x32>
 801e106:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 801e108:	2b01      	cmp	r3, #1
 801e10a:	d00a      	beq.n	801e122 <xQueueGenericSendFromISR+0x32>
 801e10c:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801e110:	b672      	cpsid	i
 801e112:	f383 8811 	msr	BASEPRI, r3
 801e116:	f3bf 8f6f 	isb	sy
 801e11a:	f3bf 8f4f 	dsb	sy
 801e11e:	b662      	cpsie	i
 801e120:	e7fe      	b.n	801e120 <xQueueGenericSendFromISR+0x30>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 801e122:	f001 fcc7 	bl	801fab4 <vPortValidateInterruptPriority>

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
 801e126:	f3ef 8811 	mrs	r8, BASEPRI
 801e12a:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801e12e:	b672      	cpsid	i
 801e130:	f383 8811 	msr	BASEPRI, r3
 801e134:	f3bf 8f6f 	isb	sy
 801e138:	f3bf 8f4f 	dsb	sy
 801e13c:	b662      	cpsie	i
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 801e13e:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
 801e140:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 801e142:	429a      	cmp	r2, r3
 801e144:	d317      	bcc.n	801e176 <xQueueGenericSendFromISR+0x86>
 801e146:	f1a5 0002 	sub.w	r0, r5, #2
 801e14a:	fab0 f080 	clz	r0, r0
 801e14e:	0940      	lsrs	r0, r0, #5
 801e150:	b988      	cbnz	r0, 801e176 <xQueueGenericSendFromISR+0x86>
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 801e152:	f388 8811 	msr	BASEPRI, r8
}
 801e156:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 801e15a:	6c03      	ldr	r3, [r0, #64]	@ 0x40
 801e15c:	2b00      	cmp	r3, #0
 801e15e:	d0d0      	beq.n	801e102 <xQueueGenericSendFromISR+0x12>
	__asm volatile
 801e160:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801e164:	b672      	cpsid	i
 801e166:	f383 8811 	msr	BASEPRI, r3
 801e16a:	f3bf 8f6f 	isb	sy
 801e16e:	f3bf 8f4f 	dsb	sy
 801e172:	b662      	cpsie	i
 801e174:	e7fe      	b.n	801e174 <xQueueGenericSendFromISR+0x84>
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 801e176:	462a      	mov	r2, r5
			const int8_t cTxLock = pxQueue->cTxLock;
 801e178:	f894 5045 	ldrb.w	r5, [r4, #69]	@ 0x45
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 801e17c:	4631      	mov	r1, r6
 801e17e:	4620      	mov	r0, r4
			const int8_t cTxLock = pxQueue->cTxLock;
 801e180:	b26d      	sxtb	r5, r5
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 801e182:	f7ff fd39 	bl	801dbf8 <prvCopyDataToQueue>
			if( cTxLock == queueUNLOCKED )
 801e186:	1c6b      	adds	r3, r5, #1
 801e188:	d010      	beq.n	801e1ac <xQueueGenericSendFromISR+0xbc>
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 801e18a:	1c6b      	adds	r3, r5, #1
 801e18c:	b25b      	sxtb	r3, r3
 801e18e:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
			xReturn = pdPASS;
 801e192:	2001      	movs	r0, #1
 801e194:	e7dd      	b.n	801e152 <xQueueGenericSendFromISR+0x62>
 801e196:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801e19a:	b672      	cpsid	i
 801e19c:	f383 8811 	msr	BASEPRI, r3
 801e1a0:	f3bf 8f6f 	isb	sy
 801e1a4:	f3bf 8f4f 	dsb	sy
 801e1a8:	b662      	cpsie	i
	configASSERT( pxQueue );
 801e1aa:	e7fe      	b.n	801e1aa <xQueueGenericSendFromISR+0xba>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 801e1ac:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 801e1ae:	2b00      	cmp	r3, #0
 801e1b0:	d0ef      	beq.n	801e192 <xQueueGenericSendFromISR+0xa2>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 801e1b2:	f104 0024 	add.w	r0, r4, #36	@ 0x24
 801e1b6:	f000 fff9 	bl	801f1ac <xTaskRemoveFromEventList>
							if( pxHigherPriorityTaskWoken != NULL )
 801e1ba:	2800      	cmp	r0, #0
 801e1bc:	d0e9      	beq.n	801e192 <xQueueGenericSendFromISR+0xa2>
 801e1be:	2f00      	cmp	r7, #0
 801e1c0:	d0e7      	beq.n	801e192 <xQueueGenericSendFromISR+0xa2>
								*pxHigherPriorityTaskWoken = pdTRUE;
 801e1c2:	2301      	movs	r3, #1
 801e1c4:	603b      	str	r3, [r7, #0]
 801e1c6:	e7e4      	b.n	801e192 <xQueueGenericSendFromISR+0xa2>

0801e1c8 <xQueueReceive>:
{
 801e1c8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 801e1cc:	b085      	sub	sp, #20
 801e1ce:	9201      	str	r2, [sp, #4]
	configASSERT( ( pxQueue ) );
 801e1d0:	2800      	cmp	r0, #0
 801e1d2:	f000 816a 	beq.w	801e4aa <xQueueReceive+0x2e2>
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 801e1d6:	460f      	mov	r7, r1
 801e1d8:	4604      	mov	r4, r0
 801e1da:	2900      	cmp	r1, #0
 801e1dc:	f000 8098 	beq.w	801e310 <xQueueReceive+0x148>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 801e1e0:	f001 f884 	bl	801f2ec <xTaskGetSchedulerState>
 801e1e4:	2800      	cmp	r0, #0
 801e1e6:	f000 80a2 	beq.w	801e32e <xQueueReceive+0x166>
		taskENTER_CRITICAL();
 801e1ea:	f001 fb43 	bl	801f874 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 801e1ee:	6ba5      	ldr	r5, [r4, #56]	@ 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 801e1f0:	2d00      	cmp	r5, #0
 801e1f2:	d176      	bne.n	801e2e2 <xQueueReceive+0x11a>
				if( xTicksToWait == ( TickType_t ) 0 )
 801e1f4:	9b01      	ldr	r3, [sp, #4]
 801e1f6:	2b00      	cmp	r3, #0
 801e1f8:	f000 80fa 	beq.w	801e3f0 <xQueueReceive+0x228>
		prvLockQueue( pxQueue );
 801e1fc:	46a8      	mov	r8, r5
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 801e1fe:	f104 0624 	add.w	r6, r4, #36	@ 0x24
					vTaskInternalSetTimeOutState( &xTimeOut );
 801e202:	a802      	add	r0, sp, #8
 801e204:	f001 f81a 	bl	801f23c <vTaskInternalSetTimeOutState>
		taskEXIT_CRITICAL();
 801e208:	f001 fb5a 	bl	801f8c0 <vPortExitCritical>
		vTaskSuspendAll();
 801e20c:	f000 fd66 	bl	801ecdc <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 801e210:	f001 fb30 	bl	801f874 <vPortEnterCritical>
 801e214:	f894 3044 	ldrb.w	r3, [r4, #68]	@ 0x44
 801e218:	2bff      	cmp	r3, #255	@ 0xff
 801e21a:	d101      	bne.n	801e220 <xQueueReceive+0x58>
 801e21c:	f884 8044 	strb.w	r8, [r4, #68]	@ 0x44
 801e220:	f894 3045 	ldrb.w	r3, [r4, #69]	@ 0x45
 801e224:	2bff      	cmp	r3, #255	@ 0xff
 801e226:	d101      	bne.n	801e22c <xQueueReceive+0x64>
 801e228:	f884 8045 	strb.w	r8, [r4, #69]	@ 0x45
 801e22c:	f001 fb48 	bl	801f8c0 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 801e230:	a901      	add	r1, sp, #4
 801e232:	a802      	add	r0, sp, #8
 801e234:	f001 f80e 	bl	801f254 <xTaskCheckForTimeOut>
 801e238:	2800      	cmp	r0, #0
 801e23a:	f040 8087 	bne.w	801e34c <xQueueReceive+0x184>
	taskENTER_CRITICAL();
 801e23e:	f001 fb19 	bl	801f874 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 801e242:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 801e244:	2b00      	cmp	r3, #0
 801e246:	f000 80d9 	beq.w	801e3fc <xQueueReceive+0x234>
	taskEXIT_CRITICAL();
 801e24a:	f001 fb39 	bl	801f8c0 <vPortExitCritical>
	taskENTER_CRITICAL();
 801e24e:	f001 fb11 	bl	801f874 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 801e252:	f894 3045 	ldrb.w	r3, [r4, #69]	@ 0x45
 801e256:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 801e258:	2d00      	cmp	r5, #0
 801e25a:	dd14      	ble.n	801e286 <xQueueReceive+0xbe>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 801e25c:	f104 0924 	add.w	r9, r4, #36	@ 0x24
 801e260:	e003      	b.n	801e26a <xQueueReceive+0xa2>
			--cTxLock;
 801e262:	1e6b      	subs	r3, r5, #1
 801e264:	b2da      	uxtb	r2, r3
 801e266:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 801e268:	b16a      	cbz	r2, 801e286 <xQueueReceive+0xbe>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 801e26a:	6a63      	ldr	r3, [r4, #36]	@ 0x24
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 801e26c:	4648      	mov	r0, r9
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 801e26e:	b153      	cbz	r3, 801e286 <xQueueReceive+0xbe>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 801e270:	f000 ff9c 	bl	801f1ac <xTaskRemoveFromEventList>
 801e274:	2800      	cmp	r0, #0
 801e276:	d0f4      	beq.n	801e262 <xQueueReceive+0x9a>
						vTaskMissedYield();
 801e278:	f001 f832 	bl	801f2e0 <vTaskMissedYield>
			--cTxLock;
 801e27c:	1e6b      	subs	r3, r5, #1
 801e27e:	b2da      	uxtb	r2, r3
 801e280:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 801e282:	2a00      	cmp	r2, #0
 801e284:	d1f1      	bne.n	801e26a <xQueueReceive+0xa2>
		pxQueue->cTxLock = queueUNLOCKED;
 801e286:	23ff      	movs	r3, #255	@ 0xff
 801e288:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
	taskEXIT_CRITICAL();
 801e28c:	f001 fb18 	bl	801f8c0 <vPortExitCritical>
	taskENTER_CRITICAL();
 801e290:	f001 faf0 	bl	801f874 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 801e294:	f894 3044 	ldrb.w	r3, [r4, #68]	@ 0x44
 801e298:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 801e29a:	2d00      	cmp	r5, #0
 801e29c:	dd14      	ble.n	801e2c8 <xQueueReceive+0x100>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 801e29e:	f104 0910 	add.w	r9, r4, #16
 801e2a2:	e003      	b.n	801e2ac <xQueueReceive+0xe4>
				--cRxLock;
 801e2a4:	1e6b      	subs	r3, r5, #1
 801e2a6:	b2da      	uxtb	r2, r3
 801e2a8:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 801e2aa:	b16a      	cbz	r2, 801e2c8 <xQueueReceive+0x100>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 801e2ac:	6923      	ldr	r3, [r4, #16]
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 801e2ae:	4648      	mov	r0, r9
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 801e2b0:	b153      	cbz	r3, 801e2c8 <xQueueReceive+0x100>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 801e2b2:	f000 ff7b 	bl	801f1ac <xTaskRemoveFromEventList>
 801e2b6:	2800      	cmp	r0, #0
 801e2b8:	d0f4      	beq.n	801e2a4 <xQueueReceive+0xdc>
					vTaskMissedYield();
 801e2ba:	f001 f811 	bl	801f2e0 <vTaskMissedYield>
				--cRxLock;
 801e2be:	1e6b      	subs	r3, r5, #1
 801e2c0:	b2da      	uxtb	r2, r3
 801e2c2:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 801e2c4:	2a00      	cmp	r2, #0
 801e2c6:	d1f1      	bne.n	801e2ac <xQueueReceive+0xe4>
		pxQueue->cRxLock = queueUNLOCKED;
 801e2c8:	23ff      	movs	r3, #255	@ 0xff
 801e2ca:	f884 3044 	strb.w	r3, [r4, #68]	@ 0x44
	taskEXIT_CRITICAL();
 801e2ce:	f001 faf7 	bl	801f8c0 <vPortExitCritical>
				( void ) xTaskResumeAll();
 801e2d2:	f000 fe5f 	bl	801ef94 <xTaskResumeAll>
		taskENTER_CRITICAL();
 801e2d6:	f001 facd 	bl	801f874 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 801e2da:	6ba5      	ldr	r5, [r4, #56]	@ 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 801e2dc:	2d00      	cmp	r5, #0
 801e2de:	f000 8083 	beq.w	801e3e8 <xQueueReceive+0x220>
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 801e2e2:	6c22      	ldr	r2, [r4, #64]	@ 0x40
 801e2e4:	b152      	cbz	r2, 801e2fc <xQueueReceive+0x134>
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 801e2e6:	68e1      	ldr	r1, [r4, #12]
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 801e2e8:	68a3      	ldr	r3, [r4, #8]
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 801e2ea:	4411      	add	r1, r2
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 801e2ec:	4299      	cmp	r1, r3
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 801e2ee:	60e1      	str	r1, [r4, #12]
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 801e2f0:	d301      	bcc.n	801e2f6 <xQueueReceive+0x12e>
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 801e2f2:	6821      	ldr	r1, [r4, #0]
 801e2f4:	60e1      	str	r1, [r4, #12]
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 801e2f6:	4638      	mov	r0, r7
 801e2f8:	f014 ff55 	bl	80331a6 <memcpy>
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 801e2fc:	3d01      	subs	r5, #1
 801e2fe:	63a5      	str	r5, [r4, #56]	@ 0x38
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 801e300:	6923      	ldr	r3, [r4, #16]
 801e302:	2b00      	cmp	r3, #0
 801e304:	f040 80dc 	bne.w	801e4c0 <xQueueReceive+0x2f8>
				taskEXIT_CRITICAL();
 801e308:	f001 fada 	bl	801f8c0 <vPortExitCritical>
				return pdPASS;
 801e30c:	2001      	movs	r0, #1
 801e30e:	e072      	b.n	801e3f6 <xQueueReceive+0x22e>
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 801e310:	6c03      	ldr	r3, [r0, #64]	@ 0x40
 801e312:	2b00      	cmp	r3, #0
 801e314:	f43f af64 	beq.w	801e1e0 <xQueueReceive+0x18>
 801e318:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801e31c:	b672      	cpsid	i
 801e31e:	f383 8811 	msr	BASEPRI, r3
 801e322:	f3bf 8f6f 	isb	sy
 801e326:	f3bf 8f4f 	dsb	sy
 801e32a:	b662      	cpsie	i
 801e32c:	e7fe      	b.n	801e32c <xQueueReceive+0x164>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 801e32e:	9b01      	ldr	r3, [sp, #4]
 801e330:	2b00      	cmp	r3, #0
 801e332:	f43f af5a 	beq.w	801e1ea <xQueueReceive+0x22>
 801e336:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801e33a:	b672      	cpsid	i
 801e33c:	f383 8811 	msr	BASEPRI, r3
 801e340:	f3bf 8f6f 	isb	sy
 801e344:	f3bf 8f4f 	dsb	sy
 801e348:	b662      	cpsie	i
 801e34a:	e7fe      	b.n	801e34a <xQueueReceive+0x182>
	taskENTER_CRITICAL();
 801e34c:	f001 fa92 	bl	801f874 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 801e350:	f894 3045 	ldrb.w	r3, [r4, #69]	@ 0x45
 801e354:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 801e356:	2d00      	cmp	r5, #0
 801e358:	dc04      	bgt.n	801e364 <xQueueReceive+0x19c>
 801e35a:	e011      	b.n	801e380 <xQueueReceive+0x1b8>
			--cTxLock;
 801e35c:	1e6b      	subs	r3, r5, #1
 801e35e:	b2da      	uxtb	r2, r3
 801e360:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 801e362:	b16a      	cbz	r2, 801e380 <xQueueReceive+0x1b8>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 801e364:	6a63      	ldr	r3, [r4, #36]	@ 0x24
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 801e366:	4630      	mov	r0, r6
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 801e368:	b153      	cbz	r3, 801e380 <xQueueReceive+0x1b8>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 801e36a:	f000 ff1f 	bl	801f1ac <xTaskRemoveFromEventList>
 801e36e:	2800      	cmp	r0, #0
 801e370:	d0f4      	beq.n	801e35c <xQueueReceive+0x194>
						vTaskMissedYield();
 801e372:	f000 ffb5 	bl	801f2e0 <vTaskMissedYield>
			--cTxLock;
 801e376:	1e6b      	subs	r3, r5, #1
 801e378:	b2da      	uxtb	r2, r3
 801e37a:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 801e37c:	2a00      	cmp	r2, #0
 801e37e:	d1f1      	bne.n	801e364 <xQueueReceive+0x19c>
		pxQueue->cTxLock = queueUNLOCKED;
 801e380:	23ff      	movs	r3, #255	@ 0xff
 801e382:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
	taskEXIT_CRITICAL();
 801e386:	f001 fa9b 	bl	801f8c0 <vPortExitCritical>
	taskENTER_CRITICAL();
 801e38a:	f001 fa73 	bl	801f874 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 801e38e:	f894 3044 	ldrb.w	r3, [r4, #68]	@ 0x44
 801e392:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 801e394:	2d00      	cmp	r5, #0
 801e396:	dd14      	ble.n	801e3c2 <xQueueReceive+0x1fa>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 801e398:	f104 0910 	add.w	r9, r4, #16
 801e39c:	e003      	b.n	801e3a6 <xQueueReceive+0x1de>
				--cRxLock;
 801e39e:	1e6b      	subs	r3, r5, #1
 801e3a0:	b2da      	uxtb	r2, r3
 801e3a2:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 801e3a4:	b16a      	cbz	r2, 801e3c2 <xQueueReceive+0x1fa>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 801e3a6:	6923      	ldr	r3, [r4, #16]
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 801e3a8:	4648      	mov	r0, r9
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 801e3aa:	b153      	cbz	r3, 801e3c2 <xQueueReceive+0x1fa>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 801e3ac:	f000 fefe 	bl	801f1ac <xTaskRemoveFromEventList>
 801e3b0:	2800      	cmp	r0, #0
 801e3b2:	d0f4      	beq.n	801e39e <xQueueReceive+0x1d6>
					vTaskMissedYield();
 801e3b4:	f000 ff94 	bl	801f2e0 <vTaskMissedYield>
				--cRxLock;
 801e3b8:	1e6b      	subs	r3, r5, #1
 801e3ba:	b2da      	uxtb	r2, r3
 801e3bc:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 801e3be:	2a00      	cmp	r2, #0
 801e3c0:	d1f1      	bne.n	801e3a6 <xQueueReceive+0x1de>
		pxQueue->cRxLock = queueUNLOCKED;
 801e3c2:	23ff      	movs	r3, #255	@ 0xff
 801e3c4:	f884 3044 	strb.w	r3, [r4, #68]	@ 0x44
	taskEXIT_CRITICAL();
 801e3c8:	f001 fa7a 	bl	801f8c0 <vPortExitCritical>
			( void ) xTaskResumeAll();
 801e3cc:	f000 fde2 	bl	801ef94 <xTaskResumeAll>
	taskENTER_CRITICAL();
 801e3d0:	f001 fa50 	bl	801f874 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 801e3d4:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 801e3d6:	b15b      	cbz	r3, 801e3f0 <xQueueReceive+0x228>
	taskEXIT_CRITICAL();
 801e3d8:	f001 fa72 	bl	801f8c0 <vPortExitCritical>
		taskENTER_CRITICAL();
 801e3dc:	f001 fa4a 	bl	801f874 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 801e3e0:	6ba5      	ldr	r5, [r4, #56]	@ 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 801e3e2:	2d00      	cmp	r5, #0
 801e3e4:	f47f af7d 	bne.w	801e2e2 <xQueueReceive+0x11a>
				if( xTicksToWait == ( TickType_t ) 0 )
 801e3e8:	9b01      	ldr	r3, [sp, #4]
 801e3ea:	2b00      	cmp	r3, #0
 801e3ec:	f47f af0c 	bne.w	801e208 <xQueueReceive+0x40>
					taskEXIT_CRITICAL();
 801e3f0:	f001 fa66 	bl	801f8c0 <vPortExitCritical>
					return errQUEUE_EMPTY;
 801e3f4:	2000      	movs	r0, #0
}
 801e3f6:	b005      	add	sp, #20
 801e3f8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 801e3fc:	f104 0924 	add.w	r9, r4, #36	@ 0x24
	taskEXIT_CRITICAL();
 801e400:	f001 fa5e 	bl	801f8c0 <vPortExitCritical>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 801e404:	9901      	ldr	r1, [sp, #4]
 801e406:	4648      	mov	r0, r9
 801e408:	f000 fe3e 	bl	801f088 <vTaskPlaceOnEventList>
	taskENTER_CRITICAL();
 801e40c:	f001 fa32 	bl	801f874 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 801e410:	f894 3045 	ldrb.w	r3, [r4, #69]	@ 0x45
 801e414:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 801e416:	2d00      	cmp	r5, #0
 801e418:	dc04      	bgt.n	801e424 <xQueueReceive+0x25c>
 801e41a:	e011      	b.n	801e440 <xQueueReceive+0x278>
			--cTxLock;
 801e41c:	1e6b      	subs	r3, r5, #1
 801e41e:	b2da      	uxtb	r2, r3
 801e420:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 801e422:	b16a      	cbz	r2, 801e440 <xQueueReceive+0x278>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 801e424:	6a63      	ldr	r3, [r4, #36]	@ 0x24
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 801e426:	4648      	mov	r0, r9
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 801e428:	b153      	cbz	r3, 801e440 <xQueueReceive+0x278>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 801e42a:	f000 febf 	bl	801f1ac <xTaskRemoveFromEventList>
 801e42e:	2800      	cmp	r0, #0
 801e430:	d0f4      	beq.n	801e41c <xQueueReceive+0x254>
						vTaskMissedYield();
 801e432:	f000 ff55 	bl	801f2e0 <vTaskMissedYield>
			--cTxLock;
 801e436:	1e6b      	subs	r3, r5, #1
 801e438:	b2da      	uxtb	r2, r3
 801e43a:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 801e43c:	2a00      	cmp	r2, #0
 801e43e:	d1f1      	bne.n	801e424 <xQueueReceive+0x25c>
		pxQueue->cTxLock = queueUNLOCKED;
 801e440:	23ff      	movs	r3, #255	@ 0xff
 801e442:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
	taskEXIT_CRITICAL();
 801e446:	f001 fa3b 	bl	801f8c0 <vPortExitCritical>
	taskENTER_CRITICAL();
 801e44a:	f001 fa13 	bl	801f874 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 801e44e:	f894 3044 	ldrb.w	r3, [r4, #68]	@ 0x44
 801e452:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 801e454:	2d00      	cmp	r5, #0
 801e456:	dd14      	ble.n	801e482 <xQueueReceive+0x2ba>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 801e458:	f104 0910 	add.w	r9, r4, #16
 801e45c:	e003      	b.n	801e466 <xQueueReceive+0x29e>
				--cRxLock;
 801e45e:	1e6b      	subs	r3, r5, #1
 801e460:	b2da      	uxtb	r2, r3
 801e462:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 801e464:	b16a      	cbz	r2, 801e482 <xQueueReceive+0x2ba>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 801e466:	6923      	ldr	r3, [r4, #16]
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 801e468:	4648      	mov	r0, r9
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 801e46a:	b153      	cbz	r3, 801e482 <xQueueReceive+0x2ba>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 801e46c:	f000 fe9e 	bl	801f1ac <xTaskRemoveFromEventList>
 801e470:	2800      	cmp	r0, #0
 801e472:	d0f4      	beq.n	801e45e <xQueueReceive+0x296>
					vTaskMissedYield();
 801e474:	f000 ff34 	bl	801f2e0 <vTaskMissedYield>
				--cRxLock;
 801e478:	1e6b      	subs	r3, r5, #1
 801e47a:	b2da      	uxtb	r2, r3
 801e47c:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 801e47e:	2a00      	cmp	r2, #0
 801e480:	d1f1      	bne.n	801e466 <xQueueReceive+0x29e>
		pxQueue->cRxLock = queueUNLOCKED;
 801e482:	23ff      	movs	r3, #255	@ 0xff
 801e484:	f884 3044 	strb.w	r3, [r4, #68]	@ 0x44
	taskEXIT_CRITICAL();
 801e488:	f001 fa1a 	bl	801f8c0 <vPortExitCritical>
				if( xTaskResumeAll() == pdFALSE )
 801e48c:	f000 fd82 	bl	801ef94 <xTaskResumeAll>
 801e490:	2800      	cmp	r0, #0
 801e492:	d1a3      	bne.n	801e3dc <xQueueReceive+0x214>
					portYIELD_WITHIN_API();
 801e494:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 801e498:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 801e49c:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 801e4a0:	f3bf 8f4f 	dsb	sy
 801e4a4:	f3bf 8f6f 	isb	sy
		taskENTER_CRITICAL();
 801e4a8:	e798      	b.n	801e3dc <xQueueReceive+0x214>
 801e4aa:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801e4ae:	b672      	cpsid	i
 801e4b0:	f383 8811 	msr	BASEPRI, r3
 801e4b4:	f3bf 8f6f 	isb	sy
 801e4b8:	f3bf 8f4f 	dsb	sy
 801e4bc:	b662      	cpsie	i
	configASSERT( ( pxQueue ) );
 801e4be:	e7fe      	b.n	801e4be <xQueueReceive+0x2f6>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 801e4c0:	f104 0010 	add.w	r0, r4, #16
 801e4c4:	f000 fe72 	bl	801f1ac <xTaskRemoveFromEventList>
 801e4c8:	2800      	cmp	r0, #0
 801e4ca:	f43f af1d 	beq.w	801e308 <xQueueReceive+0x140>
						queueYIELD_IF_USING_PREEMPTION();
 801e4ce:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 801e4d2:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 801e4d6:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 801e4da:	f3bf 8f4f 	dsb	sy
 801e4de:	f3bf 8f6f 	isb	sy
 801e4e2:	e711      	b.n	801e308 <xQueueReceive+0x140>

0801e4e4 <xQueueReceiveFromISR>:
{
 801e4e4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	configASSERT( pxQueue );
 801e4e8:	b330      	cbz	r0, 801e538 <xQueueReceiveFromISR+0x54>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 801e4ea:	460f      	mov	r7, r1
 801e4ec:	4604      	mov	r4, r0
 801e4ee:	4616      	mov	r6, r2
 801e4f0:	b1a1      	cbz	r1, 801e51c <xQueueReceiveFromISR+0x38>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 801e4f2:	f001 fadf 	bl	801fab4 <vPortValidateInterruptPriority>
	__asm volatile
 801e4f6:	f3ef 8911 	mrs	r9, BASEPRI
 801e4fa:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801e4fe:	b672      	cpsid	i
 801e500:	f383 8811 	msr	BASEPRI, r3
 801e504:	f3bf 8f6f 	isb	sy
 801e508:	f3bf 8f4f 	dsb	sy
 801e50c:	b662      	cpsie	i
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 801e50e:	6ba5      	ldr	r5, [r4, #56]	@ 0x38
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 801e510:	b9ed      	cbnz	r5, 801e54e <xQueueReceiveFromISR+0x6a>
			xReturn = pdFAIL;
 801e512:	4628      	mov	r0, r5
	__asm volatile
 801e514:	f389 8811 	msr	BASEPRI, r9
}
 801e518:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 801e51c:	6c03      	ldr	r3, [r0, #64]	@ 0x40
 801e51e:	2b00      	cmp	r3, #0
 801e520:	d0e7      	beq.n	801e4f2 <xQueueReceiveFromISR+0xe>
	__asm volatile
 801e522:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801e526:	b672      	cpsid	i
 801e528:	f383 8811 	msr	BASEPRI, r3
 801e52c:	f3bf 8f6f 	isb	sy
 801e530:	f3bf 8f4f 	dsb	sy
 801e534:	b662      	cpsie	i
 801e536:	e7fe      	b.n	801e536 <xQueueReceiveFromISR+0x52>
 801e538:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801e53c:	b672      	cpsid	i
 801e53e:	f383 8811 	msr	BASEPRI, r3
 801e542:	f3bf 8f6f 	isb	sy
 801e546:	f3bf 8f4f 	dsb	sy
 801e54a:	b662      	cpsie	i
	configASSERT( pxQueue );
 801e54c:	e7fe      	b.n	801e54c <xQueueReceiveFromISR+0x68>
			const int8_t cRxLock = pxQueue->cRxLock;
 801e54e:	f894 8044 	ldrb.w	r8, [r4, #68]	@ 0x44
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 801e552:	6c22      	ldr	r2, [r4, #64]	@ 0x40
			const int8_t cRxLock = pxQueue->cRxLock;
 801e554:	fa4f f888 	sxtb.w	r8, r8
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 801e558:	b142      	cbz	r2, 801e56c <xQueueReceiveFromISR+0x88>
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 801e55a:	68e1      	ldr	r1, [r4, #12]
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 801e55c:	68a3      	ldr	r3, [r4, #8]
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 801e55e:	4411      	add	r1, r2
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 801e560:	4299      	cmp	r1, r3
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 801e562:	60e1      	str	r1, [r4, #12]
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 801e564:	d21c      	bcs.n	801e5a0 <xQueueReceiveFromISR+0xbc>
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 801e566:	4638      	mov	r0, r7
 801e568:	f014 fe1d 	bl	80331a6 <memcpy>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 801e56c:	3d01      	subs	r5, #1
			if( cRxLock == queueUNLOCKED )
 801e56e:	f1b8 3fff 	cmp.w	r8, #4294967295
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 801e572:	63a5      	str	r5, [r4, #56]	@ 0x38
			if( cRxLock == queueUNLOCKED )
 801e574:	d006      	beq.n	801e584 <xQueueReceiveFromISR+0xa0>
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
 801e576:	f108 0301 	add.w	r3, r8, #1
 801e57a:	b25b      	sxtb	r3, r3
 801e57c:	f884 3044 	strb.w	r3, [r4, #68]	@ 0x44
			xReturn = pdPASS;
 801e580:	2001      	movs	r0, #1
 801e582:	e7c7      	b.n	801e514 <xQueueReceiveFromISR+0x30>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 801e584:	6923      	ldr	r3, [r4, #16]
 801e586:	2b00      	cmp	r3, #0
 801e588:	d0fa      	beq.n	801e580 <xQueueReceiveFromISR+0x9c>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 801e58a:	f104 0010 	add.w	r0, r4, #16
 801e58e:	f000 fe0d 	bl	801f1ac <xTaskRemoveFromEventList>
						if( pxHigherPriorityTaskWoken != NULL )
 801e592:	2e00      	cmp	r6, #0
 801e594:	d0f4      	beq.n	801e580 <xQueueReceiveFromISR+0x9c>
 801e596:	2800      	cmp	r0, #0
 801e598:	d0f2      	beq.n	801e580 <xQueueReceiveFromISR+0x9c>
							*pxHigherPriorityTaskWoken = pdTRUE;
 801e59a:	2301      	movs	r3, #1
 801e59c:	6033      	str	r3, [r6, #0]
 801e59e:	e7ef      	b.n	801e580 <xQueueReceiveFromISR+0x9c>
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 801e5a0:	6821      	ldr	r1, [r4, #0]
 801e5a2:	60e1      	str	r1, [r4, #12]
 801e5a4:	e7df      	b.n	801e566 <xQueueReceiveFromISR+0x82>
 801e5a6:	bf00      	nop

0801e5a8 <vQueueAddToRegistry>:

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
		{
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
 801e5a8:	4b12      	ldr	r3, [pc, #72]	@ (801e5f4 <vQueueAddToRegistry+0x4c>)
 801e5aa:	681a      	ldr	r2, [r3, #0]
 801e5ac:	b17a      	cbz	r2, 801e5ce <vQueueAddToRegistry+0x26>
 801e5ae:	689a      	ldr	r2, [r3, #8]
 801e5b0:	b162      	cbz	r2, 801e5cc <vQueueAddToRegistry+0x24>
 801e5b2:	691a      	ldr	r2, [r3, #16]
 801e5b4:	b192      	cbz	r2, 801e5dc <vQueueAddToRegistry+0x34>
 801e5b6:	699a      	ldr	r2, [r3, #24]
 801e5b8:	b192      	cbz	r2, 801e5e0 <vQueueAddToRegistry+0x38>
 801e5ba:	6a1a      	ldr	r2, [r3, #32]
 801e5bc:	b192      	cbz	r2, 801e5e4 <vQueueAddToRegistry+0x3c>
 801e5be:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 801e5c0:	b192      	cbz	r2, 801e5e8 <vQueueAddToRegistry+0x40>
 801e5c2:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 801e5c4:	b192      	cbz	r2, 801e5ec <vQueueAddToRegistry+0x44>
 801e5c6:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 801e5c8:	b192      	cbz	r2, 801e5f0 <vQueueAddToRegistry+0x48>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
 801e5ca:	4770      	bx	lr
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 801e5cc:	2201      	movs	r2, #1
				xQueueRegistry[ ux ].xHandle = xQueue;
 801e5ce:	eb03 0cc2 	add.w	ip, r3, r2, lsl #3
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
 801e5d2:	f843 1032 	str.w	r1, [r3, r2, lsl #3]
				xQueueRegistry[ ux ].xHandle = xQueue;
 801e5d6:	f8cc 0004 	str.w	r0, [ip, #4]
	}
 801e5da:	4770      	bx	lr
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 801e5dc:	2202      	movs	r2, #2
 801e5de:	e7f6      	b.n	801e5ce <vQueueAddToRegistry+0x26>
 801e5e0:	2203      	movs	r2, #3
 801e5e2:	e7f4      	b.n	801e5ce <vQueueAddToRegistry+0x26>
 801e5e4:	2204      	movs	r2, #4
 801e5e6:	e7f2      	b.n	801e5ce <vQueueAddToRegistry+0x26>
 801e5e8:	2205      	movs	r2, #5
 801e5ea:	e7f0      	b.n	801e5ce <vQueueAddToRegistry+0x26>
 801e5ec:	2206      	movs	r2, #6
 801e5ee:	e7ee      	b.n	801e5ce <vQueueAddToRegistry+0x26>
 801e5f0:	2207      	movs	r2, #7
 801e5f2:	e7ec      	b.n	801e5ce <vQueueAddToRegistry+0x26>
 801e5f4:	200032b0 	.word	0x200032b0

0801e5f8 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
 801e5f8:	b570      	push	{r4, r5, r6, lr}
 801e5fa:	4605      	mov	r5, r0
 801e5fc:	460e      	mov	r6, r1
 801e5fe:	4614      	mov	r4, r2
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
 801e600:	f001 f938 	bl	801f874 <vPortEnterCritical>
 801e604:	f895 3044 	ldrb.w	r3, [r5, #68]	@ 0x44
 801e608:	2bff      	cmp	r3, #255	@ 0xff
 801e60a:	d102      	bne.n	801e612 <vQueueWaitForMessageRestricted+0x1a>
 801e60c:	2300      	movs	r3, #0
 801e60e:	f885 3044 	strb.w	r3, [r5, #68]	@ 0x44
 801e612:	f895 3045 	ldrb.w	r3, [r5, #69]	@ 0x45
 801e616:	2bff      	cmp	r3, #255	@ 0xff
 801e618:	d102      	bne.n	801e620 <vQueueWaitForMessageRestricted+0x28>
 801e61a:	2300      	movs	r3, #0
 801e61c:	f885 3045 	strb.w	r3, [r5, #69]	@ 0x45
 801e620:	f001 f94e 	bl	801f8c0 <vPortExitCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 801e624:	6bab      	ldr	r3, [r5, #56]	@ 0x38
 801e626:	2b00      	cmp	r3, #0
 801e628:	d043      	beq.n	801e6b2 <vQueueWaitForMessageRestricted+0xba>
	taskENTER_CRITICAL();
 801e62a:	f001 f923 	bl	801f874 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 801e62e:	f895 3045 	ldrb.w	r3, [r5, #69]	@ 0x45
 801e632:	b25c      	sxtb	r4, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 801e634:	2c00      	cmp	r4, #0
 801e636:	dd14      	ble.n	801e662 <vQueueWaitForMessageRestricted+0x6a>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 801e638:	f105 0624 	add.w	r6, r5, #36	@ 0x24
 801e63c:	e003      	b.n	801e646 <vQueueWaitForMessageRestricted+0x4e>
			--cTxLock;
 801e63e:	1e63      	subs	r3, r4, #1
 801e640:	b2da      	uxtb	r2, r3
 801e642:	b25c      	sxtb	r4, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 801e644:	b16a      	cbz	r2, 801e662 <vQueueWaitForMessageRestricted+0x6a>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 801e646:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 801e648:	4630      	mov	r0, r6
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 801e64a:	b153      	cbz	r3, 801e662 <vQueueWaitForMessageRestricted+0x6a>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 801e64c:	f000 fdae 	bl	801f1ac <xTaskRemoveFromEventList>
 801e650:	2800      	cmp	r0, #0
 801e652:	d0f4      	beq.n	801e63e <vQueueWaitForMessageRestricted+0x46>
						vTaskMissedYield();
 801e654:	f000 fe44 	bl	801f2e0 <vTaskMissedYield>
			--cTxLock;
 801e658:	1e63      	subs	r3, r4, #1
 801e65a:	b2da      	uxtb	r2, r3
 801e65c:	b25c      	sxtb	r4, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 801e65e:	2a00      	cmp	r2, #0
 801e660:	d1f1      	bne.n	801e646 <vQueueWaitForMessageRestricted+0x4e>
		pxQueue->cTxLock = queueUNLOCKED;
 801e662:	23ff      	movs	r3, #255	@ 0xff
 801e664:	f885 3045 	strb.w	r3, [r5, #69]	@ 0x45
	taskEXIT_CRITICAL();
 801e668:	f001 f92a 	bl	801f8c0 <vPortExitCritical>
	taskENTER_CRITICAL();
 801e66c:	f001 f902 	bl	801f874 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 801e670:	f895 3044 	ldrb.w	r3, [r5, #68]	@ 0x44
 801e674:	b25c      	sxtb	r4, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 801e676:	2c00      	cmp	r4, #0
 801e678:	dd14      	ble.n	801e6a4 <vQueueWaitForMessageRestricted+0xac>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 801e67a:	f105 0610 	add.w	r6, r5, #16
 801e67e:	e003      	b.n	801e688 <vQueueWaitForMessageRestricted+0x90>
				--cRxLock;
 801e680:	1e63      	subs	r3, r4, #1
 801e682:	b2da      	uxtb	r2, r3
 801e684:	b25c      	sxtb	r4, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 801e686:	b16a      	cbz	r2, 801e6a4 <vQueueWaitForMessageRestricted+0xac>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 801e688:	692b      	ldr	r3, [r5, #16]
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 801e68a:	4630      	mov	r0, r6
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 801e68c:	b153      	cbz	r3, 801e6a4 <vQueueWaitForMessageRestricted+0xac>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 801e68e:	f000 fd8d 	bl	801f1ac <xTaskRemoveFromEventList>
 801e692:	2800      	cmp	r0, #0
 801e694:	d0f4      	beq.n	801e680 <vQueueWaitForMessageRestricted+0x88>
					vTaskMissedYield();
 801e696:	f000 fe23 	bl	801f2e0 <vTaskMissedYield>
				--cRxLock;
 801e69a:	1e63      	subs	r3, r4, #1
 801e69c:	b2da      	uxtb	r2, r3
 801e69e:	b25c      	sxtb	r4, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 801e6a0:	2a00      	cmp	r2, #0
 801e6a2:	d1f1      	bne.n	801e688 <vQueueWaitForMessageRestricted+0x90>
		pxQueue->cRxLock = queueUNLOCKED;
 801e6a4:	23ff      	movs	r3, #255	@ 0xff
 801e6a6:	f885 3044 	strb.w	r3, [r5, #68]	@ 0x44
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
	}
 801e6aa:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	taskEXIT_CRITICAL();
 801e6ae:	f001 b907 	b.w	801f8c0 <vPortExitCritical>
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
 801e6b2:	4622      	mov	r2, r4
 801e6b4:	4631      	mov	r1, r6
 801e6b6:	f105 0024 	add.w	r0, r5, #36	@ 0x24
 801e6ba:	f000 fd2b 	bl	801f114 <vTaskPlaceOnEventListRestricted>
 801e6be:	e7b4      	b.n	801e62a <vQueueWaitForMessageRestricted+0x32>

0801e6c0 <prvAddNewTaskToReadyList>:
	}
}
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
 801e6c0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 801e6c4:	4605      	mov	r5, r0
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
 801e6c6:	f001 f8d5 	bl	801f874 <vPortEnterCritical>
	{
		uxCurrentNumberOfTasks++;
 801e6ca:	4a34      	ldr	r2, [pc, #208]	@ (801e79c <prvAddNewTaskToReadyList+0xdc>)
		if( pxCurrentTCB == NULL )
 801e6cc:	4e34      	ldr	r6, [pc, #208]	@ (801e7a0 <prvAddNewTaskToReadyList+0xe0>)
		uxCurrentNumberOfTasks++;
 801e6ce:	6813      	ldr	r3, [r2, #0]
 801e6d0:	3301      	adds	r3, #1
 801e6d2:	6013      	str	r3, [r2, #0]
		if( pxCurrentTCB == NULL )
 801e6d4:	6833      	ldr	r3, [r6, #0]
 801e6d6:	2b00      	cmp	r3, #0
 801e6d8:	d031      	beq.n	801e73e <prvAddNewTaskToReadyList+0x7e>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
 801e6da:	4c32      	ldr	r4, [pc, #200]	@ (801e7a4 <prvAddNewTaskToReadyList+0xe4>)
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 801e6dc:	6ae8      	ldr	r0, [r5, #44]	@ 0x2c
			if( xSchedulerRunning == pdFALSE )
 801e6de:	6823      	ldr	r3, [r4, #0]
 801e6e0:	b333      	cbz	r3, 801e730 <prvAddNewTaskToReadyList+0x70>
 801e6e2:	4f31      	ldr	r7, [pc, #196]	@ (801e7a8 <prvAddNewTaskToReadyList+0xe8>)
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
 801e6e4:	4a31      	ldr	r2, [pc, #196]	@ (801e7ac <prvAddNewTaskToReadyList+0xec>)
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
 801e6e6:	4932      	ldr	r1, [pc, #200]	@ (801e7b0 <prvAddNewTaskToReadyList+0xf0>)
		uxTaskNumber++;
 801e6e8:	6813      	ldr	r3, [r2, #0]
 801e6ea:	3301      	adds	r3, #1
 801e6ec:	6013      	str	r3, [r2, #0]
			pxNewTCB->uxTCBNumber = uxTaskNumber;
 801e6ee:	646b      	str	r3, [r5, #68]	@ 0x44
		prvAddTaskToReadyList( pxNewTCB );
 801e6f0:	680b      	ldr	r3, [r1, #0]
 801e6f2:	4283      	cmp	r3, r0
 801e6f4:	d200      	bcs.n	801e6f8 <prvAddNewTaskToReadyList+0x38>
 801e6f6:	6008      	str	r0, [r1, #0]
 801e6f8:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 801e6fc:	1d29      	adds	r1, r5, #4
 801e6fe:	eb07 0080 	add.w	r0, r7, r0, lsl #2
 801e702:	f7ff fa3f 	bl	801db84 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
 801e706:	f001 f8db 	bl	801f8c0 <vPortExitCritical>

	if( xSchedulerRunning != pdFALSE )
 801e70a:	6823      	ldr	r3, [r4, #0]
 801e70c:	b173      	cbz	r3, 801e72c <prvAddNewTaskToReadyList+0x6c>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 801e70e:	6832      	ldr	r2, [r6, #0]
 801e710:	6aeb      	ldr	r3, [r5, #44]	@ 0x2c
 801e712:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
 801e714:	429a      	cmp	r2, r3
 801e716:	d209      	bcs.n	801e72c <prvAddNewTaskToReadyList+0x6c>
		{
			taskYIELD_IF_USING_PREEMPTION();
 801e718:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 801e71c:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 801e720:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 801e724:	f3bf 8f4f 	dsb	sy
 801e728:	f3bf 8f6f 	isb	sy
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 801e72c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 801e730:	6833      	ldr	r3, [r6, #0]
 801e732:	4f1d      	ldr	r7, [pc, #116]	@ (801e7a8 <prvAddNewTaskToReadyList+0xe8>)
 801e734:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 801e736:	4283      	cmp	r3, r0
 801e738:	d8d4      	bhi.n	801e6e4 <prvAddNewTaskToReadyList+0x24>
					pxCurrentTCB = pxNewTCB;
 801e73a:	6035      	str	r5, [r6, #0]
 801e73c:	e7d2      	b.n	801e6e4 <prvAddNewTaskToReadyList+0x24>
			pxCurrentTCB = pxNewTCB;
 801e73e:	6035      	str	r5, [r6, #0]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 801e740:	6813      	ldr	r3, [r2, #0]
 801e742:	2b01      	cmp	r3, #1
 801e744:	d003      	beq.n	801e74e <prvAddNewTaskToReadyList+0x8e>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 801e746:	6ae8      	ldr	r0, [r5, #44]	@ 0x2c
 801e748:	4f17      	ldr	r7, [pc, #92]	@ (801e7a8 <prvAddNewTaskToReadyList+0xe8>)
 801e74a:	4c16      	ldr	r4, [pc, #88]	@ (801e7a4 <prvAddNewTaskToReadyList+0xe4>)
 801e74c:	e7ca      	b.n	801e6e4 <prvAddNewTaskToReadyList+0x24>
 801e74e:	4f16      	ldr	r7, [pc, #88]	@ (801e7a8 <prvAddNewTaskToReadyList+0xe8>)
 801e750:	463c      	mov	r4, r7
 801e752:	f507 688c 	add.w	r8, r7, #1120	@ 0x460
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 801e756:	4620      	mov	r0, r4
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 801e758:	3414      	adds	r4, #20
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 801e75a:	f7ff fa03 	bl	801db64 <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 801e75e:	45a0      	cmp	r8, r4
 801e760:	d1f9      	bne.n	801e756 <prvAddNewTaskToReadyList+0x96>
	}

	vListInitialise( &xDelayedTaskList1 );
 801e762:	f8df 9064 	ldr.w	r9, [pc, #100]	@ 801e7c8 <prvAddNewTaskToReadyList+0x108>
	vListInitialise( &xDelayedTaskList2 );
 801e766:	f8df 8064 	ldr.w	r8, [pc, #100]	@ 801e7cc <prvAddNewTaskToReadyList+0x10c>
	vListInitialise( &xDelayedTaskList1 );
 801e76a:	4648      	mov	r0, r9
 801e76c:	4c0d      	ldr	r4, [pc, #52]	@ (801e7a4 <prvAddNewTaskToReadyList+0xe4>)
 801e76e:	f7ff f9f9 	bl	801db64 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 801e772:	4640      	mov	r0, r8
 801e774:	f7ff f9f6 	bl	801db64 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 801e778:	480e      	ldr	r0, [pc, #56]	@ (801e7b4 <prvAddNewTaskToReadyList+0xf4>)
 801e77a:	f7ff f9f3 	bl	801db64 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
 801e77e:	480e      	ldr	r0, [pc, #56]	@ (801e7b8 <prvAddNewTaskToReadyList+0xf8>)
 801e780:	f7ff f9f0 	bl	801db64 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
 801e784:	480d      	ldr	r0, [pc, #52]	@ (801e7bc <prvAddNewTaskToReadyList+0xfc>)
 801e786:	f7ff f9ed 	bl	801db64 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 801e78a:	4b0d      	ldr	r3, [pc, #52]	@ (801e7c0 <prvAddNewTaskToReadyList+0x100>)
		prvAddTaskToReadyList( pxNewTCB );
 801e78c:	6ae8      	ldr	r0, [r5, #44]	@ 0x2c
	pxDelayedTaskList = &xDelayedTaskList1;
 801e78e:	f8c3 9000 	str.w	r9, [r3]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 801e792:	4b0c      	ldr	r3, [pc, #48]	@ (801e7c4 <prvAddNewTaskToReadyList+0x104>)
 801e794:	f8c3 8000 	str.w	r8, [r3]
}
 801e798:	e7a4      	b.n	801e6e4 <prvAddNewTaskToReadyList+0x24>
 801e79a:	bf00      	nop
 801e79c:	20003314 	.word	0x20003314
 801e7a0:	200037e8 	.word	0x200037e8
 801e7a4:	20003308 	.word	0x20003308
 801e7a8:	20003388 	.word	0x20003388
 801e7ac:	200032f8 	.word	0x200032f8
 801e7b0:	2000330c 	.word	0x2000330c
 801e7b4:	20003344 	.word	0x20003344
 801e7b8:	20003330 	.word	0x20003330
 801e7bc:	20003318 	.word	0x20003318
 801e7c0:	2000335c 	.word	0x2000335c
 801e7c4:	20003358 	.word	0x20003358
 801e7c8:	20003374 	.word	0x20003374
 801e7cc:	20003360 	.word	0x20003360

0801e7d0 <vTaskSwitchContext.part.0>:
void vTaskSwitchContext( void )
 801e7d0:	b538      	push	{r3, r4, r5, lr}
		xYieldPending = pdFALSE;
 801e7d2:	2200      	movs	r2, #0
 801e7d4:	4b27      	ldr	r3, [pc, #156]	@ (801e874 <vTaskSwitchContext.part.0+0xa4>)
		taskCHECK_FOR_STACK_OVERFLOW();
 801e7d6:	4c28      	ldr	r4, [pc, #160]	@ (801e878 <vTaskSwitchContext.part.0+0xa8>)
		xYieldPending = pdFALSE;
 801e7d8:	601a      	str	r2, [r3, #0]
		taskCHECK_FOR_STACK_OVERFLOW();
 801e7da:	6823      	ldr	r3, [r4, #0]
 801e7dc:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 801e7de:	681a      	ldr	r2, [r3, #0]
 801e7e0:	f1b2 3fa5 	cmp.w	r2, #2779096485	@ 0xa5a5a5a5
 801e7e4:	d103      	bne.n	801e7ee <vTaskSwitchContext.part.0+0x1e>
 801e7e6:	685a      	ldr	r2, [r3, #4]
 801e7e8:	f1b2 3fa5 	cmp.w	r2, #2779096485	@ 0xa5a5a5a5
 801e7ec:	d031      	beq.n	801e852 <vTaskSwitchContext.part.0+0x82>
 801e7ee:	6820      	ldr	r0, [r4, #0]
 801e7f0:	6821      	ldr	r1, [r4, #0]
 801e7f2:	3134      	adds	r1, #52	@ 0x34
 801e7f4:	f7f2 fa8a 	bl	8010d0c <vApplicationStackOverflowHook>
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 801e7f8:	4d20      	ldr	r5, [pc, #128]	@ (801e87c <vTaskSwitchContext.part.0+0xac>)
 801e7fa:	4921      	ldr	r1, [pc, #132]	@ (801e880 <vTaskSwitchContext.part.0+0xb0>)
 801e7fc:	682b      	ldr	r3, [r5, #0]
 801e7fe:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 801e802:	0098      	lsls	r0, r3, #2
 801e804:	0092      	lsls	r2, r2, #2
 801e806:	588a      	ldr	r2, [r1, r2]
 801e808:	b942      	cbnz	r2, 801e81c <vTaskSwitchContext.part.0+0x4c>
 801e80a:	b1bb      	cbz	r3, 801e83c <vTaskSwitchContext.part.0+0x6c>
 801e80c:	3b01      	subs	r3, #1
 801e80e:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 801e812:	0098      	lsls	r0, r3, #2
 801e814:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 801e818:	2a00      	cmp	r2, #0
 801e81a:	d0f6      	beq.n	801e80a <vTaskSwitchContext.part.0+0x3a>
 801e81c:	4418      	add	r0, r3
 801e81e:	eb01 0c80 	add.w	ip, r1, r0, lsl #2
 801e822:	f8dc 1004 	ldr.w	r1, [ip, #4]
 801e826:	4662      	mov	r2, ip
 801e828:	6849      	ldr	r1, [r1, #4]
 801e82a:	3208      	adds	r2, #8
 801e82c:	4291      	cmp	r1, r2
 801e82e:	f8cc 1004 	str.w	r1, [ip, #4]
 801e832:	d017      	beq.n	801e864 <vTaskSwitchContext.part.0+0x94>
 801e834:	68ca      	ldr	r2, [r1, #12]
 801e836:	6022      	str	r2, [r4, #0]
 801e838:	602b      	str	r3, [r5, #0]
}
 801e83a:	bd38      	pop	{r3, r4, r5, pc}
 801e83c:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801e840:	b672      	cpsid	i
 801e842:	f383 8811 	msr	BASEPRI, r3
 801e846:	f3bf 8f6f 	isb	sy
 801e84a:	f3bf 8f4f 	dsb	sy
 801e84e:	b662      	cpsie	i
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 801e850:	e7fe      	b.n	801e850 <vTaskSwitchContext.part.0+0x80>
		taskCHECK_FOR_STACK_OVERFLOW();
 801e852:	689a      	ldr	r2, [r3, #8]
 801e854:	f1b2 3fa5 	cmp.w	r2, #2779096485	@ 0xa5a5a5a5
 801e858:	d1c9      	bne.n	801e7ee <vTaskSwitchContext.part.0+0x1e>
 801e85a:	68db      	ldr	r3, [r3, #12]
 801e85c:	f1b3 3fa5 	cmp.w	r3, #2779096485	@ 0xa5a5a5a5
 801e860:	d1c5      	bne.n	801e7ee <vTaskSwitchContext.part.0+0x1e>
 801e862:	e7c9      	b.n	801e7f8 <vTaskSwitchContext.part.0+0x28>
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 801e864:	6849      	ldr	r1, [r1, #4]
 801e866:	68ca      	ldr	r2, [r1, #12]
 801e868:	f8cc 1004 	str.w	r1, [ip, #4]
 801e86c:	6022      	str	r2, [r4, #0]
 801e86e:	602b      	str	r3, [r5, #0]
}
 801e870:	bd38      	pop	{r3, r4, r5, pc}
 801e872:	bf00      	nop
 801e874:	20003300 	.word	0x20003300
 801e878:	200037e8 	.word	0x200037e8
 801e87c:	2000330c 	.word	0x2000330c
 801e880:	20003388 	.word	0x20003388

0801e884 <prvIdleTask>:
{
 801e884:	b580      	push	{r7, lr}
 801e886:	4c23      	ldr	r4, [pc, #140]	@ (801e914 <prvIdleTask+0x90>)
 801e888:	4e23      	ldr	r6, [pc, #140]	@ (801e918 <prvIdleTask+0x94>)
 801e88a:	4d24      	ldr	r5, [pc, #144]	@ (801e91c <prvIdleTask+0x98>)
 801e88c:	4f24      	ldr	r7, [pc, #144]	@ (801e920 <prvIdleTask+0x9c>)
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 801e88e:	6823      	ldr	r3, [r4, #0]
 801e890:	b363      	cbz	r3, 801e8ec <prvIdleTask+0x68>
		{
			taskENTER_CRITICAL();
 801e892:	f000 ffef 	bl	801f874 <vPortEnterCritical>
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 801e896:	68f3      	ldr	r3, [r6, #12]
 801e898:	f8d3 800c 	ldr.w	r8, [r3, #12]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 801e89c:	f108 0004 	add.w	r0, r8, #4
 801e8a0:	f7ff f996 	bl	801dbd0 <uxListRemove>
				--uxCurrentNumberOfTasks;
 801e8a4:	682b      	ldr	r3, [r5, #0]
 801e8a6:	3b01      	subs	r3, #1
 801e8a8:	602b      	str	r3, [r5, #0]
				--uxDeletedTasksWaitingCleanUp;
 801e8aa:	6823      	ldr	r3, [r4, #0]
 801e8ac:	3b01      	subs	r3, #1
 801e8ae:	6023      	str	r3, [r4, #0]
			}
			taskEXIT_CRITICAL();
 801e8b0:	f001 f806 	bl	801f8c0 <vPortExitCritical>
		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */
		{
			/* The task could have been allocated statically or dynamically, so
			check what was statically allocated before trying to free the
			memory. */
			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
 801e8b4:	f898 305d 	ldrb.w	r3, [r8, #93]	@ 0x5d
 801e8b8:	b173      	cbz	r3, 801e8d8 <prvIdleTask+0x54>
				/* Both the stack and TCB were allocated dynamically, so both
				must be freed. */
				vPortFree( pxTCB->pxStack );
				vPortFree( pxTCB );
			}
			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
 801e8ba:	2b01      	cmp	r3, #1
 801e8bc:	d026      	beq.n	801e90c <prvIdleTask+0x88>
			}
			else
			{
				/* Neither the stack nor the TCB were allocated dynamically, so
				nothing needs to be freed. */
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
 801e8be:	2b02      	cmp	r3, #2
 801e8c0:	d0e5      	beq.n	801e88e <prvIdleTask+0xa>
 801e8c2:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801e8c6:	b672      	cpsid	i
 801e8c8:	f383 8811 	msr	BASEPRI, r3
 801e8cc:	f3bf 8f6f 	isb	sy
 801e8d0:	f3bf 8f4f 	dsb	sy
 801e8d4:	b662      	cpsie	i
 801e8d6:	e7fe      	b.n	801e8d6 <prvIdleTask+0x52>
				vPortFree( pxTCB->pxStack );
 801e8d8:	f8d8 0030 	ldr.w	r0, [r8, #48]	@ 0x30
 801e8dc:	f001 f9da 	bl	801fc94 <vPortFree>
				vPortFree( pxTCB );
 801e8e0:	4640      	mov	r0, r8
 801e8e2:	f001 f9d7 	bl	801fc94 <vPortFree>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 801e8e6:	6823      	ldr	r3, [r4, #0]
 801e8e8:	2b00      	cmp	r3, #0
 801e8ea:	d1d2      	bne.n	801e892 <prvIdleTask+0xe>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 801e8ec:	683b      	ldr	r3, [r7, #0]
 801e8ee:	2b01      	cmp	r3, #1
 801e8f0:	d909      	bls.n	801e906 <prvIdleTask+0x82>
				taskYIELD();
 801e8f2:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 801e8f6:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 801e8fa:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 801e8fe:	f3bf 8f4f 	dsb	sy
 801e902:	f3bf 8f6f 	isb	sy
			vApplicationIdleHook();
 801e906:	f7f2 f9ff 	bl	8010d08 <vApplicationIdleHook>
		prvCheckTasksWaitingTermination();
 801e90a:	e7c0      	b.n	801e88e <prvIdleTask+0xa>
				vPortFree( pxTCB );
 801e90c:	4640      	mov	r0, r8
 801e90e:	f001 f9c1 	bl	801fc94 <vPortFree>
 801e912:	e7bc      	b.n	801e88e <prvIdleTask+0xa>
 801e914:	2000332c 	.word	0x2000332c
 801e918:	20003330 	.word	0x20003330
 801e91c:	20003314 	.word	0x20003314
 801e920:	20003388 	.word	0x20003388

0801e924 <xTaskCreateStatic>:
	{
 801e924:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 801e928:	b083      	sub	sp, #12
 801e92a:	4698      	mov	r8, r3
		configASSERT( puxStackBuffer != NULL );
 801e92c:	e9dd 340b 	ldrd	r3, r4, [sp, #44]	@ 0x2c
 801e930:	b1db      	cbz	r3, 801e96a <xTaskCreateStatic+0x46>
		configASSERT( pxTaskBuffer != NULL );
 801e932:	b17c      	cbz	r4, 801e954 <xTaskCreateStatic+0x30>
			volatile size_t xSize = sizeof( StaticTask_t );
 801e934:	2360      	movs	r3, #96	@ 0x60
 801e936:	9301      	str	r3, [sp, #4]
			configASSERT( xSize == sizeof( TCB_t ) );
 801e938:	9b01      	ldr	r3, [sp, #4]
 801e93a:	2b60      	cmp	r3, #96	@ 0x60
 801e93c:	d020      	beq.n	801e980 <xTaskCreateStatic+0x5c>
 801e93e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801e942:	b672      	cpsid	i
 801e944:	f383 8811 	msr	BASEPRI, r3
 801e948:	f3bf 8f6f 	isb	sy
 801e94c:	f3bf 8f4f 	dsb	sy
 801e950:	b662      	cpsie	i
 801e952:	e7fe      	b.n	801e952 <xTaskCreateStatic+0x2e>
 801e954:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801e958:	b672      	cpsid	i
 801e95a:	f383 8811 	msr	BASEPRI, r3
 801e95e:	f3bf 8f6f 	isb	sy
 801e962:	f3bf 8f4f 	dsb	sy
 801e966:	b662      	cpsie	i
		configASSERT( pxTaskBuffer != NULL );
 801e968:	e7fe      	b.n	801e968 <xTaskCreateStatic+0x44>
 801e96a:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801e96e:	b672      	cpsid	i
 801e970:	f383 8811 	msr	BASEPRI, r3
 801e974:	f3bf 8f6f 	isb	sy
 801e978:	f3bf 8f4f 	dsb	sy
 801e97c:	b662      	cpsie	i
		configASSERT( puxStackBuffer != NULL );
 801e97e:	e7fe      	b.n	801e97e <xTaskCreateStatic+0x5a>
			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 801e980:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 801e982:	0096      	lsls	r6, r2, #2
 801e984:	4607      	mov	r7, r0
 801e986:	460d      	mov	r5, r1
 801e988:	4618      	mov	r0, r3
			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 801e98a:	6323      	str	r3, [r4, #48]	@ 0x30
			( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
 801e98c:	9b01      	ldr	r3, [sp, #4]
				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 801e98e:	2302      	movs	r3, #2
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 801e990:	4632      	mov	r2, r6
 801e992:	21a5      	movs	r1, #165	@ 0xa5
				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 801e994:	f884 305d 	strb.w	r3, [r4, #93]	@ 0x5d
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 801e998:	f014 fb32 	bl	8033000 <memset>
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 801e99c:	1f32      	subs	r2, r6, #4
 801e99e:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 801e9a0:	4413      	add	r3, r2
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
 801e9a2:	f023 0607 	bic.w	r6, r3, #7
	if( pcName != NULL )
 801e9a6:	2d00      	cmp	r5, #0
 801e9a8:	d068      	beq.n	801ea7c <xTaskCreateStatic+0x158>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 801e9aa:	782b      	ldrb	r3, [r5, #0]
 801e9ac:	f884 3034 	strb.w	r3, [r4, #52]	@ 0x34
			if( pcName[ x ] == ( char ) 0x00 )
 801e9b0:	2b00      	cmp	r3, #0
 801e9b2:	d036      	beq.n	801ea22 <xTaskCreateStatic+0xfe>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 801e9b4:	786b      	ldrb	r3, [r5, #1]
 801e9b6:	f884 3035 	strb.w	r3, [r4, #53]	@ 0x35
			if( pcName[ x ] == ( char ) 0x00 )
 801e9ba:	b393      	cbz	r3, 801ea22 <xTaskCreateStatic+0xfe>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 801e9bc:	78ab      	ldrb	r3, [r5, #2]
 801e9be:	f884 3036 	strb.w	r3, [r4, #54]	@ 0x36
			if( pcName[ x ] == ( char ) 0x00 )
 801e9c2:	b373      	cbz	r3, 801ea22 <xTaskCreateStatic+0xfe>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 801e9c4:	78eb      	ldrb	r3, [r5, #3]
 801e9c6:	f884 3037 	strb.w	r3, [r4, #55]	@ 0x37
			if( pcName[ x ] == ( char ) 0x00 )
 801e9ca:	b353      	cbz	r3, 801ea22 <xTaskCreateStatic+0xfe>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 801e9cc:	792b      	ldrb	r3, [r5, #4]
 801e9ce:	f884 3038 	strb.w	r3, [r4, #56]	@ 0x38
			if( pcName[ x ] == ( char ) 0x00 )
 801e9d2:	b333      	cbz	r3, 801ea22 <xTaskCreateStatic+0xfe>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 801e9d4:	796b      	ldrb	r3, [r5, #5]
 801e9d6:	f884 3039 	strb.w	r3, [r4, #57]	@ 0x39
			if( pcName[ x ] == ( char ) 0x00 )
 801e9da:	b313      	cbz	r3, 801ea22 <xTaskCreateStatic+0xfe>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 801e9dc:	79ab      	ldrb	r3, [r5, #6]
 801e9de:	f884 303a 	strb.w	r3, [r4, #58]	@ 0x3a
			if( pcName[ x ] == ( char ) 0x00 )
 801e9e2:	b1f3      	cbz	r3, 801ea22 <xTaskCreateStatic+0xfe>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 801e9e4:	79eb      	ldrb	r3, [r5, #7]
 801e9e6:	f884 303b 	strb.w	r3, [r4, #59]	@ 0x3b
			if( pcName[ x ] == ( char ) 0x00 )
 801e9ea:	b1d3      	cbz	r3, 801ea22 <xTaskCreateStatic+0xfe>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 801e9ec:	7a2b      	ldrb	r3, [r5, #8]
 801e9ee:	f884 303c 	strb.w	r3, [r4, #60]	@ 0x3c
			if( pcName[ x ] == ( char ) 0x00 )
 801e9f2:	b1b3      	cbz	r3, 801ea22 <xTaskCreateStatic+0xfe>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 801e9f4:	7a6b      	ldrb	r3, [r5, #9]
 801e9f6:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
			if( pcName[ x ] == ( char ) 0x00 )
 801e9fa:	b193      	cbz	r3, 801ea22 <xTaskCreateStatic+0xfe>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 801e9fc:	7aab      	ldrb	r3, [r5, #10]
 801e9fe:	f884 303e 	strb.w	r3, [r4, #62]	@ 0x3e
			if( pcName[ x ] == ( char ) 0x00 )
 801ea02:	b173      	cbz	r3, 801ea22 <xTaskCreateStatic+0xfe>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 801ea04:	7aeb      	ldrb	r3, [r5, #11]
 801ea06:	f884 303f 	strb.w	r3, [r4, #63]	@ 0x3f
			if( pcName[ x ] == ( char ) 0x00 )
 801ea0a:	b153      	cbz	r3, 801ea22 <xTaskCreateStatic+0xfe>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 801ea0c:	7b2b      	ldrb	r3, [r5, #12]
 801ea0e:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
			if( pcName[ x ] == ( char ) 0x00 )
 801ea12:	b133      	cbz	r3, 801ea22 <xTaskCreateStatic+0xfe>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 801ea14:	7b6b      	ldrb	r3, [r5, #13]
 801ea16:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
			if( pcName[ x ] == ( char ) 0x00 )
 801ea1a:	b113      	cbz	r3, 801ea22 <xTaskCreateStatic+0xfe>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 801ea1c:	7bab      	ldrb	r3, [r5, #14]
 801ea1e:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 801ea22:	2300      	movs	r3, #0
 801ea24:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 801ea28:	9d0a      	ldr	r5, [sp, #40]	@ 0x28
		pxNewTCB->uxMutexesHeld = 0;
 801ea2a:	f04f 0900 	mov.w	r9, #0
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 801ea2e:	1d20      	adds	r0, r4, #4
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 801ea30:	2d37      	cmp	r5, #55	@ 0x37
		pxNewTCB->uxMutexesHeld = 0;
 801ea32:	f8c4 9050 	str.w	r9, [r4, #80]	@ 0x50
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 801ea36:	bf28      	it	cs
 801ea38:	2537      	movcs	r5, #55	@ 0x37
	pxNewTCB->uxPriority = uxPriority;
 801ea3a:	62e5      	str	r5, [r4, #44]	@ 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
 801ea3c:	64e5      	str	r5, [r4, #76]	@ 0x4c
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 801ea3e:	f1c5 0538 	rsb	r5, r5, #56	@ 0x38
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 801ea42:	f7ff f89b 	bl	801db7c <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 801ea46:	f104 0018 	add.w	r0, r4, #24
 801ea4a:	f7ff f897 	bl	801db7c <vListInitialiseItem>
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 801ea4e:	4642      	mov	r2, r8
 801ea50:	4639      	mov	r1, r7
		pxNewTCB->ulNotifiedValue = 0;
 801ea52:	f8c4 9058 	str.w	r9, [r4, #88]	@ 0x58
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 801ea56:	4630      	mov	r0, r6
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 801ea58:	61a5      	str	r5, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 801ea5a:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 801ea5c:	6264      	str	r4, [r4, #36]	@ 0x24
		pxNewTCB->pxTaskTag = NULL;
 801ea5e:	f8c4 9054 	str.w	r9, [r4, #84]	@ 0x54
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 801ea62:	f884 905c 	strb.w	r9, [r4, #92]	@ 0x5c
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 801ea66:	f000 fed9 	bl	801f81c <pxPortInitialiseStack>
 801ea6a:	4603      	mov	r3, r0
			prvAddNewTaskToReadyList( pxNewTCB );
 801ea6c:	4620      	mov	r0, r4
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 801ea6e:	6023      	str	r3, [r4, #0]
			prvAddNewTaskToReadyList( pxNewTCB );
 801ea70:	f7ff fe26 	bl	801e6c0 <prvAddNewTaskToReadyList>
	}
 801ea74:	4620      	mov	r0, r4
 801ea76:	b003      	add	sp, #12
 801ea78:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
 801ea7c:	f884 5034 	strb.w	r5, [r4, #52]	@ 0x34
 801ea80:	e7d2      	b.n	801ea28 <xTaskCreateStatic+0x104>
 801ea82:	bf00      	nop

0801ea84 <xTaskCreate>:
	{
 801ea84:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 801ea88:	0096      	lsls	r6, r2, #2
	{
 801ea8a:	4680      	mov	r8, r0
 801ea8c:	460d      	mov	r5, r1
 801ea8e:	4699      	mov	r9, r3
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 801ea90:	4630      	mov	r0, r6
 801ea92:	f001 f841 	bl	801fb18 <pvPortMalloc>
			if( pxStack != NULL )
 801ea96:	2800      	cmp	r0, #0
 801ea98:	d07f      	beq.n	801eb9a <xTaskCreate+0x116>
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
 801ea9a:	4607      	mov	r7, r0
 801ea9c:	2060      	movs	r0, #96	@ 0x60
 801ea9e:	f001 f83b 	bl	801fb18 <pvPortMalloc>
				if( pxNewTCB != NULL )
 801eaa2:	4604      	mov	r4, r0
 801eaa4:	2800      	cmp	r0, #0
 801eaa6:	d075      	beq.n	801eb94 <xTaskCreate+0x110>
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
 801eaa8:	2300      	movs	r3, #0
					pxNewTCB->pxStack = pxStack;
 801eaaa:	6307      	str	r7, [r0, #48]	@ 0x30
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 801eaac:	4632      	mov	r2, r6
 801eaae:	4638      	mov	r0, r7
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
 801eab0:	f884 305d 	strb.w	r3, [r4, #93]	@ 0x5d
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 801eab4:	21a5      	movs	r1, #165	@ 0xa5
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 801eab6:	3e04      	subs	r6, #4
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 801eab8:	f014 faa2 	bl	8033000 <memset>
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 801eabc:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 801eabe:	441e      	add	r6, r3
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
 801eac0:	f026 0607 	bic.w	r6, r6, #7
	if( pcName != NULL )
 801eac4:	2d00      	cmp	r5, #0
 801eac6:	d06c      	beq.n	801eba2 <xTaskCreate+0x11e>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 801eac8:	782b      	ldrb	r3, [r5, #0]
 801eaca:	f884 3034 	strb.w	r3, [r4, #52]	@ 0x34
			if( pcName[ x ] == ( char ) 0x00 )
 801eace:	2b00      	cmp	r3, #0
 801ead0:	d036      	beq.n	801eb40 <xTaskCreate+0xbc>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 801ead2:	786b      	ldrb	r3, [r5, #1]
 801ead4:	f884 3035 	strb.w	r3, [r4, #53]	@ 0x35
			if( pcName[ x ] == ( char ) 0x00 )
 801ead8:	b393      	cbz	r3, 801eb40 <xTaskCreate+0xbc>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 801eada:	78ab      	ldrb	r3, [r5, #2]
 801eadc:	f884 3036 	strb.w	r3, [r4, #54]	@ 0x36
			if( pcName[ x ] == ( char ) 0x00 )
 801eae0:	b373      	cbz	r3, 801eb40 <xTaskCreate+0xbc>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 801eae2:	78eb      	ldrb	r3, [r5, #3]
 801eae4:	f884 3037 	strb.w	r3, [r4, #55]	@ 0x37
			if( pcName[ x ] == ( char ) 0x00 )
 801eae8:	b353      	cbz	r3, 801eb40 <xTaskCreate+0xbc>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 801eaea:	792b      	ldrb	r3, [r5, #4]
 801eaec:	f884 3038 	strb.w	r3, [r4, #56]	@ 0x38
			if( pcName[ x ] == ( char ) 0x00 )
 801eaf0:	b333      	cbz	r3, 801eb40 <xTaskCreate+0xbc>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 801eaf2:	796b      	ldrb	r3, [r5, #5]
 801eaf4:	f884 3039 	strb.w	r3, [r4, #57]	@ 0x39
			if( pcName[ x ] == ( char ) 0x00 )
 801eaf8:	b313      	cbz	r3, 801eb40 <xTaskCreate+0xbc>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 801eafa:	79ab      	ldrb	r3, [r5, #6]
 801eafc:	f884 303a 	strb.w	r3, [r4, #58]	@ 0x3a
			if( pcName[ x ] == ( char ) 0x00 )
 801eb00:	b1f3      	cbz	r3, 801eb40 <xTaskCreate+0xbc>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 801eb02:	79eb      	ldrb	r3, [r5, #7]
 801eb04:	f884 303b 	strb.w	r3, [r4, #59]	@ 0x3b
			if( pcName[ x ] == ( char ) 0x00 )
 801eb08:	b1d3      	cbz	r3, 801eb40 <xTaskCreate+0xbc>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 801eb0a:	7a2b      	ldrb	r3, [r5, #8]
 801eb0c:	f884 303c 	strb.w	r3, [r4, #60]	@ 0x3c
			if( pcName[ x ] == ( char ) 0x00 )
 801eb10:	b1b3      	cbz	r3, 801eb40 <xTaskCreate+0xbc>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 801eb12:	7a6b      	ldrb	r3, [r5, #9]
 801eb14:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
			if( pcName[ x ] == ( char ) 0x00 )
 801eb18:	b193      	cbz	r3, 801eb40 <xTaskCreate+0xbc>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 801eb1a:	7aab      	ldrb	r3, [r5, #10]
 801eb1c:	f884 303e 	strb.w	r3, [r4, #62]	@ 0x3e
			if( pcName[ x ] == ( char ) 0x00 )
 801eb20:	b173      	cbz	r3, 801eb40 <xTaskCreate+0xbc>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 801eb22:	7aeb      	ldrb	r3, [r5, #11]
 801eb24:	f884 303f 	strb.w	r3, [r4, #63]	@ 0x3f
			if( pcName[ x ] == ( char ) 0x00 )
 801eb28:	b153      	cbz	r3, 801eb40 <xTaskCreate+0xbc>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 801eb2a:	7b2b      	ldrb	r3, [r5, #12]
 801eb2c:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
			if( pcName[ x ] == ( char ) 0x00 )
 801eb30:	b133      	cbz	r3, 801eb40 <xTaskCreate+0xbc>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 801eb32:	7b6b      	ldrb	r3, [r5, #13]
 801eb34:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
			if( pcName[ x ] == ( char ) 0x00 )
 801eb38:	b113      	cbz	r3, 801eb40 <xTaskCreate+0xbc>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 801eb3a:	7bab      	ldrb	r3, [r5, #14]
 801eb3c:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 801eb40:	2300      	movs	r3, #0
 801eb42:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 801eb46:	9d08      	ldr	r5, [sp, #32]
		pxNewTCB->uxMutexesHeld = 0;
 801eb48:	2700      	movs	r7, #0
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 801eb4a:	1d20      	adds	r0, r4, #4
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 801eb4c:	2d37      	cmp	r5, #55	@ 0x37
		pxNewTCB->uxMutexesHeld = 0;
 801eb4e:	6527      	str	r7, [r4, #80]	@ 0x50
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 801eb50:	bf28      	it	cs
 801eb52:	2537      	movcs	r5, #55	@ 0x37
	pxNewTCB->uxPriority = uxPriority;
 801eb54:	62e5      	str	r5, [r4, #44]	@ 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
 801eb56:	64e5      	str	r5, [r4, #76]	@ 0x4c
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 801eb58:	f1c5 0538 	rsb	r5, r5, #56	@ 0x38
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 801eb5c:	f7ff f80e 	bl	801db7c <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 801eb60:	f104 0018 	add.w	r0, r4, #24
 801eb64:	f7ff f80a 	bl	801db7c <vListInitialiseItem>
		pxNewTCB->ulNotifiedValue = 0;
 801eb68:	65a7      	str	r7, [r4, #88]	@ 0x58
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 801eb6a:	464a      	mov	r2, r9
 801eb6c:	4641      	mov	r1, r8
 801eb6e:	4630      	mov	r0, r6
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 801eb70:	61a5      	str	r5, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 801eb72:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 801eb74:	6264      	str	r4, [r4, #36]	@ 0x24
		pxNewTCB->pxTaskTag = NULL;
 801eb76:	6567      	str	r7, [r4, #84]	@ 0x54
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 801eb78:	f884 705c 	strb.w	r7, [r4, #92]	@ 0x5c
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 801eb7c:	f000 fe4e 	bl	801f81c <pxPortInitialiseStack>
	if( pxCreatedTask != NULL )
 801eb80:	9b09      	ldr	r3, [sp, #36]	@ 0x24
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 801eb82:	6020      	str	r0, [r4, #0]
	if( pxCreatedTask != NULL )
 801eb84:	b103      	cbz	r3, 801eb88 <xTaskCreate+0x104>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 801eb86:	601c      	str	r4, [r3, #0]
			prvAddNewTaskToReadyList( pxNewTCB );
 801eb88:	4620      	mov	r0, r4
 801eb8a:	f7ff fd99 	bl	801e6c0 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
 801eb8e:	2001      	movs	r0, #1
	}
 801eb90:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
					vPortFree( pxStack );
 801eb94:	4638      	mov	r0, r7
 801eb96:	f001 f87d 	bl	801fc94 <vPortFree>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 801eb9a:	f04f 30ff 	mov.w	r0, #4294967295
	}
 801eb9e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
 801eba2:	f884 5034 	strb.w	r5, [r4, #52]	@ 0x34
 801eba6:	e7ce      	b.n	801eb46 <xTaskCreate+0xc2>

0801eba8 <vTaskStartScheduler>:
{
 801eba8:	b570      	push	{r4, r5, r6, lr}
 801ebaa:	b084      	sub	sp, #16
		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
 801ebac:	2400      	movs	r4, #0
		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
 801ebae:	4668      	mov	r0, sp
 801ebb0:	aa02      	add	r2, sp, #8
 801ebb2:	a901      	add	r1, sp, #4
		StackType_t *pxIdleTaskStackBuffer = NULL;
 801ebb4:	e9cd 4400 	strd	r4, r4, [sp]
		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
 801ebb8:	f7fe ffb6 	bl	801db28 <vApplicationGetIdleTaskMemory>
		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
 801ebbc:	9d00      	ldr	r5, [sp, #0]
 801ebbe:	e9dd 0601 	ldrd	r0, r6, [sp, #4]
		configASSERT( puxStackBuffer != NULL );
 801ebc2:	b1d8      	cbz	r0, 801ebfc <vTaskStartScheduler+0x54>
		configASSERT( pxTaskBuffer != NULL );
 801ebc4:	b17d      	cbz	r5, 801ebe6 <vTaskStartScheduler+0x3e>
			volatile size_t xSize = sizeof( StaticTask_t );
 801ebc6:	2260      	movs	r2, #96	@ 0x60
 801ebc8:	9203      	str	r2, [sp, #12]
			configASSERT( xSize == sizeof( TCB_t ) );
 801ebca:	9a03      	ldr	r2, [sp, #12]
 801ebcc:	2a60      	cmp	r2, #96	@ 0x60
 801ebce:	d020      	beq.n	801ec12 <vTaskStartScheduler+0x6a>
 801ebd0:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801ebd4:	b672      	cpsid	i
 801ebd6:	f383 8811 	msr	BASEPRI, r3
 801ebda:	f3bf 8f6f 	isb	sy
 801ebde:	f3bf 8f4f 	dsb	sy
 801ebe2:	b662      	cpsie	i
 801ebe4:	e7fe      	b.n	801ebe4 <vTaskStartScheduler+0x3c>
 801ebe6:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801ebea:	b672      	cpsid	i
 801ebec:	f383 8811 	msr	BASEPRI, r3
 801ebf0:	f3bf 8f6f 	isb	sy
 801ebf4:	f3bf 8f4f 	dsb	sy
 801ebf8:	b662      	cpsie	i
		configASSERT( pxTaskBuffer != NULL );
 801ebfa:	e7fe      	b.n	801ebfa <vTaskStartScheduler+0x52>
 801ebfc:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801ec00:	b672      	cpsid	i
 801ec02:	f383 8811 	msr	BASEPRI, r3
 801ec06:	f3bf 8f6f 	isb	sy
 801ec0a:	f3bf 8f4f 	dsb	sy
 801ec0e:	b662      	cpsie	i
		configASSERT( puxStackBuffer != NULL );
 801ec10:	e7fe      	b.n	801ec10 <vTaskStartScheduler+0x68>
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 801ec12:	00b6      	lsls	r6, r6, #2
				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 801ec14:	2302      	movs	r3, #2
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 801ec16:	21a5      	movs	r1, #165	@ 0xa5
			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 801ec18:	6328      	str	r0, [r5, #48]	@ 0x30
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 801ec1a:	4632      	mov	r2, r6
				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 801ec1c:	f885 305d 	strb.w	r3, [r5, #93]	@ 0x5d
			( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
 801ec20:	9b03      	ldr	r3, [sp, #12]
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 801ec22:	f014 f9ed 	bl	8033000 <memset>
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 801ec26:	1f33      	subs	r3, r6, #4
 801ec28:	6b2a      	ldr	r2, [r5, #48]	@ 0x30
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 801ec2a:	4927      	ldr	r1, [pc, #156]	@ (801ecc8 <vTaskStartScheduler+0x120>)
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 801ec2c:	1d28      	adds	r0, r5, #4
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 801ec2e:	441a      	add	r2, r3
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 801ec30:	f885 4038 	strb.w	r4, [r5, #56]	@ 0x38
 801ec34:	6369      	str	r1, [r5, #52]	@ 0x34
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 801ec36:	f885 4043 	strb.w	r4, [r5, #67]	@ 0x43
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
 801ec3a:	f022 0607 	bic.w	r6, r2, #7
	pxNewTCB->uxPriority = uxPriority;
 801ec3e:	62ec      	str	r4, [r5, #44]	@ 0x2c
		pxNewTCB->uxMutexesHeld = 0;
 801ec40:	e9c5 4413 	strd	r4, r4, [r5, #76]	@ 0x4c
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 801ec44:	f7fe ff9a 	bl	801db7c <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 801ec48:	f105 0018 	add.w	r0, r5, #24
 801ec4c:	f7fe ff96 	bl	801db7c <vListInitialiseItem>
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 801ec50:	2338      	movs	r3, #56	@ 0x38
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 801ec52:	4622      	mov	r2, r4
 801ec54:	491d      	ldr	r1, [pc, #116]	@ (801eccc <vTaskStartScheduler+0x124>)
		pxNewTCB->ulNotifiedValue = 0;
 801ec56:	65ac      	str	r4, [r5, #88]	@ 0x58
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 801ec58:	4630      	mov	r0, r6
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 801ec5a:	61ab      	str	r3, [r5, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 801ec5c:	612d      	str	r5, [r5, #16]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 801ec5e:	626d      	str	r5, [r5, #36]	@ 0x24
		pxNewTCB->pxTaskTag = NULL;
 801ec60:	656c      	str	r4, [r5, #84]	@ 0x54
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 801ec62:	f885 405c 	strb.w	r4, [r5, #92]	@ 0x5c
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 801ec66:	f000 fdd9 	bl	801f81c <pxPortInitialiseStack>
 801ec6a:	4603      	mov	r3, r0
			prvAddNewTaskToReadyList( pxNewTCB );
 801ec6c:	4628      	mov	r0, r5
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 801ec6e:	602b      	str	r3, [r5, #0]
			prvAddNewTaskToReadyList( pxNewTCB );
 801ec70:	f7ff fd26 	bl	801e6c0 <prvAddNewTaskToReadyList>
			xReturn = xTimerCreateTimerTask();
 801ec74:	f000 fd30 	bl	801f6d8 <xTimerCreateTimerTask>
	if( xReturn == pdPASS )
 801ec78:	2801      	cmp	r0, #1
 801ec7a:	d00e      	beq.n	801ec9a <vTaskStartScheduler+0xf2>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 801ec7c:	3001      	adds	r0, #1
 801ec7e:	d001      	beq.n	801ec84 <vTaskStartScheduler+0xdc>
}
 801ec80:	b004      	add	sp, #16
 801ec82:	bd70      	pop	{r4, r5, r6, pc}
 801ec84:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801ec88:	b672      	cpsid	i
 801ec8a:	f383 8811 	msr	BASEPRI, r3
 801ec8e:	f3bf 8f6f 	isb	sy
 801ec92:	f3bf 8f4f 	dsb	sy
 801ec96:	b662      	cpsie	i
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 801ec98:	e7fe      	b.n	801ec98 <vTaskStartScheduler+0xf0>
 801ec9a:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801ec9e:	b672      	cpsid	i
 801eca0:	f383 8811 	msr	BASEPRI, r3
 801eca4:	f3bf 8f6f 	isb	sy
 801eca8:	f3bf 8f4f 	dsb	sy
 801ecac:	b662      	cpsie	i
		xNextTaskUnblockTime = portMAX_DELAY;
 801ecae:	4b08      	ldr	r3, [pc, #32]	@ (801ecd0 <vTaskStartScheduler+0x128>)
 801ecb0:	f04f 31ff 	mov.w	r1, #4294967295
		xSchedulerRunning = pdTRUE;
 801ecb4:	4a07      	ldr	r2, [pc, #28]	@ (801ecd4 <vTaskStartScheduler+0x12c>)
		xNextTaskUnblockTime = portMAX_DELAY;
 801ecb6:	6019      	str	r1, [r3, #0]
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 801ecb8:	4b07      	ldr	r3, [pc, #28]	@ (801ecd8 <vTaskStartScheduler+0x130>)
		xSchedulerRunning = pdTRUE;
 801ecba:	6010      	str	r0, [r2, #0]
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 801ecbc:	601c      	str	r4, [r3, #0]
}
 801ecbe:	b004      	add	sp, #16
 801ecc0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		if( xPortStartScheduler() != pdFALSE )
 801ecc4:	f000 be72 	b.w	801f9ac <xPortStartScheduler>
 801ecc8:	454c4449 	.word	0x454c4449
 801eccc:	0801e885 	.word	0x0801e885
 801ecd0:	200032f4 	.word	0x200032f4
 801ecd4:	20003308 	.word	0x20003308
 801ecd8:	20003310 	.word	0x20003310

0801ecdc <vTaskSuspendAll>:
	++uxSchedulerSuspended;
 801ecdc:	4a02      	ldr	r2, [pc, #8]	@ (801ece8 <vTaskSuspendAll+0xc>)
 801ecde:	6813      	ldr	r3, [r2, #0]
 801ece0:	3301      	adds	r3, #1
 801ece2:	6013      	str	r3, [r2, #0]
}
 801ece4:	4770      	bx	lr
 801ece6:	bf00      	nop
 801ece8:	200032f0 	.word	0x200032f0

0801ecec <xTaskGetTickCount>:
		xTicks = xTickCount;
 801ecec:	4b01      	ldr	r3, [pc, #4]	@ (801ecf4 <xTaskGetTickCount+0x8>)
 801ecee:	6818      	ldr	r0, [r3, #0]
}
 801ecf0:	4770      	bx	lr
 801ecf2:	bf00      	nop
 801ecf4:	20003310 	.word	0x20003310

0801ecf8 <xTaskGetTickCountFromISR>:
{
 801ecf8:	b508      	push	{r3, lr}
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 801ecfa:	f000 fedb 	bl	801fab4 <vPortValidateInterruptPriority>
		xReturn = xTickCount;
 801ecfe:	4b01      	ldr	r3, [pc, #4]	@ (801ed04 <xTaskGetTickCountFromISR+0xc>)
 801ed00:	6818      	ldr	r0, [r3, #0]
}
 801ed02:	bd08      	pop	{r3, pc}
 801ed04:	20003310 	.word	0x20003310

0801ed08 <xTaskIncrementTick>:
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 801ed08:	4b4f      	ldr	r3, [pc, #316]	@ (801ee48 <xTaskIncrementTick+0x140>)
 801ed0a:	681b      	ldr	r3, [r3, #0]
{
 801ed0c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801ed10:	b083      	sub	sp, #12
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 801ed12:	2b00      	cmp	r3, #0
 801ed14:	d144      	bne.n	801eda0 <xTaskIncrementTick+0x98>
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 801ed16:	4b4d      	ldr	r3, [pc, #308]	@ (801ee4c <xTaskIncrementTick+0x144>)
 801ed18:	681e      	ldr	r6, [r3, #0]
 801ed1a:	3601      	adds	r6, #1
		xTickCount = xConstTickCount;
 801ed1c:	601e      	str	r6, [r3, #0]
		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 801ed1e:	2e00      	cmp	r6, #0
 801ed20:	d04c      	beq.n	801edbc <xTaskIncrementTick+0xb4>
 801ed22:	4b4b      	ldr	r3, [pc, #300]	@ (801ee50 <xTaskIncrementTick+0x148>)
 801ed24:	9301      	str	r3, [sp, #4]
		if( xConstTickCount >= xNextTaskUnblockTime )
 801ed26:	681b      	ldr	r3, [r3, #0]
 801ed28:	42b3      	cmp	r3, r6
 801ed2a:	d85f      	bhi.n	801edec <xTaskIncrementTick+0xe4>
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 801ed2c:	4f49      	ldr	r7, [pc, #292]	@ (801ee54 <xTaskIncrementTick+0x14c>)
 801ed2e:	683b      	ldr	r3, [r7, #0]
 801ed30:	681d      	ldr	r5, [r3, #0]
 801ed32:	2d00      	cmp	r5, #0
 801ed34:	d076      	beq.n	801ee24 <xTaskIncrementTick+0x11c>
BaseType_t xSwitchRequired = pdFALSE;
 801ed36:	2500      	movs	r5, #0
 801ed38:	f8df 912c 	ldr.w	r9, [pc, #300]	@ 801ee68 <xTaskIncrementTick+0x160>
 801ed3c:	f8df a12c 	ldr.w	sl, [pc, #300]	@ 801ee6c <xTaskIncrementTick+0x164>
					prvAddTaskToReadyList( pxTCB );
 801ed40:	f8df 812c 	ldr.w	r8, [pc, #300]	@ 801ee70 <xTaskIncrementTick+0x168>
 801ed44:	e020      	b.n	801ed88 <xTaskIncrementTick+0x80>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 801ed46:	f7fe ff43 	bl	801dbd0 <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 801ed4a:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 801ed4c:	f104 0018 	add.w	r0, r4, #24
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 801ed50:	b10b      	cbz	r3, 801ed56 <xTaskIncrementTick+0x4e>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 801ed52:	f7fe ff3d 	bl	801dbd0 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 801ed56:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
 801ed58:	4659      	mov	r1, fp
 801ed5a:	f8d8 3000 	ldr.w	r3, [r8]
 801ed5e:	4298      	cmp	r0, r3
 801ed60:	d901      	bls.n	801ed66 <xTaskIncrementTick+0x5e>
 801ed62:	f8c8 0000 	str.w	r0, [r8]
 801ed66:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 801ed6a:	eb09 0080 	add.w	r0, r9, r0, lsl #2
 801ed6e:	f7fe ff09 	bl	801db84 <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 801ed72:	f8da 3000 	ldr.w	r3, [sl]
 801ed76:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
 801ed78:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
							xSwitchRequired = pdTRUE;
 801ed7a:	429a      	cmp	r2, r3
 801ed7c:	bf28      	it	cs
 801ed7e:	2501      	movcs	r5, #1
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 801ed80:	683b      	ldr	r3, [r7, #0]
 801ed82:	681b      	ldr	r3, [r3, #0]
 801ed84:	2b00      	cmp	r3, #0
 801ed86:	d051      	beq.n	801ee2c <xTaskIncrementTick+0x124>
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 801ed88:	683b      	ldr	r3, [r7, #0]
 801ed8a:	68db      	ldr	r3, [r3, #12]
 801ed8c:	68dc      	ldr	r4, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 801ed8e:	6863      	ldr	r3, [r4, #4]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 801ed90:	f104 0b04 	add.w	fp, r4, #4
					if( xConstTickCount < xItemValue )
 801ed94:	429e      	cmp	r6, r3
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 801ed96:	4658      	mov	r0, fp
					if( xConstTickCount < xItemValue )
 801ed98:	d2d5      	bcs.n	801ed46 <xTaskIncrementTick+0x3e>
						xNextTaskUnblockTime = xItemValue;
 801ed9a:	9a01      	ldr	r2, [sp, #4]
 801ed9c:	6013      	str	r3, [r2, #0]
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
 801ed9e:	e02a      	b.n	801edf6 <xTaskIncrementTick+0xee>
		++uxPendedTicks;
 801eda0:	4a2d      	ldr	r2, [pc, #180]	@ (801ee58 <xTaskIncrementTick+0x150>)
BaseType_t xSwitchRequired = pdFALSE;
 801eda2:	2500      	movs	r5, #0
		++uxPendedTicks;
 801eda4:	6813      	ldr	r3, [r2, #0]
 801eda6:	3301      	adds	r3, #1
 801eda8:	6013      	str	r3, [r2, #0]
		if( xYieldPending != pdFALSE )
 801edaa:	4b2c      	ldr	r3, [pc, #176]	@ (801ee5c <xTaskIncrementTick+0x154>)
 801edac:	681b      	ldr	r3, [r3, #0]
			xSwitchRequired = pdTRUE;
 801edae:	2b00      	cmp	r3, #0
}
 801edb0:	bf0c      	ite	eq
 801edb2:	4628      	moveq	r0, r5
 801edb4:	2001      	movne	r0, #1
 801edb6:	b003      	add	sp, #12
 801edb8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			taskSWITCH_DELAYED_LISTS();
 801edbc:	4b25      	ldr	r3, [pc, #148]	@ (801ee54 <xTaskIncrementTick+0x14c>)
 801edbe:	681a      	ldr	r2, [r3, #0]
 801edc0:	6812      	ldr	r2, [r2, #0]
 801edc2:	bb22      	cbnz	r2, 801ee0e <xTaskIncrementTick+0x106>
 801edc4:	4a26      	ldr	r2, [pc, #152]	@ (801ee60 <xTaskIncrementTick+0x158>)
 801edc6:	6818      	ldr	r0, [r3, #0]
 801edc8:	6811      	ldr	r1, [r2, #0]
 801edca:	6019      	str	r1, [r3, #0]
 801edcc:	4925      	ldr	r1, [pc, #148]	@ (801ee64 <xTaskIncrementTick+0x15c>)
 801edce:	6010      	str	r0, [r2, #0]
 801edd0:	680a      	ldr	r2, [r1, #0]
 801edd2:	3201      	adds	r2, #1
 801edd4:	600a      	str	r2, [r1, #0]

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 801edd6:	681a      	ldr	r2, [r3, #0]
 801edd8:	6812      	ldr	r2, [r2, #0]
 801edda:	bb62      	cbnz	r2, 801ee36 <xTaskIncrementTick+0x12e>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 801eddc:	4b1c      	ldr	r3, [pc, #112]	@ (801ee50 <xTaskIncrementTick+0x148>)
 801edde:	461a      	mov	r2, r3
 801ede0:	9301      	str	r3, [sp, #4]
 801ede2:	f04f 33ff 	mov.w	r3, #4294967295
 801ede6:	6013      	str	r3, [r2, #0]
 801ede8:	4613      	mov	r3, r2
 801edea:	e79c      	b.n	801ed26 <xTaskIncrementTick+0x1e>
BaseType_t xSwitchRequired = pdFALSE;
 801edec:	2500      	movs	r5, #0
 801edee:	f8df 9078 	ldr.w	r9, [pc, #120]	@ 801ee68 <xTaskIncrementTick+0x160>
 801edf2:	f8df a078 	ldr.w	sl, [pc, #120]	@ 801ee6c <xTaskIncrementTick+0x164>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 801edf6:	f8da 3000 	ldr.w	r3, [sl]
 801edfa:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 801edfc:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 801ee00:	009b      	lsls	r3, r3, #2
 801ee02:	f859 3003 	ldr.w	r3, [r9, r3]
				xSwitchRequired = pdTRUE;
 801ee06:	2b02      	cmp	r3, #2
 801ee08:	bf28      	it	cs
 801ee0a:	2501      	movcs	r5, #1
 801ee0c:	e7cd      	b.n	801edaa <xTaskIncrementTick+0xa2>
 801ee0e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801ee12:	b672      	cpsid	i
 801ee14:	f383 8811 	msr	BASEPRI, r3
 801ee18:	f3bf 8f6f 	isb	sy
 801ee1c:	f3bf 8f4f 	dsb	sy
 801ee20:	b662      	cpsie	i
			taskSWITCH_DELAYED_LISTS();
 801ee22:	e7fe      	b.n	801ee22 <xTaskIncrementTick+0x11a>
 801ee24:	f8df 9040 	ldr.w	r9, [pc, #64]	@ 801ee68 <xTaskIncrementTick+0x160>
 801ee28:	f8df a040 	ldr.w	sl, [pc, #64]	@ 801ee6c <xTaskIncrementTick+0x164>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 801ee2c:	f04f 33ff 	mov.w	r3, #4294967295
 801ee30:	9a01      	ldr	r2, [sp, #4]
 801ee32:	6013      	str	r3, [r2, #0]
					break;
 801ee34:	e7df      	b.n	801edf6 <xTaskIncrementTick+0xee>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 801ee36:	681b      	ldr	r3, [r3, #0]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 801ee38:	4a05      	ldr	r2, [pc, #20]	@ (801ee50 <xTaskIncrementTick+0x148>)
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 801ee3a:	68db      	ldr	r3, [r3, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 801ee3c:	9201      	str	r2, [sp, #4]
 801ee3e:	68db      	ldr	r3, [r3, #12]
 801ee40:	685b      	ldr	r3, [r3, #4]
 801ee42:	6013      	str	r3, [r2, #0]
 801ee44:	4613      	mov	r3, r2
	}
}
 801ee46:	e76e      	b.n	801ed26 <xTaskIncrementTick+0x1e>
 801ee48:	200032f0 	.word	0x200032f0
 801ee4c:	20003310 	.word	0x20003310
 801ee50:	200032f4 	.word	0x200032f4
 801ee54:	2000335c 	.word	0x2000335c
 801ee58:	20003304 	.word	0x20003304
 801ee5c:	20003300 	.word	0x20003300
 801ee60:	20003358 	.word	0x20003358
 801ee64:	200032fc 	.word	0x200032fc
 801ee68:	20003388 	.word	0x20003388
 801ee6c:	200037e8 	.word	0x200037e8
 801ee70:	2000330c 	.word	0x2000330c

0801ee74 <xTaskResumeAll.part.0>:
BaseType_t xTaskResumeAll( void )
 801ee74:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	taskENTER_CRITICAL();
 801ee78:	f000 fcfc 	bl	801f874 <vPortEnterCritical>
		--uxSchedulerSuspended;
 801ee7c:	4b3b      	ldr	r3, [pc, #236]	@ (801ef6c <xTaskResumeAll.part.0+0xf8>)
 801ee7e:	681a      	ldr	r2, [r3, #0]
 801ee80:	3a01      	subs	r2, #1
 801ee82:	601a      	str	r2, [r3, #0]
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 801ee84:	681b      	ldr	r3, [r3, #0]
 801ee86:	2b00      	cmp	r3, #0
 801ee88:	d15a      	bne.n	801ef40 <xTaskResumeAll.part.0+0xcc>
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 801ee8a:	4b39      	ldr	r3, [pc, #228]	@ (801ef70 <xTaskResumeAll.part.0+0xfc>)
 801ee8c:	681b      	ldr	r3, [r3, #0]
 801ee8e:	2b00      	cmp	r3, #0
 801ee90:	d056      	beq.n	801ef40 <xTaskResumeAll.part.0+0xcc>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 801ee92:	4d38      	ldr	r5, [pc, #224]	@ (801ef74 <xTaskResumeAll.part.0+0x100>)
 801ee94:	682b      	ldr	r3, [r5, #0]
 801ee96:	2b00      	cmp	r3, #0
 801ee98:	d065      	beq.n	801ef66 <xTaskResumeAll.part.0+0xf2>
 801ee9a:	4e37      	ldr	r6, [pc, #220]	@ (801ef78 <xTaskResumeAll.part.0+0x104>)
						xYieldPending = pdTRUE;
 801ee9c:	f04f 0a01 	mov.w	sl, #1
 801eea0:	f8df 80e8 	ldr.w	r8, [pc, #232]	@ 801ef8c <xTaskResumeAll.part.0+0x118>
 801eea4:	4f35      	ldr	r7, [pc, #212]	@ (801ef7c <xTaskResumeAll.part.0+0x108>)
 801eea6:	f8df 90e8 	ldr.w	r9, [pc, #232]	@ 801ef90 <xTaskResumeAll.part.0+0x11c>
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 801eeaa:	68eb      	ldr	r3, [r5, #12]
 801eeac:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 801eeae:	f104 0b04 	add.w	fp, r4, #4
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 801eeb2:	f104 0018 	add.w	r0, r4, #24
 801eeb6:	f7fe fe8b 	bl	801dbd0 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 801eeba:	4658      	mov	r0, fp
 801eebc:	f7fe fe88 	bl	801dbd0 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 801eec0:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
 801eec2:	6832      	ldr	r2, [r6, #0]
 801eec4:	4659      	mov	r1, fp
 801eec6:	eb03 0083 	add.w	r0, r3, r3, lsl #2
 801eeca:	4293      	cmp	r3, r2
 801eecc:	eb08 0080 	add.w	r0, r8, r0, lsl #2
 801eed0:	d900      	bls.n	801eed4 <xTaskResumeAll.part.0+0x60>
 801eed2:	6033      	str	r3, [r6, #0]
 801eed4:	f7fe fe56 	bl	801db84 <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 801eed8:	683b      	ldr	r3, [r7, #0]
 801eeda:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
 801eedc:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 801eede:	429a      	cmp	r2, r3
 801eee0:	d334      	bcc.n	801ef4c <xTaskResumeAll.part.0+0xd8>
						xYieldPending = pdTRUE;
 801eee2:	f8c9 a000 	str.w	sl, [r9]
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 801eee6:	682b      	ldr	r3, [r5, #0]
 801eee8:	2b00      	cmp	r3, #0
 801eeea:	d1de      	bne.n	801eeaa <xTaskResumeAll.part.0+0x36>
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 801eeec:	4b24      	ldr	r3, [pc, #144]	@ (801ef80 <xTaskResumeAll.part.0+0x10c>)
 801eeee:	681a      	ldr	r2, [r3, #0]
 801eef0:	6812      	ldr	r2, [r2, #0]
 801eef2:	2a00      	cmp	r2, #0
 801eef4:	d032      	beq.n	801ef5c <xTaskResumeAll.part.0+0xe8>
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 801eef6:	681a      	ldr	r2, [r3, #0]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 801eef8:	4b22      	ldr	r3, [pc, #136]	@ (801ef84 <xTaskResumeAll.part.0+0x110>)
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 801eefa:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 801eefc:	68d2      	ldr	r2, [r2, #12]
 801eefe:	6852      	ldr	r2, [r2, #4]
 801ef00:	601a      	str	r2, [r3, #0]
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 801ef02:	4e21      	ldr	r6, [pc, #132]	@ (801ef88 <xTaskResumeAll.part.0+0x114>)
 801ef04:	6834      	ldr	r4, [r6, #0]
					if( uxPendedCounts > ( UBaseType_t ) 0U )
 801ef06:	b144      	cbz	r4, 801ef1a <xTaskResumeAll.part.0+0xa6>
								xYieldPending = pdTRUE;
 801ef08:	2501      	movs	r5, #1
							if( xTaskIncrementTick() != pdFALSE )
 801ef0a:	f7ff fefd 	bl	801ed08 <xTaskIncrementTick>
 801ef0e:	b108      	cbz	r0, 801ef14 <xTaskResumeAll.part.0+0xa0>
								xYieldPending = pdTRUE;
 801ef10:	f8c9 5000 	str.w	r5, [r9]
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 801ef14:	3c01      	subs	r4, #1
 801ef16:	d1f8      	bne.n	801ef0a <xTaskResumeAll.part.0+0x96>
						uxPendedTicks = 0;
 801ef18:	6034      	str	r4, [r6, #0]
				if( xYieldPending != pdFALSE )
 801ef1a:	f8d9 3000 	ldr.w	r3, [r9]
 801ef1e:	b17b      	cbz	r3, 801ef40 <xTaskResumeAll.part.0+0xcc>
					taskYIELD_IF_USING_PREEMPTION();
 801ef20:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 801ef24:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 801ef28:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 801ef2c:	f3bf 8f4f 	dsb	sy
 801ef30:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
 801ef34:	2401      	movs	r4, #1
	taskEXIT_CRITICAL();
 801ef36:	f000 fcc3 	bl	801f8c0 <vPortExitCritical>
}
 801ef3a:	4620      	mov	r0, r4
 801ef3c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
BaseType_t xAlreadyYielded = pdFALSE;
 801ef40:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 801ef42:	f000 fcbd 	bl	801f8c0 <vPortExitCritical>
}
 801ef46:	4620      	mov	r0, r4
 801ef48:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 801ef4c:	682b      	ldr	r3, [r5, #0]
 801ef4e:	2b00      	cmp	r3, #0
 801ef50:	d1ab      	bne.n	801eeaa <xTaskResumeAll.part.0+0x36>
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 801ef52:	4b0b      	ldr	r3, [pc, #44]	@ (801ef80 <xTaskResumeAll.part.0+0x10c>)
 801ef54:	681a      	ldr	r2, [r3, #0]
 801ef56:	6812      	ldr	r2, [r2, #0]
 801ef58:	2a00      	cmp	r2, #0
 801ef5a:	d1cc      	bne.n	801eef6 <xTaskResumeAll.part.0+0x82>
		xNextTaskUnblockTime = portMAX_DELAY;
 801ef5c:	4b09      	ldr	r3, [pc, #36]	@ (801ef84 <xTaskResumeAll.part.0+0x110>)
 801ef5e:	f04f 32ff 	mov.w	r2, #4294967295
 801ef62:	601a      	str	r2, [r3, #0]
 801ef64:	e7cd      	b.n	801ef02 <xTaskResumeAll.part.0+0x8e>
 801ef66:	f8df 9028 	ldr.w	r9, [pc, #40]	@ 801ef90 <xTaskResumeAll.part.0+0x11c>
 801ef6a:	e7ca      	b.n	801ef02 <xTaskResumeAll.part.0+0x8e>
 801ef6c:	200032f0 	.word	0x200032f0
 801ef70:	20003314 	.word	0x20003314
 801ef74:	20003344 	.word	0x20003344
 801ef78:	2000330c 	.word	0x2000330c
 801ef7c:	200037e8 	.word	0x200037e8
 801ef80:	2000335c 	.word	0x2000335c
 801ef84:	200032f4 	.word	0x200032f4
 801ef88:	20003304 	.word	0x20003304
 801ef8c:	20003388 	.word	0x20003388
 801ef90:	20003300 	.word	0x20003300

0801ef94 <xTaskResumeAll>:
	configASSERT( uxSchedulerSuspended );
 801ef94:	4b07      	ldr	r3, [pc, #28]	@ (801efb4 <xTaskResumeAll+0x20>)
 801ef96:	681b      	ldr	r3, [r3, #0]
 801ef98:	b953      	cbnz	r3, 801efb0 <xTaskResumeAll+0x1c>
 801ef9a:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801ef9e:	b672      	cpsid	i
 801efa0:	f383 8811 	msr	BASEPRI, r3
 801efa4:	f3bf 8f6f 	isb	sy
 801efa8:	f3bf 8f4f 	dsb	sy
 801efac:	b662      	cpsie	i
 801efae:	e7fe      	b.n	801efae <xTaskResumeAll+0x1a>
 801efb0:	f7ff bf60 	b.w	801ee74 <xTaskResumeAll.part.0>
 801efb4:	200032f0 	.word	0x200032f0

0801efb8 <vTaskDelay>:
	{
 801efb8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		if( xTicksToDelay > ( TickType_t ) 0U )
 801efba:	b950      	cbnz	r0, 801efd2 <vTaskDelay+0x1a>
			portYIELD_WITHIN_API();
 801efbc:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 801efc0:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 801efc4:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 801efc8:	f3bf 8f4f 	dsb	sy
 801efcc:	f3bf 8f6f 	isb	sy
	}
 801efd0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			configASSERT( uxSchedulerSuspended == 0 );
 801efd2:	4d20      	ldr	r5, [pc, #128]	@ (801f054 <vTaskDelay+0x9c>)
 801efd4:	682b      	ldr	r3, [r5, #0]
 801efd6:	b153      	cbz	r3, 801efee <vTaskDelay+0x36>
 801efd8:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801efdc:	b672      	cpsid	i
 801efde:	f383 8811 	msr	BASEPRI, r3
 801efe2:	f3bf 8f6f 	isb	sy
 801efe6:	f3bf 8f4f 	dsb	sy
 801efea:	b662      	cpsie	i
 801efec:	e7fe      	b.n	801efec <vTaskDelay+0x34>
	++uxSchedulerSuspended;
 801efee:	682b      	ldr	r3, [r5, #0]
 801eff0:	4604      	mov	r4, r0
 801eff2:	3301      	adds	r3, #1
 801eff4:	602b      	str	r3, [r5, #0]
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 801eff6:	4b18      	ldr	r3, [pc, #96]	@ (801f058 <vTaskDelay+0xa0>)
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 801eff8:	4e18      	ldr	r6, [pc, #96]	@ (801f05c <vTaskDelay+0xa4>)
const TickType_t xConstTickCount = xTickCount;
 801effa:	681f      	ldr	r7, [r3, #0]
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 801effc:	6830      	ldr	r0, [r6, #0]
 801effe:	3004      	adds	r0, #4
 801f000:	f7fe fde6 	bl	801dbd0 <uxListRemove>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
 801f004:	19e4      	adds	r4, r4, r7

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 801f006:	6833      	ldr	r3, [r6, #0]
 801f008:	605c      	str	r4, [r3, #4]

			if( xTimeToWake < xConstTickCount )
 801f00a:	d317      	bcc.n	801f03c <vTaskDelay+0x84>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 801f00c:	4b14      	ldr	r3, [pc, #80]	@ (801f060 <vTaskDelay+0xa8>)
 801f00e:	6818      	ldr	r0, [r3, #0]
 801f010:	6831      	ldr	r1, [r6, #0]
 801f012:	3104      	adds	r1, #4
 801f014:	f7fe fdc4 	bl	801dba0 <vListInsert>
	configASSERT( uxSchedulerSuspended );
 801f018:	682b      	ldr	r3, [r5, #0]
 801f01a:	b953      	cbnz	r3, 801f032 <vTaskDelay+0x7a>
 801f01c:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801f020:	b672      	cpsid	i
 801f022:	f383 8811 	msr	BASEPRI, r3
 801f026:	f3bf 8f6f 	isb	sy
 801f02a:	f3bf 8f4f 	dsb	sy
 801f02e:	b662      	cpsie	i
 801f030:	e7fe      	b.n	801f030 <vTaskDelay+0x78>
 801f032:	f7ff ff1f 	bl	801ee74 <xTaskResumeAll.part.0>
		if( xAlreadyYielded == pdFALSE )
 801f036:	2800      	cmp	r0, #0
 801f038:	d0c0      	beq.n	801efbc <vTaskDelay+0x4>
	}
 801f03a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 801f03c:	4b09      	ldr	r3, [pc, #36]	@ (801f064 <vTaskDelay+0xac>)
 801f03e:	6818      	ldr	r0, [r3, #0]
 801f040:	6831      	ldr	r1, [r6, #0]
 801f042:	3104      	adds	r1, #4
 801f044:	f7fe fdac 	bl	801dba0 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
 801f048:	4b07      	ldr	r3, [pc, #28]	@ (801f068 <vTaskDelay+0xb0>)
 801f04a:	681a      	ldr	r2, [r3, #0]
 801f04c:	4294      	cmp	r4, r2
 801f04e:	d2e3      	bcs.n	801f018 <vTaskDelay+0x60>
				{
					xNextTaskUnblockTime = xTimeToWake;
 801f050:	601c      	str	r4, [r3, #0]
 801f052:	e7e1      	b.n	801f018 <vTaskDelay+0x60>
 801f054:	200032f0 	.word	0x200032f0
 801f058:	20003310 	.word	0x20003310
 801f05c:	200037e8 	.word	0x200037e8
 801f060:	20003358 	.word	0x20003358
 801f064:	2000335c 	.word	0x2000335c
 801f068:	200032f4 	.word	0x200032f4

0801f06c <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 801f06c:	4b04      	ldr	r3, [pc, #16]	@ (801f080 <vTaskSwitchContext+0x14>)
 801f06e:	681b      	ldr	r3, [r3, #0]
 801f070:	b11b      	cbz	r3, 801f07a <vTaskSwitchContext+0xe>
		xYieldPending = pdTRUE;
 801f072:	4b04      	ldr	r3, [pc, #16]	@ (801f084 <vTaskSwitchContext+0x18>)
 801f074:	2201      	movs	r2, #1
 801f076:	601a      	str	r2, [r3, #0]
}
 801f078:	4770      	bx	lr
 801f07a:	f7ff bba9 	b.w	801e7d0 <vTaskSwitchContext.part.0>
 801f07e:	bf00      	nop
 801f080:	200032f0 	.word	0x200032f0
 801f084:	20003300 	.word	0x20003300

0801f088 <vTaskPlaceOnEventList>:
	configASSERT( pxEventList );
 801f088:	b1f0      	cbz	r0, 801f0c8 <vTaskPlaceOnEventList+0x40>
{
 801f08a:	b570      	push	{r4, r5, r6, lr}
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 801f08c:	4d1b      	ldr	r5, [pc, #108]	@ (801f0fc <vTaskPlaceOnEventList+0x74>)
 801f08e:	460c      	mov	r4, r1
 801f090:	6829      	ldr	r1, [r5, #0]
 801f092:	3118      	adds	r1, #24
 801f094:	f7fe fd84 	bl	801dba0 <vListInsert>
const TickType_t xConstTickCount = xTickCount;
 801f098:	4b19      	ldr	r3, [pc, #100]	@ (801f100 <vTaskPlaceOnEventList+0x78>)
 801f09a:	681e      	ldr	r6, [r3, #0]
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 801f09c:	6828      	ldr	r0, [r5, #0]
 801f09e:	3004      	adds	r0, #4
 801f0a0:	f7fe fd96 	bl	801dbd0 <uxListRemove>
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 801f0a4:	1c63      	adds	r3, r4, #1
 801f0a6:	d022      	beq.n	801f0ee <vTaskPlaceOnEventList+0x66>
			xTimeToWake = xConstTickCount + xTicksToWait;
 801f0a8:	19a4      	adds	r4, r4, r6
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 801f0aa:	682b      	ldr	r3, [r5, #0]
 801f0ac:	605c      	str	r4, [r3, #4]
			if( xTimeToWake < xConstTickCount )
 801f0ae:	d216      	bcs.n	801f0de <vTaskPlaceOnEventList+0x56>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 801f0b0:	4b14      	ldr	r3, [pc, #80]	@ (801f104 <vTaskPlaceOnEventList+0x7c>)
 801f0b2:	6818      	ldr	r0, [r3, #0]
 801f0b4:	6829      	ldr	r1, [r5, #0]
 801f0b6:	3104      	adds	r1, #4
 801f0b8:	f7fe fd72 	bl	801dba0 <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
 801f0bc:	4b12      	ldr	r3, [pc, #72]	@ (801f108 <vTaskPlaceOnEventList+0x80>)
 801f0be:	681a      	ldr	r2, [r3, #0]
 801f0c0:	4294      	cmp	r4, r2
 801f0c2:	d200      	bcs.n	801f0c6 <vTaskPlaceOnEventList+0x3e>
					xNextTaskUnblockTime = xTimeToWake;
 801f0c4:	601c      	str	r4, [r3, #0]
}
 801f0c6:	bd70      	pop	{r4, r5, r6, pc}
 801f0c8:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801f0cc:	b672      	cpsid	i
 801f0ce:	f383 8811 	msr	BASEPRI, r3
 801f0d2:	f3bf 8f6f 	isb	sy
 801f0d6:	f3bf 8f4f 	dsb	sy
 801f0da:	b662      	cpsie	i
	configASSERT( pxEventList );
 801f0dc:	e7fe      	b.n	801f0dc <vTaskPlaceOnEventList+0x54>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 801f0de:	4b0b      	ldr	r3, [pc, #44]	@ (801f10c <vTaskPlaceOnEventList+0x84>)
 801f0e0:	6818      	ldr	r0, [r3, #0]
 801f0e2:	6829      	ldr	r1, [r5, #0]
}
 801f0e4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 801f0e8:	3104      	adds	r1, #4
 801f0ea:	f7fe bd59 	b.w	801dba0 <vListInsert>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 801f0ee:	6829      	ldr	r1, [r5, #0]
 801f0f0:	4807      	ldr	r0, [pc, #28]	@ (801f110 <vTaskPlaceOnEventList+0x88>)
 801f0f2:	3104      	adds	r1, #4
}
 801f0f4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 801f0f8:	f7fe bd44 	b.w	801db84 <vListInsertEnd>
 801f0fc:	200037e8 	.word	0x200037e8
 801f100:	20003310 	.word	0x20003310
 801f104:	2000335c 	.word	0x2000335c
 801f108:	200032f4 	.word	0x200032f4
 801f10c:	20003358 	.word	0x20003358
 801f110:	20003318 	.word	0x20003318

0801f114 <vTaskPlaceOnEventListRestricted>:
		configASSERT( pxEventList );
 801f114:	b358      	cbz	r0, 801f16e <vTaskPlaceOnEventListRestricted+0x5a>
	{
 801f116:	b570      	push	{r4, r5, r6, lr}
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 801f118:	4e1e      	ldr	r6, [pc, #120]	@ (801f194 <vTaskPlaceOnEventListRestricted+0x80>)
 801f11a:	460c      	mov	r4, r1
 801f11c:	4615      	mov	r5, r2
 801f11e:	6831      	ldr	r1, [r6, #0]
 801f120:	3118      	adds	r1, #24
 801f122:	f7fe fd2f 	bl	801db84 <vListInsertEnd>
		if( xWaitIndefinitely != pdFALSE )
 801f126:	b165      	cbz	r5, 801f142 <vTaskPlaceOnEventListRestricted+0x2e>
const TickType_t xConstTickCount = xTickCount;
 801f128:	4b1b      	ldr	r3, [pc, #108]	@ (801f198 <vTaskPlaceOnEventListRestricted+0x84>)
 801f12a:	681b      	ldr	r3, [r3, #0]
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 801f12c:	6830      	ldr	r0, [r6, #0]
 801f12e:	3004      	adds	r0, #4
 801f130:	f7fe fd4e 	bl	801dbd0 <uxListRemove>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 801f134:	6831      	ldr	r1, [r6, #0]
 801f136:	4819      	ldr	r0, [pc, #100]	@ (801f19c <vTaskPlaceOnEventListRestricted+0x88>)
 801f138:	3104      	adds	r1, #4
	}
 801f13a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 801f13e:	f7fe bd21 	b.w	801db84 <vListInsertEnd>
const TickType_t xConstTickCount = xTickCount;
 801f142:	4b15      	ldr	r3, [pc, #84]	@ (801f198 <vTaskPlaceOnEventListRestricted+0x84>)
 801f144:	681d      	ldr	r5, [r3, #0]
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 801f146:	6830      	ldr	r0, [r6, #0]
 801f148:	3004      	adds	r0, #4
 801f14a:	f7fe fd41 	bl	801dbd0 <uxListRemove>
			xTimeToWake = xConstTickCount + xTicksToWait;
 801f14e:	1964      	adds	r4, r4, r5
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 801f150:	6833      	ldr	r3, [r6, #0]
 801f152:	605c      	str	r4, [r3, #4]
			if( xTimeToWake < xConstTickCount )
 801f154:	d216      	bcs.n	801f184 <vTaskPlaceOnEventListRestricted+0x70>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 801f156:	4b12      	ldr	r3, [pc, #72]	@ (801f1a0 <vTaskPlaceOnEventListRestricted+0x8c>)
 801f158:	6818      	ldr	r0, [r3, #0]
 801f15a:	6831      	ldr	r1, [r6, #0]
 801f15c:	3104      	adds	r1, #4
 801f15e:	f7fe fd1f 	bl	801dba0 <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
 801f162:	4b10      	ldr	r3, [pc, #64]	@ (801f1a4 <vTaskPlaceOnEventListRestricted+0x90>)
 801f164:	681a      	ldr	r2, [r3, #0]
 801f166:	4294      	cmp	r4, r2
 801f168:	d200      	bcs.n	801f16c <vTaskPlaceOnEventListRestricted+0x58>
					xNextTaskUnblockTime = xTimeToWake;
 801f16a:	601c      	str	r4, [r3, #0]
	}
 801f16c:	bd70      	pop	{r4, r5, r6, pc}
 801f16e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801f172:	b672      	cpsid	i
 801f174:	f383 8811 	msr	BASEPRI, r3
 801f178:	f3bf 8f6f 	isb	sy
 801f17c:	f3bf 8f4f 	dsb	sy
 801f180:	b662      	cpsie	i
		configASSERT( pxEventList );
 801f182:	e7fe      	b.n	801f182 <vTaskPlaceOnEventListRestricted+0x6e>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 801f184:	4b08      	ldr	r3, [pc, #32]	@ (801f1a8 <vTaskPlaceOnEventListRestricted+0x94>)
 801f186:	6818      	ldr	r0, [r3, #0]
 801f188:	6831      	ldr	r1, [r6, #0]
	}
 801f18a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 801f18e:	3104      	adds	r1, #4
 801f190:	f7fe bd06 	b.w	801dba0 <vListInsert>
 801f194:	200037e8 	.word	0x200037e8
 801f198:	20003310 	.word	0x20003310
 801f19c:	20003318 	.word	0x20003318
 801f1a0:	2000335c 	.word	0x2000335c
 801f1a4:	200032f4 	.word	0x200032f4
 801f1a8:	20003358 	.word	0x20003358

0801f1ac <xTaskRemoveFromEventList>:
{
 801f1ac:	b538      	push	{r3, r4, r5, lr}
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 801f1ae:	68c3      	ldr	r3, [r0, #12]
 801f1b0:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
 801f1b2:	b34c      	cbz	r4, 801f208 <xTaskRemoveFromEventList+0x5c>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 801f1b4:	f104 0518 	add.w	r5, r4, #24
 801f1b8:	4628      	mov	r0, r5
 801f1ba:	f7fe fd09 	bl	801dbd0 <uxListRemove>
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 801f1be:	4b19      	ldr	r3, [pc, #100]	@ (801f224 <xTaskRemoveFromEventList+0x78>)
 801f1c0:	681b      	ldr	r3, [r3, #0]
 801f1c2:	b173      	cbz	r3, 801f1e2 <xTaskRemoveFromEventList+0x36>
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 801f1c4:	4629      	mov	r1, r5
 801f1c6:	4818      	ldr	r0, [pc, #96]	@ (801f228 <xTaskRemoveFromEventList+0x7c>)
 801f1c8:	f7fe fcdc 	bl	801db84 <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 801f1cc:	4b17      	ldr	r3, [pc, #92]	@ (801f22c <xTaskRemoveFromEventList+0x80>)
 801f1ce:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
 801f1d0:	681b      	ldr	r3, [r3, #0]
 801f1d2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 801f1d4:	429a      	cmp	r2, r3
 801f1d6:	d922      	bls.n	801f21e <xTaskRemoveFromEventList+0x72>
		xYieldPending = pdTRUE;
 801f1d8:	2301      	movs	r3, #1
 801f1da:	4a15      	ldr	r2, [pc, #84]	@ (801f230 <xTaskRemoveFromEventList+0x84>)
		xReturn = pdTRUE;
 801f1dc:	4618      	mov	r0, r3
		xYieldPending = pdTRUE;
 801f1de:	6013      	str	r3, [r2, #0]
}
 801f1e0:	bd38      	pop	{r3, r4, r5, pc}
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 801f1e2:	1d25      	adds	r5, r4, #4
 801f1e4:	4628      	mov	r0, r5
 801f1e6:	f7fe fcf3 	bl	801dbd0 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 801f1ea:	4b12      	ldr	r3, [pc, #72]	@ (801f234 <xTaskRemoveFromEventList+0x88>)
 801f1ec:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
 801f1ee:	681a      	ldr	r2, [r3, #0]
 801f1f0:	4290      	cmp	r0, r2
 801f1f2:	d900      	bls.n	801f1f6 <xTaskRemoveFromEventList+0x4a>
 801f1f4:	6018      	str	r0, [r3, #0]
 801f1f6:	4b10      	ldr	r3, [pc, #64]	@ (801f238 <xTaskRemoveFromEventList+0x8c>)
 801f1f8:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 801f1fc:	4629      	mov	r1, r5
 801f1fe:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 801f202:	f7fe fcbf 	bl	801db84 <vListInsertEnd>
 801f206:	e7e1      	b.n	801f1cc <xTaskRemoveFromEventList+0x20>
 801f208:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801f20c:	b672      	cpsid	i
 801f20e:	f383 8811 	msr	BASEPRI, r3
 801f212:	f3bf 8f6f 	isb	sy
 801f216:	f3bf 8f4f 	dsb	sy
 801f21a:	b662      	cpsie	i
	configASSERT( pxUnblockedTCB );
 801f21c:	e7fe      	b.n	801f21c <xTaskRemoveFromEventList+0x70>
		xReturn = pdFALSE;
 801f21e:	2000      	movs	r0, #0
}
 801f220:	bd38      	pop	{r3, r4, r5, pc}
 801f222:	bf00      	nop
 801f224:	200032f0 	.word	0x200032f0
 801f228:	20003344 	.word	0x20003344
 801f22c:	200037e8 	.word	0x200037e8
 801f230:	20003300 	.word	0x20003300
 801f234:	2000330c 	.word	0x2000330c
 801f238:	20003388 	.word	0x20003388

0801f23c <vTaskInternalSetTimeOutState>:
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 801f23c:	4a03      	ldr	r2, [pc, #12]	@ (801f24c <vTaskInternalSetTimeOutState+0x10>)
	pxTimeOut->xTimeOnEntering = xTickCount;
 801f23e:	4b04      	ldr	r3, [pc, #16]	@ (801f250 <vTaskInternalSetTimeOutState+0x14>)
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 801f240:	6812      	ldr	r2, [r2, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 801f242:	681b      	ldr	r3, [r3, #0]
 801f244:	e9c0 2300 	strd	r2, r3, [r0]
}
 801f248:	4770      	bx	lr
 801f24a:	bf00      	nop
 801f24c:	200032fc 	.word	0x200032fc
 801f250:	20003310 	.word	0x20003310

0801f254 <xTaskCheckForTimeOut>:
{
 801f254:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	configASSERT( pxTimeOut );
 801f256:	b318      	cbz	r0, 801f2a0 <xTaskCheckForTimeOut+0x4c>
	configASSERT( pxTicksToWait );
 801f258:	460d      	mov	r5, r1
 801f25a:	b1b1      	cbz	r1, 801f28a <xTaskCheckForTimeOut+0x36>
 801f25c:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
 801f25e:	f000 fb09 	bl	801f874 <vPortEnterCritical>
			if( *pxTicksToWait == portMAX_DELAY )
 801f262:	682b      	ldr	r3, [r5, #0]
		const TickType_t xConstTickCount = xTickCount;
 801f264:	4a1c      	ldr	r2, [pc, #112]	@ (801f2d8 <xTaskCheckForTimeOut+0x84>)
			if( *pxTicksToWait == portMAX_DELAY )
 801f266:	1c58      	adds	r0, r3, #1
		const TickType_t xConstTickCount = xTickCount;
 801f268:	6811      	ldr	r1, [r2, #0]
			if( *pxTicksToWait == portMAX_DELAY )
 801f26a:	d030      	beq.n	801f2ce <xTaskCheckForTimeOut+0x7a>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 801f26c:	f8df c06c 	ldr.w	ip, [pc, #108]	@ 801f2dc <xTaskCheckForTimeOut+0x88>
 801f270:	6826      	ldr	r6, [r4, #0]
 801f272:	f8dc 7000 	ldr.w	r7, [ip]
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 801f276:	6860      	ldr	r0, [r4, #4]
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 801f278:	42be      	cmp	r6, r7
 801f27a:	d01c      	beq.n	801f2b6 <xTaskCheckForTimeOut+0x62>
 801f27c:	4288      	cmp	r0, r1
 801f27e:	d81a      	bhi.n	801f2b6 <xTaskCheckForTimeOut+0x62>
			xReturn = pdTRUE;
 801f280:	2401      	movs	r4, #1
	taskEXIT_CRITICAL();
 801f282:	f000 fb1d 	bl	801f8c0 <vPortExitCritical>
}
 801f286:	4620      	mov	r0, r4
 801f288:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801f28a:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801f28e:	b672      	cpsid	i
 801f290:	f383 8811 	msr	BASEPRI, r3
 801f294:	f3bf 8f6f 	isb	sy
 801f298:	f3bf 8f4f 	dsb	sy
 801f29c:	b662      	cpsie	i
	configASSERT( pxTicksToWait );
 801f29e:	e7fe      	b.n	801f29e <xTaskCheckForTimeOut+0x4a>
 801f2a0:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801f2a4:	b672      	cpsid	i
 801f2a6:	f383 8811 	msr	BASEPRI, r3
 801f2aa:	f3bf 8f6f 	isb	sy
 801f2ae:	f3bf 8f4f 	dsb	sy
 801f2b2:	b662      	cpsie	i
	configASSERT( pxTimeOut );
 801f2b4:	e7fe      	b.n	801f2b4 <xTaskCheckForTimeOut+0x60>
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 801f2b6:	eba1 0e00 	sub.w	lr, r1, r0
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 801f2ba:	4573      	cmp	r3, lr
 801f2bc:	d909      	bls.n	801f2d2 <xTaskCheckForTimeOut+0x7e>
			*pxTicksToWait -= xElapsedTime;
 801f2be:	1a5b      	subs	r3, r3, r1
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 801f2c0:	f8dc 1000 	ldr.w	r1, [ip]
	pxTimeOut->xTimeOnEntering = xTickCount;
 801f2c4:	6812      	ldr	r2, [r2, #0]
			*pxTicksToWait -= xElapsedTime;
 801f2c6:	4403      	add	r3, r0
 801f2c8:	602b      	str	r3, [r5, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 801f2ca:	e9c4 1200 	strd	r1, r2, [r4]
				xReturn = pdFALSE;
 801f2ce:	2400      	movs	r4, #0
 801f2d0:	e7d7      	b.n	801f282 <xTaskCheckForTimeOut+0x2e>
			*pxTicksToWait = 0;
 801f2d2:	2300      	movs	r3, #0
 801f2d4:	602b      	str	r3, [r5, #0]
			xReturn = pdTRUE;
 801f2d6:	e7d3      	b.n	801f280 <xTaskCheckForTimeOut+0x2c>
 801f2d8:	20003310 	.word	0x20003310
 801f2dc:	200032fc 	.word	0x200032fc

0801f2e0 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
 801f2e0:	4b01      	ldr	r3, [pc, #4]	@ (801f2e8 <vTaskMissedYield+0x8>)
 801f2e2:	2201      	movs	r2, #1
 801f2e4:	601a      	str	r2, [r3, #0]
}
 801f2e6:	4770      	bx	lr
 801f2e8:	20003300 	.word	0x20003300

0801f2ec <xTaskGetSchedulerState>:
		if( xSchedulerRunning == pdFALSE )
 801f2ec:	4b05      	ldr	r3, [pc, #20]	@ (801f304 <xTaskGetSchedulerState+0x18>)
 801f2ee:	681b      	ldr	r3, [r3, #0]
 801f2f0:	b133      	cbz	r3, 801f300 <xTaskGetSchedulerState+0x14>
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 801f2f2:	4b05      	ldr	r3, [pc, #20]	@ (801f308 <xTaskGetSchedulerState+0x1c>)
 801f2f4:	6818      	ldr	r0, [r3, #0]
 801f2f6:	fab0 f080 	clz	r0, r0
 801f2fa:	0940      	lsrs	r0, r0, #5
 801f2fc:	0040      	lsls	r0, r0, #1
 801f2fe:	4770      	bx	lr
			xReturn = taskSCHEDULER_NOT_STARTED;
 801f300:	2001      	movs	r0, #1
	}
 801f302:	4770      	bx	lr
 801f304:	20003308 	.word	0x20003308
 801f308:	200032f0 	.word	0x200032f0

0801f30c <xTaskPriorityDisinherit>:
		if( pxMutexHolder != NULL )
 801f30c:	b328      	cbz	r0, 801f35a <xTaskPriorityDisinherit+0x4e>
	{
 801f30e:	b538      	push	{r3, r4, r5, lr}
			configASSERT( pxTCB == pxCurrentTCB );
 801f310:	4b1f      	ldr	r3, [pc, #124]	@ (801f390 <xTaskPriorityDisinherit+0x84>)
 801f312:	681c      	ldr	r4, [r3, #0]
 801f314:	4284      	cmp	r4, r0
 801f316:	d00a      	beq.n	801f32e <xTaskPriorityDisinherit+0x22>
 801f318:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801f31c:	b672      	cpsid	i
 801f31e:	f383 8811 	msr	BASEPRI, r3
 801f322:	f3bf 8f6f 	isb	sy
 801f326:	f3bf 8f4f 	dsb	sy
 801f32a:	b662      	cpsie	i
 801f32c:	e7fe      	b.n	801f32c <xTaskPriorityDisinherit+0x20>
			configASSERT( pxTCB->uxMutexesHeld );
 801f32e:	6d23      	ldr	r3, [r4, #80]	@ 0x50
 801f330:	b143      	cbz	r3, 801f344 <xTaskPriorityDisinherit+0x38>
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 801f332:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
			( pxTCB->uxMutexesHeld )--;
 801f334:	3b01      	subs	r3, #1
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 801f336:	6ce2      	ldr	r2, [r4, #76]	@ 0x4c
			( pxTCB->uxMutexesHeld )--;
 801f338:	6523      	str	r3, [r4, #80]	@ 0x50
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 801f33a:	4291      	cmp	r1, r2
 801f33c:	d000      	beq.n	801f340 <xTaskPriorityDisinherit+0x34>
 801f33e:	b173      	cbz	r3, 801f35e <xTaskPriorityDisinherit+0x52>
	BaseType_t xReturn = pdFALSE;
 801f340:	2000      	movs	r0, #0
	}
 801f342:	bd38      	pop	{r3, r4, r5, pc}
 801f344:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801f348:	b672      	cpsid	i
 801f34a:	f383 8811 	msr	BASEPRI, r3
 801f34e:	f3bf 8f6f 	isb	sy
 801f352:	f3bf 8f4f 	dsb	sy
 801f356:	b662      	cpsie	i
			configASSERT( pxTCB->uxMutexesHeld );
 801f358:	e7fe      	b.n	801f358 <xTaskPriorityDisinherit+0x4c>
	BaseType_t xReturn = pdFALSE;
 801f35a:	2000      	movs	r0, #0
	}
 801f35c:	4770      	bx	lr
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 801f35e:	1d25      	adds	r5, r4, #4
 801f360:	4628      	mov	r0, r5
 801f362:	f7fe fc35 	bl	801dbd0 <uxListRemove>
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 801f366:	6ce0      	ldr	r0, [r4, #76]	@ 0x4c
					prvAddTaskToReadyList( pxTCB );
 801f368:	4b0a      	ldr	r3, [pc, #40]	@ (801f394 <xTaskPriorityDisinherit+0x88>)
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 801f36a:	f1c0 0238 	rsb	r2, r0, #56	@ 0x38
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 801f36e:	62e0      	str	r0, [r4, #44]	@ 0x2c
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 801f370:	61a2      	str	r2, [r4, #24]
					prvAddTaskToReadyList( pxTCB );
 801f372:	681a      	ldr	r2, [r3, #0]
 801f374:	4290      	cmp	r0, r2
 801f376:	d900      	bls.n	801f37a <xTaskPriorityDisinherit+0x6e>
 801f378:	6018      	str	r0, [r3, #0]
 801f37a:	4b07      	ldr	r3, [pc, #28]	@ (801f398 <xTaskPriorityDisinherit+0x8c>)
 801f37c:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 801f380:	4629      	mov	r1, r5
 801f382:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 801f386:	f7fe fbfd 	bl	801db84 <vListInsertEnd>
					xReturn = pdTRUE;
 801f38a:	2001      	movs	r0, #1
	}
 801f38c:	bd38      	pop	{r3, r4, r5, pc}
 801f38e:	bf00      	nop
 801f390:	200037e8 	.word	0x200037e8
 801f394:	2000330c 	.word	0x2000330c
 801f398:	20003388 	.word	0x20003388

0801f39c <prvSwitchTimerLists>:
	}
}
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( void )
{
 801f39c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801f3a0:	4e22      	ldr	r6, [pc, #136]	@ (801f42c <prvSwitchTimerLists+0x90>)
 801f3a2:	b084      	sub	sp, #16

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 801f3a4:	e00d      	b.n	801f3c2 <prvSwitchTimerLists+0x26>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 801f3a6:	68db      	ldr	r3, [r3, #12]

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 801f3a8:	68dc      	ldr	r4, [r3, #12]
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 801f3aa:	681f      	ldr	r7, [r3, #0]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 801f3ac:	1d25      	adds	r5, r4, #4
 801f3ae:	4628      	mov	r0, r5
 801f3b0:	f7fe fc0e 	bl	801dbd0 <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 801f3b4:	6a23      	ldr	r3, [r4, #32]
 801f3b6:	4620      	mov	r0, r4
 801f3b8:	4798      	blx	r3

		if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 801f3ba:	f894 3028 	ldrb.w	r3, [r4, #40]	@ 0x28
 801f3be:	075b      	lsls	r3, r3, #29
 801f3c0:	d40a      	bmi.n	801f3d8 <prvSwitchTimerLists+0x3c>
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 801f3c2:	6833      	ldr	r3, [r6, #0]
 801f3c4:	681a      	ldr	r2, [r3, #0]
 801f3c6:	2a00      	cmp	r2, #0
 801f3c8:	d1ed      	bne.n	801f3a6 <prvSwitchTimerLists+0xa>
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
 801f3ca:	4a19      	ldr	r2, [pc, #100]	@ (801f430 <prvSwitchTimerLists+0x94>)
 801f3cc:	6811      	ldr	r1, [r2, #0]
	pxOverflowTimerList = pxTemp;
 801f3ce:	6013      	str	r3, [r2, #0]
	pxCurrentTimerList = pxOverflowTimerList;
 801f3d0:	6031      	str	r1, [r6, #0]
}
 801f3d2:	b004      	add	sp, #16
 801f3d4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 801f3d8:	69a3      	ldr	r3, [r4, #24]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 801f3da:	4629      	mov	r1, r5
	if( xTimerQueue != NULL )
 801f3dc:	f8df 8054 	ldr.w	r8, [pc, #84]	@ 801f434 <prvSwitchTimerLists+0x98>
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 801f3e0:	443b      	add	r3, r7
			if( xReloadTime > xNextExpireTime )
 801f3e2:	429f      	cmp	r7, r3
 801f3e4:	d205      	bcs.n	801f3f2 <prvSwitchTimerLists+0x56>
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 801f3e6:	6830      	ldr	r0, [r6, #0]
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
 801f3e8:	6063      	str	r3, [r4, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 801f3ea:	6124      	str	r4, [r4, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 801f3ec:	f7fe fbd8 	bl	801dba0 <vListInsert>
 801f3f0:	e7e7      	b.n	801f3c2 <prvSwitchTimerLists+0x26>
	if( xTimerQueue != NULL )
 801f3f2:	f8d8 3000 	ldr.w	r3, [r8]
		xMessage.xMessageID = xCommandID;
 801f3f6:	2500      	movs	r5, #0
	if( xTimerQueue != NULL )
 801f3f8:	b16b      	cbz	r3, 801f416 <prvSwitchTimerLists+0x7a>
		xMessage.u.xTimerParameters.pxTimer = xTimer;
 801f3fa:	9402      	str	r4, [sp, #8]
		xMessage.xMessageID = xCommandID;
 801f3fc:	e9cd 5700 	strd	r5, r7, [sp]
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 801f400:	f7ff ff74 	bl	801f2ec <xTaskGetSchedulerState>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 801f404:	462b      	mov	r3, r5
 801f406:	462a      	mov	r2, r5
 801f408:	4669      	mov	r1, sp
 801f40a:	f8d8 0000 	ldr.w	r0, [r8]
 801f40e:	f7fe fce5 	bl	801dddc <xQueueGenericSend>
				configASSERT( xResult );
 801f412:	2800      	cmp	r0, #0
 801f414:	d1d5      	bne.n	801f3c2 <prvSwitchTimerLists+0x26>
 801f416:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801f41a:	b672      	cpsid	i
 801f41c:	f383 8811 	msr	BASEPRI, r3
 801f420:	f3bf 8f6f 	isb	sy
 801f424:	f3bf 8f4f 	dsb	sy
 801f428:	b662      	cpsie	i
 801f42a:	e7fe      	b.n	801f42a <prvSwitchTimerLists+0x8e>
 801f42c:	200038ec 	.word	0x200038ec
 801f430:	200038e8 	.word	0x200038e8
 801f434:	200038e4 	.word	0x200038e4

0801f438 <prvTimerTask>:
{
 801f438:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801f43c:	4ea2      	ldr	r6, [pc, #648]	@ (801f6c8 <prvTimerTask+0x290>)
 801f43e:	b089      	sub	sp, #36	@ 0x24
 801f440:	4da2      	ldr	r5, [pc, #648]	@ (801f6cc <prvTimerTask+0x294>)
					portYIELD_WITHIN_API();
 801f442:	f04f 29e0 	mov.w	r9, #3758153728	@ 0xe000e000
 801f446:	4ca2      	ldr	r4, [pc, #648]	@ (801f6d0 <prvTimerTask+0x298>)
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 801f448:	6833      	ldr	r3, [r6, #0]
 801f44a:	681f      	ldr	r7, [r3, #0]
 801f44c:	2f00      	cmp	r7, #0
 801f44e:	f000 80b4 	beq.w	801f5ba <prvTimerTask+0x182>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 801f452:	68db      	ldr	r3, [r3, #12]
 801f454:	681f      	ldr	r7, [r3, #0]
	vTaskSuspendAll();
 801f456:	f7ff fc41 	bl	801ecdc <vTaskSuspendAll>
	xTimeNow = xTaskGetTickCount();
 801f45a:	f7ff fc47 	bl	801ecec <xTaskGetTickCount>
	if( xTimeNow < xLastTime )
 801f45e:	682b      	ldr	r3, [r5, #0]
	xTimeNow = xTaskGetTickCount();
 801f460:	4682      	mov	sl, r0
	if( xTimeNow < xLastTime )
 801f462:	4298      	cmp	r0, r3
 801f464:	f0c0 80b1 	bcc.w	801f5ca <prvTimerTask+0x192>
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 801f468:	4287      	cmp	r7, r0
	xLastTime = xTimeNow;
 801f46a:	6028      	str	r0, [r5, #0]
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 801f46c:	f200 80d2 	bhi.w	801f614 <prvTimerTask+0x1dc>
				( void ) xTaskResumeAll();
 801f470:	f7ff fd90 	bl	801ef94 <xTaskResumeAll>
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 801f474:	6833      	ldr	r3, [r6, #0]
 801f476:	68db      	ldr	r3, [r3, #12]
 801f478:	f8d3 b00c 	ldr.w	fp, [r3, #12]
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 801f47c:	f10b 0804 	add.w	r8, fp, #4
 801f480:	4640      	mov	r0, r8
 801f482:	f7fe fba5 	bl	801dbd0 <uxListRemove>
	if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 801f486:	f89b 3028 	ldrb.w	r3, [fp, #40]	@ 0x28
 801f48a:	0758      	lsls	r0, r3, #29
 801f48c:	f100 80d2 	bmi.w	801f634 <prvTimerTask+0x1fc>
		pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 801f490:	f023 0301 	bic.w	r3, r3, #1
 801f494:	f88b 3028 	strb.w	r3, [fp, #40]	@ 0x28
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 801f498:	f8db 3020 	ldr.w	r3, [fp, #32]
 801f49c:	4658      	mov	r0, fp
 801f49e:	4798      	blx	r3
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 801f4a0:	2200      	movs	r2, #0
 801f4a2:	4669      	mov	r1, sp
 801f4a4:	6820      	ldr	r0, [r4, #0]
 801f4a6:	f7fe fe8f 	bl	801e1c8 <xQueueReceive>
 801f4aa:	2800      	cmp	r0, #0
 801f4ac:	d0cc      	beq.n	801f448 <prvTimerTask+0x10>
			if( xMessage.xMessageID < ( BaseType_t ) 0 )
 801f4ae:	9b00      	ldr	r3, [sp, #0]
				pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
 801f4b0:	9802      	ldr	r0, [sp, #8]
			if( xMessage.xMessageID < ( BaseType_t ) 0 )
 801f4b2:	2b00      	cmp	r3, #0
 801f4b4:	db79      	blt.n	801f5aa <prvTimerTask+0x172>
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
 801f4b6:	9f02      	ldr	r7, [sp, #8]
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
 801f4b8:	697b      	ldr	r3, [r7, #20]
 801f4ba:	b113      	cbz	r3, 801f4c2 <prvTimerTask+0x8a>
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 801f4bc:	1d38      	adds	r0, r7, #4
 801f4be:	f7fe fb87 	bl	801dbd0 <uxListRemove>
	xTimeNow = xTaskGetTickCount();
 801f4c2:	f7ff fc13 	bl	801ecec <xTaskGetTickCount>
	if( xTimeNow < xLastTime )
 801f4c6:	682b      	ldr	r3, [r5, #0]
	xTimeNow = xTaskGetTickCount();
 801f4c8:	4683      	mov	fp, r0
	if( xTimeNow < xLastTime )
 801f4ca:	4298      	cmp	r0, r3
 801f4cc:	f0c0 8084 	bcc.w	801f5d8 <prvTimerTask+0x1a0>
			switch( xMessage.xMessageID )
 801f4d0:	9b00      	ldr	r3, [sp, #0]
	xLastTime = xTimeNow;
 801f4d2:	f8c5 b000 	str.w	fp, [r5]
			switch( xMessage.xMessageID )
 801f4d6:	2b09      	cmp	r3, #9
 801f4d8:	d8e2      	bhi.n	801f4a0 <prvTimerTask+0x68>
 801f4da:	e8df f003 	tbb	[pc, r3]
 801f4de:	0505      	.short	0x0505
 801f4e0:	5d405605 	.word	0x5d405605
 801f4e4:	40560505 	.word	0x40560505
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 801f4e8:	f897 2028 	ldrb.w	r2, [r7, #40]	@ 0x28
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
 801f4ec:	9b01      	ldr	r3, [sp, #4]
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 801f4ee:	f042 0201 	orr.w	r2, r2, #1
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 801f4f2:	613f      	str	r7, [r7, #16]
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 801f4f4:	f887 2028 	strb.w	r2, [r7, #40]	@ 0x28
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
 801f4f8:	69ba      	ldr	r2, [r7, #24]
 801f4fa:	1899      	adds	r1, r3, r2
 801f4fc:	bf2c      	ite	cs
 801f4fe:	2001      	movcs	r0, #1
 801f500:	2000      	movcc	r0, #0
	if( xNextExpiryTime <= xTimeNow )
 801f502:	4559      	cmp	r1, fp
	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 801f504:	6079      	str	r1, [r7, #4]
	if( xNextExpiryTime <= xTimeNow )
 801f506:	f200 8087 	bhi.w	801f618 <prvTimerTask+0x1e0>
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 801f50a:	ebab 0303 	sub.w	r3, fp, r3
 801f50e:	429a      	cmp	r2, r3
 801f510:	f200 80c2 	bhi.w	801f698 <prvTimerTask+0x260>
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 801f514:	6a3b      	ldr	r3, [r7, #32]
 801f516:	4638      	mov	r0, r7
 801f518:	4798      	blx	r3
						if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 801f51a:	f897 3028 	ldrb.w	r3, [r7, #40]	@ 0x28
 801f51e:	0759      	lsls	r1, r3, #29
 801f520:	d5be      	bpl.n	801f4a0 <prvTimerTask+0x68>
	if( xTimerQueue != NULL )
 801f522:	6821      	ldr	r1, [r4, #0]
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
 801f524:	9b01      	ldr	r3, [sp, #4]
 801f526:	69ba      	ldr	r2, [r7, #24]
	if( xTimerQueue != NULL )
 801f528:	b171      	cbz	r1, 801f548 <prvTimerTask+0x110>
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
 801f52a:	4413      	add	r3, r2
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
 801f52c:	e9cd 3705 	strd	r3, r7, [sp, #20]
		xMessage.xMessageID = xCommandID;
 801f530:	2700      	movs	r7, #0
 801f532:	9704      	str	r7, [sp, #16]
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 801f534:	f7ff feda 	bl	801f2ec <xTaskGetSchedulerState>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 801f538:	463b      	mov	r3, r7
 801f53a:	463a      	mov	r2, r7
 801f53c:	a904      	add	r1, sp, #16
 801f53e:	6820      	ldr	r0, [r4, #0]
 801f540:	f7fe fc4c 	bl	801dddc <xQueueGenericSend>
							configASSERT( xResult );
 801f544:	2800      	cmp	r0, #0
 801f546:	d1ab      	bne.n	801f4a0 <prvTimerTask+0x68>
 801f548:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801f54c:	b672      	cpsid	i
 801f54e:	f383 8811 	msr	BASEPRI, r3
 801f552:	f3bf 8f6f 	isb	sy
 801f556:	f3bf 8f4f 	dsb	sy
 801f55a:	b662      	cpsie	i
 801f55c:	e7fe      	b.n	801f55c <prvTimerTask+0x124>
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 801f55e:	f897 2028 	ldrb.w	r2, [r7, #40]	@ 0x28
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 801f562:	9b01      	ldr	r3, [sp, #4]
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 801f564:	f042 0201 	orr.w	r2, r2, #1
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 801f568:	61bb      	str	r3, [r7, #24]
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 801f56a:	f887 2028 	strb.w	r2, [r7, #40]	@ 0x28
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 801f56e:	2b00      	cmp	r3, #0
 801f570:	f000 809e 	beq.w	801f6b0 <prvTimerTask+0x278>
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 801f574:	445b      	add	r3, fp
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 801f576:	1d39      	adds	r1, r7, #4
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 801f578:	613f      	str	r7, [r7, #16]
	if( xNextExpiryTime <= xTimeNow )
 801f57a:	455b      	cmp	r3, fp
	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 801f57c:	607b      	str	r3, [r7, #4]
	if( xNextExpiryTime <= xTimeNow )
 801f57e:	d855      	bhi.n	801f62c <prvTimerTask+0x1f4>
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 801f580:	4b54      	ldr	r3, [pc, #336]	@ (801f6d4 <prvTimerTask+0x29c>)
 801f582:	6818      	ldr	r0, [r3, #0]
 801f584:	f7fe fb0c 	bl	801dba0 <vListInsert>
 801f588:	e78a      	b.n	801f4a0 <prvTimerTask+0x68>
					pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 801f58a:	f897 3028 	ldrb.w	r3, [r7, #40]	@ 0x28
 801f58e:	f023 0301 	bic.w	r3, r3, #1
 801f592:	f887 3028 	strb.w	r3, [r7, #40]	@ 0x28
					break;
 801f596:	e783      	b.n	801f4a0 <prvTimerTask+0x68>
						if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
 801f598:	f897 3028 	ldrb.w	r3, [r7, #40]	@ 0x28
 801f59c:	079a      	lsls	r2, r3, #30
 801f59e:	d572      	bpl.n	801f686 <prvTimerTask+0x24e>
							pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 801f5a0:	f023 0301 	bic.w	r3, r3, #1
 801f5a4:	f887 3028 	strb.w	r3, [r7, #40]	@ 0x28
 801f5a8:	e77a      	b.n	801f4a0 <prvTimerTask+0x68>
				pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
 801f5aa:	9b01      	ldr	r3, [sp, #4]
 801f5ac:	9903      	ldr	r1, [sp, #12]
 801f5ae:	4798      	blx	r3
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
 801f5b0:	9b00      	ldr	r3, [sp, #0]
 801f5b2:	2b00      	cmp	r3, #0
 801f5b4:	f6ff af74 	blt.w	801f4a0 <prvTimerTask+0x68>
 801f5b8:	e77d      	b.n	801f4b6 <prvTimerTask+0x7e>
	vTaskSuspendAll();
 801f5ba:	f7ff fb8f 	bl	801ecdc <vTaskSuspendAll>
	xTimeNow = xTaskGetTickCount();
 801f5be:	f7ff fb95 	bl	801ecec <xTaskGetTickCount>
	if( xTimeNow < xLastTime )
 801f5c2:	682b      	ldr	r3, [r5, #0]
	xTimeNow = xTaskGetTickCount();
 801f5c4:	4682      	mov	sl, r0
	if( xTimeNow < xLastTime )
 801f5c6:	4298      	cmp	r0, r3
 801f5c8:	d209      	bcs.n	801f5de <prvTimerTask+0x1a6>
		prvSwitchTimerLists();
 801f5ca:	f7ff fee7 	bl	801f39c <prvSwitchTimerLists>
	xLastTime = xTimeNow;
 801f5ce:	f8c5 a000 	str.w	sl, [r5]
			( void ) xTaskResumeAll();
 801f5d2:	f7ff fcdf 	bl	801ef94 <xTaskResumeAll>
 801f5d6:	e763      	b.n	801f4a0 <prvTimerTask+0x68>
		prvSwitchTimerLists();
 801f5d8:	f7ff fee0 	bl	801f39c <prvSwitchTimerLists>
		*pxTimerListsWereSwitched = pdTRUE;
 801f5dc:	e778      	b.n	801f4d0 <prvTimerTask+0x98>
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 801f5de:	4b3d      	ldr	r3, [pc, #244]	@ (801f6d4 <prvTimerTask+0x29c>)
	xLastTime = xTimeNow;
 801f5e0:	f8c5 a000 	str.w	sl, [r5]
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 801f5e4:	681b      	ldr	r3, [r3, #0]
 801f5e6:	681a      	ldr	r2, [r3, #0]
 801f5e8:	fab2 f282 	clz	r2, r2
 801f5ec:	0952      	lsrs	r2, r2, #5
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
 801f5ee:	eba7 010a 	sub.w	r1, r7, sl
 801f5f2:	6820      	ldr	r0, [r4, #0]
 801f5f4:	f7ff f800 	bl	801e5f8 <vQueueWaitForMessageRestricted>
				if( xTaskResumeAll() == pdFALSE )
 801f5f8:	f7ff fccc 	bl	801ef94 <xTaskResumeAll>
 801f5fc:	2800      	cmp	r0, #0
 801f5fe:	f47f af4f 	bne.w	801f4a0 <prvTimerTask+0x68>
					portYIELD_WITHIN_API();
 801f602:	f04f 5380 	mov.w	r3, #268435456	@ 0x10000000
 801f606:	f8c9 3d04 	str.w	r3, [r9, #3332]	@ 0xd04
 801f60a:	f3bf 8f4f 	dsb	sy
 801f60e:	f3bf 8f6f 	isb	sy
 801f612:	e745      	b.n	801f4a0 <prvTimerTask+0x68>
 801f614:	2200      	movs	r2, #0
 801f616:	e7ea      	b.n	801f5ee <prvTimerTask+0x1b6>
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 801f618:	455b      	cmp	r3, fp
 801f61a:	d902      	bls.n	801f622 <prvTimerTask+0x1ea>
 801f61c:	2800      	cmp	r0, #0
 801f61e:	f43f af79 	beq.w	801f514 <prvTimerTask+0xdc>
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 801f622:	1d39      	adds	r1, r7, #4
 801f624:	6830      	ldr	r0, [r6, #0]
 801f626:	f7fe fabb 	bl	801dba0 <vListInsert>
	return xProcessTimerNow;
 801f62a:	e739      	b.n	801f4a0 <prvTimerTask+0x68>
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 801f62c:	6830      	ldr	r0, [r6, #0]
 801f62e:	f7fe fab7 	bl	801dba0 <vListInsert>
 801f632:	e735      	b.n	801f4a0 <prvTimerTask+0x68>
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
 801f634:	f8db 0018 	ldr.w	r0, [fp, #24]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 801f638:	f8cb b010 	str.w	fp, [fp, #16]
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
 801f63c:	183b      	adds	r3, r7, r0
	if( xNextExpiryTime <= xTimeNow )
 801f63e:	459a      	cmp	sl, r3
	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 801f640:	f8cb 3004 	str.w	r3, [fp, #4]
	if( xNextExpiryTime <= xTimeNow )
 801f644:	d323      	bcc.n	801f68e <prvTimerTask+0x256>
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 801f646:	ebaa 0a07 	sub.w	sl, sl, r7
 801f64a:	4550      	cmp	r0, sl
 801f64c:	d82a      	bhi.n	801f6a4 <prvTimerTask+0x26c>
	if( xTimerQueue != NULL )
 801f64e:	6823      	ldr	r3, [r4, #0]
 801f650:	b173      	cbz	r3, 801f670 <prvTimerTask+0x238>
		xMessage.u.xTimerParameters.pxTimer = xTimer;
 801f652:	e9cd 7b05 	strd	r7, fp, [sp, #20]
		xMessage.xMessageID = xCommandID;
 801f656:	2700      	movs	r7, #0
 801f658:	9704      	str	r7, [sp, #16]
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 801f65a:	f7ff fe47 	bl	801f2ec <xTaskGetSchedulerState>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 801f65e:	463b      	mov	r3, r7
 801f660:	463a      	mov	r2, r7
 801f662:	a904      	add	r1, sp, #16
 801f664:	6820      	ldr	r0, [r4, #0]
 801f666:	f7fe fbb9 	bl	801dddc <xQueueGenericSend>
			configASSERT( xResult );
 801f66a:	2800      	cmp	r0, #0
 801f66c:	f47f af14 	bne.w	801f498 <prvTimerTask+0x60>
 801f670:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801f674:	b672      	cpsid	i
 801f676:	f383 8811 	msr	BASEPRI, r3
 801f67a:	f3bf 8f6f 	isb	sy
 801f67e:	f3bf 8f4f 	dsb	sy
 801f682:	b662      	cpsie	i
 801f684:	e7fe      	b.n	801f684 <prvTimerTask+0x24c>
							vPortFree( pxTimer );
 801f686:	4638      	mov	r0, r7
 801f688:	f000 fb04 	bl	801fc94 <vPortFree>
 801f68c:	e708      	b.n	801f4a0 <prvTimerTask+0x68>
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 801f68e:	4641      	mov	r1, r8
 801f690:	6830      	ldr	r0, [r6, #0]
 801f692:	f7fe fa85 	bl	801dba0 <vListInsert>
	return xProcessTimerNow;
 801f696:	e6ff      	b.n	801f498 <prvTimerTask+0x60>
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 801f698:	4b0e      	ldr	r3, [pc, #56]	@ (801f6d4 <prvTimerTask+0x29c>)
 801f69a:	1d39      	adds	r1, r7, #4
 801f69c:	6818      	ldr	r0, [r3, #0]
 801f69e:	f7fe fa7f 	bl	801dba0 <vListInsert>
	return xProcessTimerNow;
 801f6a2:	e6fd      	b.n	801f4a0 <prvTimerTask+0x68>
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 801f6a4:	4b0b      	ldr	r3, [pc, #44]	@ (801f6d4 <prvTimerTask+0x29c>)
 801f6a6:	4641      	mov	r1, r8
 801f6a8:	6818      	ldr	r0, [r3, #0]
 801f6aa:	f7fe fa79 	bl	801dba0 <vListInsert>
	return xProcessTimerNow;
 801f6ae:	e6f3      	b.n	801f498 <prvTimerTask+0x60>
 801f6b0:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801f6b4:	b672      	cpsid	i
 801f6b6:	f383 8811 	msr	BASEPRI, r3
 801f6ba:	f3bf 8f6f 	isb	sy
 801f6be:	f3bf 8f4f 	dsb	sy
 801f6c2:	b662      	cpsie	i
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 801f6c4:	e7fe      	b.n	801f6c4 <prvTimerTask+0x28c>
 801f6c6:	bf00      	nop
 801f6c8:	200038ec 	.word	0x200038ec
 801f6cc:	200038dc 	.word	0x200038dc
 801f6d0:	200038e4 	.word	0x200038e4
 801f6d4:	200038e8 	.word	0x200038e8

0801f6d8 <xTimerCreateTimerTask>:
{
 801f6d8:	b5f0      	push	{r4, r5, r6, r7, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
	{
		if( xTimerQueue == NULL )
 801f6da:	4c24      	ldr	r4, [pc, #144]	@ (801f76c <xTimerCreateTimerTask+0x94>)
{
 801f6dc:	b089      	sub	sp, #36	@ 0x24
	taskENTER_CRITICAL();
 801f6de:	f000 f8c9 	bl	801f874 <vPortEnterCritical>
		if( xTimerQueue == NULL )
 801f6e2:	6825      	ldr	r5, [r4, #0]
 801f6e4:	b345      	cbz	r5, 801f738 <xTimerCreateTimerTask+0x60>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 801f6e6:	f000 f8eb 	bl	801f8c0 <vPortExitCritical>
	if( xTimerQueue != NULL )
 801f6ea:	6823      	ldr	r3, [r4, #0]
 801f6ec:	b1cb      	cbz	r3, 801f722 <xTimerCreateTimerTask+0x4a>
			StaticTask_t *pxTimerTaskTCBBuffer = NULL;
 801f6ee:	2400      	movs	r4, #0
			vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
 801f6f0:	aa07      	add	r2, sp, #28
 801f6f2:	a906      	add	r1, sp, #24
 801f6f4:	a805      	add	r0, sp, #20
			xTimerTaskHandle = xTaskCreateStatic(	prvTimerTask,
 801f6f6:	2502      	movs	r5, #2
			StackType_t *pxTimerTaskStackBuffer = NULL;
 801f6f8:	e9cd 4405 	strd	r4, r4, [sp, #20]
			vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
 801f6fc:	f7fe fa22 	bl	801db44 <vApplicationGetTimerTaskMemory>
			xTimerTaskHandle = xTaskCreateStatic(	prvTimerTask,
 801f700:	4623      	mov	r3, r4
 801f702:	9a07      	ldr	r2, [sp, #28]
 801f704:	9500      	str	r5, [sp, #0]
 801f706:	e9dd 0105 	ldrd	r0, r1, [sp, #20]
 801f70a:	e9cd 1001 	strd	r1, r0, [sp, #4]
 801f70e:	4918      	ldr	r1, [pc, #96]	@ (801f770 <xTimerCreateTimerTask+0x98>)
 801f710:	4818      	ldr	r0, [pc, #96]	@ (801f774 <xTimerCreateTimerTask+0x9c>)
 801f712:	f7ff f907 	bl	801e924 <xTaskCreateStatic>
 801f716:	4b18      	ldr	r3, [pc, #96]	@ (801f778 <xTimerCreateTimerTask+0xa0>)
 801f718:	6018      	str	r0, [r3, #0]
			if( xTimerTaskHandle != NULL )
 801f71a:	b110      	cbz	r0, 801f722 <xTimerCreateTimerTask+0x4a>
}
 801f71c:	2001      	movs	r0, #1
 801f71e:	b009      	add	sp, #36	@ 0x24
 801f720:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801f722:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801f726:	b672      	cpsid	i
 801f728:	f383 8811 	msr	BASEPRI, r3
 801f72c:	f3bf 8f6f 	isb	sy
 801f730:	f3bf 8f4f 	dsb	sy
 801f734:	b662      	cpsie	i
	configASSERT( xReturn );
 801f736:	e7fe      	b.n	801f736 <xTimerCreateTimerTask+0x5e>
			vListInitialise( &xActiveTimerList1 );
 801f738:	4f10      	ldr	r7, [pc, #64]	@ (801f77c <xTimerCreateTimerTask+0xa4>)
			vListInitialise( &xActiveTimerList2 );
 801f73a:	4e11      	ldr	r6, [pc, #68]	@ (801f780 <xTimerCreateTimerTask+0xa8>)
			vListInitialise( &xActiveTimerList1 );
 801f73c:	4638      	mov	r0, r7
 801f73e:	f7fe fa11 	bl	801db64 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
 801f742:	4630      	mov	r0, r6
 801f744:	f7fe fa0e 	bl	801db64 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
 801f748:	4a0e      	ldr	r2, [pc, #56]	@ (801f784 <xTimerCreateTimerTask+0xac>)
				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
 801f74a:	9500      	str	r5, [sp, #0]
 801f74c:	2110      	movs	r1, #16
			pxCurrentTimerList = &xActiveTimerList1;
 801f74e:	6017      	str	r7, [r2, #0]
				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
 801f750:	200a      	movs	r0, #10
			pxOverflowTimerList = &xActiveTimerList2;
 801f752:	4a0d      	ldr	r2, [pc, #52]	@ (801f788 <xTimerCreateTimerTask+0xb0>)
				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
 801f754:	4b0d      	ldr	r3, [pc, #52]	@ (801f78c <xTimerCreateTimerTask+0xb4>)
			pxOverflowTimerList = &xActiveTimerList2;
 801f756:	6016      	str	r6, [r2, #0]
				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
 801f758:	4a0d      	ldr	r2, [pc, #52]	@ (801f790 <xTimerCreateTimerTask+0xb8>)
 801f75a:	f7fe fa85 	bl	801dc68 <xQueueGenericCreateStatic>
 801f75e:	6020      	str	r0, [r4, #0]
				if( xTimerQueue != NULL )
 801f760:	2800      	cmp	r0, #0
 801f762:	d0c0      	beq.n	801f6e6 <xTimerCreateTimerTask+0xe>
					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
 801f764:	490b      	ldr	r1, [pc, #44]	@ (801f794 <xTimerCreateTimerTask+0xbc>)
 801f766:	f7fe ff1f 	bl	801e5a8 <vQueueAddToRegistry>
 801f76a:	e7bc      	b.n	801f6e6 <xTimerCreateTimerTask+0xe>
 801f76c:	200038e4 	.word	0x200038e4
 801f770:	08034c4c 	.word	0x08034c4c
 801f774:	0801f439 	.word	0x0801f439
 801f778:	200038e0 	.word	0x200038e0
 801f77c:	20003904 	.word	0x20003904
 801f780:	200038f0 	.word	0x200038f0
 801f784:	200038ec 	.word	0x200038ec
 801f788:	200038e8 	.word	0x200038e8
 801f78c:	200037ec 	.word	0x200037ec
 801f790:	2000383c 	.word	0x2000383c
 801f794:	08034c44 	.word	0x08034c44

0801f798 <prvPortStartFirstTask>:
{
	/* Start the first task.  This also clears the bit that indicates the FPU is
	in use in case the FPU was used before the scheduler was started - which
	would otherwise result in the unnecessary leaving of space in the SVC stack
	for lazy saving of FPU registers. */
	__asm volatile(
 801f798:	4808      	ldr	r0, [pc, #32]	@ (801f7bc <prvPortStartFirstTask+0x24>)
 801f79a:	6800      	ldr	r0, [r0, #0]
 801f79c:	6800      	ldr	r0, [r0, #0]
 801f79e:	f380 8808 	msr	MSP, r0
 801f7a2:	f04f 0000 	mov.w	r0, #0
 801f7a6:	f380 8814 	msr	CONTROL, r0
 801f7aa:	b662      	cpsie	i
 801f7ac:	b661      	cpsie	f
 801f7ae:	f3bf 8f4f 	dsb	sy
 801f7b2:	f3bf 8f6f 	isb	sy
 801f7b6:	df00      	svc	0
 801f7b8:	bf00      	nop
					" dsb					\n"
					" isb					\n"
					" svc 0					\n" /* System call to start first task. */
					" nop					\n"
				);
}
 801f7ba:	0000      	.short	0x0000
 801f7bc:	e000ed08 	.word	0xe000ed08

0801f7c0 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
 801f7c0:	f8df 000c 	ldr.w	r0, [pc, #12]	@ 801f7d0 <vPortEnableVFP+0x10>
 801f7c4:	6801      	ldr	r1, [r0, #0]
 801f7c6:	f441 0170 	orr.w	r1, r1, #15728640	@ 0xf00000
 801f7ca:	6001      	str	r1, [r0, #0]
 801f7cc:	4770      	bx	lr
		"								\n"
		"	orr r1, r1, #( 0xf << 20 )	\n" /* Enable CP10 and CP11 coprocessors, then save back. */
		"	str r1, [r0]				\n"
		"	bx r14						"
	);
}
 801f7ce:	0000      	.short	0x0000
 801f7d0:	e000ed88 	.word	0xe000ed88

0801f7d4 <prvTaskExitError>:
	configASSERT( uxCriticalNesting == ~0UL );
 801f7d4:	4b10      	ldr	r3, [pc, #64]	@ (801f818 <prvTaskExitError+0x44>)
{
 801f7d6:	b082      	sub	sp, #8
volatile uint32_t ulDummy = 0;
 801f7d8:	2200      	movs	r2, #0
	configASSERT( uxCriticalNesting == ~0UL );
 801f7da:	681b      	ldr	r3, [r3, #0]
volatile uint32_t ulDummy = 0;
 801f7dc:	9201      	str	r2, [sp, #4]
	configASSERT( uxCriticalNesting == ~0UL );
 801f7de:	3301      	adds	r3, #1
 801f7e0:	d00a      	beq.n	801f7f8 <prvTaskExitError+0x24>
 801f7e2:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801f7e6:	b672      	cpsid	i
 801f7e8:	f383 8811 	msr	BASEPRI, r3
 801f7ec:	f3bf 8f6f 	isb	sy
 801f7f0:	f3bf 8f4f 	dsb	sy
 801f7f4:	b662      	cpsie	i
 801f7f6:	e7fe      	b.n	801f7f6 <prvTaskExitError+0x22>
 801f7f8:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801f7fc:	b672      	cpsid	i
 801f7fe:	f383 8811 	msr	BASEPRI, r3
 801f802:	f3bf 8f6f 	isb	sy
 801f806:	f3bf 8f4f 	dsb	sy
 801f80a:	b662      	cpsie	i
	while( ulDummy == 0 )
 801f80c:	9b01      	ldr	r3, [sp, #4]
 801f80e:	2b00      	cmp	r3, #0
 801f810:	d0fc      	beq.n	801f80c <prvTaskExitError+0x38>
}
 801f812:	b002      	add	sp, #8
 801f814:	4770      	bx	lr
 801f816:	bf00      	nop
 801f818:	200000a4 	.word	0x200000a4

0801f81c <pxPortInitialiseStack>:
{
 801f81c:	4603      	mov	r3, r0
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 801f81e:	f021 0101 	bic.w	r1, r1, #1
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 801f822:	4809      	ldr	r0, [pc, #36]	@ (801f848 <pxPortInitialiseStack+0x2c>)
{
 801f824:	b410      	push	{r4}
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 801f826:	f04f 7480 	mov.w	r4, #16777216	@ 0x1000000
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 801f82a:	f843 0c0c 	str.w	r0, [r3, #-12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 801f82e:	f843 2c20 	str.w	r2, [r3, #-32]
}
 801f832:	f1a3 0044 	sub.w	r0, r3, #68	@ 0x44
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 801f836:	e943 1402 	strd	r1, r4, [r3, #-8]
	*pxTopOfStack = portINITIAL_EXC_RETURN;
 801f83a:	f06f 0102 	mvn.w	r1, #2
}
 801f83e:	f85d 4b04 	ldr.w	r4, [sp], #4
	*pxTopOfStack = portINITIAL_EXC_RETURN;
 801f842:	f843 1c24 	str.w	r1, [r3, #-36]
}
 801f846:	4770      	bx	lr
 801f848:	0801f7d5 	.word	0x0801f7d5
 801f84c:	00000000 	.word	0x00000000

0801f850 <SVC_Handler>:
	__asm volatile (
 801f850:	4b07      	ldr	r3, [pc, #28]	@ (801f870 <pxCurrentTCBConst2>)
 801f852:	6819      	ldr	r1, [r3, #0]
 801f854:	6808      	ldr	r0, [r1, #0]
 801f856:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801f85a:	f380 8809 	msr	PSP, r0
 801f85e:	f3bf 8f6f 	isb	sy
 801f862:	f04f 0000 	mov.w	r0, #0
 801f866:	f380 8811 	msr	BASEPRI, r0
 801f86a:	4770      	bx	lr
 801f86c:	f3af 8000 	nop.w

0801f870 <pxCurrentTCBConst2>:
 801f870:	200037e8 	.word	0x200037e8

0801f874 <vPortEnterCritical>:
 801f874:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801f878:	b672      	cpsid	i
 801f87a:	f383 8811 	msr	BASEPRI, r3
 801f87e:	f3bf 8f6f 	isb	sy
 801f882:	f3bf 8f4f 	dsb	sy
 801f886:	b662      	cpsie	i
	uxCriticalNesting++;
 801f888:	4a0c      	ldr	r2, [pc, #48]	@ (801f8bc <vPortEnterCritical+0x48>)
 801f88a:	6813      	ldr	r3, [r2, #0]
 801f88c:	3301      	adds	r3, #1
	if( uxCriticalNesting == 1 )
 801f88e:	2b01      	cmp	r3, #1
	uxCriticalNesting++;
 801f890:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 1 )
 801f892:	d000      	beq.n	801f896 <vPortEnterCritical+0x22>
}
 801f894:	4770      	bx	lr
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
 801f896:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 801f89a:	f8d3 3d04 	ldr.w	r3, [r3, #3332]	@ 0xd04
 801f89e:	b2db      	uxtb	r3, r3
 801f8a0:	2b00      	cmp	r3, #0
 801f8a2:	d0f7      	beq.n	801f894 <vPortEnterCritical+0x20>
 801f8a4:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801f8a8:	b672      	cpsid	i
 801f8aa:	f383 8811 	msr	BASEPRI, r3
 801f8ae:	f3bf 8f6f 	isb	sy
 801f8b2:	f3bf 8f4f 	dsb	sy
 801f8b6:	b662      	cpsie	i
 801f8b8:	e7fe      	b.n	801f8b8 <vPortEnterCritical+0x44>
 801f8ba:	bf00      	nop
 801f8bc:	200000a4 	.word	0x200000a4

0801f8c0 <vPortExitCritical>:
	configASSERT( uxCriticalNesting );
 801f8c0:	4a09      	ldr	r2, [pc, #36]	@ (801f8e8 <vPortExitCritical+0x28>)
 801f8c2:	6813      	ldr	r3, [r2, #0]
 801f8c4:	b953      	cbnz	r3, 801f8dc <vPortExitCritical+0x1c>
 801f8c6:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801f8ca:	b672      	cpsid	i
 801f8cc:	f383 8811 	msr	BASEPRI, r3
 801f8d0:	f3bf 8f6f 	isb	sy
 801f8d4:	f3bf 8f4f 	dsb	sy
 801f8d8:	b662      	cpsie	i
 801f8da:	e7fe      	b.n	801f8da <vPortExitCritical+0x1a>
	uxCriticalNesting--;
 801f8dc:	3b01      	subs	r3, #1
 801f8de:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 801f8e0:	b90b      	cbnz	r3, 801f8e6 <vPortExitCritical+0x26>
	__asm volatile
 801f8e2:	f383 8811 	msr	BASEPRI, r3
}
 801f8e6:	4770      	bx	lr
 801f8e8:	200000a4 	.word	0x200000a4
 801f8ec:	00000000 	.word	0x00000000

0801f8f0 <PendSV_Handler>:
	__asm volatile
 801f8f0:	f3ef 8009 	mrs	r0, PSP
 801f8f4:	f3bf 8f6f 	isb	sy
 801f8f8:	4b15      	ldr	r3, [pc, #84]	@ (801f950 <pxCurrentTCBConst>)
 801f8fa:	681a      	ldr	r2, [r3, #0]
 801f8fc:	f01e 0f10 	tst.w	lr, #16
 801f900:	bf08      	it	eq
 801f902:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
 801f906:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801f90a:	6010      	str	r0, [r2, #0]
 801f90c:	e92d 0009 	stmdb	sp!, {r0, r3}
 801f910:	f04f 0050 	mov.w	r0, #80	@ 0x50
 801f914:	b672      	cpsid	i
 801f916:	f380 8811 	msr	BASEPRI, r0
 801f91a:	f3bf 8f4f 	dsb	sy
 801f91e:	f3bf 8f6f 	isb	sy
 801f922:	b662      	cpsie	i
 801f924:	f7ff fba2 	bl	801f06c <vTaskSwitchContext>
 801f928:	f04f 0000 	mov.w	r0, #0
 801f92c:	f380 8811 	msr	BASEPRI, r0
 801f930:	bc09      	pop	{r0, r3}
 801f932:	6819      	ldr	r1, [r3, #0]
 801f934:	6808      	ldr	r0, [r1, #0]
 801f936:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801f93a:	f01e 0f10 	tst.w	lr, #16
 801f93e:	bf08      	it	eq
 801f940:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
 801f944:	f380 8809 	msr	PSP, r0
 801f948:	f3bf 8f6f 	isb	sy
 801f94c:	4770      	bx	lr
 801f94e:	bf00      	nop

0801f950 <pxCurrentTCBConst>:
 801f950:	200037e8 	.word	0x200037e8

0801f954 <SysTick_Handler>:
{
 801f954:	b508      	push	{r3, lr}
	__asm volatile
 801f956:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801f95a:	b672      	cpsid	i
 801f95c:	f383 8811 	msr	BASEPRI, r3
 801f960:	f3bf 8f6f 	isb	sy
 801f964:	f3bf 8f4f 	dsb	sy
 801f968:	b662      	cpsie	i
		if( xTaskIncrementTick() != pdFALSE )
 801f96a:	f7ff f9cd 	bl	801ed08 <xTaskIncrementTick>
 801f96e:	b128      	cbz	r0, 801f97c <SysTick_Handler+0x28>
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 801f970:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 801f974:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 801f978:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
	__asm volatile
 801f97c:	2300      	movs	r3, #0
 801f97e:	f383 8811 	msr	BASEPRI, r3
}
 801f982:	bd08      	pop	{r3, pc}

0801f984 <vPortSetupTimerInterrupt>:
	portNVIC_SYSTICK_CTRL_REG = 0UL;
 801f984:	f04f 22e0 	mov.w	r2, #3758153728	@ 0xe000e000
 801f988:	2300      	movs	r3, #0
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 801f98a:	4806      	ldr	r0, [pc, #24]	@ (801f9a4 <vPortSetupTimerInterrupt+0x20>)
	portNVIC_SYSTICK_CTRL_REG = 0UL;
 801f98c:	6113      	str	r3, [r2, #16]
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 801f98e:	4906      	ldr	r1, [pc, #24]	@ (801f9a8 <vPortSetupTimerInterrupt+0x24>)
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 801f990:	6193      	str	r3, [r2, #24]
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 801f992:	6803      	ldr	r3, [r0, #0]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 801f994:	2007      	movs	r0, #7
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 801f996:	fba1 1303 	umull	r1, r3, r1, r3
 801f99a:	099b      	lsrs	r3, r3, #6
 801f99c:	3b01      	subs	r3, #1
 801f99e:	6153      	str	r3, [r2, #20]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 801f9a0:	6110      	str	r0, [r2, #16]
}
 801f9a2:	4770      	bx	lr
 801f9a4:	2000000c 	.word	0x2000000c
 801f9a8:	10624dd3 	.word	0x10624dd3

0801f9ac <xPortStartScheduler>:
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 801f9ac:	4b3d      	ldr	r3, [pc, #244]	@ (801faa4 <xPortStartScheduler+0xf8>)
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 801f9ae:	f04f 0cff 	mov.w	ip, #255	@ 0xff
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 801f9b2:	483d      	ldr	r0, [pc, #244]	@ (801faa8 <xPortStartScheduler+0xfc>)
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 801f9b4:	493d      	ldr	r1, [pc, #244]	@ (801faac <xPortStartScheduler+0x100>)
{
 801f9b6:	b570      	push	{r4, r5, r6, lr}
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 801f9b8:	781a      	ldrb	r2, [r3, #0]
{
 801f9ba:	b084      	sub	sp, #16
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 801f9bc:	b2d2      	uxtb	r2, r2
 801f9be:	9202      	str	r2, [sp, #8]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 801f9c0:	2207      	movs	r2, #7
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 801f9c2:	f883 c000 	strb.w	ip, [r3]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 801f9c6:	781b      	ldrb	r3, [r3, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 801f9c8:	6002      	str	r2, [r0, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 801f9ca:	b2db      	uxtb	r3, r3
 801f9cc:	f88d 3007 	strb.w	r3, [sp, #7]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 801f9d0:	f89d 3007 	ldrb.w	r3, [sp, #7]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 801f9d4:	f89d 2007 	ldrb.w	r2, [sp, #7]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 801f9d8:	f003 0350 	and.w	r3, r3, #80	@ 0x50
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 801f9dc:	0612      	lsls	r2, r2, #24
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 801f9de:	700b      	strb	r3, [r1, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 801f9e0:	d50f      	bpl.n	801fa02 <xPortStartScheduler+0x56>
 801f9e2:	2206      	movs	r2, #6
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 801f9e4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 801f9e8:	4611      	mov	r1, r2
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 801f9ea:	3a01      	subs	r2, #1
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 801f9ec:	005b      	lsls	r3, r3, #1
 801f9ee:	b2db      	uxtb	r3, r3
 801f9f0:	f88d 3007 	strb.w	r3, [sp, #7]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 801f9f4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 801f9f8:	061b      	lsls	r3, r3, #24
 801f9fa:	d4f3      	bmi.n	801f9e4 <xPortStartScheduler+0x38>
			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
 801f9fc:	2903      	cmp	r1, #3
 801f9fe:	d00b      	beq.n	801fa18 <xPortStartScheduler+0x6c>
 801fa00:	6001      	str	r1, [r0, #0]
	__asm volatile
 801fa02:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801fa06:	b672      	cpsid	i
 801fa08:	f383 8811 	msr	BASEPRI, r3
 801fa0c:	f3bf 8f6f 	isb	sy
 801fa10:	f3bf 8f4f 	dsb	sy
 801fa14:	b662      	cpsie	i
 801fa16:	e7fe      	b.n	801fa16 <xPortStartScheduler+0x6a>
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 801fa18:	9b02      	ldr	r3, [sp, #8]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 801fa1a:	f04f 24e0 	mov.w	r4, #3758153728	@ 0xe000e000
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 801fa1e:	f44f 7140 	mov.w	r1, #768	@ 0x300
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 801fa22:	4a20      	ldr	r2, [pc, #128]	@ (801faa4 <xPortStartScheduler+0xf8>)
 801fa24:	b2db      	uxtb	r3, r3
	uxCriticalNesting = 0;
 801fa26:	4e22      	ldr	r6, [pc, #136]	@ (801fab0 <xPortStartScheduler+0x104>)
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 801fa28:	6001      	str	r1, [r0, #0]
	uxCriticalNesting = 0;
 801fa2a:	2500      	movs	r5, #0
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 801fa2c:	7013      	strb	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 801fa2e:	f8d4 3d20 	ldr.w	r3, [r4, #3360]	@ 0xd20
 801fa32:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
 801fa36:	f8c4 3d20 	str.w	r3, [r4, #3360]	@ 0xd20
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 801fa3a:	f8d4 3d20 	ldr.w	r3, [r4, #3360]	@ 0xd20
 801fa3e:	f043 4370 	orr.w	r3, r3, #4026531840	@ 0xf0000000
 801fa42:	f8c4 3d20 	str.w	r3, [r4, #3360]	@ 0xd20
	vPortSetupTimerInterrupt();
 801fa46:	f7ff ff9d 	bl	801f984 <vPortSetupTimerInterrupt>
	uxCriticalNesting = 0;
 801fa4a:	6035      	str	r5, [r6, #0]
	vPortEnableVFP();
 801fa4c:	f7ff feb8 	bl	801f7c0 <vPortEnableVFP>
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
 801fa50:	f8d4 3f34 	ldr.w	r3, [r4, #3892]	@ 0xf34
 801fa54:	f043 4340 	orr.w	r3, r3, #3221225472	@ 0xc0000000
 801fa58:	f8c4 3f34 	str.w	r3, [r4, #3892]	@ 0xf34
	prvPortStartFirstTask();
 801fa5c:	f7ff fe9c 	bl	801f798 <prvPortStartFirstTask>
	vTaskSwitchContext();
 801fa60:	f7ff fb04 	bl	801f06c <vTaskSwitchContext>
	configASSERT( uxCriticalNesting == ~0UL );
 801fa64:	6833      	ldr	r3, [r6, #0]
volatile uint32_t ulDummy = 0;
 801fa66:	9503      	str	r5, [sp, #12]
	configASSERT( uxCriticalNesting == ~0UL );
 801fa68:	3301      	adds	r3, #1
 801fa6a:	d00a      	beq.n	801fa82 <xPortStartScheduler+0xd6>
 801fa6c:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801fa70:	b672      	cpsid	i
 801fa72:	f383 8811 	msr	BASEPRI, r3
 801fa76:	f3bf 8f6f 	isb	sy
 801fa7a:	f3bf 8f4f 	dsb	sy
 801fa7e:	b662      	cpsie	i
 801fa80:	e7fe      	b.n	801fa80 <xPortStartScheduler+0xd4>
 801fa82:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801fa86:	b672      	cpsid	i
 801fa88:	f383 8811 	msr	BASEPRI, r3
 801fa8c:	f3bf 8f6f 	isb	sy
 801fa90:	f3bf 8f4f 	dsb	sy
 801fa94:	b662      	cpsie	i
	while( ulDummy == 0 )
 801fa96:	9b03      	ldr	r3, [sp, #12]
 801fa98:	2b00      	cmp	r3, #0
 801fa9a:	d0fc      	beq.n	801fa96 <xPortStartScheduler+0xea>
}
 801fa9c:	2000      	movs	r0, #0
 801fa9e:	b004      	add	sp, #16
 801faa0:	bd70      	pop	{r4, r5, r6, pc}
 801faa2:	bf00      	nop
 801faa4:	e000e400 	.word	0xe000e400
 801faa8:	20003918 	.word	0x20003918
 801faac:	2000391c 	.word	0x2000391c
 801fab0:	200000a4 	.word	0x200000a4

0801fab4 <vPortValidateInterruptPriority>:
	{
	uint32_t ulCurrentInterrupt;
	uint8_t ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
 801fab4:	f3ef 8305 	mrs	r3, IPSR

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
 801fab8:	2b0f      	cmp	r3, #15
 801faba:	d910      	bls.n	801fade <vPortValidateInterruptPriority+0x2a>
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 801fabc:	4913      	ldr	r1, [pc, #76]	@ (801fb0c <vPortValidateInterruptPriority+0x58>)
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 801fabe:	4a14      	ldr	r2, [pc, #80]	@ (801fb10 <vPortValidateInterruptPriority+0x5c>)
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 801fac0:	5c5b      	ldrb	r3, [r3, r1]
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 801fac2:	7812      	ldrb	r2, [r2, #0]
 801fac4:	429a      	cmp	r2, r3
 801fac6:	d90a      	bls.n	801fade <vPortValidateInterruptPriority+0x2a>
 801fac8:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801facc:	b672      	cpsid	i
 801face:	f383 8811 	msr	BASEPRI, r3
 801fad2:	f3bf 8f6f 	isb	sy
 801fad6:	f3bf 8f4f 	dsb	sy
 801fada:	b662      	cpsie	i
 801fadc:	e7fe      	b.n	801fadc <vPortValidateInterruptPriority+0x28>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredictable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
 801fade:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 801fae2:	4a0c      	ldr	r2, [pc, #48]	@ (801fb14 <vPortValidateInterruptPriority+0x60>)
 801fae4:	f8d3 3d0c 	ldr.w	r3, [r3, #3340]	@ 0xd0c
 801fae8:	6812      	ldr	r2, [r2, #0]
 801faea:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
 801faee:	4293      	cmp	r3, r2
 801faf0:	d90a      	bls.n	801fb08 <vPortValidateInterruptPriority+0x54>
 801faf2:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801faf6:	b672      	cpsid	i
 801faf8:	f383 8811 	msr	BASEPRI, r3
 801fafc:	f3bf 8f6f 	isb	sy
 801fb00:	f3bf 8f4f 	dsb	sy
 801fb04:	b662      	cpsie	i
 801fb06:	e7fe      	b.n	801fb06 <vPortValidateInterruptPriority+0x52>
	}
 801fb08:	4770      	bx	lr
 801fb0a:	bf00      	nop
 801fb0c:	e000e3f0 	.word	0xe000e3f0
 801fb10:	2000391c 	.word	0x2000391c
 801fb14:	20003918 	.word	0x20003918

0801fb18 <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 801fb18:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 801fb1c:	4604      	mov	r4, r0
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;

	vTaskSuspendAll();
 801fb1e:	f7ff f8dd 	bl	801ecdc <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
 801fb22:	4a55      	ldr	r2, [pc, #340]	@ (801fc78 <pvPortMalloc+0x160>)
 801fb24:	6815      	ldr	r5, [r2, #0]
 801fb26:	2d00      	cmp	r5, #0
 801fb28:	d071      	beq.n	801fc0e <pvPortMalloc+0xf6>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 801fb2a:	4b54      	ldr	r3, [pc, #336]	@ (801fc7c <pvPortMalloc+0x164>)
 801fb2c:	681f      	ldr	r7, [r3, #0]
 801fb2e:	423c      	tst	r4, r7
 801fb30:	d130      	bne.n	801fb94 <pvPortMalloc+0x7c>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
 801fb32:	b37c      	cbz	r4, 801fb94 <pvPortMalloc+0x7c>
			{
				xWantedSize += xHeapStructSize;
 801fb34:	f104 0008 	add.w	r0, r4, #8

				/* Ensure that blocks are always aligned to the required number
				of bytes. */
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 801fb38:	0764      	lsls	r4, r4, #29
 801fb3a:	d002      	beq.n	801fb42 <pvPortMalloc+0x2a>
				{
					/* Byte alignment required. */
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 801fb3c:	f020 0007 	bic.w	r0, r0, #7
 801fb40:	3008      	adds	r0, #8
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 801fb42:	b338      	cbz	r0, 801fb94 <pvPortMalloc+0x7c>
 801fb44:	f8df e148 	ldr.w	lr, [pc, #328]	@ 801fc90 <pvPortMalloc+0x178>
 801fb48:	f8de c000 	ldr.w	ip, [lr]
 801fb4c:	4584      	cmp	ip, r0
 801fb4e:	d321      	bcc.n	801fb94 <pvPortMalloc+0x7c>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
 801fb50:	4c4b      	ldr	r4, [pc, #300]	@ (801fc80 <pvPortMalloc+0x168>)
 801fb52:	6823      	ldr	r3, [r4, #0]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 801fb54:	e003      	b.n	801fb5e <pvPortMalloc+0x46>
 801fb56:	681a      	ldr	r2, [r3, #0]
 801fb58:	b122      	cbz	r2, 801fb64 <pvPortMalloc+0x4c>
 801fb5a:	461c      	mov	r4, r3
 801fb5c:	4613      	mov	r3, r2
 801fb5e:	6859      	ldr	r1, [r3, #4]
 801fb60:	4281      	cmp	r1, r0
 801fb62:	d3f8      	bcc.n	801fb56 <pvPortMalloc+0x3e>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
 801fb64:	42ab      	cmp	r3, r5
 801fb66:	d015      	beq.n	801fb94 <pvPortMalloc+0x7c>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 801fb68:	461e      	mov	r6, r3
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 801fb6a:	1a0a      	subs	r2, r1, r0
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 801fb6c:	f856 8b08 	ldr.w	r8, [r6], #8
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 801fb70:	2a10      	cmp	r2, #16
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 801fb72:	f8c4 8000 	str.w	r8, [r4]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 801fb76:	d92e      	bls.n	801fbd6 <pvPortMalloc+0xbe>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 801fb78:	181c      	adds	r4, r3, r0
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 801fb7a:	0761      	lsls	r1, r4, #29
 801fb7c:	d012      	beq.n	801fba4 <pvPortMalloc+0x8c>
 801fb7e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801fb82:	b672      	cpsid	i
 801fb84:	f383 8811 	msr	BASEPRI, r3
 801fb88:	f3bf 8f6f 	isb	sy
 801fb8c:	f3bf 8f4f 	dsb	sy
 801fb90:	b662      	cpsie	i
 801fb92:	e7fe      	b.n	801fb92 <pvPortMalloc+0x7a>
	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
 801fb94:	2600      	movs	r6, #0
	( void ) xTaskResumeAll();
 801fb96:	f7ff f9fd 	bl	801ef94 <xTaskResumeAll>
			vApplicationMallocFailedHook();
 801fb9a:	f7f1 f8b9 	bl	8010d10 <vApplicationMallocFailedHook>
	}
	#endif

	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
	return pvReturn;
}
 801fb9e:	4630      	mov	r0, r6
 801fba0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 801fba4:	6062      	str	r2, [r4, #4]
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 801fba6:	4a36      	ldr	r2, [pc, #216]	@ (801fc80 <pvPortMalloc+0x168>)
						pxBlock->xBlockSize = xWantedSize;
 801fba8:	6058      	str	r0, [r3, #4]
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 801fbaa:	4690      	mov	r8, r2
 801fbac:	6812      	ldr	r2, [r2, #0]
 801fbae:	4294      	cmp	r4, r2
 801fbb0:	d8fb      	bhi.n	801fbaa <pvPortMalloc+0x92>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 801fbb2:	f8d8 1004 	ldr.w	r1, [r8, #4]
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 801fbb6:	f8d4 9004 	ldr.w	r9, [r4, #4]
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 801fbba:	eb08 0a01 	add.w	sl, r8, r1
 801fbbe:	4554      	cmp	r4, sl
 801fbc0:	d044      	beq.n	801fc4c <pvPortMalloc+0x134>
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 801fbc2:	eb04 0109 	add.w	r1, r4, r9
 801fbc6:	428a      	cmp	r2, r1
 801fbc8:	d04a      	beq.n	801fc60 <pvPortMalloc+0x148>
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 801fbca:	4601      	mov	r1, r0
 801fbcc:	6022      	str	r2, [r4, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 801fbce:	45a0      	cmp	r8, r4
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 801fbd0:	bf18      	it	ne
 801fbd2:	f8c8 4000 	strne.w	r4, [r8]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 801fbd6:	482b      	ldr	r0, [pc, #172]	@ (801fc84 <pvPortMalloc+0x16c>)
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 801fbd8:	ebac 0201 	sub.w	r2, ip, r1
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 801fbdc:	4339      	orrs	r1, r7
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 801fbde:	6804      	ldr	r4, [r0, #0]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 801fbe0:	f8ce 2000 	str.w	r2, [lr]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 801fbe4:	42a2      	cmp	r2, r4
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 801fbe6:	bf38      	it	cc
 801fbe8:	6002      	strcc	r2, [r0, #0]
					pxBlock->pxNextFreeBlock = NULL;
 801fbea:	2200      	movs	r2, #0
 801fbec:	e9c3 2100 	strd	r2, r1, [r3]
	( void ) xTaskResumeAll();
 801fbf0:	f7ff f9d0 	bl	801ef94 <xTaskResumeAll>
	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 801fbf4:	0773      	lsls	r3, r6, #29
 801fbf6:	d0d2      	beq.n	801fb9e <pvPortMalloc+0x86>
 801fbf8:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801fbfc:	b672      	cpsid	i
 801fbfe:	f383 8811 	msr	BASEPRI, r3
 801fc02:	f3bf 8f6f 	isb	sy
 801fc06:	f3bf 8f4f 	dsb	sy
 801fc0a:	b662      	cpsie	i
 801fc0c:	e7fe      	b.n	801fc0c <pvPortMalloc+0xf4>
	uxAddress = ( size_t ) ucHeap;
 801fc0e:	4b1e      	ldr	r3, [pc, #120]	@ (801fc88 <pvPortMalloc+0x170>)
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 801fc10:	f04f 4000 	mov.w	r0, #2147483648	@ 0x80000000
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 801fc14:	4e1a      	ldr	r6, [pc, #104]	@ (801fc80 <pvPortMalloc+0x168>)
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 801fc16:	075d      	lsls	r5, r3, #29
	uxAddress -= xHeapStructSize;
 801fc18:	4d1c      	ldr	r5, [pc, #112]	@ (801fc8c <pvPortMalloc+0x174>)
}
 801fc1a:	4607      	mov	r7, r0
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
 801fc1c:	bf18      	it	ne
 801fc1e:	3307      	addne	r3, #7
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 801fc20:	f025 0507 	bic.w	r5, r5, #7
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 801fc24:	bf18      	it	ne
 801fc26:	f023 0307 	bicne.w	r3, r3, #7
	pxEnd = ( void * ) uxAddress;
 801fc2a:	6015      	str	r5, [r2, #0]
	xStart.xBlockSize = ( size_t ) 0;
 801fc2c:	2200      	movs	r2, #0
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 801fc2e:	6033      	str	r3, [r6, #0]
 801fc30:	4619      	mov	r1, r3
	xStart.xBlockSize = ( size_t ) 0;
 801fc32:	6072      	str	r2, [r6, #4]
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 801fc34:	1aeb      	subs	r3, r5, r3
	pxEnd->pxNextFreeBlock = NULL;
 801fc36:	e9c5 2200 	strd	r2, r2, [r5]
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 801fc3a:	4a12      	ldr	r2, [pc, #72]	@ (801fc84 <pvPortMalloc+0x16c>)
 801fc3c:	6013      	str	r3, [r2, #0]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 801fc3e:	4a14      	ldr	r2, [pc, #80]	@ (801fc90 <pvPortMalloc+0x178>)
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 801fc40:	e9c1 5300 	strd	r5, r3, [r1]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 801fc44:	6013      	str	r3, [r2, #0]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 801fc46:	4b0d      	ldr	r3, [pc, #52]	@ (801fc7c <pvPortMalloc+0x164>)
 801fc48:	6018      	str	r0, [r3, #0]
}
 801fc4a:	e770      	b.n	801fb2e <pvPortMalloc+0x16>
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 801fc4c:	4489      	add	r9, r1
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 801fc4e:	eb08 0109 	add.w	r1, r8, r9
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 801fc52:	f8c8 9004 	str.w	r9, [r8, #4]
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 801fc56:	428a      	cmp	r2, r1
 801fc58:	d001      	beq.n	801fc5e <pvPortMalloc+0x146>
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 801fc5a:	6859      	ldr	r1, [r3, #4]
 801fc5c:	e7bb      	b.n	801fbd6 <pvPortMalloc+0xbe>
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 801fc5e:	4644      	mov	r4, r8
		if( pxIterator->pxNextFreeBlock != pxEnd )
 801fc60:	42aa      	cmp	r2, r5
 801fc62:	d006      	beq.n	801fc72 <pvPortMalloc+0x15a>
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 801fc64:	6851      	ldr	r1, [r2, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 801fc66:	6812      	ldr	r2, [r2, #0]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 801fc68:	4449      	add	r1, r9
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 801fc6a:	6022      	str	r2, [r4, #0]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 801fc6c:	6061      	str	r1, [r4, #4]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 801fc6e:	6859      	ldr	r1, [r3, #4]
 801fc70:	e7ad      	b.n	801fbce <pvPortMalloc+0xb6>
 801fc72:	6859      	ldr	r1, [r3, #4]
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
 801fc74:	6022      	str	r2, [r4, #0]
 801fc76:	e7aa      	b.n	801fbce <pvPortMalloc+0xb6>
 801fc78:	2000392c 	.word	0x2000392c
 801fc7c:	20003920 	.word	0x20003920
 801fc80:	20003930 	.word	0x20003930
 801fc84:	20003924 	.word	0x20003924
 801fc88:	20003938 	.word	0x20003938
 801fc8c:	2000b930 	.word	0x2000b930
 801fc90:	20003928 	.word	0x20003928

0801fc94 <vPortFree>:
	if( pv != NULL )
 801fc94:	b1f0      	cbz	r0, 801fcd4 <vPortFree+0x40>
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 801fc96:	4a2d      	ldr	r2, [pc, #180]	@ (801fd4c <vPortFree+0xb8>)
 801fc98:	f850 3c04 	ldr.w	r3, [r0, #-4]
 801fc9c:	6812      	ldr	r2, [r2, #0]
 801fc9e:	4213      	tst	r3, r2
 801fca0:	d00d      	beq.n	801fcbe <vPortFree+0x2a>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 801fca2:	f850 1c08 	ldr.w	r1, [r0, #-8]
 801fca6:	b1b1      	cbz	r1, 801fcd6 <vPortFree+0x42>
 801fca8:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801fcac:	b672      	cpsid	i
 801fcae:	f383 8811 	msr	BASEPRI, r3
 801fcb2:	f3bf 8f6f 	isb	sy
 801fcb6:	f3bf 8f4f 	dsb	sy
 801fcba:	b662      	cpsie	i
 801fcbc:	e7fe      	b.n	801fcbc <vPortFree+0x28>
 801fcbe:	f04f 0350 	mov.w	r3, #80	@ 0x50
 801fcc2:	b672      	cpsid	i
 801fcc4:	f383 8811 	msr	BASEPRI, r3
 801fcc8:	f3bf 8f6f 	isb	sy
 801fccc:	f3bf 8f4f 	dsb	sy
 801fcd0:	b662      	cpsie	i
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 801fcd2:	e7fe      	b.n	801fcd2 <vPortFree+0x3e>
 801fcd4:	4770      	bx	lr
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 801fcd6:	ea23 0302 	bic.w	r3, r3, r2
{
 801fcda:	b530      	push	{r4, r5, lr}
 801fcdc:	b083      	sub	sp, #12
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 801fcde:	f840 3c04 	str.w	r3, [r0, #-4]
		puc -= xHeapStructSize;
 801fce2:	f1a0 0408 	sub.w	r4, r0, #8
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 801fce6:	9001      	str	r0, [sp, #4]
				vTaskSuspendAll();
 801fce8:	f7fe fff8 	bl	801ecdc <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
 801fcec:	4a18      	ldr	r2, [pc, #96]	@ (801fd50 <vPortFree+0xbc>)
 801fcee:	9801      	ldr	r0, [sp, #4]
 801fcf0:	6813      	ldr	r3, [r2, #0]
 801fcf2:	f850 1c04 	ldr.w	r1, [r0, #-4]
 801fcf6:	440b      	add	r3, r1
 801fcf8:	6013      	str	r3, [r2, #0]
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 801fcfa:	4b16      	ldr	r3, [pc, #88]	@ (801fd54 <vPortFree+0xc0>)
 801fcfc:	461a      	mov	r2, r3
 801fcfe:	681b      	ldr	r3, [r3, #0]
 801fd00:	429c      	cmp	r4, r3
 801fd02:	d8fb      	bhi.n	801fcfc <vPortFree+0x68>
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 801fd04:	6855      	ldr	r5, [r2, #4]
 801fd06:	eb02 0e05 	add.w	lr, r2, r5
 801fd0a:	4574      	cmp	r4, lr
 801fd0c:	d00d      	beq.n	801fd2a <vPortFree+0x96>
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 801fd0e:	eb04 0c01 	add.w	ip, r4, r1
 801fd12:	4563      	cmp	r3, ip
 801fd14:	d00f      	beq.n	801fd36 <vPortFree+0xa2>
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 801fd16:	f840 3c08 	str.w	r3, [r0, #-8]
	if( pxIterator != pxBlockToInsert )
 801fd1a:	42a2      	cmp	r2, r4
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 801fd1c:	bf18      	it	ne
 801fd1e:	6014      	strne	r4, [r2, #0]
}
 801fd20:	b003      	add	sp, #12
 801fd22:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
				( void ) xTaskResumeAll();
 801fd26:	f7ff b935 	b.w	801ef94 <xTaskResumeAll>
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 801fd2a:	4429      	add	r1, r5
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 801fd2c:	1850      	adds	r0, r2, r1
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 801fd2e:	6051      	str	r1, [r2, #4]
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 801fd30:	4283      	cmp	r3, r0
 801fd32:	d1f5      	bne.n	801fd20 <vPortFree+0x8c>
 801fd34:	4614      	mov	r4, r2
		if( pxIterator->pxNextFreeBlock != pxEnd )
 801fd36:	4808      	ldr	r0, [pc, #32]	@ (801fd58 <vPortFree+0xc4>)
 801fd38:	6800      	ldr	r0, [r0, #0]
 801fd3a:	4283      	cmp	r3, r0
 801fd3c:	d003      	beq.n	801fd46 <vPortFree+0xb2>
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 801fd3e:	e9d3 0500 	ldrd	r0, r5, [r3]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 801fd42:	4429      	add	r1, r5
 801fd44:	6061      	str	r1, [r4, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 801fd46:	6020      	str	r0, [r4, #0]
 801fd48:	e7e7      	b.n	801fd1a <vPortFree+0x86>
 801fd4a:	bf00      	nop
 801fd4c:	20003920 	.word	0x20003920
 801fd50:	20003928 	.word	0x20003928
 801fd54:	20003930 	.word	0x20003930
 801fd58:	2000392c 	.word	0x2000392c

0801fd5c <MX_USB_DEVICE_Init>:
/**
  * Init USB device Library, add supported class and start the library
  * @retval None
  */
void MX_USB_DEVICE_Init(void)
{
 801fd5c:	b508      	push	{r3, lr}
  /* USER CODE BEGIN USB_DEVICE_Init_PreTreatment */

  /* USER CODE END USB_DEVICE_Init_PreTreatment */

  /* Init Device Library, add supported class and start the library. */
  if (USBD_Init(&hUsbDeviceFS, &FS_Desc, DEVICE_FS) != USBD_OK)
 801fd5e:	2200      	movs	r2, #0
 801fd60:	4917      	ldr	r1, [pc, #92]	@ (801fdc0 <MX_USB_DEVICE_Init+0x64>)
 801fd62:	4818      	ldr	r0, [pc, #96]	@ (801fdc4 <MX_USB_DEVICE_Init+0x68>)
 801fd64:	f7fc fffa 	bl	801cd5c <USBD_Init>
 801fd68:	b970      	cbnz	r0, 801fd88 <MX_USB_DEVICE_Init+0x2c>
  {
    Error_Handler();
  }
  if (USBD_RegisterClass(&hUsbDeviceFS, &USBD_CDC) != USBD_OK)
 801fd6a:	4917      	ldr	r1, [pc, #92]	@ (801fdc8 <MX_USB_DEVICE_Init+0x6c>)
 801fd6c:	4815      	ldr	r0, [pc, #84]	@ (801fdc4 <MX_USB_DEVICE_Init+0x68>)
 801fd6e:	f7fd f809 	bl	801cd84 <USBD_RegisterClass>
 801fd72:	b988      	cbnz	r0, 801fd98 <MX_USB_DEVICE_Init+0x3c>
  {
    Error_Handler();
  }
  if (USBD_CDC_RegisterInterface(&hUsbDeviceFS, &USBD_Interface_fops_FS) != USBD_OK)
 801fd74:	4915      	ldr	r1, [pc, #84]	@ (801fdcc <MX_USB_DEVICE_Init+0x70>)
 801fd76:	4813      	ldr	r0, [pc, #76]	@ (801fdc4 <MX_USB_DEVICE_Init+0x68>)
 801fd78:	f7fc ff94 	bl	801cca4 <USBD_CDC_RegisterInterface>
 801fd7c:	b9a0      	cbnz	r0, 801fda8 <MX_USB_DEVICE_Init+0x4c>
  {
    Error_Handler();
  }
  if (USBD_Start(&hUsbDeviceFS) != USBD_OK)
 801fd7e:	4811      	ldr	r0, [pc, #68]	@ (801fdc4 <MX_USB_DEVICE_Init+0x68>)
 801fd80:	f7fd f81c 	bl	801cdbc <USBD_Start>
 801fd84:	b9b8      	cbnz	r0, 801fdb6 <MX_USB_DEVICE_Init+0x5a>
  }

  /* USER CODE BEGIN USB_DEVICE_Init_PostTreatment */

  /* USER CODE END USB_DEVICE_Init_PostTreatment */
}
 801fd86:	bd08      	pop	{r3, pc}
    Error_Handler();
 801fd88:	f7f2 f89a 	bl	8011ec0 <Error_Handler>
  if (USBD_RegisterClass(&hUsbDeviceFS, &USBD_CDC) != USBD_OK)
 801fd8c:	490e      	ldr	r1, [pc, #56]	@ (801fdc8 <MX_USB_DEVICE_Init+0x6c>)
 801fd8e:	480d      	ldr	r0, [pc, #52]	@ (801fdc4 <MX_USB_DEVICE_Init+0x68>)
 801fd90:	f7fc fff8 	bl	801cd84 <USBD_RegisterClass>
 801fd94:	2800      	cmp	r0, #0
 801fd96:	d0ed      	beq.n	801fd74 <MX_USB_DEVICE_Init+0x18>
    Error_Handler();
 801fd98:	f7f2 f892 	bl	8011ec0 <Error_Handler>
  if (USBD_CDC_RegisterInterface(&hUsbDeviceFS, &USBD_Interface_fops_FS) != USBD_OK)
 801fd9c:	490b      	ldr	r1, [pc, #44]	@ (801fdcc <MX_USB_DEVICE_Init+0x70>)
 801fd9e:	4809      	ldr	r0, [pc, #36]	@ (801fdc4 <MX_USB_DEVICE_Init+0x68>)
 801fda0:	f7fc ff80 	bl	801cca4 <USBD_CDC_RegisterInterface>
 801fda4:	2800      	cmp	r0, #0
 801fda6:	d0ea      	beq.n	801fd7e <MX_USB_DEVICE_Init+0x22>
    Error_Handler();
 801fda8:	f7f2 f88a 	bl	8011ec0 <Error_Handler>
  if (USBD_Start(&hUsbDeviceFS) != USBD_OK)
 801fdac:	4805      	ldr	r0, [pc, #20]	@ (801fdc4 <MX_USB_DEVICE_Init+0x68>)
 801fdae:	f7fd f805 	bl	801cdbc <USBD_Start>
 801fdb2:	2800      	cmp	r0, #0
 801fdb4:	d0e7      	beq.n	801fd86 <MX_USB_DEVICE_Init+0x2a>
}
 801fdb6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 801fdba:	f7f2 b881 	b.w	8011ec0 <Error_Handler>
 801fdbe:	bf00      	nop
 801fdc0:	200000fc 	.word	0x200000fc
 801fdc4:	2000b938 	.word	0x2000b938
 801fdc8:	20000060 	.word	0x20000060
 801fdcc:	200000a8 	.word	0x200000a8

0801fdd0 <CDC_DeInit_FS>:
static int8_t CDC_DeInit_FS(void)
{
  /* USER CODE BEGIN 4 */
  return (USBD_OK);
  /* USER CODE END 4 */
}
 801fdd0:	2000      	movs	r0, #0
 801fdd2:	4770      	bx	lr

0801fdd4 <CDC_Control_FS>:
    break;
  }

  return (USBD_OK);
  /* USER CODE END 5 */
}
 801fdd4:	2000      	movs	r0, #0
 801fdd6:	4770      	bx	lr

0801fdd8 <CDC_TransmitCplt_FS>:
  UNUSED(Buf);
  UNUSED(Len);
  UNUSED(epnum);
  /* USER CODE END 13 */
  return result;
}
 801fdd8:	2000      	movs	r0, #0
 801fdda:	4770      	bx	lr

0801fddc <CDC_Receive_FS>:
{
 801fddc:	b510      	push	{r4, lr}
  USBD_CDC_SetRxBuffer(&hUsbDeviceFS, &Buf[0]);
 801fdde:	4c05      	ldr	r4, [pc, #20]	@ (801fdf4 <CDC_Receive_FS+0x18>)
{
 801fde0:	4601      	mov	r1, r0
  USBD_CDC_SetRxBuffer(&hUsbDeviceFS, &Buf[0]);
 801fde2:	4620      	mov	r0, r4
 801fde4:	f7fc ff78 	bl	801ccd8 <USBD_CDC_SetRxBuffer>
  USBD_CDC_ReceivePacket(&hUsbDeviceFS);
 801fde8:	4620      	mov	r0, r4
 801fdea:	f7fc ff9d 	bl	801cd28 <USBD_CDC_ReceivePacket>
}
 801fdee:	2000      	movs	r0, #0
 801fdf0:	bd10      	pop	{r4, pc}
 801fdf2:	bf00      	nop
 801fdf4:	2000b938 	.word	0x2000b938

0801fdf8 <CDC_Init_FS>:
{
 801fdf8:	b510      	push	{r4, lr}
  USBD_CDC_SetTxBuffer(&hUsbDeviceFS, UserTxBufferFS, 0);
 801fdfa:	4c06      	ldr	r4, [pc, #24]	@ (801fe14 <CDC_Init_FS+0x1c>)
 801fdfc:	2200      	movs	r2, #0
 801fdfe:	4906      	ldr	r1, [pc, #24]	@ (801fe18 <CDC_Init_FS+0x20>)
 801fe00:	4620      	mov	r0, r4
 801fe02:	f7fc ff5b 	bl	801ccbc <USBD_CDC_SetTxBuffer>
  USBD_CDC_SetRxBuffer(&hUsbDeviceFS, UserRxBufferFS);
 801fe06:	4905      	ldr	r1, [pc, #20]	@ (801fe1c <CDC_Init_FS+0x24>)
 801fe08:	4620      	mov	r0, r4
 801fe0a:	f7fc ff65 	bl	801ccd8 <USBD_CDC_SetRxBuffer>
}
 801fe0e:	2000      	movs	r0, #0
 801fe10:	bd10      	pop	{r4, pc}
 801fe12:	bf00      	nop
 801fe14:	2000b938 	.word	0x2000b938
 801fe18:	2000bc14 	.word	0x2000bc14
 801fe1c:	2000c414 	.word	0x2000c414

0801fe20 <CDC_Transmit_FS>:
{
 801fe20:	b510      	push	{r4, lr}
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef*)hUsbDeviceFS.pClassData;
 801fe22:	4c09      	ldr	r4, [pc, #36]	@ (801fe48 <CDC_Transmit_FS+0x28>)
 801fe24:	f8d4 32bc 	ldr.w	r3, [r4, #700]	@ 0x2bc
  if (hcdc->TxState != 0){
 801fe28:	f8d3 3214 	ldr.w	r3, [r3, #532]	@ 0x214
 801fe2c:	b10b      	cbz	r3, 801fe32 <CDC_Transmit_FS+0x12>
}
 801fe2e:	2001      	movs	r0, #1
 801fe30:	bd10      	pop	{r4, pc}
  USBD_CDC_SetTxBuffer(&hUsbDeviceFS, Buf, Len);
 801fe32:	460a      	mov	r2, r1
 801fe34:	4601      	mov	r1, r0
 801fe36:	4620      	mov	r0, r4
 801fe38:	f7fc ff40 	bl	801ccbc <USBD_CDC_SetTxBuffer>
  result = USBD_CDC_TransmitPacket(&hUsbDeviceFS);
 801fe3c:	4620      	mov	r0, r4
}
 801fe3e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  result = USBD_CDC_TransmitPacket(&hUsbDeviceFS);
 801fe42:	f7fc bf55 	b.w	801ccf0 <USBD_CDC_TransmitPacket>
 801fe46:	bf00      	nop
 801fe48:	2000b938 	.word	0x2000b938

0801fe4c <USBD_FS_DeviceDescriptor>:
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_DeviceDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
  UNUSED(speed);
  *length = sizeof(USBD_FS_DeviceDesc);
 801fe4c:	2312      	movs	r3, #18
  return USBD_FS_DeviceDesc;
}
 801fe4e:	4801      	ldr	r0, [pc, #4]	@ (801fe54 <USBD_FS_DeviceDescriptor+0x8>)
  *length = sizeof(USBD_FS_DeviceDesc);
 801fe50:	800b      	strh	r3, [r1, #0]
}
 801fe52:	4770      	bx	lr
 801fe54:	200000e8 	.word	0x200000e8

0801fe58 <USBD_FS_LangIDStrDescriptor>:
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_LangIDStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
  UNUSED(speed);
  *length = sizeof(USBD_LangIDDesc);
 801fe58:	2304      	movs	r3, #4
  return USBD_LangIDDesc;
}
 801fe5a:	4801      	ldr	r0, [pc, #4]	@ (801fe60 <USBD_FS_LangIDStrDescriptor+0x8>)
  *length = sizeof(USBD_LangIDDesc);
 801fe5c:	800b      	strh	r3, [r1, #0]
}
 801fe5e:	4770      	bx	lr
 801fe60:	200000d8 	.word	0x200000d8

0801fe64 <USBD_FS_USR_BOSDescriptor>:
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_USR_BOSDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
  UNUSED(speed);
  *length = sizeof(USBD_FS_BOSDesc);
 801fe64:	230c      	movs	r3, #12
  return (uint8_t*)USBD_FS_BOSDesc;
}
 801fe66:	4801      	ldr	r0, [pc, #4]	@ (801fe6c <USBD_FS_USR_BOSDescriptor+0x8>)
  *length = sizeof(USBD_FS_BOSDesc);
 801fe68:	800b      	strh	r3, [r1, #0]
}
 801fe6a:	4770      	bx	lr
 801fe6c:	200000dc 	.word	0x200000dc

0801fe70 <USBD_FS_ManufacturerStrDescriptor>:
{
 801fe70:	b510      	push	{r4, lr}
  USBD_GetString((uint8_t *)USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 801fe72:	4c04      	ldr	r4, [pc, #16]	@ (801fe84 <USBD_FS_ManufacturerStrDescriptor+0x14>)
{
 801fe74:	460a      	mov	r2, r1
  USBD_GetString((uint8_t *)USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 801fe76:	4804      	ldr	r0, [pc, #16]	@ (801fe88 <USBD_FS_ManufacturerStrDescriptor+0x18>)
 801fe78:	4621      	mov	r1, r4
 801fe7a:	f7fd fbf7 	bl	801d66c <USBD_GetString>
}
 801fe7e:	4620      	mov	r0, r4
 801fe80:	bd10      	pop	{r4, pc}
 801fe82:	bf00      	nop
 801fe84:	2000cc14 	.word	0x2000cc14
 801fe88:	08034c54 	.word	0x08034c54

0801fe8c <USBD_FS_ProductStrDescriptor>:
{
 801fe8c:	b510      	push	{r4, lr}
    USBD_GetString((uint8_t *)USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);
 801fe8e:	4c04      	ldr	r4, [pc, #16]	@ (801fea0 <USBD_FS_ProductStrDescriptor+0x14>)
{
 801fe90:	460a      	mov	r2, r1
    USBD_GetString((uint8_t *)USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);
 801fe92:	4804      	ldr	r0, [pc, #16]	@ (801fea4 <USBD_FS_ProductStrDescriptor+0x18>)
 801fe94:	4621      	mov	r1, r4
 801fe96:	f7fd fbe9 	bl	801d66c <USBD_GetString>
}
 801fe9a:	4620      	mov	r0, r4
 801fe9c:	bd10      	pop	{r4, pc}
 801fe9e:	bf00      	nop
 801fea0:	2000cc14 	.word	0x2000cc14
 801fea4:	08034c68 	.word	0x08034c68

0801fea8 <USBD_FS_ConfigStrDescriptor>:
{
 801fea8:	b510      	push	{r4, lr}
    USBD_GetString((uint8_t *)USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length);
 801feaa:	4c04      	ldr	r4, [pc, #16]	@ (801febc <USBD_FS_ConfigStrDescriptor+0x14>)
{
 801feac:	460a      	mov	r2, r1
    USBD_GetString((uint8_t *)USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length);
 801feae:	4804      	ldr	r0, [pc, #16]	@ (801fec0 <USBD_FS_ConfigStrDescriptor+0x18>)
 801feb0:	4621      	mov	r1, r4
 801feb2:	f7fd fbdb 	bl	801d66c <USBD_GetString>
}
 801feb6:	4620      	mov	r0, r4
 801feb8:	bd10      	pop	{r4, pc}
 801feba:	bf00      	nop
 801febc:	2000cc14 	.word	0x2000cc14
 801fec0:	08034c80 	.word	0x08034c80

0801fec4 <USBD_FS_InterfaceStrDescriptor>:
{
 801fec4:	b510      	push	{r4, lr}
    USBD_GetString((uint8_t *)USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
 801fec6:	4c04      	ldr	r4, [pc, #16]	@ (801fed8 <USBD_FS_InterfaceStrDescriptor+0x14>)
{
 801fec8:	460a      	mov	r2, r1
    USBD_GetString((uint8_t *)USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
 801feca:	4804      	ldr	r0, [pc, #16]	@ (801fedc <USBD_FS_InterfaceStrDescriptor+0x18>)
 801fecc:	4621      	mov	r1, r4
 801fece:	f7fd fbcd 	bl	801d66c <USBD_GetString>
}
 801fed2:	4620      	mov	r0, r4
 801fed4:	bd10      	pop	{r4, pc}
 801fed6:	bf00      	nop
 801fed8:	2000cc14 	.word	0x2000cc14
 801fedc:	08034c8c 	.word	0x08034c8c

0801fee0 <USBD_FS_SerialStrDescriptor>:
{
  uint32_t deviceserial0;
  uint32_t deviceserial1;
  uint32_t deviceserial2;

  deviceserial0 = *(uint32_t *) DEVICE_ID1;
 801fee0:	4a52      	ldr	r2, [pc, #328]	@ (802002c <USBD_FS_SerialStrDescriptor+0x14c>)
  *length = USB_SIZ_STRING_SERIAL;
 801fee2:	f04f 0c1a 	mov.w	ip, #26
  deviceserial0 = *(uint32_t *) DEVICE_ID1;
 801fee6:	f8d2 3420 	ldr.w	r3, [r2, #1056]	@ 0x420
  deviceserial1 = *(uint32_t *) DEVICE_ID2;
  deviceserial2 = *(uint32_t *) DEVICE_ID3;

  deviceserial0 += deviceserial2;
 801feea:	f8d2 0428 	ldr.w	r0, [r2, #1064]	@ 0x428
  *length = USB_SIZ_STRING_SERIAL;
 801feee:	f8a1 c000 	strh.w	ip, [r1]

  if (deviceserial0 != 0)
 801fef2:	181b      	adds	r3, r3, r0
 801fef4:	d101      	bne.n	801fefa <USBD_FS_SerialStrDescriptor+0x1a>
}
 801fef6:	484e      	ldr	r0, [pc, #312]	@ (8020030 <USBD_FS_SerialStrDescriptor+0x150>)
 801fef8:	4770      	bx	lr
  deviceserial1 = *(uint32_t *) DEVICE_ID2;
 801fefa:	f8d2 1424 	ldr.w	r1, [r2, #1060]	@ 0x424

  for (idx = 0; idx < len; idx++)
  {
    if (((value >> 28)) < 0xA)
    {
      pbuf[2 * idx] = (value >> 28) + '0';
 801fefe:	0f18      	lsrs	r0, r3, #28
 801ff00:	4a4b      	ldr	r2, [pc, #300]	@ (8020030 <USBD_FS_SerialStrDescriptor+0x150>)
    if (((value >> 28)) < 0xA)
 801ff02:	f1b3 4f20 	cmp.w	r3, #2684354560	@ 0xa0000000
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
    }

    value = value << 4;

    pbuf[2 * idx + 1] = 0;
 801ff06:	f04f 0c00 	mov.w	ip, #0
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 801ff0a:	bf2c      	ite	cs
 801ff0c:	3037      	addcs	r0, #55	@ 0x37
      pbuf[2 * idx] = (value >> 28) + '0';
 801ff0e:	3030      	addcc	r0, #48	@ 0x30
    pbuf[2 * idx + 1] = 0;
 801ff10:	f882 c003 	strb.w	ip, [r2, #3]
    if (((value >> 28)) < 0xA)
 801ff14:	f3c3 6c03 	ubfx	ip, r3, #24, #4
      pbuf[2 * idx] = (value >> 28) + '0';
 801ff18:	7090      	strb	r0, [r2, #2]
    if (((value >> 28)) < 0xA)
 801ff1a:	f1bc 0f09 	cmp.w	ip, #9
      pbuf[2 * idx] = (value >> 28) + '0';
 801ff1e:	4660      	mov	r0, ip
    pbuf[2 * idx + 1] = 0;
 801ff20:	f04f 0c00 	mov.w	ip, #0
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 801ff24:	bf8c      	ite	hi
 801ff26:	3037      	addhi	r0, #55	@ 0x37
      pbuf[2 * idx] = (value >> 28) + '0';
 801ff28:	3030      	addls	r0, #48	@ 0x30
    pbuf[2 * idx + 1] = 0;
 801ff2a:	f882 c005 	strb.w	ip, [r2, #5]
    if (((value >> 28)) < 0xA)
 801ff2e:	f3c3 5c03 	ubfx	ip, r3, #20, #4
      pbuf[2 * idx] = (value >> 28) + '0';
 801ff32:	7110      	strb	r0, [r2, #4]
    if (((value >> 28)) < 0xA)
 801ff34:	f1bc 0f09 	cmp.w	ip, #9
      pbuf[2 * idx] = (value >> 28) + '0';
 801ff38:	4660      	mov	r0, ip
    pbuf[2 * idx + 1] = 0;
 801ff3a:	f04f 0c00 	mov.w	ip, #0
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 801ff3e:	bf8c      	ite	hi
 801ff40:	3037      	addhi	r0, #55	@ 0x37
      pbuf[2 * idx] = (value >> 28) + '0';
 801ff42:	3030      	addls	r0, #48	@ 0x30
    pbuf[2 * idx + 1] = 0;
 801ff44:	f882 c007 	strb.w	ip, [r2, #7]
    if (((value >> 28)) < 0xA)
 801ff48:	f3c3 4c03 	ubfx	ip, r3, #16, #4
      pbuf[2 * idx] = (value >> 28) + '0';
 801ff4c:	7190      	strb	r0, [r2, #6]
    if (((value >> 28)) < 0xA)
 801ff4e:	f1bc 0f09 	cmp.w	ip, #9
      pbuf[2 * idx] = (value >> 28) + '0';
 801ff52:	4660      	mov	r0, ip
    pbuf[2 * idx + 1] = 0;
 801ff54:	f04f 0c00 	mov.w	ip, #0
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 801ff58:	bf8c      	ite	hi
 801ff5a:	3037      	addhi	r0, #55	@ 0x37
      pbuf[2 * idx] = (value >> 28) + '0';
 801ff5c:	3030      	addls	r0, #48	@ 0x30
    pbuf[2 * idx + 1] = 0;
 801ff5e:	f882 c009 	strb.w	ip, [r2, #9]
    if (((value >> 28)) < 0xA)
 801ff62:	f3c3 3c03 	ubfx	ip, r3, #12, #4
      pbuf[2 * idx] = (value >> 28) + '0';
 801ff66:	7210      	strb	r0, [r2, #8]
    if (((value >> 28)) < 0xA)
 801ff68:	f1bc 0f09 	cmp.w	ip, #9
      pbuf[2 * idx] = (value >> 28) + '0';
 801ff6c:	4660      	mov	r0, ip
    pbuf[2 * idx + 1] = 0;
 801ff6e:	f04f 0c00 	mov.w	ip, #0
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 801ff72:	bf8c      	ite	hi
 801ff74:	3037      	addhi	r0, #55	@ 0x37
      pbuf[2 * idx] = (value >> 28) + '0';
 801ff76:	3030      	addls	r0, #48	@ 0x30
    pbuf[2 * idx + 1] = 0;
 801ff78:	f882 c00b 	strb.w	ip, [r2, #11]
    if (((value >> 28)) < 0xA)
 801ff7c:	f3c3 2c03 	ubfx	ip, r3, #8, #4
      pbuf[2 * idx] = (value >> 28) + '0';
 801ff80:	7290      	strb	r0, [r2, #10]
    if (((value >> 28)) < 0xA)
 801ff82:	f1bc 0f09 	cmp.w	ip, #9
      pbuf[2 * idx] = (value >> 28) + '0';
 801ff86:	4660      	mov	r0, ip
    pbuf[2 * idx + 1] = 0;
 801ff88:	f04f 0c00 	mov.w	ip, #0
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 801ff8c:	bf8c      	ite	hi
 801ff8e:	3037      	addhi	r0, #55	@ 0x37
      pbuf[2 * idx] = (value >> 28) + '0';
 801ff90:	3030      	addls	r0, #48	@ 0x30
    pbuf[2 * idx + 1] = 0;
 801ff92:	f882 c00d 	strb.w	ip, [r2, #13]
    if (((value >> 28)) < 0xA)
 801ff96:	f3c3 1c03 	ubfx	ip, r3, #4, #4
      pbuf[2 * idx] = (value >> 28) + '0';
 801ff9a:	7310      	strb	r0, [r2, #12]
    if (((value >> 28)) < 0xA)
 801ff9c:	f1bc 0f09 	cmp.w	ip, #9
      pbuf[2 * idx] = (value >> 28) + '0';
 801ffa0:	4660      	mov	r0, ip
    pbuf[2 * idx + 1] = 0;
 801ffa2:	f04f 0c00 	mov.w	ip, #0
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 801ffa6:	bf8c      	ite	hi
 801ffa8:	3037      	addhi	r0, #55	@ 0x37
      pbuf[2 * idx] = (value >> 28) + '0';
 801ffaa:	3030      	addls	r0, #48	@ 0x30
    pbuf[2 * idx + 1] = 0;
 801ffac:	f882 c00f 	strb.w	ip, [r2, #15]
 801ffb0:	f04f 0c00 	mov.w	ip, #0
      pbuf[2 * idx] = (value >> 28) + '0';
 801ffb4:	7390      	strb	r0, [r2, #14]
    if (((value >> 28)) < 0xA)
 801ffb6:	f003 000f 	and.w	r0, r3, #15
    pbuf[2 * idx + 1] = 0;
 801ffba:	f882 c013 	strb.w	ip, [r2, #19]
 801ffbe:	f04f 0c00 	mov.w	ip, #0
      pbuf[2 * idx] = (value >> 28) + '0';
 801ffc2:	4603      	mov	r3, r0
    if (((value >> 28)) < 0xA)
 801ffc4:	2809      	cmp	r0, #9
    pbuf[2 * idx + 1] = 0;
 801ffc6:	f04f 0000 	mov.w	r0, #0
 801ffca:	f882 c015 	strb.w	ip, [r2, #21]
      pbuf[2 * idx] = (value >> 28) + '0';
 801ffce:	bf94      	ite	ls
 801ffd0:	3330      	addls	r3, #48	@ 0x30
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 801ffd2:	3337      	addhi	r3, #55	@ 0x37
    if (((value >> 28)) < 0xA)
 801ffd4:	f1b1 4f20 	cmp.w	r1, #2684354560	@ 0xa0000000
    pbuf[2 * idx + 1] = 0;
 801ffd8:	7450      	strb	r0, [r2, #17]
      pbuf[2 * idx] = (value >> 28) + '0';
 801ffda:	7413      	strb	r3, [r2, #16]
 801ffdc:	ea4f 7311 	mov.w	r3, r1, lsr #28
    if (((value >> 28)) < 0xA)
 801ffe0:	f3c1 6003 	ubfx	r0, r1, #24, #4
    pbuf[2 * idx + 1] = 0;
 801ffe4:	f04f 0c00 	mov.w	ip, #0
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 801ffe8:	bf2c      	ite	cs
 801ffea:	3337      	addcs	r3, #55	@ 0x37
      pbuf[2 * idx] = (value >> 28) + '0';
 801ffec:	3330      	addcc	r3, #48	@ 0x30
    if (((value >> 28)) < 0xA)
 801ffee:	2809      	cmp	r0, #9
    pbuf[2 * idx + 1] = 0;
 801fff0:	f882 c017 	strb.w	ip, [r2, #23]
      pbuf[2 * idx] = (value >> 28) + '0';
 801fff4:	7493      	strb	r3, [r2, #18]
 801fff6:	4603      	mov	r3, r0
    if (((value >> 28)) < 0xA)
 801fff8:	f3c1 5003 	ubfx	r0, r1, #20, #4
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 801fffc:	bf8c      	ite	hi
 801fffe:	3337      	addhi	r3, #55	@ 0x37
      pbuf[2 * idx] = (value >> 28) + '0';
 8020000:	3330      	addls	r3, #48	@ 0x30
    if (((value >> 28)) < 0xA)
 8020002:	2809      	cmp	r0, #9
      pbuf[2 * idx] = (value >> 28) + '0';
 8020004:	7513      	strb	r3, [r2, #20]
 8020006:	4603      	mov	r3, r0
    if (((value >> 28)) < 0xA)
 8020008:	f3c1 4003 	ubfx	r0, r1, #16, #4
    pbuf[2 * idx + 1] = 0;
 802000c:	f04f 0100 	mov.w	r1, #0
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8020010:	bf8c      	ite	hi
 8020012:	3337      	addhi	r3, #55	@ 0x37
      pbuf[2 * idx] = (value >> 28) + '0';
 8020014:	3330      	addls	r3, #48	@ 0x30
    if (((value >> 28)) < 0xA)
 8020016:	2809      	cmp	r0, #9
    pbuf[2 * idx + 1] = 0;
 8020018:	7651      	strb	r1, [r2, #25]
      pbuf[2 * idx] = (value >> 28) + '0';
 802001a:	7593      	strb	r3, [r2, #22]
 802001c:	4603      	mov	r3, r0
}
 802001e:	4804      	ldr	r0, [pc, #16]	@ (8020030 <USBD_FS_SerialStrDescriptor+0x150>)
      pbuf[2 * idx] = (value >> 28) + '0';
 8020020:	bf94      	ite	ls
 8020022:	3330      	addls	r3, #48	@ 0x30
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8020024:	3337      	addhi	r3, #55	@ 0x37
      pbuf[2 * idx] = (value >> 28) + '0';
 8020026:	7613      	strb	r3, [r2, #24]
}
 8020028:	4770      	bx	lr
 802002a:	bf00      	nop
 802002c:	1ff0f000 	.word	0x1ff0f000
 8020030:	200000bc 	.word	0x200000bc

08020034 <HAL_PCD_MspInit>:
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(pcdHandle->Instance==USB_OTG_FS)
 8020034:	6803      	ldr	r3, [r0, #0]
{
 8020036:	b530      	push	{r4, r5, lr}
  if(pcdHandle->Instance==USB_OTG_FS)
 8020038:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
{
 802003c:	b08b      	sub	sp, #44	@ 0x2c
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 802003e:	f04f 0400 	mov.w	r4, #0
 8020042:	e9cd 4404 	strd	r4, r4, [sp, #16]
 8020046:	e9cd 4406 	strd	r4, r4, [sp, #24]
 802004a:	9408      	str	r4, [sp, #32]
  if(pcdHandle->Instance==USB_OTG_FS)
 802004c:	d001      	beq.n	8020052 <HAL_PCD_MspInit+0x1e>
    HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
  /* USER CODE BEGIN USB_OTG_FS_MspInit 1 */

  /* USER CODE END USB_OTG_FS_MspInit 1 */
  }
}
 802004e:	b00b      	add	sp, #44	@ 0x2c
 8020050:	bd30      	pop	{r4, r5, pc}
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8020052:	4d19      	ldr	r5, [pc, #100]	@ (80200b8 <HAL_PCD_MspInit+0x84>)
    GPIO_InitStruct.Pin = OTG_FS_P_Pin|OTG_FS_N_Pin;
 8020054:	f44f 52c0 	mov.w	r2, #6144	@ 0x1800
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8020058:	a904      	add	r1, sp, #16
    __HAL_RCC_GPIOA_CLK_ENABLE();
 802005a:	6b2b      	ldr	r3, [r5, #48]	@ 0x30
 802005c:	f043 0301 	orr.w	r3, r3, #1
 8020060:	632b      	str	r3, [r5, #48]	@ 0x30
 8020062:	6b2b      	ldr	r3, [r5, #48]	@ 0x30
 8020064:	f003 0301 	and.w	r3, r3, #1
 8020068:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Pin = OTG_FS_P_Pin|OTG_FS_N_Pin;
 802006a:	2302      	movs	r3, #2
    __HAL_RCC_GPIOA_CLK_ENABLE();
 802006c:	9801      	ldr	r0, [sp, #4]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 802006e:	4813      	ldr	r0, [pc, #76]	@ (80200bc <HAL_PCD_MspInit+0x88>)
    GPIO_InitStruct.Pin = OTG_FS_P_Pin|OTG_FS_N_Pin;
 8020070:	e9cd 2304 	strd	r2, r3, [sp, #16]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8020074:	2203      	movs	r2, #3
 8020076:	230a      	movs	r3, #10
 8020078:	e9cd 2307 	strd	r2, r3, [sp, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 802007c:	f7f4 fffe 	bl	801507c <HAL_GPIO_Init>
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 8020080:	6b6b      	ldr	r3, [r5, #52]	@ 0x34
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 5, 0);
 8020082:	4622      	mov	r2, r4
 8020084:	2105      	movs	r1, #5
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 8020086:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 5, 0);
 802008a:	2043      	movs	r0, #67	@ 0x43
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 802008c:	636b      	str	r3, [r5, #52]	@ 0x34
 802008e:	6b6b      	ldr	r3, [r5, #52]	@ 0x34
 8020090:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8020094:	9302      	str	r3, [sp, #8]
 8020096:	9b02      	ldr	r3, [sp, #8]
 8020098:	6c6b      	ldr	r3, [r5, #68]	@ 0x44
 802009a:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 802009e:	646b      	str	r3, [r5, #68]	@ 0x44
 80200a0:	6c6b      	ldr	r3, [r5, #68]	@ 0x44
 80200a2:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 80200a6:	9303      	str	r3, [sp, #12]
 80200a8:	9b03      	ldr	r3, [sp, #12]
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 5, 0);
 80200aa:	f7f3 f875 	bl	8013198 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
 80200ae:	2043      	movs	r0, #67	@ 0x43
 80200b0:	f7f3 f8ae 	bl	8013210 <HAL_NVIC_EnableIRQ>
}
 80200b4:	b00b      	add	sp, #44	@ 0x2c
 80200b6:	bd30      	pop	{r4, r5, pc}
 80200b8:	40023800 	.word	0x40023800
 80200bc:	40020000 	.word	0x40020000

080200c0 <HAL_PCD_SetupStageCallback>:
static void PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  USBD_LL_SetupStage((USBD_HandleTypeDef*)hpcd->pData, (uint8_t *)hpcd->Setup);
 80200c0:	f200 419c 	addw	r1, r0, #1180	@ 0x49c
 80200c4:	f8d0 04dc 	ldr.w	r0, [r0, #1244]	@ 0x4dc
 80200c8:	f7fc be8c 	b.w	801cde4 <USBD_LL_SetupStage>

080200cc <HAL_PCD_DataOutStageCallback>:
static void PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  USBD_LL_DataOutStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->OUT_ep[epnum].xfer_buff);
 80200cc:	eb01 03c1 	add.w	r3, r1, r1, lsl #3
 80200d0:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 80200d4:	f8d0 04dc 	ldr.w	r0, [r0, #1244]	@ 0x4dc
 80200d8:	f8d3 2260 	ldr.w	r2, [r3, #608]	@ 0x260
 80200dc:	f7fc beb2 	b.w	801ce44 <USBD_LL_DataOutStage>

080200e0 <HAL_PCD_DataInStageCallback>:
static void PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  USBD_LL_DataInStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->IN_ep[epnum].xfer_buff);
 80200e0:	eb01 03c1 	add.w	r3, r1, r1, lsl #3
 80200e4:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 80200e8:	f8d0 04dc 	ldr.w	r0, [r0, #1244]	@ 0x4dc
 80200ec:	6a1a      	ldr	r2, [r3, #32]
 80200ee:	f7fc bee3 	b.w	801ceb8 <USBD_LL_DataInStage>
 80200f2:	bf00      	nop

080200f4 <HAL_PCD_SOFCallback>:
static void PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  USBD_LL_SOF((USBD_HandleTypeDef*)hpcd->pData);
 80200f4:	f8d0 04dc 	ldr.w	r0, [r0, #1244]	@ 0x4dc
 80200f8:	f7fc bf8c 	b.w	801d014 <USBD_LL_SOF>

080200fc <HAL_PCD_ResetCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 80200fc:	b510      	push	{r4, lr}
  USBD_SpeedTypeDef speed = USBD_SPEED_FULL;

  if ( hpcd->Init.speed == PCD_SPEED_HIGH)
 80200fe:	79c1      	ldrb	r1, [r0, #7]
{
 8020100:	4604      	mov	r4, r0
  if ( hpcd->Init.speed == PCD_SPEED_HIGH)
 8020102:	b111      	cbz	r1, 802010a <HAL_PCD_ResetCallback+0xe>
  {
    speed = USBD_SPEED_HIGH;
  }
  else if ( hpcd->Init.speed == PCD_SPEED_FULL)
 8020104:	2902      	cmp	r1, #2
 8020106:	d10a      	bne.n	802011e <HAL_PCD_ResetCallback+0x22>
  {
    speed = USBD_SPEED_FULL;
 8020108:	2101      	movs	r1, #1
  else
  {
    Error_Handler();
  }
    /* Set Speed. */
  USBD_LL_SetSpeed((USBD_HandleTypeDef*)hpcd->pData, speed);
 802010a:	f8d4 04dc 	ldr.w	r0, [r4, #1244]	@ 0x4dc
 802010e:	f7fc ff61 	bl	801cfd4 <USBD_LL_SetSpeed>

  /* Reset Device. */
  USBD_LL_Reset((USBD_HandleTypeDef*)hpcd->pData);
 8020112:	f8d4 04dc 	ldr.w	r0, [r4, #1244]	@ 0x4dc
}
 8020116:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  USBD_LL_Reset((USBD_HandleTypeDef*)hpcd->pData);
 802011a:	f7fc bf2d 	b.w	801cf78 <USBD_LL_Reset>
    Error_Handler();
 802011e:	f7f1 fecf 	bl	8011ec0 <Error_Handler>
    speed = USBD_SPEED_FULL;
 8020122:	2101      	movs	r1, #1
 8020124:	e7f1      	b.n	802010a <HAL_PCD_ResetCallback+0xe>
 8020126:	bf00      	nop

08020128 <HAL_PCD_SuspendCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8020128:	b510      	push	{r4, lr}
 802012a:	4604      	mov	r4, r0
  /* Inform USB library that core enters in suspend Mode. */
  USBD_LL_Suspend((USBD_HandleTypeDef*)hpcd->pData);
 802012c:	f8d0 04dc 	ldr.w	r0, [r0, #1244]	@ 0x4dc
 8020130:	f7fc ff54 	bl	801cfdc <USBD_LL_Suspend>
  __HAL_PCD_GATE_PHYCLOCK(hpcd);
 8020134:	6822      	ldr	r2, [r4, #0]
 8020136:	f8d2 3e00 	ldr.w	r3, [r2, #3584]	@ 0xe00
 802013a:	f043 0301 	orr.w	r3, r3, #1
 802013e:	f8c2 3e00 	str.w	r3, [r2, #3584]	@ 0xe00
  /* Enter in STOP mode. */
  /* USER CODE BEGIN 2 */
  if (hpcd->Init.low_power_enable)
 8020142:	7ae3      	ldrb	r3, [r4, #11]
 8020144:	b123      	cbz	r3, 8020150 <HAL_PCD_SuspendCallback+0x28>
  {
    /* Set SLEEPDEEP bit and SleepOnExit of Cortex System Control Register. */
    SCB->SCR |= (uint32_t)((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 8020146:	4a03      	ldr	r2, [pc, #12]	@ (8020154 <HAL_PCD_SuspendCallback+0x2c>)
 8020148:	6913      	ldr	r3, [r2, #16]
 802014a:	f043 0306 	orr.w	r3, r3, #6
 802014e:	6113      	str	r3, [r2, #16]
  }
  /* USER CODE END 2 */
}
 8020150:	bd10      	pop	{r4, pc}
 8020152:	bf00      	nop
 8020154:	e000ed00 	.word	0xe000ed00

08020158 <HAL_PCD_ResumeCallback>:
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  /* USER CODE BEGIN 3 */

  /* USER CODE END 3 */
  USBD_LL_Resume((USBD_HandleTypeDef*)hpcd->pData);
 8020158:	f8d0 04dc 	ldr.w	r0, [r0, #1244]	@ 0x4dc
 802015c:	f7fc bf4e 	b.w	801cffc <USBD_LL_Resume>

08020160 <HAL_PCD_ISOOUTIncompleteCallback>:
static void PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  USBD_LL_IsoOUTIncomplete((USBD_HandleTypeDef*)hpcd->pData, epnum);
 8020160:	f8d0 04dc 	ldr.w	r0, [r0, #1244]	@ 0x4dc
 8020164:	f7fc bf7c 	b.w	801d060 <USBD_LL_IsoOUTIncomplete>

08020168 <HAL_PCD_ISOINIncompleteCallback>:
static void PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  USBD_LL_IsoINIncomplete((USBD_HandleTypeDef*)hpcd->pData, epnum);
 8020168:	f8d0 04dc 	ldr.w	r0, [r0, #1244]	@ 0x4dc
 802016c:	f7fc bf62 	b.w	801d034 <USBD_LL_IsoINIncomplete>

08020170 <HAL_PCD_ConnectCallback>:
static void PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  USBD_LL_DevConnected((USBD_HandleTypeDef*)hpcd->pData);
 8020170:	f8d0 04dc 	ldr.w	r0, [r0, #1244]	@ 0x4dc
 8020174:	f7fc bf8a 	b.w	801d08c <USBD_LL_DevConnected>

08020178 <HAL_PCD_DisconnectCallback>:
static void PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  USBD_LL_DevDisconnected((USBD_HandleTypeDef*)hpcd->pData);
 8020178:	f8d0 04dc 	ldr.w	r0, [r0, #1244]	@ 0x4dc
 802017c:	f7fc bf88 	b.w	801d090 <USBD_LL_DevDisconnected>

08020180 <USBD_LL_Init>:
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Init(USBD_HandleTypeDef *pdev)
{
  /* Init USB Ip. */
  if (pdev->id == DEVICE_FS) {
 8020180:	7802      	ldrb	r2, [r0, #0]
 8020182:	b10a      	cbz	r2, 8020188 <USBD_LL_Init+0x8>
  HAL_PCDEx_SetRxFiFo(&hpcd_USB_OTG_FS, 0x80);
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 0, 0x40);
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 1, 0x80);
  }
  return USBD_OK;
}
 8020184:	2000      	movs	r0, #0
 8020186:	4770      	bx	lr
{
 8020188:	b508      	push	{r3, lr}
  hpcd_USB_OTG_FS.pData = pdev;
 802018a:	4b15      	ldr	r3, [pc, #84]	@ (80201e0 <USBD_LL_Init+0x60>)
  hpcd_USB_OTG_FS.Instance = USB_OTG_FS;
 802018c:	f04f 41a0 	mov.w	r1, #1342177280	@ 0x50000000
  hpcd_USB_OTG_FS.Init.dev_endpoints = 6;
 8020190:	f04f 0c06 	mov.w	ip, #6
  hpcd_USB_OTG_FS.pData = pdev;
 8020194:	f8c3 04dc 	str.w	r0, [r3, #1244]	@ 0x4dc
  pdev->pData = &hpcd_USB_OTG_FS;
 8020198:	f8c0 32c8 	str.w	r3, [r0, #712]	@ 0x2c8
  hpcd_USB_OTG_FS.Init.dma_enable = DISABLE;
 802019c:	f44f 7000 	mov.w	r0, #512	@ 0x200
  hpcd_USB_OTG_FS.Instance = USB_OTG_FS;
 80201a0:	6019      	str	r1, [r3, #0]
  hpcd_USB_OTG_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
 80201a2:	2102      	movs	r1, #2
  hpcd_USB_OTG_FS.Init.dma_enable = DISABLE;
 80201a4:	80d8      	strh	r0, [r3, #6]
  if (HAL_PCD_Init(&hpcd_USB_OTG_FS) != HAL_OK)
 80201a6:	4618      	mov	r0, r3
  hpcd_USB_OTG_FS.Init.dev_endpoints = 6;
 80201a8:	f883 c004 	strb.w	ip, [r3, #4]
  hpcd_USB_OTG_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
 80201ac:	f8c3 1009 	str.w	r1, [r3, #9]
  hpcd_USB_OTG_FS.Init.vbus_sensing_enable = DISABLE;
 80201b0:	81da      	strh	r2, [r3, #14]
  if (HAL_PCD_Init(&hpcd_USB_OTG_FS) != HAL_OK)
 80201b2:	f7f6 f89b 	bl	80162ec <HAL_PCD_Init>
 80201b6:	b978      	cbnz	r0, 80201d8 <USBD_LL_Init+0x58>
  HAL_PCDEx_SetRxFiFo(&hpcd_USB_OTG_FS, 0x80);
 80201b8:	2180      	movs	r1, #128	@ 0x80
 80201ba:	4809      	ldr	r0, [pc, #36]	@ (80201e0 <USBD_LL_Init+0x60>)
 80201bc:	f7f7 fa4c 	bl	8017658 <HAL_PCDEx_SetRxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 0, 0x40);
 80201c0:	2240      	movs	r2, #64	@ 0x40
 80201c2:	2100      	movs	r1, #0
 80201c4:	4806      	ldr	r0, [pc, #24]	@ (80201e0 <USBD_LL_Init+0x60>)
 80201c6:	f7f7 f9c5 	bl	8017554 <HAL_PCDEx_SetTxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 1, 0x80);
 80201ca:	2280      	movs	r2, #128	@ 0x80
 80201cc:	2101      	movs	r1, #1
 80201ce:	4804      	ldr	r0, [pc, #16]	@ (80201e0 <USBD_LL_Init+0x60>)
 80201d0:	f7f7 f9c0 	bl	8017554 <HAL_PCDEx_SetTxFiFo>
}
 80201d4:	2000      	movs	r0, #0
 80201d6:	bd08      	pop	{r3, pc}
    Error_Handler( );
 80201d8:	f7f1 fe72 	bl	8011ec0 <Error_Handler>
 80201dc:	e7ec      	b.n	80201b8 <USBD_LL_Init+0x38>
 80201de:	bf00      	nop
 80201e0:	2000ce14 	.word	0x2000ce14

080201e4 <USBD_LL_Start>:
  * @brief  Starts the low level portion of the device driver.
  * @param  pdev: Device handle
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Start(USBD_HandleTypeDef *pdev)
{
 80201e4:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;

  hal_status = HAL_PCD_Start(pdev->pData);
 80201e6:	f8d0 02c8 	ldr.w	r0, [r0, #712]	@ 0x2c8
 80201ea:	f7f6 fa99 	bl	8016720 <HAL_PCD_Start>
  */
USBD_StatusTypeDef USBD_Get_USB_Status(HAL_StatusTypeDef hal_status)
{
  USBD_StatusTypeDef usb_status = USBD_OK;

  switch (hal_status)
 80201ee:	b118      	cbz	r0, 80201f8 <USBD_LL_Start+0x14>
 80201f0:	2802      	cmp	r0, #2
 80201f2:	bf0c      	ite	eq
 80201f4:	2001      	moveq	r0, #1
 80201f6:	2003      	movne	r0, #3
}
 80201f8:	bd08      	pop	{r3, pc}
 80201fa:	bf00      	nop

080201fc <USBD_LL_OpenEP>:
{
 80201fc:	4694      	mov	ip, r2
  hal_status = HAL_PCD_EP_Open(pdev->pData, ep_addr, ep_mps, ep_type);
 80201fe:	f8d0 02c8 	ldr.w	r0, [r0, #712]	@ 0x2c8
{
 8020202:	461a      	mov	r2, r3
 8020204:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_Open(pdev->pData, ep_addr, ep_mps, ep_type);
 8020206:	4663      	mov	r3, ip
 8020208:	f7f7 f860 	bl	80172cc <HAL_PCD_EP_Open>
  switch (hal_status)
 802020c:	b118      	cbz	r0, 8020216 <USBD_LL_OpenEP+0x1a>
 802020e:	2802      	cmp	r0, #2
 8020210:	bf0c      	ite	eq
 8020212:	2001      	moveq	r0, #1
 8020214:	2003      	movne	r0, #3
}
 8020216:	bd08      	pop	{r3, pc}

08020218 <USBD_LL_CloseEP>:
{
 8020218:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_Close(pdev->pData, ep_addr);
 802021a:	f8d0 02c8 	ldr.w	r0, [r0, #712]	@ 0x2c8
 802021e:	f7f7 f893 	bl	8017348 <HAL_PCD_EP_Close>
  switch (hal_status)
 8020222:	b118      	cbz	r0, 802022c <USBD_LL_CloseEP+0x14>
 8020224:	2802      	cmp	r0, #2
 8020226:	bf0c      	ite	eq
 8020228:	2001      	moveq	r0, #1
 802022a:	2003      	movne	r0, #3
}
 802022c:	bd08      	pop	{r3, pc}
 802022e:	bf00      	nop

08020230 <USBD_LL_StallEP>:
{
 8020230:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
 8020232:	f8d0 02c8 	ldr.w	r0, [r0, #712]	@ 0x2c8
 8020236:	f7f7 f90d 	bl	8017454 <HAL_PCD_EP_SetStall>
  switch (hal_status)
 802023a:	b118      	cbz	r0, 8020244 <USBD_LL_StallEP+0x14>
 802023c:	2802      	cmp	r0, #2
 802023e:	bf0c      	ite	eq
 8020240:	2001      	moveq	r0, #1
 8020242:	2003      	movne	r0, #3
}
 8020244:	bd08      	pop	{r3, pc}
 8020246:	bf00      	nop

08020248 <USBD_LL_ClearStallEP>:
{
 8020248:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);
 802024a:	f8d0 02c8 	ldr.w	r0, [r0, #712]	@ 0x2c8
 802024e:	f7f7 f945 	bl	80174dc <HAL_PCD_EP_ClrStall>
  switch (hal_status)
 8020252:	b118      	cbz	r0, 802025c <USBD_LL_ClearStallEP+0x14>
 8020254:	2802      	cmp	r0, #2
 8020256:	bf0c      	ite	eq
 8020258:	2001      	moveq	r0, #1
 802025a:	2003      	movne	r0, #3
}
 802025c:	bd08      	pop	{r3, pc}
 802025e:	bf00      	nop

08020260 <USBD_LL_IsStallEP>:
  if((ep_addr & 0x80) == 0x80)
 8020260:	060a      	lsls	r2, r1, #24
  PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef*) pdev->pData;
 8020262:	f8d0 32c8 	ldr.w	r3, [r0, #712]	@ 0x2c8
  if((ep_addr & 0x80) == 0x80)
 8020266:	d406      	bmi.n	8020276 <USBD_LL_IsStallEP+0x16>
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall;
 8020268:	eb01 01c1 	add.w	r1, r1, r1, lsl #3
 802026c:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 8020270:	f893 0256 	ldrb.w	r0, [r3, #598]	@ 0x256
}
 8020274:	4770      	bx	lr
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall;
 8020276:	f001 017f 	and.w	r1, r1, #127	@ 0x7f
 802027a:	eb01 01c1 	add.w	r1, r1, r1, lsl #3
 802027e:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 8020282:	7d98      	ldrb	r0, [r3, #22]
 8020284:	4770      	bx	lr
 8020286:	bf00      	nop

08020288 <USBD_LL_SetUSBAddress>:
{
 8020288:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_SetAddress(pdev->pData, dev_addr);
 802028a:	f8d0 02c8 	ldr.w	r0, [r0, #712]	@ 0x2c8
 802028e:	f7f7 f809 	bl	80172a4 <HAL_PCD_SetAddress>
  switch (hal_status)
 8020292:	b118      	cbz	r0, 802029c <USBD_LL_SetUSBAddress+0x14>
 8020294:	2802      	cmp	r0, #2
 8020296:	bf0c      	ite	eq
 8020298:	2001      	moveq	r0, #1
 802029a:	2003      	movne	r0, #3
}
 802029c:	bd08      	pop	{r3, pc}
 802029e:	bf00      	nop

080202a0 <USBD_LL_Transmit>:
{
 80202a0:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
 80202a2:	f8d0 02c8 	ldr.w	r0, [r0, #712]	@ 0x2c8
 80202a6:	f7f7 f8b3 	bl	8017410 <HAL_PCD_EP_Transmit>
  switch (hal_status)
 80202aa:	b118      	cbz	r0, 80202b4 <USBD_LL_Transmit+0x14>
 80202ac:	2802      	cmp	r0, #2
 80202ae:	bf0c      	ite	eq
 80202b0:	2001      	moveq	r0, #1
 80202b2:	2003      	movne	r0, #3
}
 80202b4:	bd08      	pop	{r3, pc}
 80202b6:	bf00      	nop

080202b8 <USBD_LL_PrepareReceive>:
{
 80202b8:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
 80202ba:	f8d0 02c8 	ldr.w	r0, [r0, #712]	@ 0x2c8
 80202be:	f7f7 f87b 	bl	80173b8 <HAL_PCD_EP_Receive>
  switch (hal_status)
 80202c2:	b118      	cbz	r0, 80202cc <USBD_LL_PrepareReceive+0x14>
 80202c4:	2802      	cmp	r0, #2
 80202c6:	bf0c      	ite	eq
 80202c8:	2001      	moveq	r0, #1
 80202ca:	2003      	movne	r0, #3
}
 80202cc:	bd08      	pop	{r3, pc}
 80202ce:	bf00      	nop

080202d0 <USBD_LL_GetRxDataSize>:
  return HAL_PCD_EP_GetRxCount((PCD_HandleTypeDef*) pdev->pData, ep_addr);
 80202d0:	f8d0 02c8 	ldr.w	r0, [r0, #712]	@ 0x2c8
 80202d4:	f7f7 b892 	b.w	80173fc <HAL_PCD_EP_GetRxCount>

080202d8 <HAL_PCDEx_LPM_Callback>:
{
 80202d8:	b510      	push	{r4, lr}
 80202da:	4604      	mov	r4, r0
  switch (msg)
 80202dc:	b1a1      	cbz	r1, 8020308 <HAL_PCDEx_LPM_Callback+0x30>
 80202de:	2901      	cmp	r1, #1
 80202e0:	d111      	bne.n	8020306 <HAL_PCDEx_LPM_Callback+0x2e>
    __HAL_PCD_GATE_PHYCLOCK(hpcd);
 80202e2:	6802      	ldr	r2, [r0, #0]
    USBD_LL_Suspend(hpcd->pData);
 80202e4:	f8d0 04dc 	ldr.w	r0, [r0, #1244]	@ 0x4dc
    __HAL_PCD_GATE_PHYCLOCK(hpcd);
 80202e8:	f8d2 3e00 	ldr.w	r3, [r2, #3584]	@ 0xe00
 80202ec:	f043 0301 	orr.w	r3, r3, #1
 80202f0:	f8c2 3e00 	str.w	r3, [r2, #3584]	@ 0xe00
    USBD_LL_Suspend(hpcd->pData);
 80202f4:	f7fc fe72 	bl	801cfdc <USBD_LL_Suspend>
    if (hpcd->Init.low_power_enable)
 80202f8:	7ae3      	ldrb	r3, [r4, #11]
 80202fa:	b123      	cbz	r3, 8020306 <HAL_PCDEx_LPM_Callback+0x2e>
      SCB->SCR |= (uint32_t)((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 80202fc:	4a0e      	ldr	r2, [pc, #56]	@ (8020338 <HAL_PCDEx_LPM_Callback+0x60>)
 80202fe:	6913      	ldr	r3, [r2, #16]
 8020300:	f043 0306 	orr.w	r3, r3, #6
 8020304:	6113      	str	r3, [r2, #16]
}
 8020306:	bd10      	pop	{r4, pc}
    if (hpcd->Init.low_power_enable)
 8020308:	7ac3      	ldrb	r3, [r0, #11]
 802030a:	b963      	cbnz	r3, 8020326 <HAL_PCDEx_LPM_Callback+0x4e>
    __HAL_PCD_UNGATE_PHYCLOCK(hpcd);
 802030c:	6822      	ldr	r2, [r4, #0]
    USBD_LL_Resume(hpcd->pData);
 802030e:	f8d4 04dc 	ldr.w	r0, [r4, #1244]	@ 0x4dc
    __HAL_PCD_UNGATE_PHYCLOCK(hpcd);
 8020312:	f8d2 3e00 	ldr.w	r3, [r2, #3584]	@ 0xe00
 8020316:	f023 0301 	bic.w	r3, r3, #1
}
 802031a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    __HAL_PCD_UNGATE_PHYCLOCK(hpcd);
 802031e:	f8c2 3e00 	str.w	r3, [r2, #3584]	@ 0xe00
    USBD_LL_Resume(hpcd->pData);
 8020322:	f7fc be6b 	b.w	801cffc <USBD_LL_Resume>
  SystemClock_Config();
 8020326:	f7f0 fd85 	bl	8010e34 <SystemClock_Config>
      SCB->SCR &= (uint32_t)~((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 802032a:	4a03      	ldr	r2, [pc, #12]	@ (8020338 <HAL_PCDEx_LPM_Callback+0x60>)
 802032c:	6913      	ldr	r3, [r2, #16]
 802032e:	f023 0306 	bic.w	r3, r3, #6
 8020332:	6113      	str	r3, [r2, #16]
 8020334:	e7ea      	b.n	802030c <HAL_PCDEx_LPM_Callback+0x34>
 8020336:	bf00      	nop
 8020338:	e000ed00 	.word	0xe000ed00

0802033c <MX_X_CUBE_AI_Init>:
/* USER CODE END 2 */

/* Entry points --------------------------------------------------------------*/

void MX_X_CUBE_AI_Init(void)
{
 802033c:	b570      	push	{r4, r5, r6, lr}
  err = ai_network_create_and_init(&network, act_addr, NULL);
 802033e:	4c14      	ldr	r4, [pc, #80]	@ (8020390 <MX_X_CUBE_AI_Init+0x54>)
    /* USER CODE BEGIN 5 */
  printf("\r\nTEMPLATE - initialization\r\n");
 8020340:	4814      	ldr	r0, [pc, #80]	@ (8020394 <MX_X_CUBE_AI_Init+0x58>)
 8020342:	f012 fd7d 	bl	8032e40 <puts>
  err = ai_network_create_and_init(&network, act_addr, NULL);
 8020346:	2200      	movs	r2, #0
 8020348:	4913      	ldr	r1, [pc, #76]	@ (8020398 <MX_X_CUBE_AI_Init+0x5c>)
 802034a:	4620      	mov	r0, r4
 802034c:	f000 f978 	bl	8020640 <ai_network_create_and_init>
  if (err.type != AI_ERROR_NONE) {
 8020350:	f010 05ff 	ands.w	r5, r0, #255	@ 0xff
 8020354:	d114      	bne.n	8020380 <MX_X_CUBE_AI_Init+0x44>
  ai_input = ai_network_inputs_get(network, NULL);
 8020356:	4629      	mov	r1, r5
 8020358:	6820      	ldr	r0, [r4, #0]
 802035a:	f000 f82b 	bl	80203b4 <ai_network_inputs_get>
 802035e:	4e0f      	ldr	r6, [pc, #60]	@ (802039c <MX_X_CUBE_AI_Init+0x60>)
 8020360:	4603      	mov	r3, r0
  ai_output = ai_network_outputs_get(network, NULL);
 8020362:	4629      	mov	r1, r5
 8020364:	6820      	ldr	r0, [r4, #0]
  ai_input = ai_network_inputs_get(network, NULL);
 8020366:	6033      	str	r3, [r6, #0]
  ai_output = ai_network_outputs_get(network, NULL);
 8020368:	f000 f832 	bl	80203d0 <ai_network_outputs_get>
 802036c:	4c0c      	ldr	r4, [pc, #48]	@ (80203a0 <MX_X_CUBE_AI_Init+0x64>)
	data_ins[idx] = ai_input[idx].data;
 802036e:	6832      	ldr	r2, [r6, #0]
 8020370:	4b0c      	ldr	r3, [pc, #48]	@ (80203a4 <MX_X_CUBE_AI_Init+0x68>)
 8020372:	6852      	ldr	r2, [r2, #4]
	data_outs[idx] = ai_output[idx].data;
 8020374:	490c      	ldr	r1, [pc, #48]	@ (80203a8 <MX_X_CUBE_AI_Init+0x6c>)
  ai_output = ai_network_outputs_get(network, NULL);
 8020376:	6020      	str	r0, [r4, #0]
	data_outs[idx] = ai_output[idx].data;
 8020378:	6840      	ldr	r0, [r0, #4]
	data_ins[idx] = ai_input[idx].data;
 802037a:	601a      	str	r2, [r3, #0]
	data_outs[idx] = ai_output[idx].data;
 802037c:	6008      	str	r0, [r1, #0]

  ai_boostrap(data_activations0);
    /* USER CODE END 5 */
}
 802037e:	bd70      	pop	{r4, r5, r6, pc}
    printf("TEMPLATE - Error (%s) - type=0x%02x code=0x%02x\r\n", fct,
 8020380:	0a03      	lsrs	r3, r0, #8
 8020382:	462a      	mov	r2, r5
 8020384:	4909      	ldr	r1, [pc, #36]	@ (80203ac <MX_X_CUBE_AI_Init+0x70>)
 8020386:	480a      	ldr	r0, [pc, #40]	@ (80203b0 <MX_X_CUBE_AI_Init+0x74>)
 8020388:	f012 fcf2 	bl	8032d70 <iprintf>
  do {} while (1);
 802038c:	e7fe      	b.n	802038c <MX_X_CUBE_AI_Init+0x50>
 802038e:	bf00      	nop
 8020390:	2000d2fc 	.word	0x2000d2fc
 8020394:	08034c9c 	.word	0x08034c9c
 8020398:	2000011c 	.word	0x2000011c
 802039c:	2000d2f8 	.word	0x2000d2f8
 80203a0:	2000d2f4 	.word	0x2000d2f4
 80203a4:	20012184 	.word	0x20012184
 80203a8:	20012180 	.word	0x20012180
 80203ac:	08034cbc 	.word	0x08034cbc
 80203b0:	08034cd8 	.word	0x08034cd8

080203b4 <ai_network_inputs_get>:


AI_API_ENTRY
ai_buffer* ai_network_inputs_get(ai_handle network, ai_u16 *n_buffer)
{
  if (network == AI_HANDLE_NULL) {
 80203b4:	b108      	cbz	r0, 80203ba <ai_network_inputs_get+0x6>
    network = (ai_handle)&AI_NET_OBJ_INSTANCE;
    AI_NETWORK_OBJ(network)->magic = AI_MAGIC_CONTEXT_TOKEN;
  }
  return ai_platform_inputs_get(network, n_buffer);
 80203b6:	f000 be63 	b.w	8021080 <ai_platform_inputs_get>
    AI_NETWORK_OBJ(network)->magic = AI_MAGIC_CONTEXT_TOKEN;
 80203ba:	4b03      	ldr	r3, [pc, #12]	@ (80203c8 <ai_network_inputs_get+0x14>)
 80203bc:	4a03      	ldr	r2, [pc, #12]	@ (80203cc <ai_network_inputs_get+0x18>)
    network = (ai_handle)&AI_NET_OBJ_INSTANCE;
 80203be:	4618      	mov	r0, r3
    AI_NETWORK_OBJ(network)->magic = AI_MAGIC_CONTEXT_TOKEN;
 80203c0:	601a      	str	r2, [r3, #0]
  return ai_platform_inputs_get(network, n_buffer);
 80203c2:	f000 be5d 	b.w	8021080 <ai_platform_inputs_get>
 80203c6:	bf00      	nop
 80203c8:	20000120 	.word	0x20000120
 80203cc:	a1c00100 	.word	0xa1c00100

080203d0 <ai_network_outputs_get>:


AI_API_ENTRY
ai_buffer* ai_network_outputs_get(ai_handle network, ai_u16 *n_buffer)
{
  if (network == AI_HANDLE_NULL) {
 80203d0:	b108      	cbz	r0, 80203d6 <ai_network_outputs_get+0x6>
    network = (ai_handle)&AI_NET_OBJ_INSTANCE;
    AI_NETWORK_OBJ(network)->magic = AI_MAGIC_CONTEXT_TOKEN;
  }
  return ai_platform_outputs_get(network, n_buffer);
 80203d2:	f000 becd 	b.w	8021170 <ai_platform_outputs_get>
    AI_NETWORK_OBJ(network)->magic = AI_MAGIC_CONTEXT_TOKEN;
 80203d6:	4b03      	ldr	r3, [pc, #12]	@ (80203e4 <ai_network_outputs_get+0x14>)
 80203d8:	4a03      	ldr	r2, [pc, #12]	@ (80203e8 <ai_network_outputs_get+0x18>)
    network = (ai_handle)&AI_NET_OBJ_INSTANCE;
 80203da:	4618      	mov	r0, r3
    AI_NETWORK_OBJ(network)->magic = AI_MAGIC_CONTEXT_TOKEN;
 80203dc:	601a      	str	r2, [r3, #0]
  return ai_platform_outputs_get(network, n_buffer);
 80203de:	f000 bec7 	b.w	8021170 <ai_platform_outputs_get>
 80203e2:	bf00      	nop
 80203e4:	20000120 	.word	0x20000120
 80203e8:	a1c00100 	.word	0xa1c00100

080203ec <ai_network_init>:


AI_API_ENTRY
ai_bool ai_network_init(
  ai_handle network, const ai_network_params* params)
{
 80203ec:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80203f0:	4681      	mov	r9, r0
 80203f2:	460d      	mov	r5, r1
  ai_network* net_ctx = AI_NETWORK_OBJ(ai_platform_network_init(network, params));
 80203f4:	f000 ff74 	bl	80212e0 <ai_platform_network_init>
  ai_bool ok = true;

  if (!net_ctx) return false;
 80203f8:	4604      	mov	r4, r0
 80203fa:	2800      	cmp	r0, #0
 80203fc:	f000 80d2 	beq.w	80205a4 <ai_network_init+0x1b8>
  if (ai_platform_get_weights_map(g_network_weights_map, 1, params)) {
 8020400:	4e6f      	ldr	r6, [pc, #444]	@ (80205c0 <ai_network_init+0x1d4>)
 8020402:	462a      	mov	r2, r5
 8020404:	2101      	movs	r1, #1
 8020406:	4630      	mov	r0, r6
 8020408:	f000 fd5e 	bl	8020ec8 <ai_platform_get_weights_map>
 802040c:	4680      	mov	r8, r0
 802040e:	2800      	cmp	r0, #0
 8020410:	f000 80ca 	beq.w	80205a8 <ai_network_init+0x1bc>
    conv2d_0_weights_array.format |= AI_FMT_FLAG_CONST;
 8020414:	f8df a21c 	ldr.w	sl, [pc, #540]	@ 8020634 <ai_network_init+0x248>
    conv2d_0_bias_array.format |= AI_FMT_FLAG_CONST;
 8020418:	4f6a      	ldr	r7, [pc, #424]	@ (80205c4 <ai_network_init+0x1d8>)
    conv2d_0_weights_array.format |= AI_FMT_FLAG_CONST;
 802041a:	f8da 2000 	ldr.w	r2, [sl]
    conv2d_0_weights_array.data = AI_PTR(g_network_weights_map[0] + 0);
 802041e:	6833      	ldr	r3, [r6, #0]
    conv2d_2_weights_array.format |= AI_FMT_FLAG_CONST;
 8020420:	f8df c214 	ldr.w	ip, [pc, #532]	@ 8020638 <ai_network_init+0x24c>
    conv2d_0_weights_array.format |= AI_FMT_FLAG_CONST;
 8020424:	f042 4b80 	orr.w	fp, r2, #1073741824	@ 0x40000000
    conv2d_0_bias_array.format |= AI_FMT_FLAG_CONST;
 8020428:	683a      	ldr	r2, [r7, #0]
    conv2d_2_bias_array.format |= AI_FMT_FLAG_CONST;
 802042a:	4e67      	ldr	r6, [pc, #412]	@ (80205c8 <ai_network_init+0x1dc>)
    conv2d_0_weights_array.format |= AI_FMT_FLAG_CONST;
 802042c:	f8ca b000 	str.w	fp, [sl]
    conv2d_4_weights_array.format |= AI_FMT_FLAG_CONST;
 8020430:	4866      	ldr	r0, [pc, #408]	@ (80205cc <ai_network_init+0x1e0>)
    conv2d_4_bias_array.format |= AI_FMT_FLAG_CONST;
 8020432:	4967      	ldr	r1, [pc, #412]	@ (80205d0 <ai_network_init+0x1e4>)
    gemm_6_bias_array.format |= AI_FMT_FLAG_CONST;
 8020434:	f8df e204 	ldr.w	lr, [pc, #516]	@ 802063c <ai_network_init+0x250>
    conv2d_0_weights_array.data = AI_PTR(g_network_weights_map[0] + 0);
 8020438:	e9ca 3302 	strd	r3, r3, [sl, #8]
    conv2d_0_bias_array.format |= AI_FMT_FLAG_CONST;
 802043c:	f042 4a80 	orr.w	sl, r2, #1073741824	@ 0x40000000
    conv2d_2_weights_array.format |= AI_FMT_FLAG_CONST;
 8020440:	f8dc 2000 	ldr.w	r2, [ip]
    conv2d_0_bias_array.format |= AI_FMT_FLAG_CONST;
 8020444:	f8c7 a000 	str.w	sl, [r7]
    conv2d_2_weights_array.format |= AI_FMT_FLAG_CONST;
 8020448:	f042 4a80 	orr.w	sl, r2, #1073741824	@ 0x40000000
    conv2d_2_bias_array.format |= AI_FMT_FLAG_CONST;
 802044c:	6832      	ldr	r2, [r6, #0]
    conv2d_2_weights_array.format |= AI_FMT_FLAG_CONST;
 802044e:	f8cc a000 	str.w	sl, [ip]
    conv2d_2_bias_array.format |= AI_FMT_FLAG_CONST;
 8020452:	f042 4a80 	orr.w	sl, r2, #1073741824	@ 0x40000000
    conv2d_4_weights_array.format |= AI_FMT_FLAG_CONST;
 8020456:	6802      	ldr	r2, [r0, #0]
    conv2d_2_bias_array.format |= AI_FMT_FLAG_CONST;
 8020458:	f8c6 a000 	str.w	sl, [r6]
    conv2d_4_weights_array.format |= AI_FMT_FLAG_CONST;
 802045c:	f042 4a80 	orr.w	sl, r2, #1073741824	@ 0x40000000
    conv2d_4_bias_array.format |= AI_FMT_FLAG_CONST;
 8020460:	680a      	ldr	r2, [r1, #0]
    conv2d_4_weights_array.format |= AI_FMT_FLAG_CONST;
 8020462:	f8c0 a000 	str.w	sl, [r0]
    conv2d_4_bias_array.format |= AI_FMT_FLAG_CONST;
 8020466:	f042 4a80 	orr.w	sl, r2, #1073741824	@ 0x40000000
    gemm_6_weights_array.format |= AI_FMT_FLAG_CONST;
 802046a:	4a5a      	ldr	r2, [pc, #360]	@ (80205d4 <ai_network_init+0x1e8>)
 802046c:	6812      	ldr	r2, [r2, #0]
    conv2d_4_bias_array.format |= AI_FMT_FLAG_CONST;
 802046e:	f8c1 a000 	str.w	sl, [r1]
    gemm_6_weights_array.format |= AI_FMT_FLAG_CONST;
 8020472:	f042 4a80 	orr.w	sl, r2, #1073741824	@ 0x40000000
 8020476:	4a57      	ldr	r2, [pc, #348]	@ (80205d4 <ai_network_init+0x1e8>)
 8020478:	f8c2 a000 	str.w	sl, [r2]
    gemm_6_bias_array.format |= AI_FMT_FLAG_CONST;
 802047c:	f8de 2000 	ldr.w	r2, [lr]
 8020480:	f042 4a80 	orr.w	sl, r2, #1073741824	@ 0x40000000
    gemm_6_weights_array.data = AI_PTR(g_network_weights_map[0] + 56800);
 8020484:	4a53      	ldr	r2, [pc, #332]	@ (80205d4 <ai_network_init+0x1e8>)
    gemm_6_bias_array.format |= AI_FMT_FLAG_CONST;
 8020486:	f8ce a000 	str.w	sl, [lr]
    conv2d_2_bias_array.data = AI_PTR(g_network_weights_map[0] + 19424);
 802048a:	f644 3ae0 	movw	sl, #19424	@ 0x4be0
 802048e:	449a      	add	sl, r3
 8020490:	e9c6 aa02 	strd	sl, sl, [r6, #8]
    conv2d_4_weights_array.data = AI_PTR(g_network_weights_map[0] + 19680);
 8020494:	f644 46e0 	movw	r6, #19680	@ 0x4ce0
 8020498:	441e      	add	r6, r3
 802049a:	e9c0 6602 	strd	r6, r6, [r0, #8]
    conv2d_4_bias_array.data = AI_PTR(g_network_weights_map[0] + 56544);
 802049e:	f64d 40e0 	movw	r0, #56544	@ 0xdce0
    conv2d_0_bias_array.data = AI_PTR(g_network_weights_map[0] + 864);
 80204a2:	f503 7658 	add.w	r6, r3, #864	@ 0x360
    conv2d_4_bias_array.data = AI_PTR(g_network_weights_map[0] + 56544);
 80204a6:	4418      	add	r0, r3
 80204a8:	e9c1 0002 	strd	r0, r0, [r1, #8]
    gemm_6_weights_array.data = AI_PTR(g_network_weights_map[0] + 56800);
 80204ac:	f64d 51e0 	movw	r1, #56800	@ 0xdde0
    gemm_6_bias_array.data = AI_PTR(g_network_weights_map[0] + 318944);
 80204b0:	4849      	ldr	r0, [pc, #292]	@ (80205d8 <ai_network_init+0x1ec>)
    gemm_6_weights_array.data = AI_PTR(g_network_weights_map[0] + 56800);
 80204b2:	4419      	add	r1, r3
    gemm_6_bias_array.data = AI_PTR(g_network_weights_map[0] + 318944);
 80204b4:	4418      	add	r0, r3
    conv2d_0_bias_array.data = AI_PTR(g_network_weights_map[0] + 864);
 80204b6:	e9c7 6602 	strd	r6, r6, [r7, #8]
    conv2d_2_weights_array.data = AI_PTR(g_network_weights_map[0] + 992);
 80204ba:	f503 7678 	add.w	r6, r3, #992	@ 0x3e0
    gemm_6_bias_array.data = AI_PTR(g_network_weights_map[0] + 318944);
 80204be:	f8ce 0008 	str.w	r0, [lr, #8]
    gemm_6_weights_array.data = AI_PTR(g_network_weights_map[0] + 56800);
 80204c2:	e9c2 1102 	strd	r1, r1, [r2, #8]
    conv2d_2_weights_array.data = AI_PTR(g_network_weights_map[0] + 992);
 80204c6:	e9cc 6602 	strd	r6, r6, [ip, #8]
    gemm_6_bias_array.data = AI_PTR(g_network_weights_map[0] + 318944);
 80204ca:	f8ce 000c 	str.w	r0, [lr, #12]
    gemm_7_weights_array.data = AI_PTR(g_network_weights_map[0] + 319200);
 80204ce:	4843      	ldr	r0, [pc, #268]	@ (80205dc <ai_network_init+0x1f0>)
    gemm_7_weights_array.format |= AI_FMT_FLAG_CONST;
 80204d0:	4943      	ldr	r1, [pc, #268]	@ (80205e0 <ai_network_init+0x1f4>)
    gemm_7_weights_array.data = AI_PTR(g_network_weights_map[0] + 319200);
 80204d2:	4418      	add	r0, r3
    gemm_7_bias_array.format |= AI_FMT_FLAG_CONST;
 80204d4:	4a43      	ldr	r2, [pc, #268]	@ (80205e4 <ai_network_init+0x1f8>)
    gemm_7_weights_array.data = AI_PTR(g_network_weights_map[0] + 319200);
 80204d6:	e9c1 0002 	strd	r0, r0, [r1, #8]
    gemm_7_weights_array.format |= AI_FMT_FLAG_CONST;
 80204da:	6808      	ldr	r0, [r1, #0]
 80204dc:	f040 4080 	orr.w	r0, r0, #1073741824	@ 0x40000000
 80204e0:	6008      	str	r0, [r1, #0]
    gemm_7_bias_array.format |= AI_FMT_FLAG_CONST;
 80204e2:	6811      	ldr	r1, [r2, #0]
 80204e4:	f041 4180 	orr.w	r1, r1, #1073741824	@ 0x40000000
 80204e8:	6011      	str	r1, [r2, #0]
    gemm_7_bias_array.data = AI_PTR(g_network_weights_map[0] + 319840);
 80204ea:	493f      	ldr	r1, [pc, #252]	@ (80205e8 <ai_network_init+0x1fc>)
 80204ec:	4419      	add	r1, r3
 80204ee:	e9c2 1102 	strd	r1, r1, [r2, #8]
  if (ai_platform_get_activations_map(g_network_activations_map, 1, params)) {
 80204f2:	4e3e      	ldr	r6, [pc, #248]	@ (80205ec <ai_network_init+0x200>)
 80204f4:	462a      	mov	r2, r5
 80204f6:	2101      	movs	r1, #1
 80204f8:	4630      	mov	r0, r6
 80204fa:	f000 fd3d 	bl	8020f78 <ai_platform_get_activations_map>
 80204fe:	4605      	mov	r5, r0
 8020500:	2800      	cmp	r0, #0
 8020502:	d057      	beq.n	80205b4 <ai_network_init+0x1c8>
    serving_default_input_layer_10_output_array.data = AI_PTR(g_network_activations_map[0] + 15212);
 8020504:	6833      	ldr	r3, [r6, #0]
 8020506:	f643 346c 	movw	r4, #15212	@ 0x3b6c
 802050a:	4e39      	ldr	r6, [pc, #228]	@ (80205f0 <ai_network_init+0x204>)
 802050c:	441c      	add	r4, r3
    conv2d_0_scratch0_array.data = AI_PTR(g_network_activations_map[0] + 12928);
 802050e:	f503 524a 	add.w	r2, r3, #12928	@ 0x3280
    conv2d_0_scratch1_array.data = AI_PTR(g_network_activations_map[0] + 10880);
 8020512:	f503 502a 	add.w	r0, r3, #10880	@ 0x2a80
    conv2d_4_pad_before_output_array.data = AI_PTR(g_network_activations_map[0] + 4096);
 8020516:	f503 5180 	add.w	r1, r3, #4096	@ 0x1000
    serving_default_input_layer_10_output_array.data = AI_PTR(g_network_activations_map[0] + 15212);
 802051a:	e9c6 4402 	strd	r4, r4, [r6, #8]
    conv2d_0_scratch0_array.data = AI_PTR(g_network_activations_map[0] + 12928);
 802051e:	4c35      	ldr	r4, [pc, #212]	@ (80205f4 <ai_network_init+0x208>)
    conv2d_0_output_array.data = AI_PTR(g_network_activations_map[0] + 2688);
 8020520:	f503 6628 	add.w	r6, r3, #2688	@ 0xa80
    conv2d_0_scratch0_array.data = AI_PTR(g_network_activations_map[0] + 12928);
 8020524:	e9c4 2202 	strd	r2, r2, [r4, #8]
    conv2d_0_scratch1_array.data = AI_PTR(g_network_activations_map[0] + 10880);
 8020528:	4c33      	ldr	r4, [pc, #204]	@ (80205f8 <ai_network_init+0x20c>)
 802052a:	e9c4 0002 	strd	r0, r0, [r4, #8]
    conv2d_0_output_array.data = AI_PTR(g_network_activations_map[0] + 2688);
 802052e:	4c33      	ldr	r4, [pc, #204]	@ (80205fc <ai_network_init+0x210>)
 8020530:	e9c4 6602 	strd	r6, r6, [r4, #8]
    conv2d_2_pad_before_output_array.data = AI_PTR(g_network_activations_map[0] + 512);
 8020534:	f503 7600 	add.w	r6, r3, #512	@ 0x200
 8020538:	4c31      	ldr	r4, [pc, #196]	@ (8020600 <ai_network_init+0x214>)
 802053a:	e9c4 6602 	strd	r6, r6, [r4, #8]
    conv2d_2_scratch0_array.data = AI_PTR(g_network_activations_map[0] + 10880);
 802053e:	4c31      	ldr	r4, [pc, #196]	@ (8020604 <ai_network_init+0x218>)
 8020540:	e9c4 0002 	strd	r0, r0, [r4, #8]
    conv2d_2_scratch1_array.data = AI_PTR(g_network_activations_map[0] + 18048);
 8020544:	f503 448d 	add.w	r4, r3, #18048	@ 0x4680
 8020548:	482f      	ldr	r0, [pc, #188]	@ (8020608 <ai_network_init+0x21c>)
 802054a:	e9c0 4402 	strd	r4, r4, [r0, #8]
    conv2d_2_output_array.data = AI_PTR(g_network_activations_map[0] + 0);
 802054e:	482f      	ldr	r0, [pc, #188]	@ (802060c <ai_network_init+0x220>)
    conv2d_4_scratch0_array.data = AI_PTR(g_network_activations_map[0] + 10496);
 8020550:	f503 5424 	add.w	r4, r3, #10496	@ 0x2900
    conv2d_2_output_array.data = AI_PTR(g_network_activations_map[0] + 0);
 8020554:	e9c0 3302 	strd	r3, r3, [r0, #8]
    conv2d_4_pad_before_output_array.data = AI_PTR(g_network_activations_map[0] + 4096);
 8020558:	482d      	ldr	r0, [pc, #180]	@ (8020610 <ai_network_init+0x224>)
 802055a:	e9c0 1102 	strd	r1, r1, [r0, #8]
    conv2d_4_scratch0_array.data = AI_PTR(g_network_activations_map[0] + 10496);
 802055e:	482d      	ldr	r0, [pc, #180]	@ (8020614 <ai_network_init+0x228>)
 8020560:	e9c0 4402 	strd	r4, r4, [r0, #8]
    conv2d_4_output_array.data = AI_PTR(g_network_activations_map[0] + 0);
 8020564:	482c      	ldr	r0, [pc, #176]	@ (8020618 <ai_network_init+0x22c>)
 8020566:	e9c0 3302 	strd	r3, r3, [r0, #8]
    gemm_6_scratch0_array.data = AI_PTR(g_network_activations_map[0] + 4096);
 802056a:	482c      	ldr	r0, [pc, #176]	@ (802061c <ai_network_init+0x230>)
 802056c:	e9c0 1102 	strd	r1, r1, [r0, #8]
    gemm_6_output_array.data = AI_PTR(g_network_activations_map[0] + 12928);
 8020570:	492b      	ldr	r1, [pc, #172]	@ (8020620 <ai_network_init+0x234>)
 8020572:	e9c1 2202 	strd	r2, r2, [r1, #8]
    gemm_7_scratch0_array.data = AI_PTR(g_network_activations_map[0] + 0);
 8020576:	4a2b      	ldr	r2, [pc, #172]	@ (8020624 <ai_network_init+0x238>)
    gemm_7_output_array.data = AI_PTR(g_network_activations_map[0] + 228);
 8020578:	f103 01e4 	add.w	r1, r3, #228	@ 0xe4
    gemm_7_scratch0_array.data = AI_PTR(g_network_activations_map[0] + 0);
 802057c:	e9c2 3302 	strd	r3, r3, [r2, #8]
    gemm_7_output_array.data = AI_PTR(g_network_activations_map[0] + 228);
 8020580:	4a29      	ldr	r2, [pc, #164]	@ (8020628 <ai_network_init+0x23c>)
 8020582:	e9c2 1102 	strd	r1, r1, [r2, #8]
    nl_8_scratch0_array.data = AI_PTR(g_network_activations_map[0] + 0);
 8020586:	4a29      	ldr	r2, [pc, #164]	@ (802062c <ai_network_init+0x240>)
 8020588:	e9c2 3302 	strd	r3, r3, [r2, #8]
    nl_8_output_array.data = AI_PTR(g_network_activations_map[0] + 40);
 802058c:	3328      	adds	r3, #40	@ 0x28
 802058e:	4a28      	ldr	r2, [pc, #160]	@ (8020630 <ai_network_init+0x244>)
 8020590:	e9c2 3302 	strd	r3, r3, [r2, #8]
  ok &= network_configure_weights(net_ctx, params);
  ok &= network_configure_activations(net_ctx, params);

  ok &= ai_platform_network_post_init(network);
 8020594:	4648      	mov	r0, r9
 8020596:	f000 ff63 	bl	8021460 <ai_platform_network_post_init>
 802059a:	4028      	ands	r0, r5
 802059c:	ea08 0800 	and.w	r8, r8, r0
 80205a0:	fa5f f088 	uxtb.w	r0, r8

  return ok;
}
 80205a4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  AI_ERROR_TRAP(net_ctx, INIT_FAILED, NETWORK_WEIGHTS);
 80205a8:	2212      	movs	r2, #18
 80205aa:	2130      	movs	r1, #48	@ 0x30
 80205ac:	4620      	mov	r0, r4
 80205ae:	f000 fd61 	bl	8021074 <ai_platform_network_set_error>
  return false;
 80205b2:	e79e      	b.n	80204f2 <ai_network_init+0x106>
  AI_ERROR_TRAP(net_ctx, INIT_FAILED, NETWORK_ACTIVATIONS);
 80205b4:	2213      	movs	r2, #19
 80205b6:	4620      	mov	r0, r4
 80205b8:	2130      	movs	r1, #48	@ 0x30
 80205ba:	f000 fd5b 	bl	8021074 <ai_platform_network_set_error>
  return false;
 80205be:	e7e9      	b.n	8020594 <ai_network_init+0x1a8>
 80205c0:	20012244 	.word	0x20012244
 80205c4:	20000d88 	.word	0x20000d88
 80205c8:	20000d68 	.word	0x20000d68
 80205cc:	20000d58 	.word	0x20000d58
 80205d0:	20000d48 	.word	0x20000d48
 80205d4:	20000d38 	.word	0x20000d38
 80205d8:	0004dde0 	.word	0x0004dde0
 80205dc:	0004dee0 	.word	0x0004dee0
 80205e0:	20000d18 	.word	0x20000d18
 80205e4:	20000d08 	.word	0x20000d08
 80205e8:	0004e160 	.word	0x0004e160
 80205ec:	20012248 	.word	0x20012248
 80205f0:	20000e28 	.word	0x20000e28
 80205f4:	20000cf8 	.word	0x20000cf8
 80205f8:	20000ce8 	.word	0x20000ce8
 80205fc:	20000e18 	.word	0x20000e18
 8020600:	20000e08 	.word	0x20000e08
 8020604:	20000cd8 	.word	0x20000cd8
 8020608:	20000cc8 	.word	0x20000cc8
 802060c:	20000df8 	.word	0x20000df8
 8020610:	20000de8 	.word	0x20000de8
 8020614:	20000cb8 	.word	0x20000cb8
 8020618:	20000dd8 	.word	0x20000dd8
 802061c:	20000ca8 	.word	0x20000ca8
 8020620:	20000dc8 	.word	0x20000dc8
 8020624:	20000c98 	.word	0x20000c98
 8020628:	20000db8 	.word	0x20000db8
 802062c:	20000c88 	.word	0x20000c88
 8020630:	20000da8 	.word	0x20000da8
 8020634:	20000d98 	.word	0x20000d98
 8020638:	20000d78 	.word	0x20000d78
 802063c:	20000d28 	.word	0x20000d28

08020640 <ai_network_create_and_init>:
{
 8020640:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  return ai_platform_network_create(
 8020644:	2300      	movs	r3, #0
{
 8020646:	b091      	sub	sp, #68	@ 0x44
  return ai_platform_network_create(
 8020648:	2405      	movs	r4, #5
{
 802064a:	4689      	mov	r9, r1
  return ai_platform_network_create(
 802064c:	9301      	str	r3, [sp, #4]
 802064e:	4619      	mov	r1, r3
{
 8020650:	4616      	mov	r6, r2
  return ai_platform_network_create(
 8020652:	2301      	movs	r3, #1
 8020654:	4a26      	ldr	r2, [pc, #152]	@ (80206f0 <ai_network_create_and_init+0xb0>)
{
 8020656:	4607      	mov	r7, r0
  return ai_platform_network_create(
 8020658:	9400      	str	r4, [sp, #0]
 802065a:	f000 fdff 	bl	802125c <ai_platform_network_create>
  if (err.type != AI_ERROR_NONE) {
 802065e:	f010 08ff 	ands.w	r8, r0, #255	@ 0xff
  return ai_platform_network_create(
 8020662:	4605      	mov	r5, r0
  if (err.type != AI_ERROR_NONE) {
 8020664:	d003      	beq.n	802066e <ai_network_create_and_init+0x2e>
}
 8020666:	4628      	mov	r0, r5
 8020668:	b011      	add	sp, #68	@ 0x44
 802066a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  if (ai_network_data_params_get(&params) != true) {
 802066e:	a802      	add	r0, sp, #8
 8020670:	f000 f840 	bl	80206f4 <ai_network_data_params_get>
 8020674:	2800      	cmp	r0, #0
 8020676:	d035      	beq.n	80206e4 <ai_network_create_and_init+0xa4>
  for (ai_u16 idx=0; activations && idx<params.map_activations.size; idx++) {
 8020678:	f1b9 0f00 	cmp.w	r9, #0
 802067c:	d00f      	beq.n	802069e <ai_network_create_and_init+0x5e>
 802067e:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8020682:	b163      	cbz	r3, 802069e <ai_network_create_and_init+0x5e>
 8020684:	4644      	mov	r4, r8
    AI_BUFFER_ARRAY_ITEM_SET_ADDRESS(&params.map_activations, idx, activations[idx]);
 8020686:	b2a1      	uxth	r1, r4
  for (ai_u16 idx=0; activations && idx<params.map_activations.size; idx++) {
 8020688:	3401      	adds	r4, #1
    AI_BUFFER_ARRAY_ITEM_SET_ADDRESS(&params.map_activations, idx, activations[idx]);
 802068a:	a805      	add	r0, sp, #20
 802068c:	f859 2021 	ldr.w	r2, [r9, r1, lsl #2]
 8020690:	f000 fc0a 	bl	8020ea8 <ai_buffer_array_item_set_address>
  for (ai_u16 idx=0; activations && idx<params.map_activations.size; idx++) {
 8020694:	f8bd 2016 	ldrh.w	r2, [sp, #22]
 8020698:	b2a3      	uxth	r3, r4
 802069a:	429a      	cmp	r2, r3
 802069c:	d8f3      	bhi.n	8020686 <ai_network_create_and_init+0x46>
  for (ai_u16 idx=0; weights && idx<params.map_weights.size; idx++) {
 802069e:	b17e      	cbz	r6, 80206c0 <ai_network_create_and_init+0x80>
 80206a0:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 80206a4:	b163      	cbz	r3, 80206c0 <ai_network_create_and_init+0x80>
 80206a6:	2400      	movs	r4, #0
    AI_BUFFER_ARRAY_ITEM_SET_ADDRESS(&params.map_weights, idx, weights[idx]);
 80206a8:	b2a1      	uxth	r1, r4
  for (ai_u16 idx=0; weights && idx<params.map_weights.size; idx++) {
 80206aa:	3401      	adds	r4, #1
    AI_BUFFER_ARRAY_ITEM_SET_ADDRESS(&params.map_weights, idx, weights[idx]);
 80206ac:	a803      	add	r0, sp, #12
 80206ae:	f856 2021 	ldr.w	r2, [r6, r1, lsl #2]
 80206b2:	f000 fbf9 	bl	8020ea8 <ai_buffer_array_item_set_address>
  for (ai_u16 idx=0; weights && idx<params.map_weights.size; idx++) {
 80206b6:	f8bd 200e 	ldrh.w	r2, [sp, #14]
 80206ba:	b2a3      	uxth	r3, r4
 80206bc:	429a      	cmp	r2, r3
 80206be:	d8f3      	bhi.n	80206a8 <ai_network_create_and_init+0x68>
  if (ai_network_init(*network, &params) != true) {
 80206c0:	a902      	add	r1, sp, #8
 80206c2:	6838      	ldr	r0, [r7, #0]
 80206c4:	f7ff fe92 	bl	80203ec <ai_network_init>
 80206c8:	b128      	cbz	r0, 80206d6 <ai_network_create_and_init+0x96>
  return err;
 80206ca:	f368 0507 	bfi	r5, r8, #0, #8
}
 80206ce:	4628      	mov	r0, r5
 80206d0:	b011      	add	sp, #68	@ 0x44
 80206d2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  return ai_platform_network_get_error(network);
 80206d6:	6838      	ldr	r0, [r7, #0]
 80206d8:	f000 fcc0 	bl	802105c <ai_platform_network_get_error>
 80206dc:	4605      	mov	r5, r0
 80206de:	fa5f f880 	uxtb.w	r8, r0
 80206e2:	e7f2      	b.n	80206ca <ai_network_create_and_init+0x8a>
 80206e4:	6838      	ldr	r0, [r7, #0]
 80206e6:	f000 fcb9 	bl	802105c <ai_platform_network_get_error>
 80206ea:	4605      	mov	r5, r0
    return err;
 80206ec:	e7bb      	b.n	8020666 <ai_network_create_and_init+0x26>
 80206ee:	bf00      	nop
 80206f0:	20000120 	.word	0x20000120

080206f4 <ai_network_data_params_get>:
 * @return true if a valid configuration is present, false otherwise
 */
AI_API_ENTRY
ai_bool ai_network_data_params_get(ai_network_params* params)
{
  if (!params) return false;
 80206f4:	4603      	mov	r3, r0
 80206f6:	b1a0      	cbz	r0, 8020722 <ai_network_data_params_get+0x2e>
{
 80206f8:	b510      	push	{r4, lr}
  
  const ai_buffer_array map_activations = 
 80206fa:	4c0a      	ldr	r4, [pc, #40]	@ (8020724 <ai_network_data_params_get+0x30>)
{
 80206fc:	b084      	sub	sp, #16
  const ai_buffer_array map_activations = 
 80206fe:	e894 0003 	ldmia.w	r4, {r0, r1}
 8020702:	466a      	mov	r2, sp
    AI_BUFFER_ARRAY_OBJ_INIT(AI_FLAG_NONE, AI_NETWORK_DATA_ACTIVATIONS_COUNT, g_network_data_map_activations);
  
  const ai_buffer_array map_weights = 
 8020704:	3408      	adds	r4, #8
 8020706:	f10d 0c08 	add.w	ip, sp, #8
  const ai_buffer_array map_activations = 
 802070a:	e882 0003 	stmia.w	r2, {r0, r1}
  const ai_buffer_array map_weights = 
 802070e:	e894 0003 	ldmia.w	r4, {r0, r1}
 8020712:	e88c 0003 	stmia.w	ip, {r0, r1}
    AI_BUFFER_ARRAY_OBJ_INIT(AI_FLAG_NONE, AI_NETWORK_DATA_WEIGHTS_COUNT, g_network_data_map_weights);

  return ai_platform_bind_network_params(params, &map_weights, &map_activations);
 8020716:	4661      	mov	r1, ip
 8020718:	4618      	mov	r0, r3
 802071a:	f000 fc85 	bl	8021028 <ai_platform_bind_network_params>
}
 802071e:	b004      	add	sp, #16
 8020720:	bd10      	pop	{r4, pc}
 8020722:	4770      	bx	lr
 8020724:	08034bc0 	.word	0x08034bc0

08020728 <OV5640_ReadRegWrap>:
  * @param  pData  The target register value to be written
  * @param  Length  buffer size to be written
  * @retval error status
  */
static int32_t OV5640_ReadRegWrap(void *handle, uint16_t Reg, uint8_t *pData, uint16_t Length)
{
 8020728:	b410      	push	{r4}
  OV5640_Object_t *pObj = (OV5640_Object_t *)handle;

  return pObj->IO.ReadReg(pObj->IO.Address, Reg, pData, Length);
 802072a:	6904      	ldr	r4, [r0, #16]
 802072c:	8900      	ldrh	r0, [r0, #8]
 802072e:	46a4      	mov	ip, r4
}
 8020730:	f85d 4b04 	ldr.w	r4, [sp], #4
  return pObj->IO.ReadReg(pObj->IO.Address, Reg, pData, Length);
 8020734:	4760      	bx	ip
 8020736:	bf00      	nop

08020738 <OV5640_WriteRegWrap>:
  * @param  pData  The target register value to be written
  * @param  Length  buffer size to be written
  * @retval error status
  */
static int32_t OV5640_WriteRegWrap(void *handle, uint16_t Reg, uint8_t *pData, uint16_t Length)
{
 8020738:	b410      	push	{r4}
  OV5640_Object_t *pObj = (OV5640_Object_t *)handle;

  return pObj->IO.WriteReg(pObj->IO.Address, Reg, pData, Length);
 802073a:	68c4      	ldr	r4, [r0, #12]
 802073c:	8900      	ldrh	r0, [r0, #8]
 802073e:	46a4      	mov	ip, r4
}
 8020740:	f85d 4b04 	ldr.w	r4, [sp], #4
  return pObj->IO.WriteReg(pObj->IO.Address, Reg, pData, Length);
 8020744:	4760      	bx	ip
 8020746:	bf00      	nop

08020748 <OV5640_SetResolution>:
  if (Resolution > OV5640_R800x480)
 8020748:	2904      	cmp	r1, #4
 802074a:	f200 80b3 	bhi.w	80208b4 <OV5640_SetResolution+0x16c>
    switch (Resolution)
 802074e:	3901      	subs	r1, #1
{
 8020750:	b530      	push	{r4, r5, lr}
 8020752:	b083      	sub	sp, #12
    switch (Resolution)
 8020754:	2903      	cmp	r1, #3
 8020756:	f200 80b0 	bhi.w	80208ba <OV5640_SetResolution+0x172>
 802075a:	e8df f001 	tbb	[pc, r1]
 802075e:	5016      	.short	0x5016
 8020760:	027b      	.short	0x027b
            tmp = (uint8_t)OV5640_WVGA[index][1];
 8020762:	2103      	movs	r1, #3
            if (ov5640_write_reg(&pObj->Ctx, OV5640_WVGA[index][0], &tmp, 1) != OV5640_OK)
 8020764:	f100 0418 	add.w	r4, r0, #24
 8020768:	2301      	movs	r3, #1
 802076a:	f10d 0207 	add.w	r2, sp, #7
            tmp = (uint8_t)OV5640_WVGA[index][1];
 802076e:	f88d 1007 	strb.w	r1, [sp, #7]
            if (ov5640_write_reg(&pObj->Ctx, OV5640_WVGA[index][0], &tmp, 1) != OV5640_OK)
 8020772:	4620      	mov	r0, r4
 8020774:	f643 0108 	movw	r1, #14344	@ 0x3808
 8020778:	f000 fb50 	bl	8020e1c <ov5640_write_reg>
          if (ret != OV5640_ERROR)
 802077c:	2800      	cmp	r0, #0
 802077e:	f000 8097 	beq.w	80208b0 <OV5640_SetResolution+0x168>
{
 8020782:	f04f 30ff 	mov.w	r0, #4294967295
}
 8020786:	b003      	add	sp, #12
 8020788:	bd30      	pop	{r4, r5, pc}
            tmp = (uint8_t)OV5640_QVGA[index][1];
 802078a:	2501      	movs	r5, #1
            if (ov5640_write_reg(&pObj->Ctx, OV5640_QVGA[index][0], &tmp, 1) != OV5640_OK)
 802078c:	f100 0418 	add.w	r4, r0, #24
 8020790:	f10d 0207 	add.w	r2, sp, #7
 8020794:	f643 0108 	movw	r1, #14344	@ 0x3808
 8020798:	462b      	mov	r3, r5
 802079a:	4620      	mov	r0, r4
            tmp = (uint8_t)OV5640_QVGA[index][1];
 802079c:	f88d 5007 	strb.w	r5, [sp, #7]
            if (ov5640_write_reg(&pObj->Ctx, OV5640_QVGA[index][0], &tmp, 1) != OV5640_OK)
 80207a0:	f000 fb3c 	bl	8020e1c <ov5640_write_reg>
          if (ret != OV5640_ERROR)
 80207a4:	2800      	cmp	r0, #0
 80207a6:	d1ec      	bne.n	8020782 <OV5640_SetResolution+0x3a>
            tmp = (uint8_t)OV5640_QVGA[index][1];
 80207a8:	2240      	movs	r2, #64	@ 0x40
            if (ov5640_write_reg(&pObj->Ctx, OV5640_QVGA[index][0], &tmp, 1) != OV5640_OK)
 80207aa:	462b      	mov	r3, r5
 80207ac:	f643 0109 	movw	r1, #14345	@ 0x3809
 80207b0:	4620      	mov	r0, r4
            tmp = (uint8_t)OV5640_QVGA[index][1];
 80207b2:	f88d 2007 	strb.w	r2, [sp, #7]
            if (ov5640_write_reg(&pObj->Ctx, OV5640_QVGA[index][0], &tmp, 1) != OV5640_OK)
 80207b6:	f10d 0207 	add.w	r2, sp, #7
 80207ba:	f000 fb2f 	bl	8020e1c <ov5640_write_reg>
          if (ret != OV5640_ERROR)
 80207be:	2800      	cmp	r0, #0
 80207c0:	d1df      	bne.n	8020782 <OV5640_SetResolution+0x3a>
            tmp = (uint8_t)OV5640_QVGA[index][1];
 80207c2:	f88d 0007 	strb.w	r0, [sp, #7]
            if (ov5640_write_reg(&pObj->Ctx, OV5640_QVGA[index][0], &tmp, 1) != OV5640_OK)
 80207c6:	462b      	mov	r3, r5
 80207c8:	f10d 0207 	add.w	r2, sp, #7
 80207cc:	f643 010a 	movw	r1, #14346	@ 0x380a
 80207d0:	4620      	mov	r0, r4
 80207d2:	f000 fb23 	bl	8020e1c <ov5640_write_reg>
          if (ret != OV5640_ERROR)
 80207d6:	2800      	cmp	r0, #0
 80207d8:	d1d3      	bne.n	8020782 <OV5640_SetResolution+0x3a>
            tmp = (uint8_t)OV5640_QVGA[index][1];
 80207da:	f04f 0cf0 	mov.w	ip, #240	@ 0xf0
            if (ov5640_write_reg(&pObj->Ctx, OV5640_WVGA[index][0], &tmp, 1) != OV5640_OK)
 80207de:	462b      	mov	r3, r5
 80207e0:	f10d 0207 	add.w	r2, sp, #7
 80207e4:	f643 010b 	movw	r1, #14347	@ 0x380b
 80207e8:	4620      	mov	r0, r4
            tmp = (uint8_t)OV5640_WVGA[index][1];
 80207ea:	f88d c007 	strb.w	ip, [sp, #7]
            if (ov5640_write_reg(&pObj->Ctx, OV5640_WVGA[index][0], &tmp, 1) != OV5640_OK)
 80207ee:	f000 fb15 	bl	8020e1c <ov5640_write_reg>
 80207f2:	3800      	subs	r0, #0
 80207f4:	bf18      	it	ne
 80207f6:	2001      	movne	r0, #1
 80207f8:	4240      	negs	r0, r0
}
 80207fa:	b003      	add	sp, #12
 80207fc:	bd30      	pop	{r4, r5, pc}
            tmp = (uint8_t)OV5640_480x272[index][1];
 80207fe:	2501      	movs	r5, #1
            if (ov5640_write_reg(&pObj->Ctx, OV5640_480x272[index][0], &tmp, 1) != OV5640_OK)
 8020800:	f100 0418 	add.w	r4, r0, #24
 8020804:	f10d 0207 	add.w	r2, sp, #7
 8020808:	f643 0108 	movw	r1, #14344	@ 0x3808
 802080c:	462b      	mov	r3, r5
 802080e:	4620      	mov	r0, r4
            tmp = (uint8_t)OV5640_480x272[index][1];
 8020810:	f88d 5007 	strb.w	r5, [sp, #7]
            if (ov5640_write_reg(&pObj->Ctx, OV5640_480x272[index][0], &tmp, 1) != OV5640_OK)
 8020814:	f000 fb02 	bl	8020e1c <ov5640_write_reg>
          if (ret != OV5640_ERROR)
 8020818:	2800      	cmp	r0, #0
 802081a:	d1b2      	bne.n	8020782 <OV5640_SetResolution+0x3a>
            tmp = (uint8_t)OV5640_480x272[index][1];
 802081c:	22e0      	movs	r2, #224	@ 0xe0
            if (ov5640_write_reg(&pObj->Ctx, OV5640_480x272[index][0], &tmp, 1) != OV5640_OK)
 802081e:	462b      	mov	r3, r5
 8020820:	f643 0109 	movw	r1, #14345	@ 0x3809
 8020824:	4620      	mov	r0, r4
            tmp = (uint8_t)OV5640_480x272[index][1];
 8020826:	f88d 2007 	strb.w	r2, [sp, #7]
            if (ov5640_write_reg(&pObj->Ctx, OV5640_480x272[index][0], &tmp, 1) != OV5640_OK)
 802082a:	f10d 0207 	add.w	r2, sp, #7
 802082e:	f000 faf5 	bl	8020e1c <ov5640_write_reg>
          if (ret != OV5640_ERROR)
 8020832:	2800      	cmp	r0, #0
 8020834:	d1a5      	bne.n	8020782 <OV5640_SetResolution+0x3a>
            if (ov5640_write_reg(&pObj->Ctx, OV5640_480x272[index][0], &tmp, 1) != OV5640_OK)
 8020836:	462b      	mov	r3, r5
 8020838:	f10d 0207 	add.w	r2, sp, #7
 802083c:	f643 010a 	movw	r1, #14346	@ 0x380a
 8020840:	4620      	mov	r0, r4
            tmp = (uint8_t)OV5640_480x272[index][1];
 8020842:	f88d 5007 	strb.w	r5, [sp, #7]
            if (ov5640_write_reg(&pObj->Ctx, OV5640_480x272[index][0], &tmp, 1) != OV5640_OK)
 8020846:	f000 fae9 	bl	8020e1c <ov5640_write_reg>
          if (ret != OV5640_ERROR)
 802084a:	2800      	cmp	r0, #0
 802084c:	d199      	bne.n	8020782 <OV5640_SetResolution+0x3a>
            tmp = (uint8_t)OV5640_480x272[index][1];
 802084e:	f04f 0c10 	mov.w	ip, #16
 8020852:	e7c4      	b.n	80207de <OV5640_SetResolution+0x96>
            tmp = (uint8_t)OV5640_VGA[index][1];
 8020854:	2102      	movs	r1, #2
            if (ov5640_write_reg(&pObj->Ctx, OV5640_VGA[index][0], &tmp, 1) != OV5640_OK)
 8020856:	f100 0418 	add.w	r4, r0, #24
 802085a:	2301      	movs	r3, #1
 802085c:	f10d 0207 	add.w	r2, sp, #7
            tmp = (uint8_t)OV5640_VGA[index][1];
 8020860:	f88d 1007 	strb.w	r1, [sp, #7]
            if (ov5640_write_reg(&pObj->Ctx, OV5640_VGA[index][0], &tmp, 1) != OV5640_OK)
 8020864:	4620      	mov	r0, r4
 8020866:	f643 0108 	movw	r1, #14344	@ 0x3808
 802086a:	f000 fad7 	bl	8020e1c <ov5640_write_reg>
          if (ret != OV5640_ERROR)
 802086e:	2800      	cmp	r0, #0
 8020870:	d187      	bne.n	8020782 <OV5640_SetResolution+0x3a>
            tmp = (uint8_t)OV5640_VGA[index][1];
 8020872:	2180      	movs	r1, #128	@ 0x80
            tmp = (uint8_t)OV5640_WVGA[index][1];
 8020874:	f88d 1007 	strb.w	r1, [sp, #7]
            if (ov5640_write_reg(&pObj->Ctx, OV5640_WVGA[index][0], &tmp, 1) != OV5640_OK)
 8020878:	2301      	movs	r3, #1
 802087a:	f10d 0207 	add.w	r2, sp, #7
 802087e:	f643 0109 	movw	r1, #14345	@ 0x3809
 8020882:	4620      	mov	r0, r4
 8020884:	f000 faca 	bl	8020e1c <ov5640_write_reg>
          if (ret != OV5640_ERROR)
 8020888:	2800      	cmp	r0, #0
 802088a:	f47f af7a 	bne.w	8020782 <OV5640_SetResolution+0x3a>
            tmp = (uint8_t)OV5640_WVGA[index][1];
 802088e:	2501      	movs	r5, #1
            if (ov5640_write_reg(&pObj->Ctx, OV5640_WVGA[index][0], &tmp, 1) != OV5640_OK)
 8020890:	f10d 0207 	add.w	r2, sp, #7
 8020894:	f643 010a 	movw	r1, #14346	@ 0x380a
 8020898:	4620      	mov	r0, r4
 802089a:	462b      	mov	r3, r5
            tmp = (uint8_t)OV5640_WVGA[index][1];
 802089c:	f88d 5007 	strb.w	r5, [sp, #7]
            if (ov5640_write_reg(&pObj->Ctx, OV5640_WVGA[index][0], &tmp, 1) != OV5640_OK)
 80208a0:	f000 fabc 	bl	8020e1c <ov5640_write_reg>
          if (ret != OV5640_ERROR)
 80208a4:	2800      	cmp	r0, #0
 80208a6:	f47f af6c 	bne.w	8020782 <OV5640_SetResolution+0x3a>
            tmp = (uint8_t)OV5640_WVGA[index][1];
 80208aa:	f04f 0ce0 	mov.w	ip, #224	@ 0xe0
 80208ae:	e796      	b.n	80207de <OV5640_SetResolution+0x96>
 80208b0:	2120      	movs	r1, #32
 80208b2:	e7df      	b.n	8020874 <OV5640_SetResolution+0x12c>
    ret = OV5640_ERROR;
 80208b4:	f04f 30ff 	mov.w	r0, #4294967295
}
 80208b8:	4770      	bx	lr
            tmp = (uint8_t)OV5640_QQVGA[index][1];
 80208ba:	2100      	movs	r1, #0
            if (ov5640_write_reg(&pObj->Ctx, OV5640_QQVGA[index][0], &tmp, 1) != OV5640_OK)
 80208bc:	f100 0418 	add.w	r4, r0, #24
 80208c0:	2301      	movs	r3, #1
 80208c2:	f10d 0207 	add.w	r2, sp, #7
            tmp = (uint8_t)OV5640_QQVGA[index][1];
 80208c6:	f88d 1007 	strb.w	r1, [sp, #7]
            if (ov5640_write_reg(&pObj->Ctx, OV5640_QQVGA[index][0], &tmp, 1) != OV5640_OK)
 80208ca:	4620      	mov	r0, r4
 80208cc:	f643 0108 	movw	r1, #14344	@ 0x3808
 80208d0:	f000 faa4 	bl	8020e1c <ov5640_write_reg>
          if (ret != OV5640_ERROR)
 80208d4:	2800      	cmp	r0, #0
 80208d6:	f47f af54 	bne.w	8020782 <OV5640_SetResolution+0x3a>
            tmp = (uint8_t)OV5640_QQVGA[index][1];
 80208da:	21a0      	movs	r1, #160	@ 0xa0
            if (ov5640_write_reg(&pObj->Ctx, OV5640_QQVGA[index][0], &tmp, 1) != OV5640_OK)
 80208dc:	2301      	movs	r3, #1
 80208de:	f10d 0207 	add.w	r2, sp, #7
 80208e2:	4620      	mov	r0, r4
            tmp = (uint8_t)OV5640_QQVGA[index][1];
 80208e4:	f88d 1007 	strb.w	r1, [sp, #7]
            if (ov5640_write_reg(&pObj->Ctx, OV5640_QQVGA[index][0], &tmp, 1) != OV5640_OK)
 80208e8:	f643 0109 	movw	r1, #14345	@ 0x3809
 80208ec:	f000 fa96 	bl	8020e1c <ov5640_write_reg>
          if (ret != OV5640_ERROR)
 80208f0:	2800      	cmp	r0, #0
 80208f2:	f47f af46 	bne.w	8020782 <OV5640_SetResolution+0x3a>
            tmp = (uint8_t)OV5640_QQVGA[index][1];
 80208f6:	f88d 0007 	strb.w	r0, [sp, #7]
            if (ov5640_write_reg(&pObj->Ctx, OV5640_QQVGA[index][0], &tmp, 1) != OV5640_OK)
 80208fa:	2301      	movs	r3, #1
 80208fc:	f10d 0207 	add.w	r2, sp, #7
 8020900:	f643 010a 	movw	r1, #14346	@ 0x380a
 8020904:	4620      	mov	r0, r4
 8020906:	f000 fa89 	bl	8020e1c <ov5640_write_reg>
          if (ret != OV5640_ERROR)
 802090a:	2800      	cmp	r0, #0
 802090c:	f47f af39 	bne.w	8020782 <OV5640_SetResolution+0x3a>
            tmp = (uint8_t)OV5640_QQVGA[index][1];
 8020910:	2578      	movs	r5, #120	@ 0x78
            if (ov5640_write_reg(&pObj->Ctx, OV5640_QQVGA[index][0], &tmp, 1) != OV5640_OK)
 8020912:	2301      	movs	r3, #1
 8020914:	f10d 0207 	add.w	r2, sp, #7
 8020918:	f643 010b 	movw	r1, #14347	@ 0x380b
 802091c:	4620      	mov	r0, r4
            tmp = (uint8_t)OV5640_QQVGA[index][1];
 802091e:	f88d 5007 	strb.w	r5, [sp, #7]
            if (ov5640_write_reg(&pObj->Ctx, OV5640_QQVGA[index][0], &tmp, 1) != OV5640_OK)
 8020922:	f000 fa7b 	bl	8020e1c <ov5640_write_reg>
 8020926:	3800      	subs	r0, #0
 8020928:	bf18      	it	ne
 802092a:	2001      	movne	r0, #1
 802092c:	4240      	negs	r0, r0
        for (index = 0; index < (sizeof(OV5640_QQVGA) / 4U); index++)
 802092e:	e72a      	b.n	8020786 <OV5640_SetResolution+0x3e>

08020930 <OV5640_SetPixelFormat>:
  if ((PixelFormat != OV5640_RGB565) && (PixelFormat != OV5640_YUV422) &&
 8020930:	2902      	cmp	r1, #2
{
 8020932:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8020936:	4604      	mov	r4, r0
 8020938:	b082      	sub	sp, #8
  if ((PixelFormat != OV5640_RGB565) && (PixelFormat != OV5640_YUV422) &&
 802093a:	d95f      	bls.n	80209fc <OV5640_SetPixelFormat+0xcc>
      (PixelFormat != OV5640_RGB888) && (PixelFormat != OV5640_Y8) &&
 802093c:	2907      	cmp	r1, #7
 802093e:	f000 80bb 	beq.w	8020ab8 <OV5640_SetPixelFormat+0x188>
 8020942:	2908      	cmp	r1, #8
 8020944:	d154      	bne.n	80209f0 <OV5640_SetPixelFormat+0xc0>
            tmp = (uint8_t)OV5640_PF_JPEG[index][1];
 8020946:	2230      	movs	r2, #48	@ 0x30
            if (ov5640_write_reg(&pObj->Ctx, OV5640_PF_JPEG[index][0], &tmp, 1) != OV5640_OK)
 8020948:	f100 0718 	add.w	r7, r0, #24
 802094c:	f10d 0607 	add.w	r6, sp, #7
 8020950:	2301      	movs	r3, #1
            tmp = (uint8_t)OV5640_PF_JPEG[index][1];
 8020952:	f88d 2007 	strb.w	r2, [sp, #7]
            if (ov5640_write_reg(&pObj->Ctx, OV5640_PF_JPEG[index][0], &tmp, 1) != OV5640_OK)
 8020956:	f44f 4186 	mov.w	r1, #17152	@ 0x4300
 802095a:	4632      	mov	r2, r6
 802095c:	4638      	mov	r0, r7
 802095e:	f000 fa5d 	bl	8020e1c <ov5640_write_reg>
 8020962:	2800      	cmp	r0, #0
 8020964:	f000 80d5 	beq.w	8020b12 <OV5640_SetPixelFormat+0x1e2>
{
 8020968:	f04f 35ff 	mov.w	r5, #4294967295
      if (ov5640_read_reg(&pObj->Ctx, OV5640_TIMING_TC_REG21, &tmp, 1) != OV5640_OK)
 802096c:	2301      	movs	r3, #1
 802096e:	4632      	mov	r2, r6
 8020970:	f643 0121 	movw	r1, #14369	@ 0x3821
 8020974:	4638      	mov	r0, r7
 8020976:	f000 fa49 	bl	8020e0c <ov5640_read_reg>
 802097a:	bbc8      	cbnz	r0, 80209f0 <OV5640_SetPixelFormat+0xc0>
        tmp |= (1 << 5);
 802097c:	f89d 2007 	ldrb.w	r2, [sp, #7]
        if (ov5640_write_reg(&pObj->Ctx, OV5640_TIMING_TC_REG21, &tmp, 1) != OV5640_OK)
 8020980:	2301      	movs	r3, #1
 8020982:	f643 0121 	movw	r1, #14369	@ 0x3821
 8020986:	4638      	mov	r0, r7
        tmp |= (1 << 5);
 8020988:	f042 0220 	orr.w	r2, r2, #32
 802098c:	f88d 2007 	strb.w	r2, [sp, #7]
        if (ov5640_write_reg(&pObj->Ctx, OV5640_TIMING_TC_REG21, &tmp, 1) != OV5640_OK)
 8020990:	4632      	mov	r2, r6
 8020992:	f000 fa43 	bl	8020e1c <ov5640_write_reg>
 8020996:	bb58      	cbnz	r0, 80209f0 <OV5640_SetPixelFormat+0xc0>
          if (ov5640_read_reg(&pObj->Ctx, OV5640_SYSREM_RESET02, &tmp, 1) != OV5640_OK)
 8020998:	2301      	movs	r3, #1
 802099a:	4632      	mov	r2, r6
 802099c:	f243 0102 	movw	r1, #12290	@ 0x3002
 80209a0:	4638      	mov	r0, r7
 80209a2:	f000 fa33 	bl	8020e0c <ov5640_read_reg>
 80209a6:	bb18      	cbnz	r0, 80209f0 <OV5640_SetPixelFormat+0xc0>
            tmp &= ~((1 << 4) | (1 << 3) | (1 << 2));
 80209a8:	f89d 2007 	ldrb.w	r2, [sp, #7]
            if (ov5640_write_reg(&pObj->Ctx, OV5640_SYSREM_RESET02, &tmp, 1) != OV5640_OK)
 80209ac:	2301      	movs	r3, #1
 80209ae:	f243 0102 	movw	r1, #12290	@ 0x3002
 80209b2:	4638      	mov	r0, r7
            tmp &= ~((1 << 4) | (1 << 3) | (1 << 2));
 80209b4:	f022 021c 	bic.w	r2, r2, #28
 80209b8:	f88d 2007 	strb.w	r2, [sp, #7]
            if (ov5640_write_reg(&pObj->Ctx, OV5640_SYSREM_RESET02, &tmp, 1) != OV5640_OK)
 80209bc:	4632      	mov	r2, r6
 80209be:	f000 fa2d 	bl	8020e1c <ov5640_write_reg>
 80209c2:	b9a8      	cbnz	r0, 80209f0 <OV5640_SetPixelFormat+0xc0>
              if (ov5640_read_reg(&pObj->Ctx, OV5640_CLOCK_ENABLE02, &tmp, 1) != OV5640_OK)
 80209c4:	2301      	movs	r3, #1
 80209c6:	4632      	mov	r2, r6
 80209c8:	f243 0106 	movw	r1, #12294	@ 0x3006
 80209cc:	4638      	mov	r0, r7
 80209ce:	f000 fa1d 	bl	8020e0c <ov5640_read_reg>
 80209d2:	b968      	cbnz	r0, 80209f0 <OV5640_SetPixelFormat+0xc0>
                tmp |= ((1 << 5) | (1 << 3));
 80209d4:	f89d 1007 	ldrb.w	r1, [sp, #7]
                if (ov5640_write_reg(&pObj->Ctx, OV5640_CLOCK_ENABLE02, &tmp, 1) != OV5640_OK)
 80209d8:	2301      	movs	r3, #1
 80209da:	4632      	mov	r2, r6
 80209dc:	4638      	mov	r0, r7
                tmp |= ((1 << 5) | (1 << 3));
 80209de:	f041 0128 	orr.w	r1, r1, #40	@ 0x28
 80209e2:	f88d 1007 	strb.w	r1, [sp, #7]
                if (ov5640_write_reg(&pObj->Ctx, OV5640_CLOCK_ENABLE02, &tmp, 1) != OV5640_OK)
 80209e6:	f243 0106 	movw	r1, #12294	@ 0x3006
 80209ea:	f000 fa17 	bl	8020e1c <ov5640_write_reg>
 80209ee:	b108      	cbz	r0, 80209f4 <OV5640_SetPixelFormat+0xc4>
{
 80209f0:	f04f 35ff 	mov.w	r5, #4294967295
}
 80209f4:	4628      	mov	r0, r5
 80209f6:	b002      	add	sp, #8
 80209f8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    switch (PixelFormat)
 80209fc:	3901      	subs	r1, #1
 80209fe:	2901      	cmp	r1, #1
 8020a00:	f200 80a4 	bhi.w	8020b4c <OV5640_SetPixelFormat+0x21c>
 8020a04:	e8df f001 	tbb	[pc, r1]
 8020a08:	012d      	.short	0x012d
            tmp = (uint8_t)OV5640_PF_YUV422[index][1];
 8020a0a:	2230      	movs	r2, #48	@ 0x30
            if (ov5640_write_reg(&pObj->Ctx, OV5640_PF_YUV422[index][0], &tmp, 1) != OV5640_OK)
 8020a0c:	f100 0518 	add.w	r5, r0, #24
 8020a10:	f10d 0607 	add.w	r6, sp, #7
 8020a14:	2301      	movs	r3, #1
            tmp = (uint8_t)OV5640_PF_YUV422[index][1];
 8020a16:	f88d 2007 	strb.w	r2, [sp, #7]
            if (ov5640_write_reg(&pObj->Ctx, OV5640_PF_YUV422[index][0], &tmp, 1) != OV5640_OK)
 8020a1a:	f44f 4186 	mov.w	r1, #17152	@ 0x4300
 8020a1e:	4632      	mov	r2, r6
 8020a20:	4628      	mov	r0, r5
 8020a22:	f000 f9fb 	bl	8020e1c <ov5640_write_reg>
 8020a26:	2800      	cmp	r0, #0
 8020a28:	d1e2      	bne.n	80209f0 <OV5640_SetPixelFormat+0xc0>
  tickstart = pObj->IO.GetTick();
 8020a2a:	6963      	ldr	r3, [r4, #20]
 8020a2c:	4798      	blx	r3
 8020a2e:	4607      	mov	r7, r0
  while ((pObj->IO.GetTick() - tickstart) < Delay)
 8020a30:	6963      	ldr	r3, [r4, #20]
 8020a32:	4798      	blx	r3
 8020a34:	4287      	cmp	r7, r0
 8020a36:	d0fb      	beq.n	8020a30 <OV5640_SetPixelFormat+0x100>
            tmp = (uint8_t)OV5640_PF_YUV422[index][1];
 8020a38:	2100      	movs	r1, #0
            if (ov5640_write_reg(&pObj->Ctx, OV5640_PF_YUV422[index][0], &tmp, 1) != OV5640_OK)
 8020a3a:	4628      	mov	r0, r5
 8020a3c:	2301      	movs	r3, #1
 8020a3e:	4632      	mov	r2, r6
            tmp = (uint8_t)OV5640_PF_YUV422[index][1];
 8020a40:	f88d 1007 	strb.w	r1, [sp, #7]
            if (ov5640_write_reg(&pObj->Ctx, OV5640_PF_YUV422[index][0], &tmp, 1) != OV5640_OK)
 8020a44:	f245 011f 	movw	r1, #20511	@ 0x501f
 8020a48:	f000 f9e8 	bl	8020e1c <ov5640_write_reg>
 8020a4c:	4605      	mov	r5, r0
 8020a4e:	2800      	cmp	r0, #0
 8020a50:	d1ce      	bne.n	80209f0 <OV5640_SetPixelFormat+0xc0>
  tickstart = pObj->IO.GetTick();
 8020a52:	6963      	ldr	r3, [r4, #20]
 8020a54:	4798      	blx	r3
 8020a56:	4606      	mov	r6, r0
  while ((pObj->IO.GetTick() - tickstart) < Delay)
 8020a58:	6963      	ldr	r3, [r4, #20]
 8020a5a:	4798      	blx	r3
 8020a5c:	4286      	cmp	r6, r0
 8020a5e:	d0fb      	beq.n	8020a58 <OV5640_SetPixelFormat+0x128>
 8020a60:	e7c8      	b.n	80209f4 <OV5640_SetPixelFormat+0xc4>
            tmp = (uint8_t)OV5640_PF_RGB888[index][1];
 8020a62:	2223      	movs	r2, #35	@ 0x23
            if (ov5640_write_reg(&pObj->Ctx, OV5640_PF_RGB888[index][0], &tmp, 1) != OV5640_OK)
 8020a64:	f100 0518 	add.w	r5, r0, #24
 8020a68:	f10d 0607 	add.w	r6, sp, #7
 8020a6c:	2301      	movs	r3, #1
            tmp = (uint8_t)OV5640_PF_RGB888[index][1];
 8020a6e:	f88d 2007 	strb.w	r2, [sp, #7]
            if (ov5640_write_reg(&pObj->Ctx, OV5640_PF_RGB888[index][0], &tmp, 1) != OV5640_OK)
 8020a72:	f44f 4186 	mov.w	r1, #17152	@ 0x4300
 8020a76:	4632      	mov	r2, r6
 8020a78:	4628      	mov	r0, r5
 8020a7a:	f000 f9cf 	bl	8020e1c <ov5640_write_reg>
 8020a7e:	2800      	cmp	r0, #0
 8020a80:	d1b6      	bne.n	80209f0 <OV5640_SetPixelFormat+0xc0>
  tickstart = pObj->IO.GetTick();
 8020a82:	6963      	ldr	r3, [r4, #20]
 8020a84:	4798      	blx	r3
 8020a86:	4607      	mov	r7, r0
  while ((pObj->IO.GetTick() - tickstart) < Delay)
 8020a88:	6963      	ldr	r3, [r4, #20]
 8020a8a:	4798      	blx	r3
 8020a8c:	4287      	cmp	r7, r0
 8020a8e:	d0fb      	beq.n	8020a88 <OV5640_SetPixelFormat+0x158>
            tmp = (uint8_t)OV5640_PF_RGB888[index][1];
 8020a90:	2301      	movs	r3, #1
            if (ov5640_write_reg(&pObj->Ctx, OV5640_PF_RGB888[index][0], &tmp, 1) != OV5640_OK)
 8020a92:	4628      	mov	r0, r5
 8020a94:	4632      	mov	r2, r6
 8020a96:	f245 011f 	movw	r1, #20511	@ 0x501f
            tmp = (uint8_t)OV5640_PF_RGB888[index][1];
 8020a9a:	f88d 3007 	strb.w	r3, [sp, #7]
            if (ov5640_write_reg(&pObj->Ctx, OV5640_PF_RGB888[index][0], &tmp, 1) != OV5640_OK)
 8020a9e:	f000 f9bd 	bl	8020e1c <ov5640_write_reg>
 8020aa2:	4605      	mov	r5, r0
 8020aa4:	2800      	cmp	r0, #0
 8020aa6:	d1a3      	bne.n	80209f0 <OV5640_SetPixelFormat+0xc0>
  tickstart = pObj->IO.GetTick();
 8020aa8:	6963      	ldr	r3, [r4, #20]
 8020aaa:	4798      	blx	r3
 8020aac:	4606      	mov	r6, r0
  while ((pObj->IO.GetTick() - tickstart) < Delay)
 8020aae:	6963      	ldr	r3, [r4, #20]
 8020ab0:	4798      	blx	r3
 8020ab2:	4286      	cmp	r6, r0
 8020ab4:	d0fb      	beq.n	8020aae <OV5640_SetPixelFormat+0x17e>
 8020ab6:	e79d      	b.n	80209f4 <OV5640_SetPixelFormat+0xc4>
            tmp = (uint8_t)OV5640_PF_Y8[index][1];
 8020ab8:	2210      	movs	r2, #16
            if (ov5640_write_reg(&pObj->Ctx, OV5640_PF_Y8[index][0], &tmp, 1) != OV5640_OK)
 8020aba:	f100 0518 	add.w	r5, r0, #24
 8020abe:	f10d 0607 	add.w	r6, sp, #7
 8020ac2:	2301      	movs	r3, #1
            tmp = (uint8_t)OV5640_PF_Y8[index][1];
 8020ac4:	f88d 2007 	strb.w	r2, [sp, #7]
            if (ov5640_write_reg(&pObj->Ctx, OV5640_PF_Y8[index][0], &tmp, 1) != OV5640_OK)
 8020ac8:	f44f 4186 	mov.w	r1, #17152	@ 0x4300
 8020acc:	4632      	mov	r2, r6
 8020ace:	4628      	mov	r0, r5
 8020ad0:	f000 f9a4 	bl	8020e1c <ov5640_write_reg>
 8020ad4:	2800      	cmp	r0, #0
 8020ad6:	d18b      	bne.n	80209f0 <OV5640_SetPixelFormat+0xc0>
  tickstart = pObj->IO.GetTick();
 8020ad8:	6963      	ldr	r3, [r4, #20]
 8020ada:	4798      	blx	r3
 8020adc:	4607      	mov	r7, r0
  while ((pObj->IO.GetTick() - tickstart) < Delay)
 8020ade:	6963      	ldr	r3, [r4, #20]
 8020ae0:	4798      	blx	r3
 8020ae2:	4287      	cmp	r7, r0
 8020ae4:	d0fb      	beq.n	8020ade <OV5640_SetPixelFormat+0x1ae>
            tmp = (uint8_t)OV5640_PF_Y8[index][1];
 8020ae6:	2100      	movs	r1, #0
            if (ov5640_write_reg(&pObj->Ctx, OV5640_PF_Y8[index][0], &tmp, 1) != OV5640_OK)
 8020ae8:	4628      	mov	r0, r5
 8020aea:	2301      	movs	r3, #1
 8020aec:	4632      	mov	r2, r6
            tmp = (uint8_t)OV5640_PF_Y8[index][1];
 8020aee:	f88d 1007 	strb.w	r1, [sp, #7]
            if (ov5640_write_reg(&pObj->Ctx, OV5640_PF_Y8[index][0], &tmp, 1) != OV5640_OK)
 8020af2:	f245 011f 	movw	r1, #20511	@ 0x501f
 8020af6:	f000 f991 	bl	8020e1c <ov5640_write_reg>
 8020afa:	4605      	mov	r5, r0
 8020afc:	2800      	cmp	r0, #0
 8020afe:	f47f af77 	bne.w	80209f0 <OV5640_SetPixelFormat+0xc0>
  tickstart = pObj->IO.GetTick();
 8020b02:	6963      	ldr	r3, [r4, #20]
 8020b04:	4798      	blx	r3
 8020b06:	4606      	mov	r6, r0
  while ((pObj->IO.GetTick() - tickstart) < Delay)
 8020b08:	6963      	ldr	r3, [r4, #20]
 8020b0a:	4798      	blx	r3
 8020b0c:	4286      	cmp	r6, r0
 8020b0e:	d0fb      	beq.n	8020b08 <OV5640_SetPixelFormat+0x1d8>
 8020b10:	e770      	b.n	80209f4 <OV5640_SetPixelFormat+0xc4>
  tickstart = pObj->IO.GetTick();
 8020b12:	6963      	ldr	r3, [r4, #20]
 8020b14:	4798      	blx	r3
 8020b16:	4605      	mov	r5, r0
  while ((pObj->IO.GetTick() - tickstart) < Delay)
 8020b18:	6963      	ldr	r3, [r4, #20]
 8020b1a:	4798      	blx	r3
 8020b1c:	4285      	cmp	r5, r0
 8020b1e:	d0fb      	beq.n	8020b18 <OV5640_SetPixelFormat+0x1e8>
            tmp = (uint8_t)OV5640_PF_JPEG[index][1];
 8020b20:	2200      	movs	r2, #0
            if (ov5640_write_reg(&pObj->Ctx, OV5640_PF_JPEG[index][0], &tmp, 1) != OV5640_OK)
 8020b22:	2301      	movs	r3, #1
 8020b24:	f245 011f 	movw	r1, #20511	@ 0x501f
 8020b28:	4638      	mov	r0, r7
            tmp = (uint8_t)OV5640_PF_JPEG[index][1];
 8020b2a:	f88d 2007 	strb.w	r2, [sp, #7]
            if (ov5640_write_reg(&pObj->Ctx, OV5640_PF_JPEG[index][0], &tmp, 1) != OV5640_OK)
 8020b2e:	4632      	mov	r2, r6
 8020b30:	f000 f974 	bl	8020e1c <ov5640_write_reg>
 8020b34:	4605      	mov	r5, r0
 8020b36:	2800      	cmp	r0, #0
 8020b38:	f47f af16 	bne.w	8020968 <OV5640_SetPixelFormat+0x38>
  tickstart = pObj->IO.GetTick();
 8020b3c:	6963      	ldr	r3, [r4, #20]
 8020b3e:	4798      	blx	r3
 8020b40:	4680      	mov	r8, r0
  while ((pObj->IO.GetTick() - tickstart) < Delay)
 8020b42:	6963      	ldr	r3, [r4, #20]
 8020b44:	4798      	blx	r3
 8020b46:	4580      	cmp	r8, r0
 8020b48:	d0fb      	beq.n	8020b42 <OV5640_SetPixelFormat+0x212>
 8020b4a:	e70f      	b.n	802096c <OV5640_SetPixelFormat+0x3c>
            tmp = (uint8_t)OV5640_PF_RGB565[index][1];
 8020b4c:	226f      	movs	r2, #111	@ 0x6f
            if (ov5640_write_reg(&pObj->Ctx, OV5640_PF_RGB565[index][0], &tmp, 1) != OV5640_OK)
 8020b4e:	f100 0718 	add.w	r7, r0, #24
 8020b52:	f10d 0607 	add.w	r6, sp, #7
 8020b56:	2301      	movs	r3, #1
            tmp = (uint8_t)OV5640_PF_RGB565[index][1];
 8020b58:	f88d 2007 	strb.w	r2, [sp, #7]
            if (ov5640_write_reg(&pObj->Ctx, OV5640_PF_RGB565[index][0], &tmp, 1) != OV5640_OK)
 8020b5c:	f44f 4186 	mov.w	r1, #17152	@ 0x4300
 8020b60:	4632      	mov	r2, r6
 8020b62:	4638      	mov	r0, r7
 8020b64:	f000 f95a 	bl	8020e1c <ov5640_write_reg>
 8020b68:	2800      	cmp	r0, #0
 8020b6a:	f47f af41 	bne.w	80209f0 <OV5640_SetPixelFormat+0xc0>
  tickstart = pObj->IO.GetTick();
 8020b6e:	6963      	ldr	r3, [r4, #20]
 8020b70:	4798      	blx	r3
 8020b72:	4605      	mov	r5, r0
  while ((pObj->IO.GetTick() - tickstart) < Delay)
 8020b74:	6963      	ldr	r3, [r4, #20]
 8020b76:	4798      	blx	r3
 8020b78:	4285      	cmp	r5, r0
 8020b7a:	d0fb      	beq.n	8020b74 <OV5640_SetPixelFormat+0x244>
            tmp = (uint8_t)OV5640_PF_RGB565[index][1];
 8020b7c:	2301      	movs	r3, #1
            if (ov5640_write_reg(&pObj->Ctx, OV5640_PF_RGB565[index][0], &tmp, 1) != OV5640_OK)
 8020b7e:	4632      	mov	r2, r6
 8020b80:	4638      	mov	r0, r7
 8020b82:	f245 011f 	movw	r1, #20511	@ 0x501f
            tmp = (uint8_t)OV5640_PF_RGB565[index][1];
 8020b86:	f88d 3007 	strb.w	r3, [sp, #7]
            if (ov5640_write_reg(&pObj->Ctx, OV5640_PF_RGB565[index][0], &tmp, 1) != OV5640_OK)
 8020b8a:	f000 f947 	bl	8020e1c <ov5640_write_reg>
 8020b8e:	4605      	mov	r5, r0
 8020b90:	2800      	cmp	r0, #0
 8020b92:	f47f af2d 	bne.w	80209f0 <OV5640_SetPixelFormat+0xc0>
  tickstart = pObj->IO.GetTick();
 8020b96:	6963      	ldr	r3, [r4, #20]
 8020b98:	4798      	blx	r3
 8020b9a:	4606      	mov	r6, r0
  while ((pObj->IO.GetTick() - tickstart) < Delay)
 8020b9c:	6963      	ldr	r3, [r4, #20]
 8020b9e:	4798      	blx	r3
 8020ba0:	4286      	cmp	r6, r0
 8020ba2:	d0fb      	beq.n	8020b9c <OV5640_SetPixelFormat+0x26c>
 8020ba4:	e726      	b.n	80209f4 <OV5640_SetPixelFormat+0xc4>
 8020ba6:	bf00      	nop

08020ba8 <OV5640_Init>:
  if (pObj->IsInitialized == 0U)
 8020ba8:	f890 3024 	ldrb.w	r3, [r0, #36]	@ 0x24
 8020bac:	b10b      	cbz	r3, 8020bb2 <OV5640_Init+0xa>
  int32_t ret = OV5640_OK;
 8020bae:	2000      	movs	r0, #0
}
 8020bb0:	4770      	bx	lr
    if ((Resolution > OV5640_R800x480) ||
 8020bb2:	2904      	cmp	r1, #4
{
 8020bb4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8020bb8:	4689      	mov	r9, r1
 8020bba:	b082      	sub	sp, #8
    if ((Resolution > OV5640_R800x480) ||
 8020bbc:	d823      	bhi.n	8020c06 <OV5640_Init+0x5e>
 8020bbe:	f032 0302 	bics.w	r3, r2, #2
 8020bc2:	4607      	mov	r7, r0
 8020bc4:	4690      	mov	r8, r2
 8020bc6:	d004      	beq.n	8020bd2 <OV5640_Init+0x2a>
         (PixelFormat != OV5640_RGB888) && (PixelFormat != OV5640_Y8) &&
 8020bc8:	1fd3      	subs	r3, r2, #7
 8020bca:	2b01      	cmp	r3, #1
 8020bcc:	d901      	bls.n	8020bd2 <OV5640_Init+0x2a>
 8020bce:	2a01      	cmp	r2, #1
 8020bd0:	d119      	bne.n	8020c06 <OV5640_Init+0x5e>
 8020bd2:	4c44      	ldr	r4, [pc, #272]	@ (8020ce4 <OV5640_Init+0x13c>)
{
 8020bd4:	2100      	movs	r1, #0
          if (ov5640_write_reg(&pObj->Ctx, OV5640_Common[index][0], &tmp, 1) != OV5640_OK)
 8020bd6:	f107 0518 	add.w	r5, r7, #24
 8020bda:	f504 7676 	add.w	r6, r4, #984	@ 0x3d8
 8020bde:	2301      	movs	r3, #1
 8020be0:	f10d 0206 	add.w	r2, sp, #6
 8020be4:	4628      	mov	r0, r5
        if (ret != OV5640_ERROR)
 8020be6:	b951      	cbnz	r1, 8020bfe <OV5640_Init+0x56>
          tmp = (uint8_t)OV5640_Common[index][1];
 8020be8:	f8b4 c002 	ldrh.w	ip, [r4, #2]
          if (ov5640_write_reg(&pObj->Ctx, OV5640_Common[index][0], &tmp, 1) != OV5640_OK)
 8020bec:	8821      	ldrh	r1, [r4, #0]
          tmp = (uint8_t)OV5640_Common[index][1];
 8020bee:	f88d c006 	strb.w	ip, [sp, #6]
          if (ov5640_write_reg(&pObj->Ctx, OV5640_Common[index][0], &tmp, 1) != OV5640_OK)
 8020bf2:	f000 f913 	bl	8020e1c <ov5640_write_reg>
 8020bf6:	1e01      	subs	r1, r0, #0
 8020bf8:	bf18      	it	ne
 8020bfa:	2101      	movne	r1, #1
 8020bfc:	4249      	negs	r1, r1
      for (index = 0; index < (sizeof(OV5640_Common) / 4U) ; index++)
 8020bfe:	3404      	adds	r4, #4
 8020c00:	42b4      	cmp	r4, r6
 8020c02:	d1ec      	bne.n	8020bde <OV5640_Init+0x36>
      if(ret == OV5640_OK)
 8020c04:	b121      	cbz	r1, 8020c10 <OV5640_Init+0x68>
      ret = OV5640_ERROR;
 8020c06:	f04f 30ff 	mov.w	r0, #4294967295
}
 8020c0a:	b002      	add	sp, #8
 8020c0c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        if(pObj->Mode == SERIAL_MODE)
 8020c10:	f897 3025 	ldrb.w	r3, [r7, #37]	@ 0x25
    if (ov5640_write_reg(&pObj->Ctx, OV5640_POLARITY_CTRL, &tmp, 1) != OV5640_OK)
 8020c14:	f107 0518 	add.w	r5, r7, #24
        if(pObj->Mode == SERIAL_MODE)
 8020c18:	2b01      	cmp	r3, #1
 8020c1a:	d032      	beq.n	8020c82 <OV5640_Init+0xda>
 8020c1c:	4c32      	ldr	r4, [pc, #200]	@ (8020ce8 <OV5640_Init+0x140>)
 8020c1e:	f10d 0607 	add.w	r6, sp, #7
 8020c22:	f104 0a28 	add.w	sl, r4, #40	@ 0x28
    tmp = (uint8_t)regs[index][1];
 8020c26:	8860      	ldrh	r0, [r4, #2]
    if(ov5640_write_reg(&pObj->Ctx, regs[index][0], &tmp, 1) != OV5640_OK)
 8020c28:	2301      	movs	r3, #1
 8020c2a:	4632      	mov	r2, r6
  for(index=0; index < sizeof(regs) / 4U ; index++)
 8020c2c:	3404      	adds	r4, #4
    tmp = (uint8_t)regs[index][1];
 8020c2e:	f88d 0007 	strb.w	r0, [sp, #7]
    if(ov5640_write_reg(&pObj->Ctx, regs[index][0], &tmp, 1) != OV5640_OK)
 8020c32:	4628      	mov	r0, r5
 8020c34:	f834 1c04 	ldrh.w	r1, [r4, #-4]
 8020c38:	f000 f8f0 	bl	8020e1c <ov5640_write_reg>
 8020c3c:	2800      	cmp	r0, #0
 8020c3e:	d1e2      	bne.n	8020c06 <OV5640_Init+0x5e>
  for(index=0; index < sizeof(regs) / 4U ; index++)
 8020c40:	4554      	cmp	r4, sl
 8020c42:	d1f0      	bne.n	8020c26 <OV5640_Init+0x7e>
        if (OV5640_SetResolution(pObj, Resolution) != OV5640_OK)
 8020c44:	4649      	mov	r1, r9
 8020c46:	4638      	mov	r0, r7
 8020c48:	f7ff fd7e 	bl	8020748 <OV5640_SetResolution>
 8020c4c:	2800      	cmp	r0, #0
 8020c4e:	d1da      	bne.n	8020c06 <OV5640_Init+0x5e>
        else if (OV5640_SetPixelFormat(pObj, PixelFormat) != OV5640_OK)
 8020c50:	4641      	mov	r1, r8
 8020c52:	4638      	mov	r0, r7
 8020c54:	f7ff fe6c 	bl	8020930 <OV5640_SetPixelFormat>
 8020c58:	2800      	cmp	r0, #0
 8020c5a:	d1d4      	bne.n	8020c06 <OV5640_Init+0x5e>
    tmp = (uint8_t)(PclkPolarity << 5U) | (HrefPolarity << 1U) | VsyncPolarity;
 8020c5c:	2122      	movs	r1, #34	@ 0x22
    if (ov5640_write_reg(&pObj->Ctx, OV5640_POLARITY_CTRL, &tmp, 1) != OV5640_OK)
 8020c5e:	2301      	movs	r3, #1
 8020c60:	4632      	mov	r2, r6
 8020c62:	4628      	mov	r0, r5
    tmp = (uint8_t)(PclkPolarity << 5U) | (HrefPolarity << 1U) | VsyncPolarity;
 8020c64:	f88d 1007 	strb.w	r1, [sp, #7]
    if (ov5640_write_reg(&pObj->Ctx, OV5640_POLARITY_CTRL, &tmp, 1) != OV5640_OK)
 8020c68:	f244 7140 	movw	r1, #18240	@ 0x4740
 8020c6c:	f000 f8d6 	bl	8020e1c <ov5640_write_reg>
 8020c70:	2800      	cmp	r0, #0
 8020c72:	d1c8      	bne.n	8020c06 <OV5640_Init+0x5e>
          pObj->IsInitialized = 1U;
 8020c74:	2301      	movs	r3, #1
  int32_t ret = OV5640_OK;
 8020c76:	2000      	movs	r0, #0
          pObj->IsInitialized = 1U;
 8020c78:	f887 3024 	strb.w	r3, [r7, #36]	@ 0x24
}
 8020c7c:	b002      	add	sp, #8
 8020c7e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8020c82:	4c1a      	ldr	r4, [pc, #104]	@ (8020cec <OV5640_Init+0x144>)
 8020c84:	f10d 0607 	add.w	r6, sp, #7
 8020c88:	f104 0a38 	add.w	sl, r4, #56	@ 0x38
    tmp = (uint8_t)regs[index][1];
 8020c8c:	8862      	ldrh	r2, [r4, #2]
    if(ov5640_write_reg(&pObj->Ctx, regs[index][0], &tmp, 1) != OV5640_OK)
 8020c8e:	2301      	movs	r3, #1
 8020c90:	4628      	mov	r0, r5
  for(index=0; index < sizeof(regs) / 4U ; index++)
 8020c92:	3404      	adds	r4, #4
    tmp = (uint8_t)regs[index][1];
 8020c94:	f88d 2007 	strb.w	r2, [sp, #7]
    if(ov5640_write_reg(&pObj->Ctx, regs[index][0], &tmp, 1) != OV5640_OK)
 8020c98:	4632      	mov	r2, r6
 8020c9a:	f834 1c04 	ldrh.w	r1, [r4, #-4]
 8020c9e:	f000 f8bd 	bl	8020e1c <ov5640_write_reg>
 8020ca2:	2800      	cmp	r0, #0
 8020ca4:	d1af      	bne.n	8020c06 <OV5640_Init+0x5e>
  for(index=0; index < sizeof(regs) / 4U ; index++)
 8020ca6:	4554      	cmp	r4, sl
 8020ca8:	d1f0      	bne.n	8020c8c <OV5640_Init+0xe4>
  if (ov5640_read_reg(&pObj->Ctx, 0x4814, &tmp, 1) != OV5640_OK)
 8020caa:	2301      	movs	r3, #1
 8020cac:	4632      	mov	r2, r6
 8020cae:	f644 0114 	movw	r1, #18452	@ 0x4814
 8020cb2:	4628      	mov	r0, r5
          else if(OV5640_SetMIPIVirtualChannel(pObj, pObj->VirtualChannelID) != OV5640_OK)
 8020cb4:	6abc      	ldr	r4, [r7, #40]	@ 0x28
  if (ov5640_read_reg(&pObj->Ctx, 0x4814, &tmp, 1) != OV5640_OK)
 8020cb6:	f000 f8a9 	bl	8020e0c <ov5640_read_reg>
 8020cba:	2800      	cmp	r0, #0
 8020cbc:	d1a3      	bne.n	8020c06 <OV5640_Init+0x5e>
    tmp &= ~(3 << 6);
 8020cbe:	f89d 3007 	ldrb.w	r3, [sp, #7]
    if (ov5640_write_reg(&pObj->Ctx, 0x4814, &tmp, 1) != OV5640_OK)
 8020cc2:	4632      	mov	r2, r6
 8020cc4:	f644 0114 	movw	r1, #18452	@ 0x4814
 8020cc8:	4628      	mov	r0, r5
    tmp &= ~(3 << 6);
 8020cca:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
    tmp |= (vchannel << 6);
 8020cce:	ea43 1384 	orr.w	r3, r3, r4, lsl #6
 8020cd2:	f88d 3007 	strb.w	r3, [sp, #7]
    if (ov5640_write_reg(&pObj->Ctx, 0x4814, &tmp, 1) != OV5640_OK)
 8020cd6:	2301      	movs	r3, #1
 8020cd8:	f000 f8a0 	bl	8020e1c <ov5640_write_reg>
 8020cdc:	2800      	cmp	r0, #0
 8020cde:	d0b1      	beq.n	8020c44 <OV5640_Init+0x9c>
 8020ce0:	e791      	b.n	8020c06 <OV5640_Init+0x5e>
 8020ce2:	bf00      	nop
 8020ce4:	08083568 	.word	0x08083568
 8020ce8:	08083540 	.word	0x08083540
 8020cec:	08083508 	.word	0x08083508

08020cf0 <OV5640_RegisterBusIO>:
  if (pObj == NULL)
 8020cf0:	b1c0      	cbz	r0, 8020d24 <OV5640_RegisterBusIO+0x34>
    pObj->IO.Address   = pIO->Address;
 8020cf2:	890a      	ldrh	r2, [r1, #8]
{
 8020cf4:	b430      	push	{r4, r5}
    pObj->IO.DeInit    = pIO->DeInit;
 8020cf6:	e9d1 3400 	ldrd	r3, r4, [r1]
    pObj->IO.Address   = pIO->Address;
 8020cfa:	8102      	strh	r2, [r0, #8]
    pObj->IO.DeInit    = pIO->DeInit;
 8020cfc:	e9c0 3400 	strd	r3, r4, [r0]
    pObj->IO.WriteReg  = pIO->WriteReg;
 8020d00:	694a      	ldr	r2, [r1, #20]
 8020d02:	e9d1 5403 	ldrd	r5, r4, [r1, #12]
    pObj->Ctx.ReadReg  = OV5640_ReadRegWrap;
 8020d06:	4909      	ldr	r1, [pc, #36]	@ (8020d2c <OV5640_RegisterBusIO+0x3c>)
    pObj->IO.WriteReg  = pIO->WriteReg;
 8020d08:	60c5      	str	r5, [r0, #12]
 8020d0a:	e9c0 4204 	strd	r4, r2, [r0, #16]
    pObj->Ctx.WriteReg = OV5640_WriteRegWrap;
 8020d0e:	4a08      	ldr	r2, [pc, #32]	@ (8020d30 <OV5640_RegisterBusIO+0x40>)
    pObj->Ctx.handle   = pObj;
 8020d10:	e9c0 1007 	strd	r1, r0, [r0, #28]
    pObj->Ctx.WriteReg = OV5640_WriteRegWrap;
 8020d14:	6182      	str	r2, [r0, #24]
    if (pObj->IO.Init != NULL)
 8020d16:	b10b      	cbz	r3, 8020d1c <OV5640_RegisterBusIO+0x2c>
}
 8020d18:	bc30      	pop	{r4, r5}
      ret = pObj->IO.Init();
 8020d1a:	4718      	bx	r3
}
 8020d1c:	f04f 30ff 	mov.w	r0, #4294967295
 8020d20:	bc30      	pop	{r4, r5}
 8020d22:	4770      	bx	lr
 8020d24:	f04f 30ff 	mov.w	r0, #4294967295
 8020d28:	4770      	bx	lr
 8020d2a:	bf00      	nop
 8020d2c:	08020729 	.word	0x08020729
 8020d30:	08020739 	.word	0x08020739

08020d34 <OV5640_SetPCLK>:
{
 8020d34:	b530      	push	{r4, r5, lr}
      ret = ov5640_write_reg(&pObj->Ctx, OV5640_SC_PLL_CONTRL2, &tmp, 1);
 8020d36:	f100 0518 	add.w	r5, r0, #24
{
 8020d3a:	b083      	sub	sp, #12
  switch (ClockValue)
 8020d3c:	2909      	cmp	r1, #9
 8020d3e:	d806      	bhi.n	8020d4e <OV5640_SetPCLK+0x1a>
 8020d40:	e8df f001 	tbb	[pc, r1]
 8020d44:	05333123 	.word	0x05333123
 8020d48:	05050541 	.word	0x05050541
 8020d4c:	4305      	.short	0x4305
      tmp = 0x60;
 8020d4e:	2160      	movs	r1, #96	@ 0x60
      ret = ov5640_write_reg(&pObj->Ctx, OV5640_SC_PLL_CONTRL2, &tmp, 1);
 8020d50:	2301      	movs	r3, #1
 8020d52:	f10d 0207 	add.w	r2, sp, #7
 8020d56:	4628      	mov	r0, r5
      tmp = 0x60;
 8020d58:	f88d 1007 	strb.w	r1, [sp, #7]
      ret = ov5640_write_reg(&pObj->Ctx, OV5640_SC_PLL_CONTRL2, &tmp, 1);
 8020d5c:	f243 0136 	movw	r1, #12342	@ 0x3036
 8020d60:	f000 f85c 	bl	8020e1c <ov5640_write_reg>
      tmp = 0x13;
 8020d64:	2113      	movs	r1, #19
      ret = ov5640_write_reg(&pObj->Ctx, OV5640_SC_PLL_CONTRL2, &tmp, 1);
 8020d66:	4604      	mov	r4, r0
      tmp = 0x13;
 8020d68:	f88d 1007 	strb.w	r1, [sp, #7]
      ret += ov5640_write_reg(&pObj->Ctx, OV5640_SC_PLL_CONTRL3, &tmp, 1);
 8020d6c:	2301      	movs	r3, #1
 8020d6e:	f10d 0207 	add.w	r2, sp, #7
 8020d72:	4628      	mov	r0, r5
 8020d74:	f243 0137 	movw	r1, #12343	@ 0x3037
 8020d78:	f000 f850 	bl	8020e1c <ov5640_write_reg>
 8020d7c:	4420      	add	r0, r4
  if (ret != OV5640_OK)
 8020d7e:	3800      	subs	r0, #0
 8020d80:	bf18      	it	ne
 8020d82:	2001      	movne	r0, #1
}
 8020d84:	4240      	negs	r0, r0
 8020d86:	b003      	add	sp, #12
 8020d88:	bd30      	pop	{r4, r5, pc}
      tmp = 0x38;
 8020d8a:	2138      	movs	r1, #56	@ 0x38
      tmp = 0x60;
 8020d8c:	f88d 1007 	strb.w	r1, [sp, #7]
      ret = ov5640_write_reg(&pObj->Ctx, OV5640_SC_PLL_CONTRL2, &tmp, 1);
 8020d90:	2301      	movs	r3, #1
 8020d92:	f243 0136 	movw	r1, #12342	@ 0x3036
 8020d96:	f10d 0207 	add.w	r2, sp, #7
 8020d9a:	4628      	mov	r0, r5
 8020d9c:	f000 f83e 	bl	8020e1c <ov5640_write_reg>
      tmp = 0x16;
 8020da0:	2116      	movs	r1, #22
      ret = ov5640_write_reg(&pObj->Ctx, OV5640_SC_PLL_CONTRL2, &tmp, 1);
 8020da2:	4604      	mov	r4, r0
 8020da4:	e7e0      	b.n	8020d68 <OV5640_SetPCLK+0x34>
      tmp = 0x40;
 8020da6:	2140      	movs	r1, #64	@ 0x40
 8020da8:	e7f0      	b.n	8020d8c <OV5640_SetPCLK+0x58>
      tmp = 0x60;
 8020daa:	2160      	movs	r1, #96	@ 0x60
      ret = ov5640_write_reg(&pObj->Ctx, OV5640_SC_PLL_CONTRL2, &tmp, 1);
 8020dac:	2301      	movs	r3, #1
 8020dae:	f10d 0207 	add.w	r2, sp, #7
 8020db2:	4628      	mov	r0, r5
      tmp = 0x60;
 8020db4:	f88d 1007 	strb.w	r1, [sp, #7]
      ret = ov5640_write_reg(&pObj->Ctx, OV5640_SC_PLL_CONTRL2, &tmp, 1);
 8020db8:	f243 0136 	movw	r1, #12342	@ 0x3036
 8020dbc:	f000 f82e 	bl	8020e1c <ov5640_write_reg>
      tmp = 0x18;
 8020dc0:	2118      	movs	r1, #24
      ret = ov5640_write_reg(&pObj->Ctx, OV5640_SC_PLL_CONTRL2, &tmp, 1);
 8020dc2:	4604      	mov	r4, r0
 8020dc4:	e7d0      	b.n	8020d68 <OV5640_SetPCLK+0x34>
      tmp = 0x60;
 8020dc6:	2160      	movs	r1, #96	@ 0x60
 8020dc8:	e7e0      	b.n	8020d8c <OV5640_SetPCLK+0x58>
      tmp = 0x60;
 8020dca:	2160      	movs	r1, #96	@ 0x60
      ret = ov5640_write_reg(&pObj->Ctx, OV5640_SC_PLL_CONTRL2, &tmp, 1);
 8020dcc:	2301      	movs	r3, #1
 8020dce:	f10d 0207 	add.w	r2, sp, #7
 8020dd2:	4628      	mov	r0, r5
      tmp = 0x60;
 8020dd4:	f88d 1007 	strb.w	r1, [sp, #7]
      ret = ov5640_write_reg(&pObj->Ctx, OV5640_SC_PLL_CONTRL2, &tmp, 1);
 8020dd8:	f243 0136 	movw	r1, #12342	@ 0x3036
 8020ddc:	f000 f81e 	bl	8020e1c <ov5640_write_reg>
      tmp = 0x03;
 8020de0:	2103      	movs	r1, #3
      ret = ov5640_write_reg(&pObj->Ctx, OV5640_SC_PLL_CONTRL2, &tmp, 1);
 8020de2:	4604      	mov	r4, r0
 8020de4:	e7c0      	b.n	8020d68 <OV5640_SetPCLK+0x34>
 8020de6:	bf00      	nop

08020de8 <OV5640_Start>:
{
 8020de8:	b500      	push	{lr}
 8020dea:	b083      	sub	sp, #12
  tmp = 0x2;
 8020dec:	f04f 0c02 	mov.w	ip, #2
  return ov5640_write_reg(&pObj->Ctx, OV5640_SYSTEM_CTROL0, &tmp, 1);
 8020df0:	2301      	movs	r3, #1
 8020df2:	f243 0108 	movw	r1, #12296	@ 0x3008
 8020df6:	f10d 0207 	add.w	r2, sp, #7
 8020dfa:	3018      	adds	r0, #24
  tmp = 0x2;
 8020dfc:	f88d c007 	strb.w	ip, [sp, #7]
  return ov5640_write_reg(&pObj->Ctx, OV5640_SYSTEM_CTROL0, &tmp, 1);
 8020e00:	f000 f80c 	bl	8020e1c <ov5640_write_reg>
}
 8020e04:	b003      	add	sp, #12
 8020e06:	f85d fb04 	ldr.w	pc, [sp], #4
 8020e0a:	bf00      	nop

08020e0c <ov5640_read_reg>:
  * @param  pdata Pointer to data buffer
  * @param  length Number of data to read
  * @retval Component status
  */
int32_t ov5640_read_reg(ov5640_ctx_t *ctx, uint16_t reg, uint8_t *pdata, uint16_t length)
{
 8020e0c:	b410      	push	{r4}
  return ctx->ReadReg(ctx->handle, reg, pdata, length);
 8020e0e:	e9d0 4001 	ldrd	r4, r0, [r0, #4]
 8020e12:	46a4      	mov	ip, r4
}
 8020e14:	f85d 4b04 	ldr.w	r4, [sp], #4
  return ctx->ReadReg(ctx->handle, reg, pdata, length);
 8020e18:	4760      	bx	ip
 8020e1a:	bf00      	nop

08020e1c <ov5640_write_reg>:
  * @param  pdata Pointer to data buffer
  * @param  length Number of data to write
  * @retval Component status
  */
int32_t ov5640_write_reg(ov5640_ctx_t *ctx, uint16_t reg, uint8_t *data, uint16_t length)
{
 8020e1c:	b410      	push	{r4}
  return ctx->WriteReg(ctx->handle, reg, data, length);
 8020e1e:	6804      	ldr	r4, [r0, #0]
 8020e20:	6880      	ldr	r0, [r0, #8]
 8020e22:	46a4      	mov	ip, r4
}
 8020e24:	f85d 4b04 	ldr.w	r4, [sp], #4
  return ctx->WriteReg(ctx->handle, reg, data, length);
 8020e28:	4760      	bx	ip
 8020e2a:	bf00      	nop

08020e2c <ai_buffer_get_size>:
 8020e2c:	b368      	cbz	r0, 8020e8a <ai_buffer_get_size+0x5e>
 8020e2e:	4b17      	ldr	r3, [pc, #92]	@ (8020e8c <ai_buffer_get_size+0x60>)
 8020e30:	4a17      	ldr	r2, [pc, #92]	@ (8020e90 <ai_buffer_get_size+0x64>)
 8020e32:	b410      	push	{r4}
 8020e34:	6804      	ldr	r4, [r0, #0]
 8020e36:	4023      	ands	r3, r4
 8020e38:	4293      	cmp	r3, r2
 8020e3a:	d123      	bne.n	8020e84 <ai_buffer_get_size+0x58>
 8020e3c:	b311      	cbz	r1, 8020e84 <ai_buffer_get_size+0x58>
 8020e3e:	6984      	ldr	r4, [r0, #24]
 8020e40:	6862      	ldr	r2, [r4, #4]
 8020e42:	321f      	adds	r2, #31
 8020e44:	f022 021f 	bic.w	r2, r2, #31
 8020e48:	7d03      	ldrb	r3, [r0, #20]
 8020e4a:	6941      	ldr	r1, [r0, #20]
 8020e4c:	f1a3 0301 	sub.w	r3, r3, #1
 8020e50:	f3c1 2017 	ubfx	r0, r1, #8, #24
 8020e54:	fab3 f383 	clz	r3, r3
 8020e58:	095b      	lsrs	r3, r3, #5
 8020e5a:	ebb3 2f11 	cmp.w	r3, r1, lsr #8
 8020e5e:	da0c      	bge.n	8020e7a <ai_buffer_get_size+0x4e>
 8020e60:	2b01      	cmp	r3, #1
 8020e62:	d103      	bne.n	8020e6c <ai_buffer_get_size+0x40>
 8020e64:	2802      	cmp	r0, #2
 8020e66:	f04f 0302 	mov.w	r3, #2
 8020e6a:	d006      	beq.n	8020e7a <ai_buffer_get_size+0x4e>
 8020e6c:	f854 1023 	ldr.w	r1, [r4, r3, lsl #2]
 8020e70:	3301      	adds	r3, #1
 8020e72:	4298      	cmp	r0, r3
 8020e74:	fb01 f202 	mul.w	r2, r1, r2
 8020e78:	d1f2      	bne.n	8020e60 <ai_buffer_get_size+0x34>
 8020e7a:	ea22 70e2 	bic.w	r0, r2, r2, asr #31
 8020e7e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8020e82:	4770      	bx	lr
 8020e84:	6984      	ldr	r4, [r0, #24]
 8020e86:	6862      	ldr	r2, [r4, #4]
 8020e88:	e7de      	b.n	8020e48 <ai_buffer_get_size+0x1c>
 8020e8a:	4770      	bx	lr
 8020e8c:	017fffff 	.word	0x017fffff
 8020e90:	000400c0 	.word	0x000400c0

08020e94 <ai_buffer_array_sane>:
 8020e94:	b138      	cbz	r0, 8020ea6 <ai_buffer_array_sane+0x12>
 8020e96:	6843      	ldr	r3, [r0, #4]
 8020e98:	b123      	cbz	r3, 8020ea4 <ai_buffer_array_sane+0x10>
 8020e9a:	8840      	ldrh	r0, [r0, #2]
 8020e9c:	3800      	subs	r0, #0
 8020e9e:	bf18      	it	ne
 8020ea0:	2001      	movne	r0, #1
 8020ea2:	4770      	bx	lr
 8020ea4:	4618      	mov	r0, r3
 8020ea6:	4770      	bx	lr

08020ea8 <ai_buffer_array_item_set_address>:
 8020ea8:	b150      	cbz	r0, 8020ec0 <ai_buffer_array_item_set_address+0x18>
 8020eaa:	6843      	ldr	r3, [r0, #4]
 8020eac:	b14b      	cbz	r3, 8020ec2 <ai_buffer_array_item_set_address+0x1a>
 8020eae:	8840      	ldrh	r0, [r0, #2]
 8020eb0:	b900      	cbnz	r0, 8020eb4 <ai_buffer_array_item_set_address+0xc>
 8020eb2:	4770      	bx	lr
 8020eb4:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
 8020eb8:	2001      	movs	r0, #1
 8020eba:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 8020ebe:	605a      	str	r2, [r3, #4]
 8020ec0:	4770      	bx	lr
 8020ec2:	4618      	mov	r0, r3
 8020ec4:	4770      	bx	lr
 8020ec6:	bf00      	nop

08020ec8 <ai_platform_get_weights_map>:
 8020ec8:	2900      	cmp	r1, #0
 8020eca:	bf18      	it	ne
 8020ecc:	2800      	cmpne	r0, #0
 8020ece:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8020ed0:	bf0c      	ite	eq
 8020ed2:	2401      	moveq	r4, #1
 8020ed4:	2400      	movne	r4, #0
 8020ed6:	2a00      	cmp	r2, #0
 8020ed8:	bf08      	it	eq
 8020eda:	f044 0401 	orreq.w	r4, r4, #1
 8020ede:	b114      	cbz	r4, 8020ee6 <ai_platform_get_weights_map+0x1e>
 8020ee0:	2400      	movs	r4, #0
 8020ee2:	4620      	mov	r0, r4
 8020ee4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8020ee6:	4616      	mov	r6, r2
 8020ee8:	4b22      	ldr	r3, [pc, #136]	@ (8020f74 <ai_platform_get_weights_map+0xac>)
 8020eea:	6812      	ldr	r2, [r2, #0]
 8020eec:	4605      	mov	r5, r0
 8020eee:	460f      	mov	r7, r1
 8020ef0:	429a      	cmp	r2, r3
 8020ef2:	d022      	beq.n	8020f3a <ai_platform_get_weights_map+0x72>
 8020ef4:	6870      	ldr	r0, [r6, #4]
 8020ef6:	2800      	cmp	r0, #0
 8020ef8:	d0f2      	beq.n	8020ee0 <ai_platform_get_weights_map+0x18>
 8020efa:	6806      	ldr	r6, [r0, #0]
 8020efc:	429e      	cmp	r6, r3
 8020efe:	d006      	beq.n	8020f0e <ai_platform_get_weights_map+0x46>
 8020f00:	f1a1 0401 	sub.w	r4, r1, #1
 8020f04:	6028      	str	r0, [r5, #0]
 8020f06:	fab4 f484 	clz	r4, r4
 8020f0a:	0964      	lsrs	r4, r4, #5
 8020f0c:	e7e9      	b.n	8020ee2 <ai_platform_get_weights_map+0x1a>
 8020f0e:	3d04      	subs	r5, #4
 8020f10:	4602      	mov	r2, r0
 8020f12:	4621      	mov	r1, r4
 8020f14:	e000      	b.n	8020f18 <ai_platform_get_weights_map+0x50>
 8020f16:	4619      	mov	r1, r3
 8020f18:	f852 3f04 	ldr.w	r3, [r2, #4]!
 8020f1c:	42b3      	cmp	r3, r6
 8020f1e:	d025      	beq.n	8020f6c <ai_platform_get_weights_map+0xa4>
 8020f20:	f845 3f04 	str.w	r3, [r5, #4]!
 8020f24:	1c4b      	adds	r3, r1, #1
 8020f26:	429f      	cmp	r7, r3
 8020f28:	d8f5      	bhi.n	8020f16 <ai_platform_get_weights_map+0x4e>
 8020f2a:	d1da      	bne.n	8020ee2 <ai_platform_get_weights_map+0x1a>
 8020f2c:	3102      	adds	r1, #2
 8020f2e:	f850 3021 	ldr.w	r3, [r0, r1, lsl #2]
 8020f32:	42b3      	cmp	r3, r6
 8020f34:	d1d5      	bne.n	8020ee2 <ai_platform_get_weights_map+0x1a>
 8020f36:	2401      	movs	r4, #1
 8020f38:	e7d3      	b.n	8020ee2 <ai_platform_get_weights_map+0x1a>
 8020f3a:	1d30      	adds	r0, r6, #4
 8020f3c:	f7ff ffaa 	bl	8020e94 <ai_buffer_array_sane>
 8020f40:	2800      	cmp	r0, #0
 8020f42:	d0cd      	beq.n	8020ee0 <ai_platform_get_weights_map+0x18>
 8020f44:	88f3      	ldrh	r3, [r6, #6]
 8020f46:	429f      	cmp	r7, r3
 8020f48:	d1ca      	bne.n	8020ee0 <ai_platform_get_weights_map+0x18>
 8020f4a:	3d04      	subs	r5, #4
 8020f4c:	4622      	mov	r2, r4
 8020f4e:	68b3      	ldr	r3, [r6, #8]
 8020f50:	4423      	add	r3, r4
 8020f52:	341c      	adds	r4, #28
 8020f54:	685b      	ldr	r3, [r3, #4]
 8020f56:	b123      	cbz	r3, 8020f62 <ai_platform_get_weights_map+0x9a>
 8020f58:	3201      	adds	r2, #1
 8020f5a:	f845 3f04 	str.w	r3, [r5, #4]!
 8020f5e:	4297      	cmp	r7, r2
 8020f60:	d8f5      	bhi.n	8020f4e <ai_platform_get_weights_map+0x86>
 8020f62:	1abc      	subs	r4, r7, r2
 8020f64:	fab4 f484 	clz	r4, r4
 8020f68:	0964      	lsrs	r4, r4, #5
 8020f6a:	e7ba      	b.n	8020ee2 <ai_platform_get_weights_map+0x1a>
 8020f6c:	428f      	cmp	r7, r1
 8020f6e:	d1b8      	bne.n	8020ee2 <ai_platform_get_weights_map+0x1a>
 8020f70:	e7e1      	b.n	8020f36 <ai_platform_get_weights_map+0x6e>
 8020f72:	bf00      	nop
 8020f74:	a1facade 	.word	0xa1facade

08020f78 <ai_platform_get_activations_map>:
 8020f78:	2900      	cmp	r1, #0
 8020f7a:	bf18      	it	ne
 8020f7c:	2800      	cmpne	r0, #0
 8020f7e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8020f80:	bf0c      	ite	eq
 8020f82:	2401      	moveq	r4, #1
 8020f84:	2400      	movne	r4, #0
 8020f86:	2a00      	cmp	r2, #0
 8020f88:	bf08      	it	eq
 8020f8a:	f044 0401 	orreq.w	r4, r4, #1
 8020f8e:	b114      	cbz	r4, 8020f96 <ai_platform_get_activations_map+0x1e>
 8020f90:	2400      	movs	r4, #0
 8020f92:	4620      	mov	r0, r4
 8020f94:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8020f96:	4616      	mov	r6, r2
 8020f98:	4b22      	ldr	r3, [pc, #136]	@ (8021024 <ai_platform_get_activations_map+0xac>)
 8020f9a:	6812      	ldr	r2, [r2, #0]
 8020f9c:	4605      	mov	r5, r0
 8020f9e:	460f      	mov	r7, r1
 8020fa0:	429a      	cmp	r2, r3
 8020fa2:	d022      	beq.n	8020fea <ai_platform_get_activations_map+0x72>
 8020fa4:	6a30      	ldr	r0, [r6, #32]
 8020fa6:	2800      	cmp	r0, #0
 8020fa8:	d0f2      	beq.n	8020f90 <ai_platform_get_activations_map+0x18>
 8020faa:	6806      	ldr	r6, [r0, #0]
 8020fac:	429e      	cmp	r6, r3
 8020fae:	d006      	beq.n	8020fbe <ai_platform_get_activations_map+0x46>
 8020fb0:	f1a1 0401 	sub.w	r4, r1, #1
 8020fb4:	6028      	str	r0, [r5, #0]
 8020fb6:	fab4 f484 	clz	r4, r4
 8020fba:	0964      	lsrs	r4, r4, #5
 8020fbc:	e7e9      	b.n	8020f92 <ai_platform_get_activations_map+0x1a>
 8020fbe:	3d04      	subs	r5, #4
 8020fc0:	4602      	mov	r2, r0
 8020fc2:	4621      	mov	r1, r4
 8020fc4:	e000      	b.n	8020fc8 <ai_platform_get_activations_map+0x50>
 8020fc6:	4619      	mov	r1, r3
 8020fc8:	f852 3f04 	ldr.w	r3, [r2, #4]!
 8020fcc:	42b3      	cmp	r3, r6
 8020fce:	d026      	beq.n	802101e <ai_platform_get_activations_map+0xa6>
 8020fd0:	f845 3f04 	str.w	r3, [r5, #4]!
 8020fd4:	1c4b      	adds	r3, r1, #1
 8020fd6:	429f      	cmp	r7, r3
 8020fd8:	d8f5      	bhi.n	8020fc6 <ai_platform_get_activations_map+0x4e>
 8020fda:	d1da      	bne.n	8020f92 <ai_platform_get_activations_map+0x1a>
 8020fdc:	3102      	adds	r1, #2
 8020fde:	f850 3021 	ldr.w	r3, [r0, r1, lsl #2]
 8020fe2:	42b3      	cmp	r3, r6
 8020fe4:	d1d5      	bne.n	8020f92 <ai_platform_get_activations_map+0x1a>
 8020fe6:	2401      	movs	r4, #1
 8020fe8:	e7d3      	b.n	8020f92 <ai_platform_get_activations_map+0x1a>
 8020fea:	f106 000c 	add.w	r0, r6, #12
 8020fee:	f7ff ff51 	bl	8020e94 <ai_buffer_array_sane>
 8020ff2:	2800      	cmp	r0, #0
 8020ff4:	d0cc      	beq.n	8020f90 <ai_platform_get_activations_map+0x18>
 8020ff6:	89f3      	ldrh	r3, [r6, #14]
 8020ff8:	429f      	cmp	r7, r3
 8020ffa:	d1c9      	bne.n	8020f90 <ai_platform_get_activations_map+0x18>
 8020ffc:	3d04      	subs	r5, #4
 8020ffe:	4622      	mov	r2, r4
 8021000:	6933      	ldr	r3, [r6, #16]
 8021002:	4423      	add	r3, r4
 8021004:	341c      	adds	r4, #28
 8021006:	685b      	ldr	r3, [r3, #4]
 8021008:	b123      	cbz	r3, 8021014 <ai_platform_get_activations_map+0x9c>
 802100a:	3201      	adds	r2, #1
 802100c:	f845 3f04 	str.w	r3, [r5, #4]!
 8021010:	4297      	cmp	r7, r2
 8021012:	d8f5      	bhi.n	8021000 <ai_platform_get_activations_map+0x88>
 8021014:	1abc      	subs	r4, r7, r2
 8021016:	fab4 f484 	clz	r4, r4
 802101a:	0964      	lsrs	r4, r4, #5
 802101c:	e7b9      	b.n	8020f92 <ai_platform_get_activations_map+0x1a>
 802101e:	428f      	cmp	r7, r1
 8021020:	d1b7      	bne.n	8020f92 <ai_platform_get_activations_map+0x1a>
 8021022:	e7e0      	b.n	8020fe6 <ai_platform_get_activations_map+0x6e>
 8021024:	a1facade 	.word	0xa1facade

08021028 <ai_platform_bind_network_params>:
 8021028:	2a00      	cmp	r2, #0
 802102a:	bf18      	it	ne
 802102c:	2900      	cmpne	r1, #0
 802102e:	d010      	beq.n	8021052 <ai_platform_bind_network_params+0x2a>
 8021030:	b178      	cbz	r0, 8021052 <ai_platform_bind_network_params+0x2a>
 8021032:	4603      	mov	r3, r0
 8021034:	4808      	ldr	r0, [pc, #32]	@ (8021058 <ai_platform_bind_network_params+0x30>)
 8021036:	f103 0c0c 	add.w	ip, r3, #12
 802103a:	f843 0b04 	str.w	r0, [r3], #4
 802103e:	c903      	ldmia	r1, {r0, r1}
 8021040:	e883 0003 	stmia.w	r3, {r0, r1}
 8021044:	2301      	movs	r3, #1
 8021046:	e892 0003 	ldmia.w	r2, {r0, r1}
 802104a:	e88c 0003 	stmia.w	ip, {r0, r1}
 802104e:	4618      	mov	r0, r3
 8021050:	4770      	bx	lr
 8021052:	2300      	movs	r3, #0
 8021054:	4618      	mov	r0, r3
 8021056:	4770      	bx	lr
 8021058:	a1facade 	.word	0xa1facade

0802105c <ai_platform_network_get_error>:
 802105c:	4b04      	ldr	r3, [pc, #16]	@ (8021070 <ai_platform_network_get_error+0x14>)
 802105e:	6802      	ldr	r2, [r0, #0]
 8021060:	4393      	bics	r3, r2
 8021062:	d102      	bne.n	802106a <ai_platform_network_get_error+0xe>
 8021064:	300c      	adds	r0, #12
 8021066:	f000 ba2d 	b.w	80214c4 <core_get_error>
 802106a:	f241 0010 	movw	r0, #4112	@ 0x1010
 802106e:	4770      	bx	lr
 8021070:	a1c00100 	.word	0xa1c00100

08021074 <ai_platform_network_set_error>:
 8021074:	b110      	cbz	r0, 802107c <ai_platform_network_set_error+0x8>
 8021076:	300c      	adds	r0, #12
 8021078:	f000 ba2a 	b.w	80214d0 <core_set_error>
 802107c:	4770      	bx	lr
 802107e:	bf00      	nop

08021080 <ai_platform_inputs_get>:
 8021080:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8021084:	4b39      	ldr	r3, [pc, #228]	@ (802116c <ai_platform_inputs_get+0xec>)
 8021086:	b085      	sub	sp, #20
 8021088:	6802      	ldr	r2, [r0, #0]
 802108a:	4393      	bics	r3, r2
 802108c:	e9cd 1002 	strd	r1, r0, [sp, #8]
 8021090:	d162      	bne.n	8021158 <ai_platform_inputs_get+0xd8>
 8021092:	8e03      	ldrh	r3, [r0, #48]	@ 0x30
 8021094:	2b00      	cmp	r3, #0
 8021096:	d051      	beq.n	802113c <ai_platform_inputs_get+0xbc>
 8021098:	f8d0 a034 	ldr.w	sl, [r0, #52]	@ 0x34
 802109c:	f1ba 0f00 	cmp.w	sl, #0
 80210a0:	d04c      	beq.n	802113c <ai_platform_inputs_get+0xbc>
 80210a2:	f04f 0900 	mov.w	r9, #0
 80210a6:	464d      	mov	r5, r9
 80210a8:	e016      	b.n	80210d8 <ai_platform_inputs_get+0x58>
 80210aa:	9901      	ldr	r1, [sp, #4]
 80210ac:	2301      	movs	r3, #1
 80210ae:	f848 3001 	str.w	r3, [r8, r1]
 80210b2:	69b1      	ldr	r1, [r6, #24]
 80210b4:	f04f 0301 	mov.w	r3, #1
 80210b8:	684e      	ldr	r6, [r1, #4]
 80210ba:	3501      	adds	r5, #1
 80210bc:	f109 091c 	add.w	r9, r9, #28
 80210c0:	7523      	strb	r3, [r4, #20]
 80210c2:	2300      	movs	r3, #0
 80210c4:	6961      	ldr	r1, [r4, #20]
 80210c6:	6020      	str	r0, [r4, #0]
 80210c8:	f36b 211f 	bfi	r1, fp, #8, #24
 80210cc:	e9c4 c701 	strd	ip, r7, [r4, #4]
 80210d0:	e9c4 3603 	strd	r3, r6, [r4, #12]
 80210d4:	e9c4 1205 	strd	r1, r2, [r4, #20]
 80210d8:	f8ba 3000 	ldrh.w	r3, [sl]
 80210dc:	b2ac      	uxth	r4, r5
 80210de:	42ab      	cmp	r3, r5
 80210e0:	ea4f 03c5 	mov.w	r3, r5, lsl #3
 80210e4:	9301      	str	r3, [sp, #4]
 80210e6:	d93b      	bls.n	8021160 <ai_platform_inputs_get+0xe0>
 80210e8:	f8da 3004 	ldr.w	r3, [sl, #4]
 80210ec:	2b00      	cmp	r3, #0
 80210ee:	d037      	beq.n	8021160 <ai_platform_inputs_get+0xe0>
 80210f0:	f853 6025 	ldr.w	r6, [r3, r5, lsl #2]
 80210f4:	2e00      	cmp	r6, #0
 80210f6:	d033      	beq.n	8021160 <ai_platform_inputs_get+0xe0>
 80210f8:	f8da 3008 	ldr.w	r3, [sl, #8]
 80210fc:	69b2      	ldr	r2, [r6, #24]
 80210fe:	e9d3 4801 	ldrd	r4, r8, [r3, #4]
 8021102:	6810      	ldr	r0, [r2, #0]
 8021104:	68b3      	ldr	r3, [r6, #8]
 8021106:	eb08 07c5 	add.w	r7, r8, r5, lsl #3
 802110a:	68f2      	ldr	r2, [r6, #12]
 802110c:	444c      	add	r4, r9
 802110e:	f3c3 2b17 	ubfx	fp, r3, #8, #24
 8021112:	9200      	str	r2, [sp, #0]
 8021114:	f00f fecc 	bl	8030eb0 <ai_array_to_buffer_fmt>
 8021118:	69b1      	ldr	r1, [r6, #24]
 802111a:	9a00      	ldr	r2, [sp, #0]
 802111c:	f8d1 c008 	ldr.w	ip, [r1, #8]
 8021120:	2f00      	cmp	r7, #0
 8021122:	d0c7      	beq.n	80210b4 <ai_platform_inputs_get+0x34>
 8021124:	2100      	movs	r1, #0
 8021126:	f848 1035 	str.w	r1, [r8, r5, lsl #3]
 802112a:	6831      	ldr	r1, [r6, #0]
 802112c:	6079      	str	r1, [r7, #4]
 802112e:	b111      	cbz	r1, 8021136 <ai_platform_inputs_get+0xb6>
 8021130:	8849      	ldrh	r1, [r1, #2]
 8021132:	2900      	cmp	r1, #0
 8021134:	d1b9      	bne.n	80210aa <ai_platform_inputs_get+0x2a>
 8021136:	69b1      	ldr	r1, [r6, #24]
 8021138:	2700      	movs	r7, #0
 802113a:	e7bb      	b.n	80210b4 <ai_platform_inputs_get+0x34>
 802113c:	9803      	ldr	r0, [sp, #12]
 802113e:	2400      	movs	r4, #0
 8021140:	2218      	movs	r2, #24
 8021142:	2111      	movs	r1, #17
 8021144:	300c      	adds	r0, #12
 8021146:	f000 f9c3 	bl	80214d0 <core_set_error>
 802114a:	4620      	mov	r0, r4
 802114c:	9b02      	ldr	r3, [sp, #8]
 802114e:	b103      	cbz	r3, 8021152 <ai_platform_inputs_get+0xd2>
 8021150:	801c      	strh	r4, [r3, #0]
 8021152:	b005      	add	sp, #20
 8021154:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8021158:	2000      	movs	r0, #0
 802115a:	b005      	add	sp, #20
 802115c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8021160:	2c00      	cmp	r4, #0
 8021162:	d0eb      	beq.n	802113c <ai_platform_inputs_get+0xbc>
 8021164:	f8da 3008 	ldr.w	r3, [sl, #8]
 8021168:	6858      	ldr	r0, [r3, #4]
 802116a:	e7ef      	b.n	802114c <ai_platform_inputs_get+0xcc>
 802116c:	a1c00100 	.word	0xa1c00100

08021170 <ai_platform_outputs_get>:
 8021170:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8021174:	4b38      	ldr	r3, [pc, #224]	@ (8021258 <ai_platform_outputs_get+0xe8>)
 8021176:	b085      	sub	sp, #20
 8021178:	6802      	ldr	r2, [r0, #0]
 802117a:	4393      	bics	r3, r2
 802117c:	e9cd 1002 	strd	r1, r0, [sp, #8]
 8021180:	d15f      	bne.n	8021242 <ai_platform_outputs_get+0xd2>
 8021182:	8e03      	ldrh	r3, [r0, #48]	@ 0x30
 8021184:	2b01      	cmp	r3, #1
 8021186:	d94e      	bls.n	8021226 <ai_platform_outputs_get+0xb6>
 8021188:	f04f 0900 	mov.w	r9, #0
 802118c:	f8d0 a034 	ldr.w	sl, [r0, #52]	@ 0x34
 8021190:	464d      	mov	r5, r9
 8021192:	e016      	b.n	80211c2 <ai_platform_outputs_get+0x52>
 8021194:	9901      	ldr	r1, [sp, #4]
 8021196:	2301      	movs	r3, #1
 8021198:	f848 3001 	str.w	r3, [r8, r1]
 802119c:	69b1      	ldr	r1, [r6, #24]
 802119e:	f04f 0301 	mov.w	r3, #1
 80211a2:	684e      	ldr	r6, [r1, #4]
 80211a4:	3501      	adds	r5, #1
 80211a6:	f109 091c 	add.w	r9, r9, #28
 80211aa:	7523      	strb	r3, [r4, #20]
 80211ac:	2300      	movs	r3, #0
 80211ae:	6961      	ldr	r1, [r4, #20]
 80211b0:	6020      	str	r0, [r4, #0]
 80211b2:	f36b 211f 	bfi	r1, fp, #8, #24
 80211b6:	e9c4 c701 	strd	ip, r7, [r4, #4]
 80211ba:	e9c4 3603 	strd	r3, r6, [r4, #12]
 80211be:	e9c4 1205 	strd	r1, r2, [r4, #20]
 80211c2:	f8ba 300c 	ldrh.w	r3, [sl, #12]
 80211c6:	b2ac      	uxth	r4, r5
 80211c8:	42ab      	cmp	r3, r5
 80211ca:	ea4f 03c5 	mov.w	r3, r5, lsl #3
 80211ce:	9301      	str	r3, [sp, #4]
 80211d0:	d93b      	bls.n	802124a <ai_platform_outputs_get+0xda>
 80211d2:	f8da 3010 	ldr.w	r3, [sl, #16]
 80211d6:	2b00      	cmp	r3, #0
 80211d8:	d037      	beq.n	802124a <ai_platform_outputs_get+0xda>
 80211da:	f853 6025 	ldr.w	r6, [r3, r5, lsl #2]
 80211de:	2e00      	cmp	r6, #0
 80211e0:	d033      	beq.n	802124a <ai_platform_outputs_get+0xda>
 80211e2:	f8da 3014 	ldr.w	r3, [sl, #20]
 80211e6:	69b2      	ldr	r2, [r6, #24]
 80211e8:	e9d3 4801 	ldrd	r4, r8, [r3, #4]
 80211ec:	6810      	ldr	r0, [r2, #0]
 80211ee:	68b3      	ldr	r3, [r6, #8]
 80211f0:	eb08 07c5 	add.w	r7, r8, r5, lsl #3
 80211f4:	68f2      	ldr	r2, [r6, #12]
 80211f6:	444c      	add	r4, r9
 80211f8:	f3c3 2b17 	ubfx	fp, r3, #8, #24
 80211fc:	9200      	str	r2, [sp, #0]
 80211fe:	f00f fe57 	bl	8030eb0 <ai_array_to_buffer_fmt>
 8021202:	69b1      	ldr	r1, [r6, #24]
 8021204:	9a00      	ldr	r2, [sp, #0]
 8021206:	f8d1 c008 	ldr.w	ip, [r1, #8]
 802120a:	2f00      	cmp	r7, #0
 802120c:	d0c7      	beq.n	802119e <ai_platform_outputs_get+0x2e>
 802120e:	2100      	movs	r1, #0
 8021210:	f848 1035 	str.w	r1, [r8, r5, lsl #3]
 8021214:	6831      	ldr	r1, [r6, #0]
 8021216:	6079      	str	r1, [r7, #4]
 8021218:	b111      	cbz	r1, 8021220 <ai_platform_outputs_get+0xb0>
 802121a:	8849      	ldrh	r1, [r1, #2]
 802121c:	2900      	cmp	r1, #0
 802121e:	d1b9      	bne.n	8021194 <ai_platform_outputs_get+0x24>
 8021220:	69b1      	ldr	r1, [r6, #24]
 8021222:	2700      	movs	r7, #0
 8021224:	e7bb      	b.n	802119e <ai_platform_outputs_get+0x2e>
 8021226:	9803      	ldr	r0, [sp, #12]
 8021228:	2400      	movs	r4, #0
 802122a:	2218      	movs	r2, #24
 802122c:	2111      	movs	r1, #17
 802122e:	300c      	adds	r0, #12
 8021230:	f000 f94e 	bl	80214d0 <core_set_error>
 8021234:	4620      	mov	r0, r4
 8021236:	9b02      	ldr	r3, [sp, #8]
 8021238:	b103      	cbz	r3, 802123c <ai_platform_outputs_get+0xcc>
 802123a:	801c      	strh	r4, [r3, #0]
 802123c:	b005      	add	sp, #20
 802123e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8021242:	2000      	movs	r0, #0
 8021244:	b005      	add	sp, #20
 8021246:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802124a:	2c00      	cmp	r4, #0
 802124c:	d0eb      	beq.n	8021226 <ai_platform_outputs_get+0xb6>
 802124e:	f8da 3014 	ldr.w	r3, [sl, #20]
 8021252:	6858      	ldr	r0, [r3, #4]
 8021254:	e7ef      	b.n	8021236 <ai_platform_outputs_get+0xc6>
 8021256:	bf00      	nop
 8021258:	a1c00100 	.word	0xa1c00100

0802125c <ai_platform_network_create>:
 802125c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8021260:	b083      	sub	sp, #12
 8021262:	f89d 8028 	ldrb.w	r8, [sp, #40]	@ 0x28
 8021266:	f89d 902c 	ldrb.w	r9, [sp, #44]	@ 0x2c
 802126a:	b320      	cbz	r0, 80212b6 <ai_platform_network_create+0x5a>
 802126c:	6002      	str	r2, [r0, #0]
 802126e:	4616      	mov	r6, r2
 8021270:	461f      	mov	r7, r3
 8021272:	4604      	mov	r4, r0
 8021274:	f000 f924 	bl	80214c0 <core_init>
 8021278:	b970      	cbnz	r0, 8021298 <ai_platform_network_create+0x3c>
 802127a:	2530      	movs	r5, #48	@ 0x30
 802127c:	2300      	movs	r3, #0
 802127e:	6023      	str	r3, [r4, #0]
 8021280:	2410      	movs	r4, #16
 8021282:	464a      	mov	r2, r9
 8021284:	4641      	mov	r1, r8
 8021286:	4638      	mov	r0, r7
 8021288:	f00f feaa 	bl	8030fe0 <ai_version_get>
 802128c:	60b0      	str	r0, [r6, #8]
 802128e:	ea45 2004 	orr.w	r0, r5, r4, lsl #8
 8021292:	b003      	add	sp, #12
 8021294:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8021298:	2200      	movs	r2, #0
 802129a:	4641      	mov	r1, r8
 802129c:	4638      	mov	r0, r7
 802129e:	f00f fe9f 	bl	8030fe0 <ai_version_get>
 80212a2:	4605      	mov	r5, r0
 80212a4:	2200      	movs	r2, #0
 80212a6:	2105      	movs	r1, #5
 80212a8:	2001      	movs	r0, #1
 80212aa:	f00f fe99 	bl	8030fe0 <ai_version_get>
 80212ae:	4285      	cmp	r5, r0
 80212b0:	d008      	beq.n	80212c4 <ai_platform_network_create+0x68>
 80212b2:	2501      	movs	r5, #1
 80212b4:	e7e2      	b.n	802127c <ai_platform_network_create+0x20>
 80212b6:	2510      	movs	r5, #16
 80212b8:	462c      	mov	r4, r5
 80212ba:	ea45 2004 	orr.w	r0, r5, r4, lsl #8
 80212be:	b003      	add	sp, #12
 80212c0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80212c4:	4b05      	ldr	r3, [pc, #20]	@ (80212dc <ai_platform_network_create+0x80>)
 80212c6:	a801      	add	r0, sp, #4
 80212c8:	9301      	str	r3, [sp, #4]
 80212ca:	f000 f90d 	bl	80214e8 <ai_check_custom_types>
 80212ce:	b110      	cbz	r0, 80212d6 <ai_platform_network_create+0x7a>
 80212d0:	2400      	movs	r4, #0
 80212d2:	4625      	mov	r5, r4
 80212d4:	e7d5      	b.n	8021282 <ai_platform_network_create+0x26>
 80212d6:	2502      	movs	r5, #2
 80212d8:	e7d0      	b.n	802127c <ai_platform_network_create+0x20>
 80212da:	bf00      	nop
 80212dc:	84048403 	.word	0x84048403

080212e0 <ai_platform_network_init>:
 80212e0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80212e4:	4a5c      	ldr	r2, [pc, #368]	@ (8021458 <ai_platform_network_init+0x178>)
 80212e6:	460c      	mov	r4, r1
 80212e8:	6801      	ldr	r1, [r0, #0]
 80212ea:	438a      	bics	r2, r1
 80212ec:	d133      	bne.n	8021356 <ai_platform_network_init+0x76>
 80212ee:	4605      	mov	r5, r0
 80212f0:	2c00      	cmp	r4, #0
 80212f2:	f000 8093 	beq.w	802141c <ai_platform_network_init+0x13c>
 80212f6:	f8d4 b000 	ldr.w	fp, [r4]
 80212fa:	4a58      	ldr	r2, [pc, #352]	@ (802145c <ai_platform_network_init+0x17c>)
 80212fc:	4593      	cmp	fp, r2
 80212fe:	d10f      	bne.n	8021320 <ai_platform_network_init+0x40>
 8021300:	e9d4 e803 	ldrd	lr, r8, [r4, #12]
 8021304:	e9d4 6701 	ldrd	r6, r7, [r4, #4]
 8021308:	4b53      	ldr	r3, [pc, #332]	@ (8021458 <ai_platform_network_init+0x178>)
 802130a:	ea4f 4a1e 	mov.w	sl, lr, lsr #16
 802130e:	0c32      	lsrs	r2, r6, #16
 8021310:	4299      	cmp	r1, r3
 8021312:	d02c      	beq.n	802136e <ai_platform_network_init+0x8e>
 8021314:	2303      	movs	r3, #3
 8021316:	462c      	mov	r4, r5
 8021318:	612b      	str	r3, [r5, #16]
 802131a:	4620      	mov	r0, r4
 802131c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8021320:	4627      	mov	r7, r4
 8021322:	2101      	movs	r1, #1
 8021324:	6864      	ldr	r4, [r4, #4]
 8021326:	4638      	mov	r0, r7
 8021328:	f107 081c 	add.w	r8, r7, #28
 802132c:	f7ff fd7e 	bl	8020e2c <ai_buffer_get_size>
 8021330:	4606      	mov	r6, r0
 8021332:	2101      	movs	r1, #1
 8021334:	4640      	mov	r0, r8
 8021336:	f8d7 9020 	ldr.w	r9, [r7, #32]
 802133a:	f7ff fd77 	bl	8020e2c <ai_buffer_get_size>
 802133e:	b976      	cbnz	r6, 802135e <ai_platform_network_init+0x7e>
 8021340:	2800      	cmp	r0, #0
 8021342:	d150      	bne.n	80213e6 <ai_platform_network_init+0x106>
 8021344:	4680      	mov	r8, r0
 8021346:	4686      	mov	lr, r0
 8021348:	4606      	mov	r6, r0
 802134a:	4607      	mov	r7, r0
 802134c:	ea4f 4e0e 	mov.w	lr, lr, lsl #16
 8021350:	6829      	ldr	r1, [r5, #0]
 8021352:	0436      	lsls	r6, r6, #16
 8021354:	e7d8      	b.n	8021308 <ai_platform_network_init+0x28>
 8021356:	2400      	movs	r4, #0
 8021358:	4620      	mov	r0, r4
 802135a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802135e:	2800      	cmp	r0, #0
 8021360:	d13b      	bne.n	80213da <ai_platform_network_init+0xfa>
 8021362:	4680      	mov	r8, r0
 8021364:	4686      	mov	lr, r0
 8021366:	2c00      	cmp	r4, #0
 8021368:	d05e      	beq.n	8021428 <ai_platform_network_init+0x148>
 802136a:	2601      	movs	r6, #1
 802136c:	e7ee      	b.n	802134c <ai_platform_network_init+0x6c>
 802136e:	8c6b      	ldrh	r3, [r5, #34]	@ 0x22
 8021370:	4293      	cmp	r3, r2
 8021372:	4b3a      	ldr	r3, [pc, #232]	@ (802145c <ai_platform_network_init+0x17c>)
 8021374:	d33e      	bcc.n	80213f4 <ai_platform_network_init+0x114>
 8021376:	459b      	cmp	fp, r3
 8021378:	d03e      	beq.n	80213f8 <ai_platform_network_init+0x118>
 802137a:	b1a2      	cbz	r2, 80213a6 <ai_platform_network_init+0xc6>
 802137c:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
 8021380:	f04f 0c00 	mov.w	ip, #0
 8021384:	ea4f 0982 	mov.w	r9, r2, lsl #2
 8021388:	6a6c      	ldr	r4, [r5, #36]	@ 0x24
 802138a:	eb07 0b0c 	add.w	fp, r7, ip
 802138e:	4464      	add	r4, ip
 8021390:	f10c 0c1c 	add.w	ip, ip, #28
 8021394:	e8bb 000f 	ldmia.w	fp!, {r0, r1, r2, r3}
 8021398:	45cc      	cmp	ip, r9
 802139a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 802139c:	e89b 0007 	ldmia.w	fp, {r0, r1, r2}
 80213a0:	e884 0007 	stmia.w	r4, {r0, r1, r2}
 80213a4:	d1f0      	bne.n	8021388 <ai_platform_network_init+0xa8>
 80213a6:	8d6b      	ldrh	r3, [r5, #42]	@ 0x2a
 80213a8:	622e      	str	r6, [r5, #32]
 80213aa:	4553      	cmp	r3, sl
 80213ac:	d34b      	bcc.n	8021446 <ai_platform_network_init+0x166>
 80213ae:	f1ba 0f00 	cmp.w	sl, #0
 80213b2:	d025      	beq.n	8021400 <ai_platform_network_init+0x120>
 80213b4:	ebca 0aca 	rsb	sl, sl, sl, lsl #3
 80213b8:	2700      	movs	r7, #0
 80213ba:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 80213be:	6aec      	ldr	r4, [r5, #44]	@ 0x2c
 80213c0:	eb08 0607 	add.w	r6, r8, r7
 80213c4:	443c      	add	r4, r7
 80213c6:	371c      	adds	r7, #28
 80213c8:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80213ca:	4557      	cmp	r7, sl
 80213cc:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80213ce:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
 80213d2:	e884 0007 	stmia.w	r4, {r0, r1, r2}
 80213d6:	d1f2      	bne.n	80213be <ai_platform_network_init+0xde>
 80213d8:	e012      	b.n	8021400 <ai_platform_network_init+0x120>
 80213da:	f1b9 0f00 	cmp.w	r9, #0
 80213de:	d015      	beq.n	802140c <ai_platform_network_init+0x12c>
 80213e0:	f04f 0e01 	mov.w	lr, #1
 80213e4:	e7bf      	b.n	8021366 <ai_platform_network_init+0x86>
 80213e6:	f1b9 0f00 	cmp.w	r9, #0
 80213ea:	d00f      	beq.n	802140c <ai_platform_network_init+0x12c>
 80213ec:	f04f 0e01 	mov.w	lr, #1
 80213f0:	4637      	mov	r7, r6
 80213f2:	e7ab      	b.n	802134c <ai_platform_network_init+0x6c>
 80213f4:	459b      	cmp	fp, r3
 80213f6:	d11e      	bne.n	8021436 <ai_platform_network_init+0x156>
 80213f8:	f8c5 802c 	str.w	r8, [r5, #44]	@ 0x2c
 80213fc:	e9c5 6708 	strd	r6, r7, [r5, #32]
 8021400:	4628      	mov	r0, r5
 8021402:	f8c5 e028 	str.w	lr, [r5, #40]	@ 0x28
 8021406:	f000 f897 	bl	8021538 <ai_layers_init_all>
 802140a:	e783      	b.n	8021314 <ai_platform_network_init+0x34>
 802140c:	2213      	movs	r2, #19
 802140e:	2110      	movs	r1, #16
 8021410:	f105 000c 	add.w	r0, r5, #12
 8021414:	2400      	movs	r4, #0
 8021416:	f000 f85b 	bl	80214d0 <core_set_error>
 802141a:	e77e      	b.n	802131a <ai_platform_network_init+0x3a>
 802141c:	2211      	movs	r2, #17
 802141e:	2110      	movs	r1, #16
 8021420:	300c      	adds	r0, #12
 8021422:	f000 f855 	bl	80214d0 <core_set_error>
 8021426:	e778      	b.n	802131a <ai_platform_network_init+0x3a>
 8021428:	2212      	movs	r2, #18
 802142a:	2110      	movs	r1, #16
 802142c:	f105 000c 	add.w	r0, r5, #12
 8021430:	f000 f84e 	bl	80214d0 <core_set_error>
 8021434:	e771      	b.n	802131a <ai_platform_network_init+0x3a>
 8021436:	2212      	movs	r2, #18
 8021438:	2116      	movs	r1, #22
 802143a:	f105 000c 	add.w	r0, r5, #12
 802143e:	2400      	movs	r4, #0
 8021440:	f000 f846 	bl	80214d0 <core_set_error>
 8021444:	e769      	b.n	802131a <ai_platform_network_init+0x3a>
 8021446:	2213      	movs	r2, #19
 8021448:	2116      	movs	r1, #22
 802144a:	f105 000c 	add.w	r0, r5, #12
 802144e:	2400      	movs	r4, #0
 8021450:	f000 f83e 	bl	80214d0 <core_set_error>
 8021454:	e761      	b.n	802131a <ai_platform_network_init+0x3a>
 8021456:	bf00      	nop
 8021458:	a1c00100 	.word	0xa1c00100
 802145c:	a1facade 	.word	0xa1facade

08021460 <ai_platform_network_post_init>:
 8021460:	b538      	push	{r3, r4, r5, lr}
 8021462:	4b16      	ldr	r3, [pc, #88]	@ (80214bc <ai_platform_network_post_init+0x5c>)
 8021464:	6802      	ldr	r2, [r0, #0]
 8021466:	ea02 0103 	and.w	r1, r2, r3
 802146a:	4393      	bics	r3, r2
 802146c:	d108      	bne.n	8021480 <ai_platform_network_post_init+0x20>
 802146e:	6903      	ldr	r3, [r0, #16]
 8021470:	4604      	mov	r4, r0
 8021472:	f013 0502 	ands.w	r5, r3, #2
 8021476:	d005      	beq.n	8021484 <ai_platform_network_post_init+0x24>
 8021478:	428a      	cmp	r2, r1
 802147a:	d00a      	beq.n	8021492 <ai_platform_network_post_init+0x32>
 802147c:	2001      	movs	r0, #1
 802147e:	bd38      	pop	{r3, r4, r5, pc}
 8021480:	2000      	movs	r0, #0
 8021482:	bd38      	pop	{r3, r4, r5, pc}
 8021484:	2210      	movs	r2, #16
 8021486:	2111      	movs	r1, #17
 8021488:	300c      	adds	r0, #12
 802148a:	f000 f821 	bl	80214d0 <core_set_error>
 802148e:	4628      	mov	r0, r5
 8021490:	bd38      	pop	{r3, r4, r5, pc}
 8021492:	f000 f85f 	bl	8021554 <ai_layers_post_init_all>
 8021496:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 8021498:	2b00      	cmp	r3, #0
 802149a:	d0ef      	beq.n	802147c <ai_platform_network_post_init+0x1c>
 802149c:	6ba5      	ldr	r5, [r4, #56]	@ 0x38
 802149e:	e008      	b.n	80214b2 <ai_platform_network_post_init+0x52>
 80214a0:	e9d4 3210 	ldrd	r3, r2, [r4, #64]	@ 0x40
 80214a4:	4798      	blx	r3
 80214a6:	692b      	ldr	r3, [r5, #16]
 80214a8:	42ab      	cmp	r3, r5
 80214aa:	461d      	mov	r5, r3
 80214ac:	d0e6      	beq.n	802147c <ai_platform_network_post_init+0x1c>
 80214ae:	2b00      	cmp	r3, #0
 80214b0:	d0e4      	beq.n	802147c <ai_platform_network_post_init+0x1c>
 80214b2:	4629      	mov	r1, r5
 80214b4:	2000      	movs	r0, #0
 80214b6:	2d00      	cmp	r5, #0
 80214b8:	d1f2      	bne.n	80214a0 <ai_platform_network_post_init+0x40>
 80214ba:	e7df      	b.n	802147c <ai_platform_network_post_init+0x1c>
 80214bc:	a1c00100 	.word	0xa1c00100

080214c0 <core_init>:
 80214c0:	2001      	movs	r0, #1
 80214c2:	4770      	bx	lr

080214c4 <core_get_error>:
 80214c4:	4603      	mov	r3, r0
 80214c6:	2200      	movs	r2, #0
 80214c8:	6800      	ldr	r0, [r0, #0]
 80214ca:	601a      	str	r2, [r3, #0]
 80214cc:	4770      	bx	lr
 80214ce:	bf00      	nop

080214d0 <core_set_error>:
 80214d0:	4603      	mov	r3, r0
 80214d2:	7800      	ldrb	r0, [r0, #0]
 80214d4:	b108      	cbz	r0, 80214da <core_set_error+0xa>
 80214d6:	2000      	movs	r0, #0
 80214d8:	4770      	bx	lr
 80214da:	7019      	strb	r1, [r3, #0]
 80214dc:	2001      	movs	r0, #1
 80214de:	6819      	ldr	r1, [r3, #0]
 80214e0:	f362 211f 	bfi	r1, r2, #8, #24
 80214e4:	6019      	str	r1, [r3, #0]
 80214e6:	4770      	bx	lr

080214e8 <ai_check_custom_types>:
 80214e8:	b082      	sub	sp, #8
 80214ea:	4b12      	ldr	r3, [pc, #72]	@ (8021534 <ai_check_custom_types+0x4c>)
 80214ec:	9301      	str	r3, [sp, #4]
 80214ee:	b118      	cbz	r0, 80214f8 <ai_check_custom_types+0x10>
 80214f0:	7803      	ldrb	r3, [r0, #0]
 80214f2:	2b03      	cmp	r3, #3
 80214f4:	d002      	beq.n	80214fc <ai_check_custom_types+0x14>
 80214f6:	2000      	movs	r0, #0
 80214f8:	b002      	add	sp, #8
 80214fa:	4770      	bx	lr
 80214fc:	f89d 2004 	ldrb.w	r2, [sp, #4]
 8021500:	4293      	cmp	r3, r2
 8021502:	d004      	beq.n	802150e <ai_check_custom_types+0x26>
 8021504:	2001      	movs	r0, #1
 8021506:	f080 0001 	eor.w	r0, r0, #1
 802150a:	b002      	add	sp, #8
 802150c:	4770      	bx	lr
 802150e:	7842      	ldrb	r2, [r0, #1]
 8021510:	3001      	adds	r0, #1
 8021512:	f89d 3005 	ldrb.w	r3, [sp, #5]
 8021516:	429a      	cmp	r2, r3
 8021518:	d1f4      	bne.n	8021504 <ai_check_custom_types+0x1c>
 802151a:	f810 2f01 	ldrb.w	r2, [r0, #1]!
 802151e:	f89d 3006 	ldrb.w	r3, [sp, #6]
 8021522:	429a      	cmp	r2, r3
 8021524:	d1ee      	bne.n	8021504 <ai_check_custom_types+0x1c>
 8021526:	7842      	ldrb	r2, [r0, #1]
 8021528:	f89d 3007 	ldrb.w	r3, [sp, #7]
 802152c:	429a      	cmp	r2, r3
 802152e:	d1e9      	bne.n	8021504 <ai_check_custom_types+0x1c>
 8021530:	2000      	movs	r0, #0
 8021532:	e7e8      	b.n	8021506 <ai_check_custom_types+0x1e>
 8021534:	84048403 	.word	0x84048403

08021538 <ai_layers_init_all>:
 8021538:	2100      	movs	r1, #0
 802153a:	6b83      	ldr	r3, [r0, #56]	@ 0x38
 802153c:	b13b      	cbz	r3, 802154e <ai_layers_init_all+0x16>
 802153e:	691a      	ldr	r2, [r3, #16]
 8021540:	3101      	adds	r1, #1
 8021542:	60d8      	str	r0, [r3, #12]
 8021544:	429a      	cmp	r2, r3
 8021546:	4613      	mov	r3, r2
 8021548:	d001      	beq.n	802154e <ai_layers_init_all+0x16>
 802154a:	2a00      	cmp	r2, #0
 802154c:	d1f6      	bne.n	802153c <ai_layers_init_all+0x4>
 802154e:	4608      	mov	r0, r1
 8021550:	4770      	bx	lr
 8021552:	bf00      	nop

08021554 <ai_layers_post_init_all>:
 8021554:	b538      	push	{r3, r4, r5, lr}
 8021556:	2500      	movs	r5, #0
 8021558:	6b84      	ldr	r4, [r0, #56]	@ 0x38
 802155a:	b16c      	cbz	r4, 8021578 <ai_layers_post_init_all+0x24>
 802155c:	6863      	ldr	r3, [r4, #4]
 802155e:	07db      	lsls	r3, r3, #31
 8021560:	d504      	bpl.n	802156c <ai_layers_post_init_all+0x18>
 8021562:	6a23      	ldr	r3, [r4, #32]
 8021564:	4620      	mov	r0, r4
 8021566:	b10b      	cbz	r3, 802156c <ai_layers_post_init_all+0x18>
 8021568:	3501      	adds	r5, #1
 802156a:	4798      	blx	r3
 802156c:	6923      	ldr	r3, [r4, #16]
 802156e:	42a3      	cmp	r3, r4
 8021570:	461c      	mov	r4, r3
 8021572:	d001      	beq.n	8021578 <ai_layers_post_init_all+0x24>
 8021574:	2b00      	cmp	r3, #0
 8021576:	d1f0      	bne.n	802155a <ai_layers_post_init_all+0x6>
 8021578:	4628      	mov	r0, r5
 802157a:	bd38      	pop	{r3, r4, r5, pc}

0802157c <func_dummy>:
 802157c:	4770      	bx	lr
 802157e:	bf00      	nop

08021580 <forward_conv2d_deep_3x3_sssa8_ch>:
 8021580:	6982      	ldr	r2, [r0, #24]
 8021582:	8813      	ldrh	r3, [r2, #0]
 8021584:	2b00      	cmp	r3, #0
 8021586:	f000 80a6 	beq.w	80216d6 <forward_conv2d_deep_3x3_sssa8_ch+0x156>
 802158a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802158e:	6854      	ldr	r4, [r2, #4]
 8021590:	b099      	sub	sp, #100	@ 0x64
 8021592:	6861      	ldr	r1, [r4, #4]
 8021594:	b101      	cbz	r1, 8021598 <forward_conv2d_deep_3x3_sssa8_ch+0x18>
 8021596:	6809      	ldr	r1, [r1, #0]
 8021598:	2b01      	cmp	r3, #1
 802159a:	f000 80b5 	beq.w	8021708 <forward_conv2d_deep_3x3_sssa8_ch+0x188>
 802159e:	6922      	ldr	r2, [r4, #16]
 80215a0:	b102      	cbz	r2, 80215a4 <forward_conv2d_deep_3x3_sssa8_ch+0x24>
 80215a2:	6812      	ldr	r2, [r2, #0]
 80215a4:	2b02      	cmp	r3, #2
 80215a6:	f000 80aa 	beq.w	80216fe <forward_conv2d_deep_3x3_sssa8_ch+0x17e>
 80215aa:	69e5      	ldr	r5, [r4, #28]
 80215ac:	2d00      	cmp	r5, #0
 80215ae:	f000 809e 	beq.w	80216ee <forward_conv2d_deep_3x3_sssa8_ch+0x16e>
 80215b2:	8b26      	ldrh	r6, [r4, #24]
 80215b4:	f8d5 e000 	ldr.w	lr, [r5]
 80215b8:	2e01      	cmp	r6, #1
 80215ba:	f240 809a 	bls.w	80216f2 <forward_conv2d_deep_3x3_sssa8_ch+0x172>
 80215be:	686d      	ldr	r5, [r5, #4]
 80215c0:	2b03      	cmp	r3, #3
 80215c2:	f000 80a4 	beq.w	802170e <forward_conv2d_deep_3x3_sssa8_ch+0x18e>
 80215c6:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 80215c8:	2b00      	cmp	r3, #0
 80215ca:	f000 8094 	beq.w	80216f6 <forward_conv2d_deep_3x3_sssa8_ch+0x176>
 80215ce:	6a44      	ldr	r4, [r0, #36]	@ 0x24
 80215d0:	b104      	cbz	r4, 80215d4 <forward_conv2d_deep_3x3_sssa8_ch+0x54>
 80215d2:	685a      	ldr	r2, [r3, #4]
 80215d4:	681c      	ldr	r4, [r3, #0]
 80215d6:	69ab      	ldr	r3, [r5, #24]
 80215d8:	68d6      	ldr	r6, [r2, #12]
 80215da:	f8d4 c018 	ldr.w	ip, [r4, #24]
 80215de:	689b      	ldr	r3, [r3, #8]
 80215e0:	88b7      	ldrh	r7, [r6, #4]
 80215e2:	68cc      	ldr	r4, [r1, #12]
 80215e4:	9316      	str	r3, [sp, #88]	@ 0x58
 80215e6:	f8dc 3008 	ldr.w	r3, [ip, #8]
 80215ea:	9712      	str	r7, [sp, #72]	@ 0x48
 80215ec:	9317      	str	r3, [sp, #92]	@ 0x5c
 80215ee:	68f7      	ldr	r7, [r6, #12]
 80215f0:	88a3      	ldrh	r3, [r4, #4]
 80215f2:	68b6      	ldr	r6, [r6, #8]
 80215f4:	680d      	ldr	r5, [r1, #0]
 80215f6:	9614      	str	r6, [sp, #80]	@ 0x50
 80215f8:	9713      	str	r7, [sp, #76]	@ 0x4c
 80215fa:	f8de 6000 	ldr.w	r6, [lr]
 80215fe:	e9d4 4b02 	ldrd	r4, fp, [r4, #8]
 8021602:	9415      	str	r4, [sp, #84]	@ 0x54
 8021604:	6814      	ldr	r4, [r2, #0]
 8021606:	2d00      	cmp	r5, #0
 8021608:	d06a      	beq.n	80216e0 <forward_conv2d_deep_3x3_sssa8_ch+0x160>
 802160a:	686f      	ldr	r7, [r5, #4]
 802160c:	2f00      	cmp	r7, #0
 802160e:	d067      	beq.n	80216e0 <forward_conv2d_deep_3x3_sssa8_ch+0x160>
 8021610:	f8b5 8002 	ldrh.w	r8, [r5, #2]
 8021614:	f1b8 0f00 	cmp.w	r8, #0
 8021618:	d062      	beq.n	80216e0 <forward_conv2d_deep_3x3_sssa8_ch+0x160>
 802161a:	683f      	ldr	r7, [r7, #0]
 802161c:	ed97 0a00 	vldr	s0, [r7]
 8021620:	2c00      	cmp	r4, #0
 8021622:	d05a      	beq.n	80216da <forward_conv2d_deep_3x3_sssa8_ch+0x15a>
 8021624:	6867      	ldr	r7, [r4, #4]
 8021626:	2f00      	cmp	r7, #0
 8021628:	d057      	beq.n	80216da <forward_conv2d_deep_3x3_sssa8_ch+0x15a>
 802162a:	f8b4 8002 	ldrh.w	r8, [r4, #2]
 802162e:	f1b8 0f00 	cmp.w	r8, #0
 8021632:	d052      	beq.n	80216da <forward_conv2d_deep_3x3_sssa8_ch+0x15a>
 8021634:	683f      	ldr	r7, [r7, #0]
 8021636:	edd7 0a00 	vldr	s1, [r7]
 802163a:	698f      	ldr	r7, [r1, #24]
 802163c:	6992      	ldr	r2, [r2, #24]
 802163e:	f8de 1018 	ldr.w	r1, [lr, #24]
 8021642:	f890 9041 	ldrb.w	r9, [r0, #65]	@ 0x41
 8021646:	f8d2 a008 	ldr.w	sl, [r2, #8]
 802164a:	68bf      	ldr	r7, [r7, #8]
 802164c:	f8d1 8008 	ldr.w	r8, [r1, #8]
 8021650:	b116      	cbz	r6, 8021658 <forward_conv2d_deep_3x3_sssa8_ch+0xd8>
 8021652:	6876      	ldr	r6, [r6, #4]
 8021654:	b106      	cbz	r6, 8021658 <forward_conv2d_deep_3x3_sssa8_ch+0xd8>
 8021656:	6836      	ldr	r6, [r6, #0]
 8021658:	b13d      	cbz	r5, 802166a <forward_conv2d_deep_3x3_sssa8_ch+0xea>
 802165a:	6869      	ldr	r1, [r5, #4]
 802165c:	2900      	cmp	r1, #0
 802165e:	d042      	beq.n	80216e6 <forward_conv2d_deep_3x3_sssa8_ch+0x166>
 8021660:	886d      	ldrh	r5, [r5, #2]
 8021662:	b115      	cbz	r5, 802166a <forward_conv2d_deep_3x3_sssa8_ch+0xea>
 8021664:	6849      	ldr	r1, [r1, #4]
 8021666:	f991 5000 	ldrsb.w	r5, [r1]
 802166a:	b13c      	cbz	r4, 802167c <forward_conv2d_deep_3x3_sssa8_ch+0xfc>
 802166c:	6861      	ldr	r1, [r4, #4]
 802166e:	2900      	cmp	r1, #0
 8021670:	d03b      	beq.n	80216ea <forward_conv2d_deep_3x3_sssa8_ch+0x16a>
 8021672:	8864      	ldrh	r4, [r4, #2]
 8021674:	b114      	cbz	r4, 802167c <forward_conv2d_deep_3x3_sssa8_ch+0xfc>
 8021676:	6849      	ldr	r1, [r1, #4]
 8021678:	f991 4000 	ldrsb.w	r4, [r1]
 802167c:	9311      	str	r3, [sp, #68]	@ 0x44
 802167e:	edcd 0a10 	vstr	s1, [sp, #64]	@ 0x40
 8021682:	ed8d 0a0f 	vstr	s0, [sp, #60]	@ 0x3c
 8021686:	e9dc 0100 	ldrd	r0, r1, [ip]
 802168a:	f00f fc81 	bl	8030f90 <ai_array_get_byte_size>
 802168e:	9b17      	ldr	r3, [sp, #92]	@ 0x5c
 8021690:	f8bd 204c 	ldrh.w	r2, [sp, #76]	@ 0x4c
 8021694:	eddd 0a10 	vldr	s1, [sp, #64]	@ 0x40
 8021698:	9209      	str	r2, [sp, #36]	@ 0x24
 802169a:	fa1f f28b 	uxth.w	r2, fp
 802169e:	ed9d 0a0f 	vldr	s0, [sp, #60]	@ 0x3c
 80216a2:	f8bd 1054 	ldrh.w	r1, [sp, #84]	@ 0x54
 80216a6:	9503      	str	r5, [sp, #12]
 80216a8:	e9cd 030b 	strd	r0, r3, [sp, #44]	@ 0x2c
 80216ac:	9b16      	ldr	r3, [sp, #88]	@ 0x58
 80216ae:	4638      	mov	r0, r7
 80216b0:	e9cd 4604 	strd	r4, r6, [sp, #16]
 80216b4:	9302      	str	r3, [sp, #8]
 80216b6:	f8bd 4050 	ldrh.w	r4, [sp, #80]	@ 0x50
 80216ba:	9b12      	ldr	r3, [sp, #72]	@ 0x48
 80216bc:	9408      	str	r4, [sp, #32]
 80216be:	2401      	movs	r4, #1
 80216c0:	e9cd 8300 	strd	r8, r3, [sp]
 80216c4:	9b11      	ldr	r3, [sp, #68]	@ 0x44
 80216c6:	940a      	str	r4, [sp, #40]	@ 0x28
 80216c8:	e9cd 9a06 	strd	r9, sl, [sp, #24]
 80216cc:	f001 f9ca 	bl	8022a64 <forward_lite_conv2d_deep_3x3_sssa8_ch>
 80216d0:	b019      	add	sp, #100	@ 0x64
 80216d2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80216d6:	685b      	ldr	r3, [r3, #4]
 80216d8:	deff      	udf	#255	@ 0xff
 80216da:	eddf 0a0e 	vldr	s1, [pc, #56]	@ 8021714 <forward_conv2d_deep_3x3_sssa8_ch+0x194>
 80216de:	e7ac      	b.n	802163a <forward_conv2d_deep_3x3_sssa8_ch+0xba>
 80216e0:	ed9f 0a0c 	vldr	s0, [pc, #48]	@ 8021714 <forward_conv2d_deep_3x3_sssa8_ch+0x194>
 80216e4:	e79c      	b.n	8021620 <forward_conv2d_deep_3x3_sssa8_ch+0xa0>
 80216e6:	460d      	mov	r5, r1
 80216e8:	e7bf      	b.n	802166a <forward_conv2d_deep_3x3_sssa8_ch+0xea>
 80216ea:	460c      	mov	r4, r1
 80216ec:	e7c6      	b.n	802167c <forward_conv2d_deep_3x3_sssa8_ch+0xfc>
 80216ee:	46ae      	mov	lr, r5
 80216f0:	e766      	b.n	80215c0 <forward_conv2d_deep_3x3_sssa8_ch+0x40>
 80216f2:	2500      	movs	r5, #0
 80216f4:	e764      	b.n	80215c0 <forward_conv2d_deep_3x3_sssa8_ch+0x40>
 80216f6:	6a42      	ldr	r2, [r0, #36]	@ 0x24
 80216f8:	b922      	cbnz	r2, 8021704 <forward_conv2d_deep_3x3_sssa8_ch+0x184>
 80216fa:	6993      	ldr	r3, [r2, #24]
 80216fc:	deff      	udf	#255	@ 0xff
 80216fe:	2300      	movs	r3, #0
 8021700:	685b      	ldr	r3, [r3, #4]
 8021702:	deff      	udf	#255	@ 0xff
 8021704:	68db      	ldr	r3, [r3, #12]
 8021706:	deff      	udf	#255	@ 0xff
 8021708:	2300      	movs	r3, #0
 802170a:	685b      	ldr	r3, [r3, #4]
 802170c:	deff      	udf	#255	@ 0xff
 802170e:	2300      	movs	r3, #0
 8021710:	685b      	ldr	r3, [r3, #4]
 8021712:	deff      	udf	#255	@ 0xff
 8021714:	00000000 	.word	0x00000000

08021718 <forward_conv2d_deep_3x3_sssa8_ch_nl_pool>:
 8021718:	6982      	ldr	r2, [r0, #24]
 802171a:	8813      	ldrh	r3, [r2, #0]
 802171c:	2b00      	cmp	r3, #0
 802171e:	f000 81fc 	beq.w	8021b1a <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x402>
 8021722:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8021726:	ed2d 8b06 	vpush	{d8-d10}
 802172a:	6852      	ldr	r2, [r2, #4]
 802172c:	b0c5      	sub	sp, #276	@ 0x114
 802172e:	4682      	mov	sl, r0
 8021730:	f8d2 b004 	ldr.w	fp, [r2, #4]
 8021734:	f1bb 0f00 	cmp.w	fp, #0
 8021738:	d001      	beq.n	802173e <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x26>
 802173a:	f8db b000 	ldr.w	fp, [fp]
 802173e:	2b01      	cmp	r3, #1
 8021740:	f000 8237 	beq.w	8021bb2 <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x49a>
 8021744:	6911      	ldr	r1, [r2, #16]
 8021746:	9115      	str	r1, [sp, #84]	@ 0x54
 8021748:	b109      	cbz	r1, 802174e <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x36>
 802174a:	6809      	ldr	r1, [r1, #0]
 802174c:	9115      	str	r1, [sp, #84]	@ 0x54
 802174e:	2b02      	cmp	r3, #2
 8021750:	f000 81e0 	beq.w	8021b14 <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x3fc>
 8021754:	69d0      	ldr	r0, [r2, #28]
 8021756:	2800      	cmp	r0, #0
 8021758:	f000 8226 	beq.w	8021ba8 <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x490>
 802175c:	8b11      	ldrh	r1, [r2, #24]
 802175e:	f8d0 8000 	ldr.w	r8, [r0]
 8021762:	2901      	cmp	r1, #1
 8021764:	f200 81db 	bhi.w	8021b1e <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x406>
 8021768:	2100      	movs	r1, #0
 802176a:	9112      	str	r1, [sp, #72]	@ 0x48
 802176c:	2b03      	cmp	r3, #3
 802176e:	f000 8223 	beq.w	8021bb8 <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x4a0>
 8021772:	6a93      	ldr	r3, [r2, #40]	@ 0x28
 8021774:	2b00      	cmp	r3, #0
 8021776:	f000 821a 	beq.w	8021bae <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x496>
 802177a:	6819      	ldr	r1, [r3, #0]
 802177c:	f8da 2024 	ldr.w	r2, [sl, #36]	@ 0x24
 8021780:	f8d3 9004 	ldr.w	r9, [r3, #4]
 8021784:	9121      	str	r1, [sp, #132]	@ 0x84
 8021786:	2a00      	cmp	r2, #0
 8021788:	f000 8207 	beq.w	8021b9a <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x482>
 802178c:	689b      	ldr	r3, [r3, #8]
 802178e:	922e      	str	r2, [sp, #184]	@ 0xb8
 8021790:	9310      	str	r3, [sp, #64]	@ 0x40
 8021792:	f8d9 300c 	ldr.w	r3, [r9, #12]
 8021796:	f8db 400c 	ldr.w	r4, [fp, #12]
 802179a:	685f      	ldr	r7, [r3, #4]
 802179c:	9b15      	ldr	r3, [sp, #84]	@ 0x54
 802179e:	f8da 103c 	ldr.w	r1, [sl, #60]	@ 0x3c
 80217a2:	68dd      	ldr	r5, [r3, #12]
 80217a4:	6863      	ldr	r3, [r4, #4]
 80217a6:	680a      	ldr	r2, [r1, #0]
 80217a8:	9311      	str	r3, [sp, #68]	@ 0x44
 80217aa:	688b      	ldr	r3, [r1, #8]
 80217ac:	f8d8 100c 	ldr.w	r1, [r8, #12]
 80217b0:	f8da 6058 	ldr.w	r6, [sl, #88]	@ 0x58
 80217b4:	6889      	ldr	r1, [r1, #8]
 80217b6:	9714      	str	r7, [sp, #80]	@ 0x50
 80217b8:	911a      	str	r1, [sp, #104]	@ 0x68
 80217ba:	f8bd 1044 	ldrh.w	r1, [sp, #68]	@ 0x44
 80217be:	ee0a 1a10 	vmov	s20, r1
 80217c2:	b2b9      	uxth	r1, r7
 80217c4:	ee09 1a10 	vmov	s18, r1
 80217c8:	68e9      	ldr	r1, [r5, #12]
 80217ca:	9117      	str	r1, [sp, #92]	@ 0x5c
 80217cc:	68a9      	ldr	r1, [r5, #8]
 80217ce:	9124      	str	r1, [sp, #144]	@ 0x90
 80217d0:	e9d4 1502 	ldrd	r1, r5, [r4, #8]
 80217d4:	b294      	uxth	r4, r2
 80217d6:	9116      	str	r1, [sp, #88]	@ 0x58
 80217d8:	941e      	str	r4, [sp, #120]	@ 0x78
 80217da:	f8da 4044 	ldr.w	r4, [sl, #68]	@ 0x44
 80217de:	f8da 102c 	ldr.w	r1, [sl, #44]	@ 0x2c
 80217e2:	9425      	str	r4, [sp, #148]	@ 0x94
 80217e4:	f8da 404c 	ldr.w	r4, [sl, #76]	@ 0x4c
 80217e8:	9426      	str	r4, [sp, #152]	@ 0x98
 80217ea:	f8da 4050 	ldr.w	r4, [sl, #80]	@ 0x50
 80217ee:	9413      	str	r4, [sp, #76]	@ 0x4c
 80217f0:	e9d6 4600 	ldrd	r4, r6, [r6]
 80217f4:	9627      	str	r6, [sp, #156]	@ 0x9c
 80217f6:	2800      	cmp	r0, #0
 80217f8:	f000 81c4 	beq.w	8021b84 <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x46c>
 80217fc:	6880      	ldr	r0, [r0, #8]
 80217fe:	2800      	cmp	r0, #0
 8021800:	f000 81c0 	beq.w	8021b84 <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x46c>
 8021804:	6986      	ldr	r6, [r0, #24]
 8021806:	2e00      	cmp	r6, #0
 8021808:	bf08      	it	eq
 802180a:	4630      	moveq	r0, r6
 802180c:	9023      	str	r0, [sp, #140]	@ 0x8c
 802180e:	b292      	uxth	r2, r2
 8021810:	9810      	ldr	r0, [sp, #64]	@ 0x40
 8021812:	b289      	uxth	r1, r1
 8021814:	f10d 0cc4 	add.w	ip, sp, #196	@ 0xc4
 8021818:	fa12 f383 	uxtah	r3, r2, r3
 802181c:	442a      	add	r2, r5
 802181e:	6986      	ldr	r6, [r0, #24]
 8021820:	b224      	sxth	r4, r4
 8021822:	442b      	add	r3, r5
 8021824:	921c      	str	r2, [sp, #112]	@ 0x70
 8021826:	9a1a      	ldr	r2, [sp, #104]	@ 0x68
 8021828:	f8d9 5018 	ldr.w	r5, [r9, #24]
 802182c:	1a9f      	subs	r7, r3, r2
 802182e:	aa35      	add	r2, sp, #212	@ 0xd4
 8021830:	f8cd c100 	str.w	ip, [sp, #256]	@ 0x100
 8021834:	9242      	str	r2, [sp, #264]	@ 0x108
 8021836:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
 802183a:	fbb7 f3f1 	udiv	r3, r7, r1
 802183e:	9f15      	ldr	r7, [sp, #84]	@ 0x54
 8021840:	f240 4101 	movw	r1, #1025	@ 0x401
 8021844:	930f      	str	r3, [sp, #60]	@ 0x3c
 8021846:	2300      	movs	r3, #0
 8021848:	69bf      	ldr	r7, [r7, #24]
 802184a:	933d      	str	r3, [sp, #244]	@ 0xf4
 802184c:	9331      	str	r3, [sp, #196]	@ 0xc4
 802184e:	9335      	str	r3, [sp, #212]	@ 0xd4
 8021850:	9334      	str	r3, [sp, #208]	@ 0xd0
 8021852:	9338      	str	r3, [sp, #224]	@ 0xe0
 8021854:	9343      	str	r3, [sp, #268]	@ 0x10c
 8021856:	9720      	str	r7, [sp, #128]	@ 0x80
 8021858:	e9cd 3332 	strd	r3, r3, [sp, #200]	@ 0xc8
 802185c:	e9cd 3336 	strd	r3, r3, [sp, #216]	@ 0xd8
 8021860:	f8da 3048 	ldr.w	r3, [sl, #72]	@ 0x48
 8021864:	e9cd 213e 	strd	r2, r1, [sp, #248]	@ 0xf8
 8021868:	f240 4102 	movw	r1, #1026	@ 0x402
 802186c:	9318      	str	r3, [sp, #96]	@ 0x60
 802186e:	f8da 305c 	ldr.w	r3, [sl, #92]	@ 0x5c
 8021872:	9141      	str	r1, [sp, #260]	@ 0x104
 8021874:	4601      	mov	r1, r0
 8021876:	a83d      	add	r0, sp, #244	@ 0xf4
 8021878:	9322      	str	r3, [sp, #136]	@ 0x88
 802187a:	f00f fbcd 	bl	8031018 <core_tensor_clone>
 802187e:	4631      	mov	r1, r6
 8021880:	a839      	add	r0, sp, #228	@ 0xe4
 8021882:	f00f fbfb 	bl	803107c <core_array_clone>
 8021886:	ab39      	add	r3, sp, #228	@ 0xe4
 8021888:	9343      	str	r3, [sp, #268]	@ 0x10c
 802188a:	f8d9 300c 	ldr.w	r3, [r9, #12]
 802188e:	f8d8 1000 	ldr.w	r1, [r8]
 8021892:	f8d3 c008 	ldr.w	ip, [r3, #8]
 8021896:	9b21      	ldr	r3, [sp, #132]	@ 0x84
 8021898:	f8db 2000 	ldr.w	r2, [fp]
 802189c:	699b      	ldr	r3, [r3, #24]
 802189e:	911f      	str	r1, [sp, #124]	@ 0x7c
 80218a0:	689b      	ldr	r3, [r3, #8]
 80218a2:	932a      	str	r3, [sp, #168]	@ 0xa8
 80218a4:	f8d9 3000 	ldr.w	r3, [r9]
 80218a8:	2a00      	cmp	r2, #0
 80218aa:	f000 8152 	beq.w	8021b52 <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x43a>
 80218ae:	6851      	ldr	r1, [r2, #4]
 80218b0:	2900      	cmp	r1, #0
 80218b2:	f000 814e 	beq.w	8021b52 <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x43a>
 80218b6:	8850      	ldrh	r0, [r2, #2]
 80218b8:	2800      	cmp	r0, #0
 80218ba:	f000 814a 	beq.w	8021b52 <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x43a>
 80218be:	6809      	ldr	r1, [r1, #0]
 80218c0:	ed91 8a00 	vldr	s16, [r1]
 80218c4:	2b00      	cmp	r3, #0
 80218c6:	f000 8141 	beq.w	8021b4c <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x434>
 80218ca:	6859      	ldr	r1, [r3, #4]
 80218cc:	2900      	cmp	r1, #0
 80218ce:	f000 813d 	beq.w	8021b4c <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x434>
 80218d2:	8858      	ldrh	r0, [r3, #2]
 80218d4:	2800      	cmp	r0, #0
 80218d6:	f000 8139 	beq.w	8021b4c <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x434>
 80218da:	6809      	ldr	r1, [r1, #0]
 80218dc:	edd1 8a00 	vldr	s17, [r1]
 80218e0:	9912      	ldr	r1, [sp, #72]	@ 0x48
 80218e2:	f8db 0018 	ldr.w	r0, [fp, #24]
 80218e6:	6989      	ldr	r1, [r1, #24]
 80218e8:	6880      	ldr	r0, [r0, #8]
 80218ea:	6889      	ldr	r1, [r1, #8]
 80218ec:	f8d8 e018 	ldr.w	lr, [r8, #24]
 80218f0:	912d      	str	r1, [sp, #180]	@ 0xb4
 80218f2:	f89a 1041 	ldrb.w	r1, [sl, #65]	@ 0x41
 80218f6:	901b      	str	r0, [sp, #108]	@ 0x6c
 80218f8:	912b      	str	r1, [sp, #172]	@ 0xac
 80218fa:	f8de 0008 	ldr.w	r0, [lr, #8]
 80218fe:	991f      	ldr	r1, [sp, #124]	@ 0x7c
 8021900:	902c      	str	r0, [sp, #176]	@ 0xb0
 8021902:	b121      	cbz	r1, 802190e <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x1f6>
 8021904:	6849      	ldr	r1, [r1, #4]
 8021906:	911f      	str	r1, [sp, #124]	@ 0x7c
 8021908:	b109      	cbz	r1, 802190e <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x1f6>
 802190a:	6809      	ldr	r1, [r1, #0]
 802190c:	911f      	str	r1, [sp, #124]	@ 0x7c
 802190e:	2a00      	cmp	r2, #0
 8021910:	f000 8136 	beq.w	8021b80 <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x468>
 8021914:	6851      	ldr	r1, [r2, #4]
 8021916:	2900      	cmp	r1, #0
 8021918:	f000 813d 	beq.w	8021b96 <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x47e>
 802191c:	8852      	ldrh	r2, [r2, #2]
 802191e:	2a00      	cmp	r2, #0
 8021920:	f000 812e 	beq.w	8021b80 <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x468>
 8021924:	684a      	ldr	r2, [r1, #4]
 8021926:	f992 2000 	ldrsb.w	r2, [r2]
 802192a:	9228      	str	r2, [sp, #160]	@ 0xa0
 802192c:	2b00      	cmp	r3, #0
 802192e:	f000 8125 	beq.w	8021b7c <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x464>
 8021932:	685a      	ldr	r2, [r3, #4]
 8021934:	2a00      	cmp	r2, #0
 8021936:	f000 8135 	beq.w	8021ba4 <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x48c>
 802193a:	885b      	ldrh	r3, [r3, #2]
 802193c:	2b00      	cmp	r3, #0
 802193e:	f000 811d 	beq.w	8021b7c <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x464>
 8021942:	6853      	ldr	r3, [r2, #4]
 8021944:	f993 3000 	ldrsb.w	r3, [r3]
 8021948:	9329      	str	r3, [sp, #164]	@ 0xa4
 802194a:	9b17      	ldr	r3, [sp, #92]	@ 0x5c
 802194c:	2b00      	cmp	r3, #0
 802194e:	f000 80f1 	beq.w	8021b34 <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x41c>
 8021952:	f8bd 2050 	ldrh.w	r2, [sp, #80]	@ 0x50
 8021956:	f04f 0b00 	mov.w	fp, #0
 802195a:	f8bd 3044 	ldrh.w	r3, [sp, #68]	@ 0x44
 802195e:	fb0c f202 	mul.w	r2, ip, r2
 8021962:	f8dd 8040 	ldr.w	r8, [sp, #64]	@ 0x40
 8021966:	9412      	str	r4, [sp, #72]	@ 0x48
 8021968:	921d      	str	r2, [sp, #116]	@ 0x74
 802196a:	9a16      	ldr	r2, [sp, #88]	@ 0x58
 802196c:	f8cd b050 	str.w	fp, [sp, #80]	@ 0x50
 8021970:	fb02 f303 	mul.w	r3, r2, r3
 8021974:	932f      	str	r3, [sp, #188]	@ 0xbc
 8021976:	b293      	uxth	r3, r2
 8021978:	ee09 3a90 	vmov	s19, r3
 802197c:	fa1f f38c 	uxth.w	r3, ip
 8021980:	9319      	str	r3, [sp, #100]	@ 0x64
 8021982:	f9bd 3060 	ldrsh.w	r3, [sp, #96]	@ 0x60
 8021986:	9316      	str	r3, [sp, #88]	@ 0x58
 8021988:	e07a      	b.n	8021a80 <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x368>
 802198a:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 802198c:	2b00      	cmp	r3, #0
 802198e:	da18      	bge.n	80219c2 <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x2aa>
 8021990:	9b1d      	ldr	r3, [sp, #116]	@ 0x74
 8021992:	e9d6 1202 	ldrd	r1, r2, [r6, #8]
 8021996:	fb03 1314 	mls	r3, r3, r4, r1
 802199a:	429a      	cmp	r2, r3
 802199c:	d901      	bls.n	80219a2 <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x28a>
 802199e:	6870      	ldr	r0, [r6, #4]
 80219a0:	4403      	add	r3, r0
 80219a2:	429a      	cmp	r2, r3
 80219a4:	d203      	bcs.n	80219ae <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x296>
 80219a6:	9816      	ldr	r0, [sp, #88]	@ 0x58
 80219a8:	42a0      	cmp	r0, r4
 80219aa:	f040 80d5 	bne.w	8021b58 <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x440>
 80219ae:	9b14      	ldr	r3, [sp, #80]	@ 0x50
 80219b0:	b2a4      	uxth	r4, r4
 80219b2:	9a18      	ldr	r2, [sp, #96]	@ 0x60
 80219b4:	4413      	add	r3, r2
 80219b6:	9a13      	ldr	r2, [sp, #76]	@ 0x4c
 80219b8:	1b1b      	subs	r3, r3, r4
 80219ba:	4414      	add	r4, r2
 80219bc:	b21b      	sxth	r3, r3
 80219be:	b224      	sxth	r4, r4
 80219c0:	9314      	str	r3, [sp, #80]	@ 0x50
 80219c2:	9b16      	ldr	r3, [sp, #88]	@ 0x58
 80219c4:	42a3      	cmp	r3, r4
 80219c6:	dc33      	bgt.n	8021a30 <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x318>
 80219c8:	9b15      	ldr	r3, [sp, #84]	@ 0x54
 80219ca:	2201      	movs	r2, #1
 80219cc:	9914      	ldr	r1, [sp, #80]	@ 0x50
 80219ce:	a83d      	add	r0, sp, #244	@ 0xf4
 80219d0:	9308      	str	r3, [sp, #32]
 80219d2:	4493      	add	fp, r2
 80219d4:	f8bd 304c 	ldrh.w	r3, [sp, #76]	@ 0x4c
 80219d8:	9207      	str	r2, [sp, #28]
 80219da:	1ae4      	subs	r4, r4, r3
 80219dc:	9305      	str	r3, [sp, #20]
 80219de:	f8bd 3048 	ldrh.w	r3, [sp, #72]	@ 0x48
 80219e2:	f8bd 2060 	ldrh.w	r2, [sp, #96]	@ 0x60
 80219e6:	b224      	sxth	r4, r4
 80219e8:	9303      	str	r3, [sp, #12]
 80219ea:	f8bd 3090 	ldrh.w	r3, [sp, #144]	@ 0x90
 80219ee:	9201      	str	r2, [sp, #4]
 80219f0:	1a52      	subs	r2, r2, r1
 80219f2:	9306      	str	r3, [sp, #24]
 80219f4:	f8bd 3098 	ldrh.w	r3, [sp, #152]	@ 0x98
 80219f8:	b292      	uxth	r2, r2
 80219fa:	9919      	ldr	r1, [sp, #100]	@ 0x64
 80219fc:	9304      	str	r3, [sp, #16]
 80219fe:	f8bd 309c 	ldrh.w	r3, [sp, #156]	@ 0x9c
 8021a02:	9f22      	ldr	r7, [sp, #136]	@ 0x88
 8021a04:	9302      	str	r3, [sp, #8]
 8021a06:	f8bd 3094 	ldrh.w	r3, [sp, #148]	@ 0x94
 8021a0a:	9300      	str	r3, [sp, #0]
 8021a0c:	ee19 3a10 	vmov	r3, s18
 8021a10:	47b8      	blx	r7
 8021a12:	9a12      	ldr	r2, [sp, #72]	@ 0x48
 8021a14:	f9bd 304c 	ldrsh.w	r3, [sp, #76]	@ 0x4c
 8021a18:	9920      	ldr	r1, [sp, #128]	@ 0x80
 8021a1a:	1ad3      	subs	r3, r2, r3
 8021a1c:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 8021a20:	b21a      	sxth	r2, r3
 8021a22:	9b15      	ldr	r3, [sp, #84]	@ 0x54
 8021a24:	695b      	ldr	r3, [r3, #20]
 8021a26:	9212      	str	r2, [sp, #72]	@ 0x48
 8021a28:	68da      	ldr	r2, [r3, #12]
 8021a2a:	688b      	ldr	r3, [r1, #8]
 8021a2c:	4413      	add	r3, r2
 8021a2e:	608b      	str	r3, [r1, #8]
 8021a30:	f8d9 3014 	ldr.w	r3, [r9, #20]
 8021a34:	68da      	ldr	r2, [r3, #12]
 8021a36:	68ab      	ldr	r3, [r5, #8]
 8021a38:	4413      	add	r3, r2
 8021a3a:	60ab      	str	r3, [r5, #8]
 8021a3c:	f8da 2024 	ldr.w	r2, [sl, #36]	@ 0x24
 8021a40:	b132      	cbz	r2, 8021a50 <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x338>
 8021a42:	f8d8 3014 	ldr.w	r3, [r8, #20]
 8021a46:	68da      	ldr	r2, [r3, #12]
 8021a48:	68b3      	ldr	r3, [r6, #8]
 8021a4a:	4413      	add	r3, r2
 8021a4c:	60b3      	str	r3, [r6, #8]
 8021a4e:	68ab      	ldr	r3, [r5, #8]
 8021a50:	68ea      	ldr	r2, [r5, #12]
 8021a52:	4648      	mov	r0, r9
 8021a54:	9311      	str	r3, [sp, #68]	@ 0x44
 8021a56:	9210      	str	r2, [sp, #64]	@ 0x40
 8021a58:	f00f fac8 	bl	8030fec <get_tensor_byte_size>
 8021a5c:	9a10      	ldr	r2, [sp, #64]	@ 0x40
 8021a5e:	9b11      	ldr	r3, [sp, #68]	@ 0x44
 8021a60:	4410      	add	r0, r2
 8021a62:	4283      	cmp	r3, r0
 8021a64:	d306      	bcc.n	8021a74 <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x35c>
 8021a66:	68eb      	ldr	r3, [r5, #12]
 8021a68:	60ab      	str	r3, [r5, #8]
 8021a6a:	f8da 3024 	ldr.w	r3, [sl, #36]	@ 0x24
 8021a6e:	b10b      	cbz	r3, 8021a74 <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x35c>
 8021a70:	68f3      	ldr	r3, [r6, #12]
 8021a72:	60b3      	str	r3, [r6, #8]
 8021a74:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 8021a76:	3b01      	subs	r3, #1
 8021a78:	930f      	str	r3, [sp, #60]	@ 0x3c
 8021a7a:	9b17      	ldr	r3, [sp, #92]	@ 0x5c
 8021a7c:	459b      	cmp	fp, r3
 8021a7e:	d259      	bcs.n	8021b34 <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x41c>
 8021a80:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 8021a82:	3301      	adds	r3, #1
 8021a84:	2b00      	cmp	r3, #0
 8021a86:	dd80      	ble.n	802198a <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x272>
 8021a88:	9b21      	ldr	r3, [sp, #132]	@ 0x84
 8021a8a:	68aa      	ldr	r2, [r5, #8]
 8021a8c:	699b      	ldr	r3, [r3, #24]
 8021a8e:	9210      	str	r2, [sp, #64]	@ 0x40
 8021a90:	e9d3 0100 	ldrd	r0, r1, [r3]
 8021a94:	f00f fa7c 	bl	8030f90 <ai_array_get_byte_size>
 8021a98:	9b2a      	ldr	r3, [sp, #168]	@ 0xa8
 8021a9a:	9a10      	ldr	r2, [sp, #64]	@ 0x40
 8021a9c:	eef0 0a68 	vmov.f32	s1, s17
 8021aa0:	930c      	str	r3, [sp, #48]	@ 0x30
 8021aa2:	2301      	movs	r3, #1
 8021aa4:	9f1a      	ldr	r7, [sp, #104]	@ 0x68
 8021aa6:	eeb0 0a48 	vmov.f32	s0, s16
 8021aaa:	9207      	str	r2, [sp, #28]
 8021aac:	ee19 1a90 	vmov	r1, s19
 8021ab0:	900b      	str	r0, [sp, #44]	@ 0x2c
 8021ab2:	b2ba      	uxth	r2, r7
 8021ab4:	981b      	ldr	r0, [sp, #108]	@ 0x6c
 8021ab6:	ed8d 9a01 	vstr	s18, [sp, #4]
 8021aba:	e9cd 3309 	strd	r3, r3, [sp, #36]	@ 0x24
 8021abe:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 8021ac0:	9308      	str	r3, [sp, #32]
 8021ac2:	9b2b      	ldr	r3, [sp, #172]	@ 0xac
 8021ac4:	9306      	str	r3, [sp, #24]
 8021ac6:	9b1f      	ldr	r3, [sp, #124]	@ 0x7c
 8021ac8:	9305      	str	r3, [sp, #20]
 8021aca:	9b29      	ldr	r3, [sp, #164]	@ 0xa4
 8021acc:	9304      	str	r3, [sp, #16]
 8021ace:	9b28      	ldr	r3, [sp, #160]	@ 0xa0
 8021ad0:	9303      	str	r3, [sp, #12]
 8021ad2:	9b2d      	ldr	r3, [sp, #180]	@ 0xb4
 8021ad4:	9302      	str	r3, [sp, #8]
 8021ad6:	9b2c      	ldr	r3, [sp, #176]	@ 0xb0
 8021ad8:	9300      	str	r3, [sp, #0]
 8021ada:	ee1a 3a10 	vmov	r3, s20
 8021ade:	f000 ffc1 	bl	8022a64 <forward_lite_conv2d_deep_3x3_sssa8_ch>
 8021ae2:	9b1c      	ldr	r3, [sp, #112]	@ 0x70
 8021ae4:	2b01      	cmp	r3, #1
 8021ae6:	d021      	beq.n	8021b2c <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x414>
 8021ae8:	3b01      	subs	r3, #1
 8021aea:	463a      	mov	r2, r7
 8021aec:	429f      	cmp	r7, r3
 8021aee:	931c      	str	r3, [sp, #112]	@ 0x70
 8021af0:	bf28      	it	cs
 8021af2:	461a      	movcs	r2, r3
 8021af4:	921a      	str	r2, [sp, #104]	@ 0x68
 8021af6:	9b1e      	ldr	r3, [sp, #120]	@ 0x78
 8021af8:	b9a3      	cbnz	r3, 8021b24 <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x40c>
 8021afa:	9b1b      	ldr	r3, [sp, #108]	@ 0x6c
 8021afc:	9a2f      	ldr	r2, [sp, #188]	@ 0xbc
 8021afe:	4413      	add	r3, r2
 8021b00:	931b      	str	r3, [sp, #108]	@ 0x6c
 8021b02:	3401      	adds	r4, #1
 8021b04:	9b23      	ldr	r3, [sp, #140]	@ 0x8c
 8021b06:	9a1d      	ldr	r2, [sp, #116]	@ 0x74
 8021b08:	4649      	mov	r1, r9
 8021b0a:	4640      	mov	r0, r8
 8021b0c:	9f2e      	ldr	r7, [sp, #184]	@ 0xb8
 8021b0e:	b224      	sxth	r4, r4
 8021b10:	47b8      	blx	r7
 8021b12:	e756      	b.n	80219c2 <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x2aa>
 8021b14:	2300      	movs	r3, #0
 8021b16:	685b      	ldr	r3, [r3, #4]
 8021b18:	deff      	udf	#255	@ 0xff
 8021b1a:	685b      	ldr	r3, [r3, #4]
 8021b1c:	deff      	udf	#255	@ 0xff
 8021b1e:	6841      	ldr	r1, [r0, #4]
 8021b20:	9112      	str	r1, [sp, #72]	@ 0x48
 8021b22:	e623      	b.n	802176c <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x54>
 8021b24:	3b01      	subs	r3, #1
 8021b26:	b29b      	uxth	r3, r3
 8021b28:	931e      	str	r3, [sp, #120]	@ 0x78
 8021b2a:	e7ea      	b.n	8021b02 <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x3ea>
 8021b2c:	2300      	movs	r3, #0
 8021b2e:	931a      	str	r3, [sp, #104]	@ 0x68
 8021b30:	931c      	str	r3, [sp, #112]	@ 0x70
 8021b32:	e7e0      	b.n	8021af6 <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x3de>
 8021b34:	68eb      	ldr	r3, [r5, #12]
 8021b36:	9a20      	ldr	r2, [sp, #128]	@ 0x80
 8021b38:	60ab      	str	r3, [r5, #8]
 8021b3a:	68f3      	ldr	r3, [r6, #12]
 8021b3c:	60b3      	str	r3, [r6, #8]
 8021b3e:	68d3      	ldr	r3, [r2, #12]
 8021b40:	6093      	str	r3, [r2, #8]
 8021b42:	b045      	add	sp, #276	@ 0x114
 8021b44:	ecbd 8b06 	vpop	{d8-d10}
 8021b48:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8021b4c:	eddf 8a1c 	vldr	s17, [pc, #112]	@ 8021bc0 <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x4a8>
 8021b50:	e6c6      	b.n	80218e0 <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x1c8>
 8021b52:	ed9f 8a1b 	vldr	s16, [pc, #108]	@ 8021bc0 <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x4a8>
 8021b56:	e6b5      	b.n	80218c4 <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x1ac>
 8021b58:	6870      	ldr	r0, [r6, #4]
 8021b5a:	4402      	add	r2, r0
 8021b5c:	4293      	cmp	r3, r2
 8021b5e:	f4bf af26 	bcs.w	80219ae <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x296>
 8021b62:	3901      	subs	r1, #1
 8021b64:	9f0f      	ldr	r7, [sp, #60]	@ 0x3c
 8021b66:	f813 2b01 	ldrb.w	r2, [r3], #1
 8021b6a:	f801 2f01 	strb.w	r2, [r1, #1]!
 8021b6e:	68f2      	ldr	r2, [r6, #12]
 8021b70:	6870      	ldr	r0, [r6, #4]
 8021b72:	4402      	add	r2, r0
 8021b74:	4293      	cmp	r3, r2
 8021b76:	d3f6      	bcc.n	8021b66 <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x44e>
 8021b78:	970f      	str	r7, [sp, #60]	@ 0x3c
 8021b7a:	e718      	b.n	80219ae <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x296>
 8021b7c:	9329      	str	r3, [sp, #164]	@ 0xa4
 8021b7e:	e6e4      	b.n	802194a <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x232>
 8021b80:	9228      	str	r2, [sp, #160]	@ 0xa0
 8021b82:	e6d3      	b.n	802192c <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x214>
 8021b84:	f8da 0020 	ldr.w	r0, [sl, #32]
 8021b88:	9023      	str	r0, [sp, #140]	@ 0x8c
 8021b8a:	2800      	cmp	r0, #0
 8021b8c:	f43f ae3f 	beq.w	802180e <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0xf6>
 8021b90:	6880      	ldr	r0, [r0, #8]
 8021b92:	9023      	str	r0, [sp, #140]	@ 0x8c
 8021b94:	e63b      	b.n	802180e <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0xf6>
 8021b96:	9128      	str	r1, [sp, #160]	@ 0xa0
 8021b98:	e6c8      	b.n	802192c <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x214>
 8021b9a:	4b0a      	ldr	r3, [pc, #40]	@ (8021bc4 <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x4ac>)
 8021b9c:	f8cd 9040 	str.w	r9, [sp, #64]	@ 0x40
 8021ba0:	932e      	str	r3, [sp, #184]	@ 0xb8
 8021ba2:	e5f6      	b.n	8021792 <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x7a>
 8021ba4:	9229      	str	r2, [sp, #164]	@ 0xa4
 8021ba6:	e6d0      	b.n	802194a <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x232>
 8021ba8:	4680      	mov	r8, r0
 8021baa:	9012      	str	r0, [sp, #72]	@ 0x48
 8021bac:	e5de      	b.n	802176c <forward_conv2d_deep_3x3_sssa8_ch_nl_pool+0x54>
 8021bae:	68db      	ldr	r3, [r3, #12]
 8021bb0:	deff      	udf	#255	@ 0xff
 8021bb2:	2300      	movs	r3, #0
 8021bb4:	685b      	ldr	r3, [r3, #4]
 8021bb6:	deff      	udf	#255	@ 0xff
 8021bb8:	2300      	movs	r3, #0
 8021bba:	685b      	ldr	r3, [r3, #4]
 8021bbc:	deff      	udf	#255	@ 0xff
 8021bbe:	bf00      	nop
 8021bc0:	00000000 	.word	0x00000000
 8021bc4:	0802157d 	.word	0x0802157d

08021bc8 <forward_conv2d_sssa8_ch_nl_pool>:
 8021bc8:	6982      	ldr	r2, [r0, #24]
 8021bca:	8813      	ldrh	r3, [r2, #0]
 8021bcc:	2b00      	cmp	r3, #0
 8021bce:	f000 8230 	beq.w	8022032 <forward_conv2d_sssa8_ch_nl_pool+0x46a>
 8021bd2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8021bd6:	ed2d 8b06 	vpush	{d8-d10}
 8021bda:	6852      	ldr	r2, [r2, #4]
 8021bdc:	b0d1      	sub	sp, #324	@ 0x144
 8021bde:	4681      	mov	r9, r0
 8021be0:	f8d2 a004 	ldr.w	sl, [r2, #4]
 8021be4:	f1ba 0f00 	cmp.w	sl, #0
 8021be8:	d001      	beq.n	8021bee <forward_conv2d_sssa8_ch_nl_pool+0x26>
 8021bea:	f8da a000 	ldr.w	sl, [sl]
 8021bee:	2b01      	cmp	r3, #1
 8021bf0:	f000 8276 	beq.w	80220e0 <forward_conv2d_sssa8_ch_nl_pool+0x518>
 8021bf4:	6911      	ldr	r1, [r2, #16]
 8021bf6:	911c      	str	r1, [sp, #112]	@ 0x70
 8021bf8:	b109      	cbz	r1, 8021bfe <forward_conv2d_sssa8_ch_nl_pool+0x36>
 8021bfa:	6809      	ldr	r1, [r1, #0]
 8021bfc:	911c      	str	r1, [sp, #112]	@ 0x70
 8021bfe:	2b02      	cmp	r3, #2
 8021c00:	f000 8214 	beq.w	802202c <forward_conv2d_sssa8_ch_nl_pool+0x464>
 8021c04:	69d1      	ldr	r1, [r2, #28]
 8021c06:	2900      	cmp	r1, #0
 8021c08:	f000 8265 	beq.w	80220d6 <forward_conv2d_sssa8_ch_nl_pool+0x50e>
 8021c0c:	8b10      	ldrh	r0, [r2, #24]
 8021c0e:	680c      	ldr	r4, [r1, #0]
 8021c10:	2801      	cmp	r0, #1
 8021c12:	9415      	str	r4, [sp, #84]	@ 0x54
 8021c14:	f200 820f 	bhi.w	8022036 <forward_conv2d_sssa8_ch_nl_pool+0x46e>
 8021c18:	2000      	movs	r0, #0
 8021c1a:	9018      	str	r0, [sp, #96]	@ 0x60
 8021c1c:	2b03      	cmp	r3, #3
 8021c1e:	f000 8262 	beq.w	80220e6 <forward_conv2d_sssa8_ch_nl_pool+0x51e>
 8021c22:	6a93      	ldr	r3, [r2, #40]	@ 0x28
 8021c24:	2b00      	cmp	r3, #0
 8021c26:	f000 8259 	beq.w	80220dc <forward_conv2d_sssa8_ch_nl_pool+0x514>
 8021c2a:	6818      	ldr	r0, [r3, #0]
 8021c2c:	f8d9 2024 	ldr.w	r2, [r9, #36]	@ 0x24
 8021c30:	f8d3 8004 	ldr.w	r8, [r3, #4]
 8021c34:	9027      	str	r0, [sp, #156]	@ 0x9c
 8021c36:	2a00      	cmp	r2, #0
 8021c38:	f000 8247 	beq.w	80220ca <forward_conv2d_sssa8_ch_nl_pool+0x502>
 8021c3c:	f8d3 b008 	ldr.w	fp, [r3, #8]
 8021c40:	9230      	str	r2, [sp, #192]	@ 0xc0
 8021c42:	f8d8 200c 	ldr.w	r2, [r8, #12]
 8021c46:	f8da 500c 	ldr.w	r5, [sl, #12]
 8021c4a:	6852      	ldr	r2, [r2, #4]
 8021c4c:	9c15      	ldr	r4, [sp, #84]	@ 0x54
 8021c4e:	4616      	mov	r6, r2
 8021c50:	981c      	ldr	r0, [sp, #112]	@ 0x70
 8021c52:	f8d4 c00c 	ldr.w	ip, [r4, #12]
 8021c56:	b2b6      	uxth	r6, r6
 8021c58:	686c      	ldr	r4, [r5, #4]
 8021c5a:	68c0      	ldr	r0, [r0, #12]
 8021c5c:	9416      	str	r4, [sp, #88]	@ 0x58
 8021c5e:	9622      	str	r6, [sp, #136]	@ 0x88
 8021c60:	f8bd 6058 	ldrh.w	r6, [sp, #88]	@ 0x58
 8021c64:	f8d9 303c 	ldr.w	r3, [r9, #60]	@ 0x3c
 8021c68:	ee0a 6a90 	vmov	s21, r6
 8021c6c:	68c6      	ldr	r6, [r0, #12]
 8021c6e:	6880      	ldr	r0, [r0, #8]
 8021c70:	f8d9 402c 	ldr.w	r4, [r9, #44]	@ 0x2c
 8021c74:	9036      	str	r0, [sp, #216]	@ 0xd8
 8021c76:	921b      	str	r2, [sp, #108]	@ 0x6c
 8021c78:	681a      	ldr	r2, [r3, #0]
 8021c7a:	f8d9 7058 	ldr.w	r7, [r9, #88]	@ 0x58
 8021c7e:	9621      	str	r6, [sp, #132]	@ 0x84
 8021c80:	e9d5 5002 	ldrd	r5, r0, [r5, #8]
 8021c84:	951d      	str	r5, [sp, #116]	@ 0x74
 8021c86:	f8b9 5028 	ldrh.w	r5, [r9, #40]	@ 0x28
 8021c8a:	9531      	str	r5, [sp, #196]	@ 0xc4
 8021c8c:	b2a5      	uxth	r5, r4
 8021c8e:	9532      	str	r5, [sp, #200]	@ 0xc8
 8021c90:	b295      	uxth	r5, r2
 8021c92:	9517      	str	r5, [sp, #92]	@ 0x5c
 8021c94:	889d      	ldrh	r5, [r3, #4]
 8021c96:	689b      	ldr	r3, [r3, #8]
 8021c98:	9533      	str	r5, [sp, #204]	@ 0xcc
 8021c9a:	f8dc 5008 	ldr.w	r5, [ip, #8]
 8021c9e:	9526      	str	r5, [sp, #152]	@ 0x98
 8021ca0:	f8dc 5004 	ldr.w	r5, [ip, #4]
 8021ca4:	9534      	str	r5, [sp, #208]	@ 0xd0
 8021ca6:	f8d9 5044 	ldr.w	r5, [r9, #68]	@ 0x44
 8021caa:	9537      	str	r5, [sp, #220]	@ 0xdc
 8021cac:	f8d9 504c 	ldr.w	r5, [r9, #76]	@ 0x4c
 8021cb0:	9538      	str	r5, [sp, #224]	@ 0xe0
 8021cb2:	f8d9 5050 	ldr.w	r5, [r9, #80]	@ 0x50
 8021cb6:	951a      	str	r5, [sp, #104]	@ 0x68
 8021cb8:	683d      	ldr	r5, [r7, #0]
 8021cba:	9528      	str	r5, [sp, #160]	@ 0xa0
 8021cbc:	687d      	ldr	r5, [r7, #4]
 8021cbe:	9539      	str	r5, [sp, #228]	@ 0xe4
 8021cc0:	2900      	cmp	r1, #0
 8021cc2:	f000 81f5 	beq.w	80220b0 <forward_conv2d_sssa8_ch_nl_pool+0x4e8>
 8021cc6:	6889      	ldr	r1, [r1, #8]
 8021cc8:	2900      	cmp	r1, #0
 8021cca:	f000 81f1 	beq.w	80220b0 <forward_conv2d_sssa8_ch_nl_pool+0x4e8>
 8021cce:	698d      	ldr	r5, [r1, #24]
 8021cd0:	2d00      	cmp	r5, #0
 8021cd2:	bf08      	it	eq
 8021cd4:	4629      	moveq	r1, r5
 8021cd6:	ee09 1a90 	vmov	s19, r1
 8021cda:	b292      	uxth	r2, r2
 8021cdc:	f8db 6018 	ldr.w	r6, [fp, #24]
 8021ce0:	b2a1      	uxth	r1, r4
 8021ce2:	f8d8 5018 	ldr.w	r5, [r8, #24]
 8021ce6:	fa12 f783 	uxtah	r7, r2, r3
 8021cea:	1813      	adds	r3, r2, r0
 8021cec:	aa41      	add	r2, sp, #260	@ 0x104
 8021cee:	9124      	str	r1, [sp, #144]	@ 0x90
 8021cf0:	4407      	add	r7, r0
 8021cf2:	931e      	str	r3, [sp, #120]	@ 0x78
 8021cf4:	9b26      	ldr	r3, [sp, #152]	@ 0x98
 8021cf6:	f10d 0cf4 	add.w	ip, sp, #244	@ 0xf4
 8021cfa:	924e      	str	r2, [sp, #312]	@ 0x138
 8021cfc:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
 8021d00:	1aff      	subs	r7, r7, r3
 8021d02:	ac45      	add	r4, sp, #276	@ 0x114
 8021d04:	a849      	add	r0, sp, #292	@ 0x124
 8021d06:	f8cd c130 	str.w	ip, [sp, #304]	@ 0x130
 8021d0a:	fbb7 f3f1 	udiv	r3, r7, r1
 8021d0e:	9f1c      	ldr	r7, [sp, #112]	@ 0x70
 8021d10:	f240 4101 	movw	r1, #1025	@ 0x401
 8021d14:	9314      	str	r3, [sp, #80]	@ 0x50
 8021d16:	2300      	movs	r3, #0
 8021d18:	69bf      	ldr	r7, [r7, #24]
 8021d1a:	9349      	str	r3, [sp, #292]	@ 0x124
 8021d1c:	933d      	str	r3, [sp, #244]	@ 0xf4
 8021d1e:	9341      	str	r3, [sp, #260]	@ 0x104
 8021d20:	9340      	str	r3, [sp, #256]	@ 0x100
 8021d22:	9344      	str	r3, [sp, #272]	@ 0x110
 8021d24:	934f      	str	r3, [sp, #316]	@ 0x13c
 8021d26:	9729      	str	r7, [sp, #164]	@ 0xa4
 8021d28:	e9cd 333e 	strd	r3, r3, [sp, #248]	@ 0xf8
 8021d2c:	e9cd 3342 	strd	r3, r3, [sp, #264]	@ 0x108
 8021d30:	f8d9 3048 	ldr.w	r3, [r9, #72]	@ 0x48
 8021d34:	e9cd 214a 	strd	r2, r1, [sp, #296]	@ 0x128
 8021d38:	f240 4102 	movw	r1, #1026	@ 0x402
 8021d3c:	9323      	str	r3, [sp, #140]	@ 0x8c
 8021d3e:	f8d9 305c 	ldr.w	r3, [r9, #92]	@ 0x5c
 8021d42:	914d      	str	r1, [sp, #308]	@ 0x134
 8021d44:	4659      	mov	r1, fp
 8021d46:	9335      	str	r3, [sp, #212]	@ 0xd4
 8021d48:	f00f f966 	bl	8031018 <core_tensor_clone>
 8021d4c:	4631      	mov	r1, r6
 8021d4e:	4620      	mov	r0, r4
 8021d50:	f00f f994 	bl	803107c <core_array_clone>
 8021d54:	944f      	str	r4, [sp, #316]	@ 0x13c
 8021d56:	f8d8 300c 	ldr.w	r3, [r8, #12]
 8021d5a:	9915      	ldr	r1, [sp, #84]	@ 0x54
 8021d5c:	f8d3 c008 	ldr.w	ip, [r3, #8]
 8021d60:	9b27      	ldr	r3, [sp, #156]	@ 0x9c
 8021d62:	6809      	ldr	r1, [r1, #0]
 8021d64:	699b      	ldr	r3, [r3, #24]
 8021d66:	f8da 2000 	ldr.w	r2, [sl]
 8021d6a:	689b      	ldr	r3, [r3, #8]
 8021d6c:	f9bd 40a0 	ldrsh.w	r4, [sp, #160]	@ 0xa0
 8021d70:	932c      	str	r3, [sp, #176]	@ 0xb0
 8021d72:	9125      	str	r1, [sp, #148]	@ 0x94
 8021d74:	f8d8 3000 	ldr.w	r3, [r8]
 8021d78:	2a00      	cmp	r2, #0
 8021d7a:	f000 8181 	beq.w	8022080 <forward_conv2d_sssa8_ch_nl_pool+0x4b8>
 8021d7e:	6851      	ldr	r1, [r2, #4]
 8021d80:	2900      	cmp	r1, #0
 8021d82:	f000 817d 	beq.w	8022080 <forward_conv2d_sssa8_ch_nl_pool+0x4b8>
 8021d86:	8850      	ldrh	r0, [r2, #2]
 8021d88:	2800      	cmp	r0, #0
 8021d8a:	f000 8179 	beq.w	8022080 <forward_conv2d_sssa8_ch_nl_pool+0x4b8>
 8021d8e:	6809      	ldr	r1, [r1, #0]
 8021d90:	ed91 8a00 	vldr	s16, [r1]
 8021d94:	2b00      	cmp	r3, #0
 8021d96:	f000 8170 	beq.w	802207a <forward_conv2d_sssa8_ch_nl_pool+0x4b2>
 8021d9a:	6859      	ldr	r1, [r3, #4]
 8021d9c:	2900      	cmp	r1, #0
 8021d9e:	f000 816c 	beq.w	802207a <forward_conv2d_sssa8_ch_nl_pool+0x4b2>
 8021da2:	8858      	ldrh	r0, [r3, #2]
 8021da4:	2800      	cmp	r0, #0
 8021da6:	f000 8168 	beq.w	802207a <forward_conv2d_sssa8_ch_nl_pool+0x4b2>
 8021daa:	6809      	ldr	r1, [r1, #0]
 8021dac:	edd1 8a00 	vldr	s17, [r1]
 8021db0:	9915      	ldr	r1, [sp, #84]	@ 0x54
 8021db2:	f8da 0018 	ldr.w	r0, [sl, #24]
 8021db6:	f8d1 e018 	ldr.w	lr, [r1, #24]
 8021dba:	9918      	ldr	r1, [sp, #96]	@ 0x60
 8021dbc:	6880      	ldr	r0, [r0, #8]
 8021dbe:	6989      	ldr	r1, [r1, #24]
 8021dc0:	9019      	str	r0, [sp, #100]	@ 0x64
 8021dc2:	6889      	ldr	r1, [r1, #8]
 8021dc4:	f8de 0008 	ldr.w	r0, [lr, #8]
 8021dc8:	912f      	str	r1, [sp, #188]	@ 0xbc
 8021dca:	f899 1041 	ldrb.w	r1, [r9, #65]	@ 0x41
 8021dce:	902e      	str	r0, [sp, #184]	@ 0xb8
 8021dd0:	912d      	str	r1, [sp, #180]	@ 0xb4
 8021dd2:	9925      	ldr	r1, [sp, #148]	@ 0x94
 8021dd4:	b121      	cbz	r1, 8021de0 <forward_conv2d_sssa8_ch_nl_pool+0x218>
 8021dd6:	6849      	ldr	r1, [r1, #4]
 8021dd8:	9125      	str	r1, [sp, #148]	@ 0x94
 8021dda:	b109      	cbz	r1, 8021de0 <forward_conv2d_sssa8_ch_nl_pool+0x218>
 8021ddc:	6809      	ldr	r1, [r1, #0]
 8021dde:	9125      	str	r1, [sp, #148]	@ 0x94
 8021de0:	2a00      	cmp	r2, #0
 8021de2:	f000 8163 	beq.w	80220ac <forward_conv2d_sssa8_ch_nl_pool+0x4e4>
 8021de6:	6851      	ldr	r1, [r2, #4]
 8021de8:	2900      	cmp	r1, #0
 8021dea:	f000 816c 	beq.w	80220c6 <forward_conv2d_sssa8_ch_nl_pool+0x4fe>
 8021dee:	8852      	ldrh	r2, [r2, #2]
 8021df0:	2a00      	cmp	r2, #0
 8021df2:	f000 815b 	beq.w	80220ac <forward_conv2d_sssa8_ch_nl_pool+0x4e4>
 8021df6:	684a      	ldr	r2, [r1, #4]
 8021df8:	f992 2000 	ldrsb.w	r2, [r2]
 8021dfc:	922a      	str	r2, [sp, #168]	@ 0xa8
 8021dfe:	2b00      	cmp	r3, #0
 8021e00:	f000 8152 	beq.w	80220a8 <forward_conv2d_sssa8_ch_nl_pool+0x4e0>
 8021e04:	685a      	ldr	r2, [r3, #4]
 8021e06:	2a00      	cmp	r2, #0
 8021e08:	f000 8163 	beq.w	80220d2 <forward_conv2d_sssa8_ch_nl_pool+0x50a>
 8021e0c:	885b      	ldrh	r3, [r3, #2]
 8021e0e:	2b00      	cmp	r3, #0
 8021e10:	f000 814a 	beq.w	80220a8 <forward_conv2d_sssa8_ch_nl_pool+0x4e0>
 8021e14:	6853      	ldr	r3, [r2, #4]
 8021e16:	f993 3000 	ldrsb.w	r3, [r3]
 8021e1a:	932b      	str	r3, [sp, #172]	@ 0xac
 8021e1c:	9b21      	ldr	r3, [sp, #132]	@ 0x84
 8021e1e:	2b00      	cmp	r3, #0
 8021e20:	f000 811f 	beq.w	8022062 <forward_conv2d_sssa8_ch_nl_pool+0x49a>
 8021e24:	f8bd 206c 	ldrh.w	r2, [sp, #108]	@ 0x6c
 8021e28:	f04f 0a00 	mov.w	sl, #0
 8021e2c:	991d      	ldr	r1, [sp, #116]	@ 0x74
 8021e2e:	fb0c f202 	mul.w	r2, ip, r2
 8021e32:	f8bd 3058 	ldrh.w	r3, [sp, #88]	@ 0x58
 8021e36:	9418      	str	r4, [sp, #96]	@ 0x60
 8021e38:	ee09 2a10 	vmov	s18, r2
 8021e3c:	fa1f f28c 	uxth.w	r2, ip
 8021e40:	f8cd a06c 	str.w	sl, [sp, #108]	@ 0x6c
 8021e44:	9220      	str	r2, [sp, #128]	@ 0x80
 8021e46:	9a24      	ldr	r2, [sp, #144]	@ 0x90
 8021e48:	fb01 f202 	mul.w	r2, r1, r2
 8021e4c:	fb03 f202 	mul.w	r2, r3, r2
 8021e50:	fb01 f303 	mul.w	r3, r1, r3
 8021e54:	923a      	str	r2, [sp, #232]	@ 0xe8
 8021e56:	933b      	str	r3, [sp, #236]	@ 0xec
 8021e58:	b28b      	uxth	r3, r1
 8021e5a:	ee0a 3a10 	vmov	s20, r3
 8021e5e:	f9bd 308c 	ldrsh.w	r3, [sp, #140]	@ 0x8c
 8021e62:	931d      	str	r3, [sp, #116]	@ 0x74
 8021e64:	9b26      	ldr	r3, [sp, #152]	@ 0x98
 8021e66:	931f      	str	r3, [sp, #124]	@ 0x7c
 8021e68:	e0be      	b.n	8021fe8 <forward_conv2d_sssa8_ch_nl_pool+0x420>
 8021e6a:	9b27      	ldr	r3, [sp, #156]	@ 0x9c
 8021e6c:	68aa      	ldr	r2, [r5, #8]
 8021e6e:	699b      	ldr	r3, [r3, #24]
 8021e70:	9215      	str	r2, [sp, #84]	@ 0x54
 8021e72:	e9d3 0100 	ldrd	r0, r1, [r3]
 8021e76:	f00f f88b 	bl	8030f90 <ai_array_get_byte_size>
 8021e7a:	9b2d      	ldr	r3, [sp, #180]	@ 0xb4
 8021e7c:	9a15      	ldr	r2, [sp, #84]	@ 0x54
 8021e7e:	eef0 0a68 	vmov.f32	s1, s17
 8021e82:	930c      	str	r3, [sp, #48]	@ 0x30
 8021e84:	eeb0 0a48 	vmov.f32	s0, s16
 8021e88:	9b25      	ldr	r3, [sp, #148]	@ 0x94
 8021e8a:	ee1a 1a10 	vmov	r1, s20
 8021e8e:	920d      	str	r2, [sp, #52]	@ 0x34
 8021e90:	930b      	str	r3, [sp, #44]	@ 0x2c
 8021e92:	9b2b      	ldr	r3, [sp, #172]	@ 0xac
 8021e94:	9011      	str	r0, [sp, #68]	@ 0x44
 8021e96:	930a      	str	r3, [sp, #40]	@ 0x28
 8021e98:	9b2a      	ldr	r3, [sp, #168]	@ 0xa8
 8021e9a:	9309      	str	r3, [sp, #36]	@ 0x24
 8021e9c:	9b2f      	ldr	r3, [sp, #188]	@ 0xbc
 8021e9e:	9308      	str	r3, [sp, #32]
 8021ea0:	9b17      	ldr	r3, [sp, #92]	@ 0x5c
 8021ea2:	9307      	str	r3, [sp, #28]
 8021ea4:	9b33      	ldr	r3, [sp, #204]	@ 0xcc
 8021ea6:	9306      	str	r3, [sp, #24]
 8021ea8:	9b32      	ldr	r3, [sp, #200]	@ 0xc8
 8021eaa:	9305      	str	r3, [sp, #20]
 8021eac:	9b31      	ldr	r3, [sp, #196]	@ 0xc4
 8021eae:	9304      	str	r3, [sp, #16]
 8021eb0:	9b22      	ldr	r3, [sp, #136]	@ 0x88
 8021eb2:	9301      	str	r3, [sp, #4]
 8021eb4:	9b2e      	ldr	r3, [sp, #184]	@ 0xb8
 8021eb6:	9300      	str	r3, [sp, #0]
 8021eb8:	9b2c      	ldr	r3, [sp, #176]	@ 0xb0
 8021eba:	9312      	str	r3, [sp, #72]	@ 0x48
 8021ebc:	2301      	movs	r3, #1
 8021ebe:	930f      	str	r3, [sp, #60]	@ 0x3c
 8021ec0:	9b20      	ldr	r3, [sp, #128]	@ 0x80
 8021ec2:	930e      	str	r3, [sp, #56]	@ 0x38
 8021ec4:	f8bd 3098 	ldrh.w	r3, [sp, #152]	@ 0x98
 8021ec8:	9303      	str	r3, [sp, #12]
 8021eca:	f8bd 30d0 	ldrh.w	r3, [sp, #208]	@ 0xd0
 8021ece:	9f1f      	ldr	r7, [sp, #124]	@ 0x7c
 8021ed0:	9302      	str	r3, [sp, #8]
 8021ed2:	9b28      	ldr	r3, [sp, #160]	@ 0xa0
 8021ed4:	b2ba      	uxth	r2, r7
 8021ed6:	9819      	ldr	r0, [sp, #100]	@ 0x64
 8021ed8:	429c      	cmp	r4, r3
 8021eda:	bf08      	it	eq
 8021edc:	f1ba 0f00 	cmpeq.w	sl, #0
 8021ee0:	bf0c      	ite	eq
 8021ee2:	2301      	moveq	r3, #1
 8021ee4:	2300      	movne	r3, #0
 8021ee6:	9310      	str	r3, [sp, #64]	@ 0x40
 8021ee8:	ee1a 3a90 	vmov	r3, s21
 8021eec:	f000 fe62 	bl	8022bb4 <forward_lite_conv2d_sssa8_ch>
 8021ef0:	9b24      	ldr	r3, [sp, #144]	@ 0x90
 8021ef2:	9a1e      	ldr	r2, [sp, #120]	@ 0x78
 8021ef4:	4293      	cmp	r3, r2
 8021ef6:	f000 80b0 	beq.w	802205a <forward_conv2d_sssa8_ch_nl_pool+0x492>
 8021efa:	1ad3      	subs	r3, r2, r3
 8021efc:	463a      	mov	r2, r7
 8021efe:	429f      	cmp	r7, r3
 8021f00:	931e      	str	r3, [sp, #120]	@ 0x78
 8021f02:	bf28      	it	cs
 8021f04:	461a      	movcs	r2, r3
 8021f06:	921f      	str	r2, [sp, #124]	@ 0x7c
 8021f08:	9b17      	ldr	r3, [sp, #92]	@ 0x5c
 8021f0a:	2b00      	cmp	r3, #0
 8021f0c:	f040 8096 	bne.w	802203c <forward_conv2d_sssa8_ch_nl_pool+0x474>
 8021f10:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 8021f12:	9a3a      	ldr	r2, [sp, #232]	@ 0xe8
 8021f14:	4413      	add	r3, r2
 8021f16:	9319      	str	r3, [sp, #100]	@ 0x64
 8021f18:	3401      	adds	r4, #1
 8021f1a:	ee19 3a90 	vmov	r3, s19
 8021f1e:	ee19 2a10 	vmov	r2, s18
 8021f22:	4641      	mov	r1, r8
 8021f24:	b224      	sxth	r4, r4
 8021f26:	4658      	mov	r0, fp
 8021f28:	9f30      	ldr	r7, [sp, #192]	@ 0xc0
 8021f2a:	47b8      	blx	r7
 8021f2c:	9b1d      	ldr	r3, [sp, #116]	@ 0x74
 8021f2e:	429c      	cmp	r4, r3
 8021f30:	db32      	blt.n	8021f98 <forward_conv2d_sssa8_ch_nl_pool+0x3d0>
 8021f32:	9b1c      	ldr	r3, [sp, #112]	@ 0x70
 8021f34:	2201      	movs	r2, #1
 8021f36:	991b      	ldr	r1, [sp, #108]	@ 0x6c
 8021f38:	a849      	add	r0, sp, #292	@ 0x124
 8021f3a:	9308      	str	r3, [sp, #32]
 8021f3c:	4492      	add	sl, r2
 8021f3e:	f8bd 3068 	ldrh.w	r3, [sp, #104]	@ 0x68
 8021f42:	9207      	str	r2, [sp, #28]
 8021f44:	1ae4      	subs	r4, r4, r3
 8021f46:	9305      	str	r3, [sp, #20]
 8021f48:	f8bd 3060 	ldrh.w	r3, [sp, #96]	@ 0x60
 8021f4c:	f8bd 208c 	ldrh.w	r2, [sp, #140]	@ 0x8c
 8021f50:	b224      	sxth	r4, r4
 8021f52:	9303      	str	r3, [sp, #12]
 8021f54:	f8bd 30d8 	ldrh.w	r3, [sp, #216]	@ 0xd8
 8021f58:	9201      	str	r2, [sp, #4]
 8021f5a:	1a52      	subs	r2, r2, r1
 8021f5c:	9306      	str	r3, [sp, #24]
 8021f5e:	f8bd 30e0 	ldrh.w	r3, [sp, #224]	@ 0xe0
 8021f62:	b292      	uxth	r2, r2
 8021f64:	9920      	ldr	r1, [sp, #128]	@ 0x80
 8021f66:	9304      	str	r3, [sp, #16]
 8021f68:	f8bd 30e4 	ldrh.w	r3, [sp, #228]	@ 0xe4
 8021f6c:	9f35      	ldr	r7, [sp, #212]	@ 0xd4
 8021f6e:	9302      	str	r3, [sp, #8]
 8021f70:	f8bd 30dc 	ldrh.w	r3, [sp, #220]	@ 0xdc
 8021f74:	9300      	str	r3, [sp, #0]
 8021f76:	9b22      	ldr	r3, [sp, #136]	@ 0x88
 8021f78:	47b8      	blx	r7
 8021f7a:	9a18      	ldr	r2, [sp, #96]	@ 0x60
 8021f7c:	f9bd 3068 	ldrsh.w	r3, [sp, #104]	@ 0x68
 8021f80:	9929      	ldr	r1, [sp, #164]	@ 0xa4
 8021f82:	1ad3      	subs	r3, r2, r3
 8021f84:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 8021f88:	b21a      	sxth	r2, r3
 8021f8a:	9b1c      	ldr	r3, [sp, #112]	@ 0x70
 8021f8c:	695b      	ldr	r3, [r3, #20]
 8021f8e:	9218      	str	r2, [sp, #96]	@ 0x60
 8021f90:	68da      	ldr	r2, [r3, #12]
 8021f92:	688b      	ldr	r3, [r1, #8]
 8021f94:	4413      	add	r3, r2
 8021f96:	608b      	str	r3, [r1, #8]
 8021f98:	f8d8 3014 	ldr.w	r3, [r8, #20]
 8021f9c:	68da      	ldr	r2, [r3, #12]
 8021f9e:	68ab      	ldr	r3, [r5, #8]
 8021fa0:	4413      	add	r3, r2
 8021fa2:	60ab      	str	r3, [r5, #8]
 8021fa4:	f8d9 2024 	ldr.w	r2, [r9, #36]	@ 0x24
 8021fa8:	b132      	cbz	r2, 8021fb8 <forward_conv2d_sssa8_ch_nl_pool+0x3f0>
 8021faa:	f8db 3014 	ldr.w	r3, [fp, #20]
 8021fae:	68da      	ldr	r2, [r3, #12]
 8021fb0:	68b3      	ldr	r3, [r6, #8]
 8021fb2:	4413      	add	r3, r2
 8021fb4:	60b3      	str	r3, [r6, #8]
 8021fb6:	68ab      	ldr	r3, [r5, #8]
 8021fb8:	68ea      	ldr	r2, [r5, #12]
 8021fba:	4640      	mov	r0, r8
 8021fbc:	9316      	str	r3, [sp, #88]	@ 0x58
 8021fbe:	9215      	str	r2, [sp, #84]	@ 0x54
 8021fc0:	f00f f814 	bl	8030fec <get_tensor_byte_size>
 8021fc4:	9a15      	ldr	r2, [sp, #84]	@ 0x54
 8021fc6:	9b16      	ldr	r3, [sp, #88]	@ 0x58
 8021fc8:	4410      	add	r0, r2
 8021fca:	4283      	cmp	r3, r0
 8021fcc:	d306      	bcc.n	8021fdc <forward_conv2d_sssa8_ch_nl_pool+0x414>
 8021fce:	68eb      	ldr	r3, [r5, #12]
 8021fd0:	60ab      	str	r3, [r5, #8]
 8021fd2:	f8d9 3024 	ldr.w	r3, [r9, #36]	@ 0x24
 8021fd6:	b10b      	cbz	r3, 8021fdc <forward_conv2d_sssa8_ch_nl_pool+0x414>
 8021fd8:	68f3      	ldr	r3, [r6, #12]
 8021fda:	60b3      	str	r3, [r6, #8]
 8021fdc:	9b14      	ldr	r3, [sp, #80]	@ 0x50
 8021fde:	3b01      	subs	r3, #1
 8021fe0:	9314      	str	r3, [sp, #80]	@ 0x50
 8021fe2:	9b21      	ldr	r3, [sp, #132]	@ 0x84
 8021fe4:	459a      	cmp	sl, r3
 8021fe6:	d23c      	bcs.n	8022062 <forward_conv2d_sssa8_ch_nl_pool+0x49a>
 8021fe8:	9b14      	ldr	r3, [sp, #80]	@ 0x50
 8021fea:	3301      	adds	r3, #1
 8021fec:	2b00      	cmp	r3, #0
 8021fee:	f73f af3c 	bgt.w	8021e6a <forward_conv2d_sssa8_ch_nl_pool+0x2a2>
 8021ff2:	9b14      	ldr	r3, [sp, #80]	@ 0x50
 8021ff4:	2b00      	cmp	r3, #0
 8021ff6:	da99      	bge.n	8021f2c <forward_conv2d_sssa8_ch_nl_pool+0x364>
 8021ff8:	ee19 3a10 	vmov	r3, s18
 8021ffc:	e9d6 1202 	ldrd	r1, r2, [r6, #8]
 8022000:	fb03 1314 	mls	r3, r3, r4, r1
 8022004:	429a      	cmp	r2, r3
 8022006:	d901      	bls.n	802200c <forward_conv2d_sssa8_ch_nl_pool+0x444>
 8022008:	6870      	ldr	r0, [r6, #4]
 802200a:	4403      	add	r3, r0
 802200c:	429a      	cmp	r2, r3
 802200e:	d202      	bcs.n	8022016 <forward_conv2d_sssa8_ch_nl_pool+0x44e>
 8022010:	981d      	ldr	r0, [sp, #116]	@ 0x74
 8022012:	42a0      	cmp	r0, r4
 8022014:	d137      	bne.n	8022086 <forward_conv2d_sssa8_ch_nl_pool+0x4be>
 8022016:	9b1b      	ldr	r3, [sp, #108]	@ 0x6c
 8022018:	b2a4      	uxth	r4, r4
 802201a:	9a23      	ldr	r2, [sp, #140]	@ 0x8c
 802201c:	4413      	add	r3, r2
 802201e:	9a1a      	ldr	r2, [sp, #104]	@ 0x68
 8022020:	1b1b      	subs	r3, r3, r4
 8022022:	4414      	add	r4, r2
 8022024:	b21b      	sxth	r3, r3
 8022026:	b224      	sxth	r4, r4
 8022028:	931b      	str	r3, [sp, #108]	@ 0x6c
 802202a:	e77f      	b.n	8021f2c <forward_conv2d_sssa8_ch_nl_pool+0x364>
 802202c:	2300      	movs	r3, #0
 802202e:	685b      	ldr	r3, [r3, #4]
 8022030:	deff      	udf	#255	@ 0xff
 8022032:	685b      	ldr	r3, [r3, #4]
 8022034:	deff      	udf	#255	@ 0xff
 8022036:	6848      	ldr	r0, [r1, #4]
 8022038:	9018      	str	r0, [sp, #96]	@ 0x60
 802203a:	e5ef      	b.n	8021c1c <forward_conv2d_sssa8_ch_nl_pool+0x54>
 802203c:	9924      	ldr	r1, [sp, #144]	@ 0x90
 802203e:	461a      	mov	r2, r3
 8022040:	1a5b      	subs	r3, r3, r1
 8022042:	d505      	bpl.n	8022050 <forward_conv2d_sssa8_ch_nl_pool+0x488>
 8022044:	1a8a      	subs	r2, r1, r2
 8022046:	983b      	ldr	r0, [sp, #236]	@ 0xec
 8022048:	9919      	ldr	r1, [sp, #100]	@ 0x64
 802204a:	fb00 1202 	mla	r2, r0, r2, r1
 802204e:	9219      	str	r2, [sp, #100]	@ 0x64
 8022050:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 8022054:	b29b      	uxth	r3, r3
 8022056:	9317      	str	r3, [sp, #92]	@ 0x5c
 8022058:	e75e      	b.n	8021f18 <forward_conv2d_sssa8_ch_nl_pool+0x350>
 802205a:	2300      	movs	r3, #0
 802205c:	e9cd 331e 	strd	r3, r3, [sp, #120]	@ 0x78
 8022060:	e752      	b.n	8021f08 <forward_conv2d_sssa8_ch_nl_pool+0x340>
 8022062:	68eb      	ldr	r3, [r5, #12]
 8022064:	9a29      	ldr	r2, [sp, #164]	@ 0xa4
 8022066:	60ab      	str	r3, [r5, #8]
 8022068:	68f3      	ldr	r3, [r6, #12]
 802206a:	60b3      	str	r3, [r6, #8]
 802206c:	68d3      	ldr	r3, [r2, #12]
 802206e:	6093      	str	r3, [r2, #8]
 8022070:	b051      	add	sp, #324	@ 0x144
 8022072:	ecbd 8b06 	vpop	{d8-d10}
 8022076:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802207a:	eddf 8a1c 	vldr	s17, [pc, #112]	@ 80220ec <forward_conv2d_sssa8_ch_nl_pool+0x524>
 802207e:	e697      	b.n	8021db0 <forward_conv2d_sssa8_ch_nl_pool+0x1e8>
 8022080:	ed9f 8a1a 	vldr	s16, [pc, #104]	@ 80220ec <forward_conv2d_sssa8_ch_nl_pool+0x524>
 8022084:	e686      	b.n	8021d94 <forward_conv2d_sssa8_ch_nl_pool+0x1cc>
 8022086:	6870      	ldr	r0, [r6, #4]
 8022088:	4402      	add	r2, r0
 802208a:	4293      	cmp	r3, r2
 802208c:	d2c3      	bcs.n	8022016 <forward_conv2d_sssa8_ch_nl_pool+0x44e>
 802208e:	3901      	subs	r1, #1
 8022090:	9f14      	ldr	r7, [sp, #80]	@ 0x50
 8022092:	f813 2b01 	ldrb.w	r2, [r3], #1
 8022096:	f801 2f01 	strb.w	r2, [r1, #1]!
 802209a:	68f2      	ldr	r2, [r6, #12]
 802209c:	6870      	ldr	r0, [r6, #4]
 802209e:	4402      	add	r2, r0
 80220a0:	4293      	cmp	r3, r2
 80220a2:	d3f6      	bcc.n	8022092 <forward_conv2d_sssa8_ch_nl_pool+0x4ca>
 80220a4:	9714      	str	r7, [sp, #80]	@ 0x50
 80220a6:	e7b6      	b.n	8022016 <forward_conv2d_sssa8_ch_nl_pool+0x44e>
 80220a8:	932b      	str	r3, [sp, #172]	@ 0xac
 80220aa:	e6b7      	b.n	8021e1c <forward_conv2d_sssa8_ch_nl_pool+0x254>
 80220ac:	922a      	str	r2, [sp, #168]	@ 0xa8
 80220ae:	e6a6      	b.n	8021dfe <forward_conv2d_sssa8_ch_nl_pool+0x236>
 80220b0:	f8d9 1020 	ldr.w	r1, [r9, #32]
 80220b4:	ee09 1a90 	vmov	s19, r1
 80220b8:	2900      	cmp	r1, #0
 80220ba:	f43f ae0e 	beq.w	8021cda <forward_conv2d_sssa8_ch_nl_pool+0x112>
 80220be:	6889      	ldr	r1, [r1, #8]
 80220c0:	ee09 1a90 	vmov	s19, r1
 80220c4:	e609      	b.n	8021cda <forward_conv2d_sssa8_ch_nl_pool+0x112>
 80220c6:	912a      	str	r1, [sp, #168]	@ 0xa8
 80220c8:	e699      	b.n	8021dfe <forward_conv2d_sssa8_ch_nl_pool+0x236>
 80220ca:	4b09      	ldr	r3, [pc, #36]	@ (80220f0 <forward_conv2d_sssa8_ch_nl_pool+0x528>)
 80220cc:	46c3      	mov	fp, r8
 80220ce:	9330      	str	r3, [sp, #192]	@ 0xc0
 80220d0:	e5b7      	b.n	8021c42 <forward_conv2d_sssa8_ch_nl_pool+0x7a>
 80220d2:	922b      	str	r2, [sp, #172]	@ 0xac
 80220d4:	e6a2      	b.n	8021e1c <forward_conv2d_sssa8_ch_nl_pool+0x254>
 80220d6:	9115      	str	r1, [sp, #84]	@ 0x54
 80220d8:	9118      	str	r1, [sp, #96]	@ 0x60
 80220da:	e59f      	b.n	8021c1c <forward_conv2d_sssa8_ch_nl_pool+0x54>
 80220dc:	68db      	ldr	r3, [r3, #12]
 80220de:	deff      	udf	#255	@ 0xff
 80220e0:	2300      	movs	r3, #0
 80220e2:	685b      	ldr	r3, [r3, #4]
 80220e4:	deff      	udf	#255	@ 0xff
 80220e6:	2300      	movs	r3, #0
 80220e8:	685b      	ldr	r3, [r3, #4]
 80220ea:	deff      	udf	#255	@ 0xff
 80220ec:	00000000 	.word	0x00000000
 80220f0:	0802157d 	.word	0x0802157d

080220f4 <forward_dense_integer_SSSA_ch>:
 80220f4:	6983      	ldr	r3, [r0, #24]
 80220f6:	8818      	ldrh	r0, [r3, #0]
 80220f8:	2800      	cmp	r0, #0
 80220fa:	f000 80af 	beq.w	802225c <forward_dense_integer_SSSA_ch+0x168>
 80220fe:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8022102:	685c      	ldr	r4, [r3, #4]
 8022104:	b08f      	sub	sp, #60	@ 0x3c
 8022106:	6863      	ldr	r3, [r4, #4]
 8022108:	b103      	cbz	r3, 802210c <forward_dense_integer_SSSA_ch+0x18>
 802210a:	681b      	ldr	r3, [r3, #0]
 802210c:	2801      	cmp	r0, #1
 802210e:	f000 813f 	beq.w	8022390 <forward_dense_integer_SSSA_ch+0x29c>
 8022112:	6922      	ldr	r2, [r4, #16]
 8022114:	b102      	cbz	r2, 8022118 <forward_dense_integer_SSSA_ch+0x24>
 8022116:	6812      	ldr	r2, [r2, #0]
 8022118:	2802      	cmp	r0, #2
 802211a:	f000 813c 	beq.w	8022396 <forward_dense_integer_SSSA_ch+0x2a2>
 802211e:	69e5      	ldr	r5, [r4, #28]
 8022120:	2d00      	cmp	r5, #0
 8022122:	f000 80eb 	beq.w	80222fc <forward_dense_integer_SSSA_ch+0x208>
 8022126:	8b26      	ldrh	r6, [r4, #24]
 8022128:	6829      	ldr	r1, [r5, #0]
 802212a:	2e01      	cmp	r6, #1
 802212c:	f240 8110 	bls.w	8022350 <forward_dense_integer_SSSA_ch+0x25c>
 8022130:	686d      	ldr	r5, [r5, #4]
 8022132:	2803      	cmp	r0, #3
 8022134:	f000 8132 	beq.w	802239c <forward_dense_integer_SSSA_ch+0x2a8>
 8022138:	f8d4 8028 	ldr.w	r8, [r4, #40]	@ 0x28
 802213c:	69a8      	ldr	r0, [r5, #24]
 802213e:	f1b8 0f00 	cmp.w	r8, #0
 8022142:	f000 80f2 	beq.w	802232a <forward_dense_integer_SSSA_ch+0x236>
 8022146:	6880      	ldr	r0, [r0, #8]
 8022148:	68dc      	ldr	r4, [r3, #12]
 802214a:	900d      	str	r0, [sp, #52]	@ 0x34
 802214c:	68d0      	ldr	r0, [r2, #12]
 802214e:	6866      	ldr	r6, [r4, #4]
 8022150:	f8d8 8000 	ldr.w	r8, [r8]
 8022154:	6995      	ldr	r5, [r2, #24]
 8022156:	fa1f fa86 	uxth.w	sl, r6
 802215a:	9609      	str	r6, [sp, #36]	@ 0x24
 802215c:	e9d0 9401 	ldrd	r9, r4, [r0, #4]
 8022160:	68c0      	ldr	r0, [r0, #12]
 8022162:	fa1f fb89 	uxth.w	fp, r9
 8022166:	fb00 f004 	mul.w	r0, r0, r4
 802216a:	699c      	ldr	r4, [r3, #24]
 802216c:	9008      	str	r0, [sp, #32]
 802216e:	f1b8 0f00 	cmp.w	r8, #0
 8022172:	d003      	beq.n	802217c <forward_dense_integer_SSSA_ch+0x88>
 8022174:	f8d8 0018 	ldr.w	r0, [r8, #24]
 8022178:	f8d0 8008 	ldr.w	r8, [r0, #8]
 802217c:	681b      	ldr	r3, [r3, #0]
 802217e:	f8d2 c000 	ldr.w	ip, [r2]
 8022182:	6808      	ldr	r0, [r1, #0]
 8022184:	698a      	ldr	r2, [r1, #24]
 8022186:	2b00      	cmp	r3, #0
 8022188:	d06a      	beq.n	8022260 <forward_dense_integer_SSSA_ch+0x16c>
 802218a:	6859      	ldr	r1, [r3, #4]
 802218c:	2900      	cmp	r1, #0
 802218e:	f000 8098 	beq.w	80222c2 <forward_dense_integer_SSSA_ch+0x1ce>
 8022192:	885e      	ldrh	r6, [r3, #2]
 8022194:	2e00      	cmp	r6, #0
 8022196:	f000 8084 	beq.w	80222a2 <forward_dense_integer_SSSA_ch+0x1ae>
 802219a:	680f      	ldr	r7, [r1, #0]
 802219c:	ed97 0a00 	vldr	s0, [r7]
 80221a0:	f1bc 0f00 	cmp.w	ip, #0
 80221a4:	f000 8083 	beq.w	80222ae <forward_dense_integer_SSSA_ch+0x1ba>
 80221a8:	f8dc e004 	ldr.w	lr, [ip, #4]
 80221ac:	f1be 0f00 	cmp.w	lr, #0
 80221b0:	f000 8092 	beq.w	80222d8 <forward_dense_integer_SSSA_ch+0x1e4>
 80221b4:	f8bc 6002 	ldrh.w	r6, [ip, #2]
 80221b8:	2e00      	cmp	r6, #0
 80221ba:	d05f      	beq.n	802227c <forward_dense_integer_SSSA_ch+0x188>
 80221bc:	6897      	ldr	r7, [r2, #8]
 80221be:	f8de 2000 	ldr.w	r2, [lr]
 80221c2:	68ad      	ldr	r5, [r5, #8]
 80221c4:	68a4      	ldr	r4, [r4, #8]
 80221c6:	edd2 0a00 	vldr	s1, [r2]
 80221ca:	2900      	cmp	r1, #0
 80221cc:	d060      	beq.n	8022290 <forward_dense_integer_SSSA_ch+0x19c>
 80221ce:	885b      	ldrh	r3, [r3, #2]
 80221d0:	2b00      	cmp	r3, #0
 80221d2:	f000 808a 	beq.w	80222ea <forward_dense_integer_SSSA_ch+0x1f6>
 80221d6:	684b      	ldr	r3, [r1, #4]
 80221d8:	f993 3000 	ldrsb.w	r3, [r3]
 80221dc:	930c      	str	r3, [sp, #48]	@ 0x30
 80221de:	f1bc 0f00 	cmp.w	ip, #0
 80221e2:	f000 80d2 	beq.w	802238a <forward_dense_integer_SSSA_ch+0x296>
 80221e6:	f1be 0f00 	cmp.w	lr, #0
 80221ea:	f000 8084 	beq.w	80222f6 <forward_dense_integer_SSSA_ch+0x202>
 80221ee:	f8bc 6002 	ldrh.w	r6, [ip, #2]
 80221f2:	2e00      	cmp	r6, #0
 80221f4:	d14f      	bne.n	8022296 <forward_dense_integer_SSSA_ch+0x1a2>
 80221f6:	960b      	str	r6, [sp, #44]	@ 0x2c
 80221f8:	b110      	cbz	r0, 8022200 <forward_dense_integer_SSSA_ch+0x10c>
 80221fa:	6840      	ldr	r0, [r0, #4]
 80221fc:	b100      	cbz	r0, 8022200 <forward_dense_integer_SSSA_ch+0x10c>
 80221fe:	6800      	ldr	r0, [r0, #0]
 8022200:	fa1f f989 	uxth.w	r9, r9
 8022204:	4642      	mov	r2, r8
 8022206:	4659      	mov	r1, fp
 8022208:	eb08 03c9 	add.w	r3, r8, r9, lsl #3
 802220c:	930a      	str	r3, [sp, #40]	@ 0x28
 802220e:	f001 fdb7 	bl	8023d80 <align_factor_ch>
 8022212:	9b08      	ldr	r3, [sp, #32]
 8022214:	b1fb      	cbz	r3, 8022256 <forward_dense_integer_SSSA_ch+0x162>
 8022216:	f8bd 1024 	ldrh.w	r1, [sp, #36]	@ 0x24
 802221a:	4652      	mov	r2, sl
 802221c:	2600      	movs	r6, #0
 802221e:	468a      	mov	sl, r1
 8022220:	4639      	mov	r1, r7
 8022222:	4647      	mov	r7, r8
 8022224:	4698      	mov	r8, r3
 8022226:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 8022228:	3601      	adds	r6, #1
 802222a:	4620      	mov	r0, r4
 802222c:	4454      	add	r4, sl
 802222e:	9304      	str	r3, [sp, #16]
 8022230:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 8022232:	9303      	str	r3, [sp, #12]
 8022234:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 8022236:	9302      	str	r3, [sp, #8]
 8022238:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 802223a:	e9cd 5705 	strd	r5, r7, [sp, #20]
 802223e:	e9cd 7300 	strd	r7, r3, [sp]
 8022242:	465b      	mov	r3, fp
 8022244:	444d      	add	r5, r9
 8022246:	e9cd 1208 	strd	r1, r2, [sp, #32]
 802224a:	f002 f93f 	bl	80244cc <st_sssa8_ch_fully_connected>
 802224e:	4546      	cmp	r6, r8
 8022250:	e9dd 1208 	ldrd	r1, r2, [sp, #32]
 8022254:	d1e7      	bne.n	8022226 <forward_dense_integer_SSSA_ch+0x132>
 8022256:	b00f      	add	sp, #60	@ 0x3c
 8022258:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802225c:	6843      	ldr	r3, [r0, #4]
 802225e:	deff      	udf	#255	@ 0xff
 8022260:	f1bc 0f00 	cmp.w	ip, #0
 8022264:	d052      	beq.n	802230c <forward_dense_integer_SSSA_ch+0x218>
 8022266:	f8dc e004 	ldr.w	lr, [ip, #4]
 802226a:	f1be 0f00 	cmp.w	lr, #0
 802226e:	d058      	beq.n	8022322 <forward_dense_integer_SSSA_ch+0x22e>
 8022270:	f8bc 6002 	ldrh.w	r6, [ip, #2]
 8022274:	2e00      	cmp	r6, #0
 8022276:	d16d      	bne.n	8022354 <forward_dense_integer_SSSA_ch+0x260>
 8022278:	ed9f 0a4a 	vldr	s0, [pc, #296]	@ 80223a4 <forward_dense_integer_SSSA_ch+0x2b0>
 802227c:	68ad      	ldr	r5, [r5, #8]
 802227e:	68a4      	ldr	r4, [r4, #8]
 8022280:	6897      	ldr	r7, [r2, #8]
 8022282:	2b00      	cmp	r3, #0
 8022284:	d03d      	beq.n	8022302 <forward_dense_integer_SSSA_ch+0x20e>
 8022286:	6859      	ldr	r1, [r3, #4]
 8022288:	eddf 0a46 	vldr	s1, [pc, #280]	@ 80223a4 <forward_dense_integer_SSSA_ch+0x2b0>
 802228c:	2900      	cmp	r1, #0
 802228e:	d19e      	bne.n	80221ce <forward_dense_integer_SSSA_ch+0xda>
 8022290:	910c      	str	r1, [sp, #48]	@ 0x30
 8022292:	2e00      	cmp	r6, #0
 8022294:	d0af      	beq.n	80221f6 <forward_dense_integer_SSSA_ch+0x102>
 8022296:	f8de 3004 	ldr.w	r3, [lr, #4]
 802229a:	f993 3000 	ldrsb.w	r3, [r3]
 802229e:	930b      	str	r3, [sp, #44]	@ 0x2c
 80222a0:	e7aa      	b.n	80221f8 <forward_dense_integer_SSSA_ch+0x104>
 80222a2:	ed9f 0a40 	vldr	s0, [pc, #256]	@ 80223a4 <forward_dense_integer_SSSA_ch+0x2b0>
 80222a6:	f1bc 0f00 	cmp.w	ip, #0
 80222aa:	f47f af7d 	bne.w	80221a8 <forward_dense_integer_SSSA_ch+0xb4>
 80222ae:	68ad      	ldr	r5, [r5, #8]
 80222b0:	68a4      	ldr	r4, [r4, #8]
 80222b2:	6897      	ldr	r7, [r2, #8]
 80222b4:	2e00      	cmp	r6, #0
 80222b6:	d158      	bne.n	802236a <forward_dense_integer_SSSA_ch+0x276>
 80222b8:	eddf 0a3a 	vldr	s1, [pc, #232]	@ 80223a4 <forward_dense_integer_SSSA_ch+0x2b0>
 80222bc:	960c      	str	r6, [sp, #48]	@ 0x30
 80222be:	960b      	str	r6, [sp, #44]	@ 0x2c
 80222c0:	e79a      	b.n	80221f8 <forward_dense_integer_SSSA_ch+0x104>
 80222c2:	f1bc 0f00 	cmp.w	ip, #0
 80222c6:	d021      	beq.n	802230c <forward_dense_integer_SSSA_ch+0x218>
 80222c8:	f8dc e004 	ldr.w	lr, [ip, #4]
 80222cc:	ed9f 0a35 	vldr	s0, [pc, #212]	@ 80223a4 <forward_dense_integer_SSSA_ch+0x2b0>
 80222d0:	f1be 0f00 	cmp.w	lr, #0
 80222d4:	f47f af6e 	bne.w	80221b4 <forward_dense_integer_SSSA_ch+0xc0>
 80222d8:	68ad      	ldr	r5, [r5, #8]
 80222da:	68a4      	ldr	r4, [r4, #8]
 80222dc:	6897      	ldr	r7, [r2, #8]
 80222de:	b179      	cbz	r1, 8022300 <forward_dense_integer_SSSA_ch+0x20c>
 80222e0:	885b      	ldrh	r3, [r3, #2]
 80222e2:	2b00      	cmp	r3, #0
 80222e4:	d14a      	bne.n	802237c <forward_dense_integer_SSSA_ch+0x288>
 80222e6:	eddf 0a2f 	vldr	s1, [pc, #188]	@ 80223a4 <forward_dense_integer_SSSA_ch+0x2b0>
 80222ea:	2300      	movs	r3, #0
 80222ec:	930c      	str	r3, [sp, #48]	@ 0x30
 80222ee:	f1be 0f00 	cmp.w	lr, #0
 80222f2:	f47f af7c 	bne.w	80221ee <forward_dense_integer_SSSA_ch+0xfa>
 80222f6:	2300      	movs	r3, #0
 80222f8:	930b      	str	r3, [sp, #44]	@ 0x2c
 80222fa:	e77d      	b.n	80221f8 <forward_dense_integer_SSSA_ch+0x104>
 80222fc:	4629      	mov	r1, r5
 80222fe:	e718      	b.n	8022132 <forward_dense_integer_SSSA_ch+0x3e>
 8022300:	460b      	mov	r3, r1
 8022302:	eddf 0a28 	vldr	s1, [pc, #160]	@ 80223a4 <forward_dense_integer_SSSA_ch+0x2b0>
 8022306:	930c      	str	r3, [sp, #48]	@ 0x30
 8022308:	930b      	str	r3, [sp, #44]	@ 0x2c
 802230a:	e775      	b.n	80221f8 <forward_dense_integer_SSSA_ch+0x104>
 802230c:	ed9f 0a25 	vldr	s0, [pc, #148]	@ 80223a4 <forward_dense_integer_SSSA_ch+0x2b0>
 8022310:	4663      	mov	r3, ip
 8022312:	eef0 0a40 	vmov.f32	s1, s0
 8022316:	68ad      	ldr	r5, [r5, #8]
 8022318:	68a4      	ldr	r4, [r4, #8]
 802231a:	6897      	ldr	r7, [r2, #8]
 802231c:	930c      	str	r3, [sp, #48]	@ 0x30
 802231e:	930b      	str	r3, [sp, #44]	@ 0x2c
 8022320:	e76a      	b.n	80221f8 <forward_dense_integer_SSSA_ch+0x104>
 8022322:	ed9f 0a20 	vldr	s0, [pc, #128]	@ 80223a4 <forward_dense_integer_SSSA_ch+0x2b0>
 8022326:	4673      	mov	r3, lr
 8022328:	e7f3      	b.n	8022312 <forward_dense_integer_SSSA_ch+0x21e>
 802232a:	6880      	ldr	r0, [r0, #8]
 802232c:	68dc      	ldr	r4, [r3, #12]
 802232e:	900d      	str	r0, [sp, #52]	@ 0x34
 8022330:	68d0      	ldr	r0, [r2, #12]
 8022332:	6866      	ldr	r6, [r4, #4]
 8022334:	6995      	ldr	r5, [r2, #24]
 8022336:	fa1f fa86 	uxth.w	sl, r6
 802233a:	9609      	str	r6, [sp, #36]	@ 0x24
 802233c:	e9d0 9401 	ldrd	r9, r4, [r0, #4]
 8022340:	68c0      	ldr	r0, [r0, #12]
 8022342:	fa1f fb89 	uxth.w	fp, r9
 8022346:	fb00 f004 	mul.w	r0, r0, r4
 802234a:	699c      	ldr	r4, [r3, #24]
 802234c:	9008      	str	r0, [sp, #32]
 802234e:	e715      	b.n	802217c <forward_dense_integer_SSSA_ch+0x88>
 8022350:	2500      	movs	r5, #0
 8022352:	e6ee      	b.n	8022132 <forward_dense_integer_SSSA_ch+0x3e>
 8022354:	930c      	str	r3, [sp, #48]	@ 0x30
 8022356:	f8de 3000 	ldr.w	r3, [lr]
 802235a:	68ad      	ldr	r5, [r5, #8]
 802235c:	68a4      	ldr	r4, [r4, #8]
 802235e:	6897      	ldr	r7, [r2, #8]
 8022360:	ed9f 0a10 	vldr	s0, [pc, #64]	@ 80223a4 <forward_dense_integer_SSSA_ch+0x2b0>
 8022364:	edd3 0a00 	vldr	s1, [r3]
 8022368:	e795      	b.n	8022296 <forward_dense_integer_SSSA_ch+0x1a2>
 802236a:	684b      	ldr	r3, [r1, #4]
 802236c:	eddf 0a0d 	vldr	s1, [pc, #52]	@ 80223a4 <forward_dense_integer_SSSA_ch+0x2b0>
 8022370:	f993 3000 	ldrsb.w	r3, [r3]
 8022374:	f8cd c02c 	str.w	ip, [sp, #44]	@ 0x2c
 8022378:	930c      	str	r3, [sp, #48]	@ 0x30
 802237a:	e73d      	b.n	80221f8 <forward_dense_integer_SSSA_ch+0x104>
 802237c:	684b      	ldr	r3, [r1, #4]
 802237e:	eddf 0a09 	vldr	s1, [pc, #36]	@ 80223a4 <forward_dense_integer_SSSA_ch+0x2b0>
 8022382:	f993 3000 	ldrsb.w	r3, [r3]
 8022386:	930c      	str	r3, [sp, #48]	@ 0x30
 8022388:	e7b5      	b.n	80222f6 <forward_dense_integer_SSSA_ch+0x202>
 802238a:	f8cd c02c 	str.w	ip, [sp, #44]	@ 0x2c
 802238e:	e733      	b.n	80221f8 <forward_dense_integer_SSSA_ch+0x104>
 8022390:	2300      	movs	r3, #0
 8022392:	685b      	ldr	r3, [r3, #4]
 8022394:	deff      	udf	#255	@ 0xff
 8022396:	2300      	movs	r3, #0
 8022398:	685b      	ldr	r3, [r3, #4]
 802239a:	deff      	udf	#255	@ 0xff
 802239c:	2300      	movs	r3, #0
 802239e:	685b      	ldr	r3, [r3, #4]
 80223a0:	deff      	udf	#255	@ 0xff
 80223a2:	bf00      	nop
 80223a4:	00000000 	.word	0x00000000

080223a8 <forward_pad>:
 80223a8:	7f03      	ldrb	r3, [r0, #28]
 80223aa:	2b03      	cmp	r3, #3
 80223ac:	d80b      	bhi.n	80223c6 <forward_pad+0x1e>
 80223ae:	e8df f003 	tbb	[pc, r3]
 80223b2:	0608      	.short	0x0608
 80223b4:	0204      	.short	0x0204
 80223b6:	f000 b863 	b.w	8022480 <forward_pad_8bit_ch1st_3x3_constant>
 80223ba:	f000 b8f3 	b.w	80225a4 <forward_pad_edge>
 80223be:	f000 b933 	b.w	8022628 <forward_pad_reflect>
 80223c2:	f000 b8a7 	b.w	8022514 <forward_pad_constant>
 80223c6:	4770      	bx	lr

080223c8 <forward_sm_integer>:
 80223c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80223cc:	6983      	ldr	r3, [r0, #24]
 80223ce:	b086      	sub	sp, #24
 80223d0:	881f      	ldrh	r7, [r3, #0]
 80223d2:	2f00      	cmp	r7, #0
 80223d4:	d042      	beq.n	802245c <forward_sm_integer+0x94>
 80223d6:	f8d3 8004 	ldr.w	r8, [r3, #4]
 80223da:	f8d8 6004 	ldr.w	r6, [r8, #4]
 80223de:	b106      	cbz	r6, 80223e2 <forward_sm_integer+0x1a>
 80223e0:	6836      	ldr	r6, [r6, #0]
 80223e2:	2f01      	cmp	r7, #1
 80223e4:	d043      	beq.n	802246e <forward_sm_integer+0xa6>
 80223e6:	f8d8 3010 	ldr.w	r3, [r8, #16]
 80223ea:	2b00      	cmp	r3, #0
 80223ec:	d044      	beq.n	8022478 <forward_sm_integer+0xb0>
 80223ee:	f8d3 e000 	ldr.w	lr, [r3]
 80223f2:	e9d6 1502 	ldrd	r1, r5, [r6, #8]
 80223f6:	f8de 300c 	ldr.w	r3, [lr, #12]
 80223fa:	0a09      	lsrs	r1, r1, #8
 80223fc:	f8d3 c004 	ldr.w	ip, [r3, #4]
 8022400:	686b      	ldr	r3, [r5, #4]
 8022402:	d032      	beq.n	802246a <forward_sm_integer+0xa2>
 8022404:	eb05 0181 	add.w	r1, r5, r1, lsl #2
 8022408:	2201      	movs	r2, #1
 802240a:	f851 4d04 	ldr.w	r4, [r1, #-4]!
 802240e:	428d      	cmp	r5, r1
 8022410:	fb04 f202 	mul.w	r2, r4, r2
 8022414:	d1f9      	bne.n	802240a <forward_sm_integer+0x42>
 8022416:	69c1      	ldr	r1, [r0, #28]
 8022418:	2f03      	cmp	r7, #3
 802241a:	688c      	ldr	r4, [r1, #8]
 802241c:	d927      	bls.n	802246e <forward_sm_integer+0xa6>
 802241e:	f8d8 1028 	ldr.w	r1, [r8, #40]	@ 0x28
 8022422:	b339      	cbz	r1, 8022474 <forward_sm_integer+0xac>
 8022424:	6809      	ldr	r1, [r1, #0]
 8022426:	69b0      	ldr	r0, [r6, #24]
 8022428:	6989      	ldr	r1, [r1, #24]
 802242a:	4e14      	ldr	r6, [pc, #80]	@ (802247c <forward_sm_integer+0xb4>)
 802242c:	688d      	ldr	r5, [r1, #8]
 802242e:	6801      	ldr	r1, [r0, #0]
 8022430:	f021 417e 	bic.w	r1, r1, #4261412864	@ 0xfe000000
 8022434:	42b1      	cmp	r1, r6
 8022436:	f8de 6018 	ldr.w	r6, [lr, #24]
 802243a:	6881      	ldr	r1, [r0, #8]
 802243c:	68b0      	ldr	r0, [r6, #8]
 802243e:	9505      	str	r5, [sp, #20]
 8022440:	68a5      	ldr	r5, [r4, #8]
 8022442:	9504      	str	r5, [sp, #16]
 8022444:	6865      	ldr	r5, [r4, #4]
 8022446:	9503      	str	r5, [sp, #12]
 8022448:	6824      	ldr	r4, [r4, #0]
 802244a:	9300      	str	r3, [sp, #0]
 802244c:	e9cd c401 	strd	ip, r4, [sp, #4]
 8022450:	d006      	beq.n	8022460 <forward_sm_integer+0x98>
 8022452:	f001 f9e9 	bl	8023828 <forward_lite_nl_softmax_iu8ou8>
 8022456:	b006      	add	sp, #24
 8022458:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802245c:	687b      	ldr	r3, [r7, #4]
 802245e:	deff      	udf	#255	@ 0xff
 8022460:	f001 f9e0 	bl	8023824 <forward_lite_nl_softmax_is8os8>
 8022464:	b006      	add	sp, #24
 8022466:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802246a:	2201      	movs	r2, #1
 802246c:	e7d3      	b.n	8022416 <forward_sm_integer+0x4e>
 802246e:	2300      	movs	r3, #0
 8022470:	685b      	ldr	r3, [r3, #4]
 8022472:	deff      	udf	#255	@ 0xff
 8022474:	698b      	ldr	r3, [r1, #24]
 8022476:	deff      	udf	#255	@ 0xff
 8022478:	68db      	ldr	r3, [r3, #12]
 802247a:	deff      	udf	#255	@ 0xff
 802247c:	00840440 	.word	0x00840440

08022480 <forward_pad_8bit_ch1st_3x3_constant>:
 8022480:	6982      	ldr	r2, [r0, #24]
 8022482:	8813      	ldrh	r3, [r2, #0]
 8022484:	2b00      	cmp	r3, #0
 8022486:	d03e      	beq.n	8022506 <forward_pad_8bit_ch1st_3x3_constant+0x86>
 8022488:	6852      	ldr	r2, [r2, #4]
 802248a:	6851      	ldr	r1, [r2, #4]
 802248c:	b101      	cbz	r1, 8022490 <forward_pad_8bit_ch1st_3x3_constant+0x10>
 802248e:	6809      	ldr	r1, [r1, #0]
 8022490:	2b01      	cmp	r3, #1
 8022492:	d03c      	beq.n	802250e <forward_pad_8bit_ch1st_3x3_constant+0x8e>
 8022494:	6913      	ldr	r3, [r2, #16]
 8022496:	2b00      	cmp	r3, #0
 8022498:	d037      	beq.n	802250a <forward_pad_8bit_ch1st_3x3_constant+0x8a>
 802249a:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 802249e:	e9d0 5209 	ldrd	r5, r2, [r0, #36]	@ 0x24
 80224a2:	681f      	ldr	r7, [r3, #0]
 80224a4:	b085      	sub	sp, #20
 80224a6:	68cb      	ldr	r3, [r1, #12]
 80224a8:	f9b5 8008 	ldrsh.w	r8, [r5, #8]
 80224ac:	f8d3 c004 	ldr.w	ip, [r3, #4]
 80224b0:	f9b5 900c 	ldrsh.w	r9, [r5, #12]
 80224b4:	68db      	ldr	r3, [r3, #12]
 80224b6:	6892      	ldr	r2, [r2, #8]
 80224b8:	e9d5 0400 	ldrd	r0, r4, [r5]
 80224bc:	e9d1 6105 	ldrd	r6, r1, [r1, #20]
 80224c0:	4320      	orrs	r0, r4
 80224c2:	6875      	ldr	r5, [r6, #4]
 80224c4:	b204      	sxth	r4, r0
 80224c6:	6888      	ldr	r0, [r1, #8]
 80224c8:	e9d7 7105 	ldrd	r7, r1, [r7, #20]
 80224cc:	f8d7 e00c 	ldr.w	lr, [r7, #12]
 80224d0:	6889      	ldr	r1, [r1, #8]
 80224d2:	68f7      	ldr	r7, [r6, #12]
 80224d4:	b974      	cbnz	r4, 80224f4 <forward_pad_8bit_ch1st_3x3_constant+0x74>
 80224d6:	f1b8 0f02 	cmp.w	r8, #2
 80224da:	d10b      	bne.n	80224f4 <forward_pad_8bit_ch1st_3x3_constant+0x74>
 80224dc:	f1b9 0f02 	cmp.w	r9, #2
 80224e0:	d108      	bne.n	80224f4 <forward_pad_8bit_ch1st_3x3_constant+0x74>
 80224e2:	e9cd 7e02 	strd	r7, lr, [sp, #8]
 80224e6:	e9cd c500 	strd	ip, r5, [sp]
 80224ea:	f001 f99f 	bl	802382c <forward_lite_pad_8bit_ch1st_3x3_constant_P0022>
 80224ee:	b005      	add	sp, #20
 80224f0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80224f4:	e9cd 7e02 	strd	r7, lr, [sp, #8]
 80224f8:	e9cd c500 	strd	ip, r5, [sp]
 80224fc:	f001 f9ca 	bl	8023894 <forward_lite_pad_8bit_ch1st_3x3_constant_P1111>
 8022500:	b005      	add	sp, #20
 8022502:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8022506:	685b      	ldr	r3, [r3, #4]
 8022508:	deff      	udf	#255	@ 0xff
 802250a:	699b      	ldr	r3, [r3, #24]
 802250c:	deff      	udf	#255	@ 0xff
 802250e:	2300      	movs	r3, #0
 8022510:	685b      	ldr	r3, [r3, #4]
 8022512:	deff      	udf	#255	@ 0xff

08022514 <forward_pad_constant>:
 8022514:	6982      	ldr	r2, [r0, #24]
 8022516:	8813      	ldrh	r3, [r2, #0]
 8022518:	2b00      	cmp	r3, #0
 802251a:	d03b      	beq.n	8022594 <forward_pad_constant+0x80>
 802251c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8022520:	6852      	ldr	r2, [r2, #4]
 8022522:	b088      	sub	sp, #32
 8022524:	6854      	ldr	r4, [r2, #4]
 8022526:	b104      	cbz	r4, 802252a <forward_pad_constant+0x16>
 8022528:	6824      	ldr	r4, [r4, #0]
 802252a:	2b01      	cmp	r3, #1
 802252c:	d034      	beq.n	8022598 <forward_pad_constant+0x84>
 802252e:	6913      	ldr	r3, [r2, #16]
 8022530:	2b00      	cmp	r3, #0
 8022532:	d034      	beq.n	802259e <forward_pad_constant+0x8a>
 8022534:	6819      	ldr	r1, [r3, #0]
 8022536:	6a45      	ldr	r5, [r0, #36]	@ 0x24
 8022538:	6a82      	ldr	r2, [r0, #40]	@ 0x28
 802253a:	f9b5 600c 	ldrsh.w	r6, [r5, #12]
 802253e:	69a3      	ldr	r3, [r4, #24]
 8022540:	6967      	ldr	r7, [r4, #20]
 8022542:	f8d3 8000 	ldr.w	r8, [r3]
 8022546:	6892      	ldr	r2, [r2, #8]
 8022548:	e9d1 0105 	ldrd	r0, r1, [r1, #20]
 802254c:	e9d0 ec02 	ldrd	lr, ip, [r0, #8]
 8022550:	6889      	ldr	r1, [r1, #8]
 8022552:	fb0e f606 	mul.w	r6, lr, r6
 8022556:	6898      	ldr	r0, [r3, #8]
 8022558:	f3c8 13c6 	ubfx	r3, r8, #7, #7
 802255c:	9606      	str	r6, [sp, #24]
 802255e:	f9b5 6004 	ldrsh.w	r6, [r5, #4]
 8022562:	fb0e f606 	mul.w	r6, lr, r6
 8022566:	9605      	str	r6, [sp, #20]
 8022568:	f9b5 6008 	ldrsh.w	r6, [r5, #8]
 802256c:	fb0c f606 	mul.w	r6, ip, r6
 8022570:	9604      	str	r6, [sp, #16]
 8022572:	f9b5 5000 	ldrsh.w	r5, [r5]
 8022576:	fb0c f505 	mul.w	r5, ip, r5
 802257a:	9503      	str	r5, [sp, #12]
 802257c:	68fd      	ldr	r5, [r7, #12]
 802257e:	9502      	str	r5, [sp, #8]
 8022580:	687d      	ldr	r5, [r7, #4]
 8022582:	9501      	str	r5, [sp, #4]
 8022584:	68e4      	ldr	r4, [r4, #12]
 8022586:	68e4      	ldr	r4, [r4, #12]
 8022588:	9400      	str	r4, [sp, #0]
 802258a:	f001 fa43 	bl	8023a14 <forward_lite_pad_constant>
 802258e:	b008      	add	sp, #32
 8022590:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8022594:	685b      	ldr	r3, [r3, #4]
 8022596:	deff      	udf	#255	@ 0xff
 8022598:	2300      	movs	r3, #0
 802259a:	685b      	ldr	r3, [r3, #4]
 802259c:	deff      	udf	#255	@ 0xff
 802259e:	699b      	ldr	r3, [r3, #24]
 80225a0:	deff      	udf	#255	@ 0xff
 80225a2:	bf00      	nop

080225a4 <forward_pad_edge>:
 80225a4:	6982      	ldr	r2, [r0, #24]
 80225a6:	8813      	ldrh	r3, [r2, #0]
 80225a8:	2b00      	cmp	r3, #0
 80225aa:	d035      	beq.n	8022618 <forward_pad_edge+0x74>
 80225ac:	6851      	ldr	r1, [r2, #4]
 80225ae:	684a      	ldr	r2, [r1, #4]
 80225b0:	b102      	cbz	r2, 80225b4 <forward_pad_edge+0x10>
 80225b2:	6812      	ldr	r2, [r2, #0]
 80225b4:	2b01      	cmp	r3, #1
 80225b6:	d031      	beq.n	802261c <forward_pad_edge+0x78>
 80225b8:	690b      	ldr	r3, [r1, #16]
 80225ba:	2b00      	cmp	r3, #0
 80225bc:	d031      	beq.n	8022622 <forward_pad_edge+0x7e>
 80225be:	b5f0      	push	{r4, r5, r6, r7, lr}
 80225c0:	681b      	ldr	r3, [r3, #0]
 80225c2:	b089      	sub	sp, #36	@ 0x24
 80225c4:	6a45      	ldr	r5, [r0, #36]	@ 0x24
 80225c6:	f8d2 e00c 	ldr.w	lr, [r2, #12]
 80225ca:	f9b5 6008 	ldrsh.w	r6, [r5, #8]
 80225ce:	6990      	ldr	r0, [r2, #24]
 80225d0:	6957      	ldr	r7, [r2, #20]
 80225d2:	6880      	ldr	r0, [r0, #8]
 80225d4:	f8de 200c 	ldr.w	r2, [lr, #12]
 80225d8:	e9d3 c105 	ldrd	ip, r1, [r3, #20]
 80225dc:	f9b5 3000 	ldrsh.w	r3, [r5]
 80225e0:	f8dc 400c 	ldr.w	r4, [ip, #12]
 80225e4:	6889      	ldr	r1, [r1, #8]
 80225e6:	fb04 f606 	mul.w	r6, r4, r6
 80225ea:	9606      	str	r6, [sp, #24]
 80225ec:	f8dc c008 	ldr.w	ip, [ip, #8]
 80225f0:	f9b5 6004 	ldrsh.w	r6, [r5, #4]
 80225f4:	9403      	str	r4, [sp, #12]
 80225f6:	fb0c f606 	mul.w	r6, ip, r6
 80225fa:	fb03 f404 	mul.w	r4, r3, r4
 80225fe:	9605      	str	r6, [sp, #20]
 8022600:	9404      	str	r4, [sp, #16]
 8022602:	68bc      	ldr	r4, [r7, #8]
 8022604:	9402      	str	r4, [sp, #8]
 8022606:	68fc      	ldr	r4, [r7, #12]
 8022608:	9401      	str	r4, [sp, #4]
 802260a:	f9b5 400c 	ldrsh.w	r4, [r5, #12]
 802260e:	9400      	str	r4, [sp, #0]
 8022610:	f001 fa9c 	bl	8023b4c <forward_lite_pad_edge>
 8022614:	b009      	add	sp, #36	@ 0x24
 8022616:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8022618:	685b      	ldr	r3, [r3, #4]
 802261a:	deff      	udf	#255	@ 0xff
 802261c:	2300      	movs	r3, #0
 802261e:	685b      	ldr	r3, [r3, #4]
 8022620:	deff      	udf	#255	@ 0xff
 8022622:	699b      	ldr	r3, [r3, #24]
 8022624:	deff      	udf	#255	@ 0xff
 8022626:	bf00      	nop

08022628 <forward_pad_reflect>:
 8022628:	6982      	ldr	r2, [r0, #24]
 802262a:	8813      	ldrh	r3, [r2, #0]
 802262c:	2b00      	cmp	r3, #0
 802262e:	d044      	beq.n	80226ba <forward_pad_reflect+0x92>
 8022630:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8022634:	6852      	ldr	r2, [r2, #4]
 8022636:	b08f      	sub	sp, #60	@ 0x3c
 8022638:	6857      	ldr	r7, [r2, #4]
 802263a:	b107      	cbz	r7, 802263e <forward_pad_reflect+0x16>
 802263c:	683f      	ldr	r7, [r7, #0]
 802263e:	2b01      	cmp	r3, #1
 8022640:	d03d      	beq.n	80226be <forward_pad_reflect+0x96>
 8022642:	6913      	ldr	r3, [r2, #16]
 8022644:	2b00      	cmp	r3, #0
 8022646:	d03d      	beq.n	80226c4 <forward_pad_reflect+0x9c>
 8022648:	6819      	ldr	r1, [r3, #0]
 802264a:	68fa      	ldr	r2, [r7, #12]
 802264c:	e9d2 8302 	ldrd	r8, r3, [r2, #8]
 8022650:	e9d1 4202 	ldrd	r4, r2, [r1, #8]
 8022654:	f5b4 6fa0 	cmp.w	r4, #1280	@ 0x500
 8022658:	6a44      	ldr	r4, [r0, #36]	@ 0x24
 802265a:	e9d1 0105 	ldrd	r0, r1, [r1, #20]
 802265e:	f9b4 600c 	ldrsh.w	r6, [r4, #12]
 8022662:	f9b4 e004 	ldrsh.w	lr, [r4, #4]
 8022666:	f9b4 b000 	ldrsh.w	fp, [r4]
 802266a:	6889      	ldr	r1, [r1, #8]
 802266c:	e9d0 5c02 	ldrd	r5, ip, [r0, #8]
 8022670:	e9d7 7005 	ldrd	r7, r0, [r7, #20]
 8022674:	fb05 f606 	mul.w	r6, r5, r6
 8022678:	6880      	ldr	r0, [r0, #8]
 802267a:	e9d2 a902 	ldrd	sl, r9, [r2, #8]
 802267e:	bf2c      	ite	cs
 8022680:	6912      	ldrcs	r2, [r2, #16]
 8022682:	2201      	movcc	r2, #1
 8022684:	960c      	str	r6, [sp, #48]	@ 0x30
 8022686:	fb05 f60e 	mul.w	r6, r5, lr
 802268a:	960b      	str	r6, [sp, #44]	@ 0x2c
 802268c:	fb0c f60b 	mul.w	r6, ip, fp
 8022690:	960a      	str	r6, [sp, #40]	@ 0x28
 8022692:	f9b4 4008 	ldrsh.w	r4, [r4, #8]
 8022696:	9409      	str	r4, [sp, #36]	@ 0x24
 8022698:	e9cd eb07 	strd	lr, fp, [sp, #28]
 802269c:	e9cd c505 	strd	ip, r5, [sp, #20]
 80226a0:	68bc      	ldr	r4, [r7, #8]
 80226a2:	9404      	str	r4, [sp, #16]
 80226a4:	68fc      	ldr	r4, [r7, #12]
 80226a6:	f8cd 8000 	str.w	r8, [sp]
 80226aa:	9403      	str	r4, [sp, #12]
 80226ac:	e9cd 9a01 	strd	r9, sl, [sp, #4]
 80226b0:	f001 fabe 	bl	8023c30 <forward_lite_pad_reflect>
 80226b4:	b00f      	add	sp, #60	@ 0x3c
 80226b6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80226ba:	685b      	ldr	r3, [r3, #4]
 80226bc:	deff      	udf	#255	@ 0xff
 80226be:	2300      	movs	r3, #0
 80226c0:	685b      	ldr	r3, [r3, #4]
 80226c2:	deff      	udf	#255	@ 0xff
 80226c4:	68db      	ldr	r3, [r3, #12]
 80226c6:	deff      	udf	#255	@ 0xff

080226c8 <pool_func_mp_array_integer_INT8>:
 80226c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80226cc:	b093      	sub	sp, #76	@ 0x4c
 80226ce:	468c      	mov	ip, r1
 80226d0:	469a      	mov	sl, r3
 80226d2:	6804      	ldr	r4, [r0, #0]
 80226d4:	f8bd 1074 	ldrh.w	r1, [sp, #116]	@ 0x74
 80226d8:	f8bd 3070 	ldrh.w	r3, [sp, #112]	@ 0x70
 80226dc:	910e      	str	r1, [sp, #56]	@ 0x38
 80226de:	f8bd 1078 	ldrh.w	r1, [sp, #120]	@ 0x78
 80226e2:	930d      	str	r3, [sp, #52]	@ 0x34
 80226e4:	910f      	str	r1, [sp, #60]	@ 0x3c
 80226e6:	9b24      	ldr	r3, [sp, #144]	@ 0x90
 80226e8:	f8bd 107c 	ldrh.w	r1, [sp, #124]	@ 0x7c
 80226ec:	6980      	ldr	r0, [r0, #24]
 80226ee:	9110      	str	r1, [sp, #64]	@ 0x40
 80226f0:	f8bd b080 	ldrh.w	fp, [sp, #128]	@ 0x80
 80226f4:	f8bd 7084 	ldrh.w	r7, [sp, #132]	@ 0x84
 80226f8:	f8bd e088 	ldrh.w	lr, [sp, #136]	@ 0x88
 80226fc:	f8bd 808c 	ldrh.w	r8, [sp, #140]	@ 0x8c
 8022700:	6999      	ldr	r1, [r3, #24]
 8022702:	681d      	ldr	r5, [r3, #0]
 8022704:	2c00      	cmp	r4, #0
 8022706:	d068      	beq.n	80227da <pool_func_mp_array_integer_INT8+0x112>
 8022708:	6866      	ldr	r6, [r4, #4]
 802270a:	2e00      	cmp	r6, #0
 802270c:	d04c      	beq.n	80227a8 <pool_func_mp_array_integer_INT8+0xe0>
 802270e:	f8b4 9002 	ldrh.w	r9, [r4, #2]
 8022712:	f1b9 0f00 	cmp.w	r9, #0
 8022716:	d07a      	beq.n	802280e <pool_func_mp_array_integer_INT8+0x146>
 8022718:	6833      	ldr	r3, [r6, #0]
 802271a:	edd3 7a00 	vldr	s15, [r3]
 802271e:	2d00      	cmp	r5, #0
 8022720:	d079      	beq.n	8022816 <pool_func_mp_array_integer_INT8+0x14e>
 8022722:	f8d5 9004 	ldr.w	r9, [r5, #4]
 8022726:	f1b9 0f00 	cmp.w	r9, #0
 802272a:	d046      	beq.n	80227ba <pool_func_mp_array_integer_INT8+0xf2>
 802272c:	886b      	ldrh	r3, [r5, #2]
 802272e:	9311      	str	r3, [sp, #68]	@ 0x44
 8022730:	2b00      	cmp	r3, #0
 8022732:	d05f      	beq.n	80227f4 <pool_func_mp_array_integer_INT8+0x12c>
 8022734:	f8d9 3000 	ldr.w	r3, [r9]
 8022738:	6880      	ldr	r0, [r0, #8]
 802273a:	ed93 7a00 	vldr	s14, [r3]
 802273e:	6889      	ldr	r1, [r1, #8]
 8022740:	ee87 0a87 	vdiv.f32	s0, s15, s14
 8022744:	2e00      	cmp	r6, #0
 8022746:	d060      	beq.n	802280a <pool_func_mp_array_integer_INT8+0x142>
 8022748:	8863      	ldrh	r3, [r4, #2]
 802274a:	2b00      	cmp	r3, #0
 802274c:	f000 808c 	beq.w	8022868 <pool_func_mp_array_integer_INT8+0x1a0>
 8022750:	6873      	ldr	r3, [r6, #4]
 8022752:	f993 4000 	ldrsb.w	r4, [r3]
 8022756:	2d00      	cmp	r5, #0
 8022758:	d03d      	beq.n	80227d6 <pool_func_mp_array_integer_INT8+0x10e>
 802275a:	f1b9 0f00 	cmp.w	r9, #0
 802275e:	d03a      	beq.n	80227d6 <pool_func_mp_array_integer_INT8+0x10e>
 8022760:	886b      	ldrh	r3, [r5, #2]
 8022762:	9311      	str	r3, [sp, #68]	@ 0x44
 8022764:	9b11      	ldr	r3, [sp, #68]	@ 0x44
 8022766:	b11b      	cbz	r3, 8022770 <pool_func_mp_array_integer_INT8+0xa8>
 8022768:	f8d9 3004 	ldr.w	r3, [r9, #4]
 802276c:	f993 3000 	ldrsb.w	r3, [r3]
 8022770:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8022774:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8022778:	da5f      	bge.n	802283a <pool_func_mp_array_integer_INT8+0x172>
 802277a:	f8cd a000 	str.w	sl, [sp]
 802277e:	e9cd 4309 	strd	r4, r3, [sp, #36]	@ 0x24
 8022782:	9b10      	ldr	r3, [sp, #64]	@ 0x40
 8022784:	9304      	str	r3, [sp, #16]
 8022786:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 8022788:	9303      	str	r3, [sp, #12]
 802278a:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 802278c:	9302      	str	r3, [sp, #8]
 802278e:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 8022790:	9301      	str	r3, [sp, #4]
 8022792:	4613      	mov	r3, r2
 8022794:	4662      	mov	r2, ip
 8022796:	e9cd e807 	strd	lr, r8, [sp, #28]
 802279a:	e9cd b705 	strd	fp, r7, [sp, #20]
 802279e:	f000 ff61 	bl	8023664 <forward_lite_maxpool_is8os8_scaleneg>
 80227a2:	b013      	add	sp, #76	@ 0x4c
 80227a4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80227a8:	2d00      	cmp	r5, #0
 80227aa:	d040      	beq.n	802282e <pool_func_mp_array_integer_INT8+0x166>
 80227ac:	f8d5 9004 	ldr.w	r9, [r5, #4]
 80227b0:	eddf 7a39 	vldr	s15, [pc, #228]	@ 8022898 <pool_func_mp_array_integer_INT8+0x1d0>
 80227b4:	f1b9 0f00 	cmp.w	r9, #0
 80227b8:	d1b8      	bne.n	802272c <pool_func_mp_array_integer_INT8+0x64>
 80227ba:	ed9f 7a37 	vldr	s14, [pc, #220]	@ 8022898 <pool_func_mp_array_integer_INT8+0x1d0>
 80227be:	6880      	ldr	r0, [r0, #8]
 80227c0:	ee87 0a87 	vdiv.f32	s0, s15, s14
 80227c4:	6889      	ldr	r1, [r1, #8]
 80227c6:	2e00      	cmp	r6, #0
 80227c8:	d063      	beq.n	8022892 <pool_func_mp_array_integer_INT8+0x1ca>
 80227ca:	8863      	ldrh	r3, [r4, #2]
 80227cc:	2b00      	cmp	r3, #0
 80227ce:	d04b      	beq.n	8022868 <pool_func_mp_array_integer_INT8+0x1a0>
 80227d0:	6873      	ldr	r3, [r6, #4]
 80227d2:	f993 4000 	ldrsb.w	r4, [r3]
 80227d6:	2300      	movs	r3, #0
 80227d8:	e7ca      	b.n	8022770 <pool_func_mp_array_integer_INT8+0xa8>
 80227da:	2d00      	cmp	r5, #0
 80227dc:	d046      	beq.n	802286c <pool_func_mp_array_integer_INT8+0x1a4>
 80227de:	f8d5 9004 	ldr.w	r9, [r5, #4]
 80227e2:	f1b9 0f00 	cmp.w	r9, #0
 80227e6:	d022      	beq.n	802282e <pool_func_mp_array_integer_INT8+0x166>
 80227e8:	886b      	ldrh	r3, [r5, #2]
 80227ea:	9311      	str	r3, [sp, #68]	@ 0x44
 80227ec:	2b00      	cmp	r3, #0
 80227ee:	d144      	bne.n	802287a <pool_func_mp_array_integer_INT8+0x1b2>
 80227f0:	eddf 7a29 	vldr	s15, [pc, #164]	@ 8022898 <pool_func_mp_array_integer_INT8+0x1d0>
 80227f4:	ed9f 7a28 	vldr	s14, [pc, #160]	@ 8022898 <pool_func_mp_array_integer_INT8+0x1d0>
 80227f8:	6880      	ldr	r0, [r0, #8]
 80227fa:	ee87 0a87 	vdiv.f32	s0, s15, s14
 80227fe:	6889      	ldr	r1, [r1, #8]
 8022800:	2c00      	cmp	r4, #0
 8022802:	d0e8      	beq.n	80227d6 <pool_func_mp_array_integer_INT8+0x10e>
 8022804:	6866      	ldr	r6, [r4, #4]
 8022806:	2e00      	cmp	r6, #0
 8022808:	d19e      	bne.n	8022748 <pool_func_mp_array_integer_INT8+0x80>
 802280a:	4634      	mov	r4, r6
 802280c:	e7aa      	b.n	8022764 <pool_func_mp_array_integer_INT8+0x9c>
 802280e:	eddf 7a22 	vldr	s15, [pc, #136]	@ 8022898 <pool_func_mp_array_integer_INT8+0x1d0>
 8022812:	2d00      	cmp	r5, #0
 8022814:	d185      	bne.n	8022722 <pool_func_mp_array_integer_INT8+0x5a>
 8022816:	ed9f 7a20 	vldr	s14, [pc, #128]	@ 8022898 <pool_func_mp_array_integer_INT8+0x1d0>
 802281a:	6880      	ldr	r0, [r0, #8]
 802281c:	ee87 0a87 	vdiv.f32	s0, s15, s14
 8022820:	6889      	ldr	r1, [r1, #8]
 8022822:	f1b9 0f00 	cmp.w	r9, #0
 8022826:	d12f      	bne.n	8022888 <pool_func_mp_array_integer_INT8+0x1c0>
 8022828:	464c      	mov	r4, r9
 802282a:	464b      	mov	r3, r9
 802282c:	e7a0      	b.n	8022770 <pool_func_mp_array_integer_INT8+0xa8>
 802282e:	2400      	movs	r4, #0
 8022830:	6880      	ldr	r0, [r0, #8]
 8022832:	6889      	ldr	r1, [r1, #8]
 8022834:	ed9f 0a19 	vldr	s0, [pc, #100]	@ 802289c <pool_func_mp_array_integer_INT8+0x1d4>
 8022838:	4623      	mov	r3, r4
 802283a:	f8cd a000 	str.w	sl, [sp]
 802283e:	e9cd 4309 	strd	r4, r3, [sp, #36]	@ 0x24
 8022842:	9b10      	ldr	r3, [sp, #64]	@ 0x40
 8022844:	9304      	str	r3, [sp, #16]
 8022846:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 8022848:	9303      	str	r3, [sp, #12]
 802284a:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 802284c:	9302      	str	r3, [sp, #8]
 802284e:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 8022850:	9301      	str	r3, [sp, #4]
 8022852:	4613      	mov	r3, r2
 8022854:	4662      	mov	r2, ip
 8022856:	e9cd e807 	strd	lr, r8, [sp, #28]
 802285a:	e9cd b705 	strd	fp, r7, [sp, #20]
 802285e:	f000 f81f 	bl	80228a0 <forward_lite_maxpool_is8os8_scalepos>
 8022862:	b013      	add	sp, #76	@ 0x4c
 8022864:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8022868:	2400      	movs	r4, #0
 802286a:	e776      	b.n	802275a <pool_func_mp_array_integer_INT8+0x92>
 802286c:	462c      	mov	r4, r5
 802286e:	6880      	ldr	r0, [r0, #8]
 8022870:	6889      	ldr	r1, [r1, #8]
 8022872:	462b      	mov	r3, r5
 8022874:	ed9f 0a09 	vldr	s0, [pc, #36]	@ 802289c <pool_func_mp_array_integer_INT8+0x1d4>
 8022878:	e7df      	b.n	802283a <pool_func_mp_array_integer_INT8+0x172>
 802287a:	ed9f 0a07 	vldr	s0, [pc, #28]	@ 8022898 <pool_func_mp_array_integer_INT8+0x1d0>
 802287e:	6880      	ldr	r0, [r0, #8]
 8022880:	eef0 7a40 	vmov.f32	s15, s0
 8022884:	6889      	ldr	r1, [r1, #8]
 8022886:	e76f      	b.n	8022768 <pool_func_mp_array_integer_INT8+0xa0>
 8022888:	6874      	ldr	r4, [r6, #4]
 802288a:	462b      	mov	r3, r5
 802288c:	f994 4000 	ldrsb.w	r4, [r4]
 8022890:	e76e      	b.n	8022770 <pool_func_mp_array_integer_INT8+0xa8>
 8022892:	4634      	mov	r4, r6
 8022894:	4633      	mov	r3, r6
 8022896:	e76b      	b.n	8022770 <pool_func_mp_array_integer_INT8+0xa8>
 8022898:	00000000 	.word	0x00000000
 802289c:	7fc00000 	.word	0x7fc00000

080228a0 <forward_lite_maxpool_is8os8_scalepos>:
 80228a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80228a4:	b095      	sub	sp, #84	@ 0x54
 80228a6:	4614      	mov	r4, r2
 80228a8:	e9cd 010a 	strd	r0, r1, [sp, #40]	@ 0x28
 80228ac:	f8bd 107c 	ldrh.w	r1, [sp, #124]	@ 0x7c
 80228b0:	f99d 009c 	ldrsb.w	r0, [sp, #156]	@ 0x9c
 80228b4:	910d      	str	r1, [sp, #52]	@ 0x34
 80228b6:	f8bd 1080 	ldrh.w	r1, [sp, #128]	@ 0x80
 80228ba:	930c      	str	r3, [sp, #48]	@ 0x30
 80228bc:	910e      	str	r1, [sp, #56]	@ 0x38
 80228be:	f8bd 1084 	ldrh.w	r1, [sp, #132]	@ 0x84
 80228c2:	f8bd 3098 	ldrh.w	r3, [sp, #152]	@ 0x98
 80228c6:	910f      	str	r1, [sp, #60]	@ 0x3c
 80228c8:	f8bd 1088 	ldrh.w	r1, [sp, #136]	@ 0x88
 80228cc:	9206      	str	r2, [sp, #24]
 80228ce:	9110      	str	r1, [sp, #64]	@ 0x40
 80228d0:	f8bd 108c 	ldrh.w	r1, [sp, #140]	@ 0x8c
 80228d4:	f8bd a078 	ldrh.w	sl, [sp, #120]	@ 0x78
 80228d8:	9111      	str	r1, [sp, #68]	@ 0x44
 80228da:	f8bd 1090 	ldrh.w	r1, [sp, #144]	@ 0x90
 80228de:	f99d 20a0 	ldrsb.w	r2, [sp, #160]	@ 0xa0
 80228e2:	9112      	str	r1, [sp, #72]	@ 0x48
 80228e4:	f8bd 1094 	ldrh.w	r1, [sp, #148]	@ 0x94
 80228e8:	9313      	str	r3, [sp, #76]	@ 0x4c
 80228ea:	9107      	str	r1, [sp, #28]
 80228ec:	9003      	str	r0, [sp, #12]
 80228ee:	2b00      	cmp	r3, #0
 80228f0:	f000 8094 	beq.w	8022a1c <forward_lite_maxpool_is8os8_scalepos+0x17c>
 80228f4:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 80228f8:	eeb4 0a67 	vcmp.f32	s0, s15
 80228fc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8022900:	bf0c      	ite	eq
 8022902:	2301      	moveq	r3, #1
 8022904:	2300      	movne	r3, #0
 8022906:	4290      	cmp	r0, r2
 8022908:	bf14      	ite	ne
 802290a:	2300      	movne	r3, #0
 802290c:	f003 0301 	andeq.w	r3, r3, #1
 8022910:	9301      	str	r3, [sp, #4]
 8022912:	2900      	cmp	r1, #0
 8022914:	f000 8082 	beq.w	8022a1c <forward_lite_maxpool_is8os8_scalepos+0x17c>
 8022918:	f1ba 0f00 	cmp.w	sl, #0
 802291c:	d07e      	beq.n	8022a1c <forward_lite_maxpool_is8os8_scalepos+0x17c>
 802291e:	ee07 2a90 	vmov	s15, r2
 8022922:	2300      	movs	r3, #0
 8022924:	ed9f 6a4e 	vldr	s12, [pc, #312]	@ 8022a60 <forward_lite_maxpool_is8os8_scalepos+0x1c0>
 8022928:	fb04 fb0a 	mul.w	fp, r4, sl
 802292c:	eef8 6ae7 	vcvt.f32.s32	s13, s15
 8022930:	9304      	str	r3, [sp, #16]
 8022932:	9b04      	ldr	r3, [sp, #16]
 8022934:	eef6 5a00 	vmov.f32	s11, #96	@ 0x3f000000  0.5
 8022938:	9907      	ldr	r1, [sp, #28]
 802293a:	9a12      	ldr	r2, [sp, #72]	@ 0x48
 802293c:	fb03 f202 	mul.w	r2, r3, r2
 8022940:	fb03 f301 	mul.w	r3, r3, r1
 8022944:	9910      	ldr	r1, [sp, #64]	@ 0x40
 8022946:	9308      	str	r3, [sp, #32]
 8022948:	2300      	movs	r3, #0
 802294a:	9305      	str	r3, [sp, #20]
 802294c:	1a53      	subs	r3, r2, r1
 802294e:	1a8a      	subs	r2, r1, r2
 8022950:	990c      	ldr	r1, [sp, #48]	@ 0x30
 8022952:	2b00      	cmp	r3, #0
 8022954:	eb02 0c01 	add.w	ip, r2, r1
 8022958:	bfd8      	it	le
 802295a:	4691      	movle	r9, r2
 802295c:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
 802295e:	bfc8      	it	gt
 8022960:	f04f 0900 	movgt.w	r9, #0
 8022964:	4594      	cmp	ip, r2
 8022966:	444b      	add	r3, r9
 8022968:	bfa8      	it	ge
 802296a:	4694      	movge	ip, r2
 802296c:	9a06      	ldr	r2, [sp, #24]
 802296e:	fb02 f303 	mul.w	r3, r2, r3
 8022972:	9309      	str	r3, [sp, #36]	@ 0x24
 8022974:	9a05      	ldr	r2, [sp, #20]
 8022976:	f04f 0e00 	mov.w	lr, #0
 802297a:	9908      	ldr	r1, [sp, #32]
 802297c:	9b11      	ldr	r3, [sp, #68]	@ 0x44
 802297e:	eb02 0801 	add.w	r8, r2, r1
 8022982:	990f      	ldr	r1, [sp, #60]	@ 0x3c
 8022984:	fb03 f302 	mul.w	r3, r3, r2
 8022988:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
 802298a:	9c0d      	ldr	r4, [sp, #52]	@ 0x34
 802298c:	fb0a 2808 	mla	r8, sl, r8, r2
 8022990:	1a5a      	subs	r2, r3, r1
 8022992:	1acb      	subs	r3, r1, r3
 8022994:	9906      	ldr	r1, [sp, #24]
 8022996:	2a00      	cmp	r2, #0
 8022998:	bfd8      	it	le
 802299a:	461f      	movle	r7, r3
 802299c:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 802299e:	bfc8      	it	gt
 80229a0:	2700      	movgt	r7, #0
 80229a2:	18d3      	adds	r3, r2, r3
 80229a4:	1a8a      	subs	r2, r1, r2
 80229a6:	4294      	cmp	r4, r2
 80229a8:	443b      	add	r3, r7
 80229aa:	bfa8      	it	ge
 80229ac:	4614      	movge	r4, r2
 80229ae:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 80229b0:	fb0a 2303 	mla	r3, sl, r3, r2
 80229b4:	9302      	str	r3, [sp, #8]
 80229b6:	45e1      	cmp	r9, ip
 80229b8:	da4e      	bge.n	8022a58 <forward_lite_maxpool_is8os8_scalepos+0x1b8>
 80229ba:	9b02      	ldr	r3, [sp, #8]
 80229bc:	464d      	mov	r5, r9
 80229be:	f06f 017f 	mvn.w	r1, #127	@ 0x7f
 80229c2:	eb03 060e 	add.w	r6, r3, lr
 80229c6:	42a7      	cmp	r7, r4
 80229c8:	da0a      	bge.n	80229e0 <forward_lite_maxpool_is8os8_scalepos+0x140>
 80229ca:	4632      	mov	r2, r6
 80229cc:	463b      	mov	r3, r7
 80229ce:	f992 0000 	ldrsb.w	r0, [r2]
 80229d2:	3301      	adds	r3, #1
 80229d4:	4452      	add	r2, sl
 80229d6:	4281      	cmp	r1, r0
 80229d8:	bfb8      	it	lt
 80229da:	4601      	movlt	r1, r0
 80229dc:	429c      	cmp	r4, r3
 80229de:	d1f6      	bne.n	80229ce <forward_lite_maxpool_is8os8_scalepos+0x12e>
 80229e0:	3501      	adds	r5, #1
 80229e2:	445e      	add	r6, fp
 80229e4:	45ac      	cmp	ip, r5
 80229e6:	d1ee      	bne.n	80229c6 <forward_lite_maxpool_is8os8_scalepos+0x126>
 80229e8:	9b01      	ldr	r3, [sp, #4]
 80229ea:	b1d3      	cbz	r3, 8022a22 <forward_lite_maxpool_is8os8_scalepos+0x182>
 80229ec:	f888 1000 	strb.w	r1, [r8]
 80229f0:	f10e 0e01 	add.w	lr, lr, #1
 80229f4:	f108 0801 	add.w	r8, r8, #1
 80229f8:	fa1f f38e 	uxth.w	r3, lr
 80229fc:	459a      	cmp	sl, r3
 80229fe:	d8da      	bhi.n	80229b6 <forward_lite_maxpool_is8os8_scalepos+0x116>
 8022a00:	9b05      	ldr	r3, [sp, #20]
 8022a02:	9a07      	ldr	r2, [sp, #28]
 8022a04:	3301      	adds	r3, #1
 8022a06:	b29b      	uxth	r3, r3
 8022a08:	429a      	cmp	r2, r3
 8022a0a:	9305      	str	r3, [sp, #20]
 8022a0c:	d8b2      	bhi.n	8022974 <forward_lite_maxpool_is8os8_scalepos+0xd4>
 8022a0e:	9b04      	ldr	r3, [sp, #16]
 8022a10:	9a13      	ldr	r2, [sp, #76]	@ 0x4c
 8022a12:	3301      	adds	r3, #1
 8022a14:	b29b      	uxth	r3, r3
 8022a16:	429a      	cmp	r2, r3
 8022a18:	9304      	str	r3, [sp, #16]
 8022a1a:	d88a      	bhi.n	8022932 <forward_lite_maxpool_is8os8_scalepos+0x92>
 8022a1c:	b015      	add	sp, #84	@ 0x54
 8022a1e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8022a22:	9b03      	ldr	r3, [sp, #12]
 8022a24:	eeb0 7a66 	vmov.f32	s14, s13
 8022a28:	1ac9      	subs	r1, r1, r3
 8022a2a:	ee07 1a90 	vmov	s15, r1
 8022a2e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8022a32:	eea7 7a80 	vfma.f32	s14, s15, s0
 8022a36:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
 8022a3a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8022a3e:	fe65 7a86 	vselge.f32	s15, s11, s12
 8022a42:	ee77 7a87 	vadd.f32	s15, s15, s14
 8022a46:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8022a4a:	ee17 3a90 	vmov	r3, s15
 8022a4e:	f303 0307 	ssat	r3, #8, r3
 8022a52:	f888 3000 	strb.w	r3, [r8]
 8022a56:	e7cb      	b.n	80229f0 <forward_lite_maxpool_is8os8_scalepos+0x150>
 8022a58:	f06f 017f 	mvn.w	r1, #127	@ 0x7f
 8022a5c:	e7c4      	b.n	80229e8 <forward_lite_maxpool_is8os8_scalepos+0x148>
 8022a5e:	bf00      	nop
 8022a60:	befffffc 	.word	0xbefffffc

08022a64 <forward_lite_conv2d_deep_3x3_sssa8_ch>:
 8022a64:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8022a68:	b097      	sub	sp, #92	@ 0x5c
 8022a6a:	4605      	mov	r5, r0
 8022a6c:	e9cd 130d 	strd	r1, r3, [sp, #52]	@ 0x34
 8022a70:	f8bd 10a4 	ldrh.w	r1, [sp, #164]	@ 0xa4
 8022a74:	f8bd 30a0 	ldrh.w	r3, [sp, #160]	@ 0xa0
 8022a78:	f8bd 9084 	ldrh.w	r9, [sp, #132]	@ 0x84
 8022a7c:	9e27      	ldr	r6, [sp, #156]	@ 0x9c
 8022a7e:	930f      	str	r3, [sp, #60]	@ 0x3c
 8022a80:	fb03 f301 	mul.w	r3, r3, r1
 8022a84:	f8dd b080 	ldr.w	fp, [sp, #128]	@ 0x80
 8022a88:	9110      	str	r1, [sp, #64]	@ 0x40
 8022a8a:	fb09 6303 	mla	r3, r9, r3, r6
 8022a8e:	f99d 108c 	ldrsb.w	r1, [sp, #140]	@ 0x8c
 8022a92:	f8dd a088 	ldr.w	sl, [sp, #136]	@ 0x88
 8022a96:	9113      	str	r1, [sp, #76]	@ 0x4c
 8022a98:	4298      	cmp	r0, r3
 8022a9a:	f89d 1098 	ldrb.w	r1, [sp, #152]	@ 0x98
 8022a9e:	f99d 7090 	ldrsb.w	r7, [sp, #144]	@ 0x90
 8022aa2:	9114      	str	r1, [sp, #80]	@ 0x50
 8022aa4:	d207      	bcs.n	8022ab6 <forward_lite_conv2d_deep_3x3_sssa8_ch+0x52>
 8022aa6:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 8022aa8:	fb03 f202 	mul.w	r2, r3, r2
 8022aac:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 8022aae:	fb03 0202 	mla	r2, r3, r2, r0
 8022ab2:	4296      	cmp	r6, r2
 8022ab4:	d377      	bcc.n	8022ba6 <forward_lite_conv2d_deep_3x3_sssa8_ch+0x142>
 8022ab6:	2301      	movs	r3, #1
 8022ab8:	9315      	str	r3, [sp, #84]	@ 0x54
 8022aba:	9b2b      	ldr	r3, [sp, #172]	@ 0xac
 8022abc:	4649      	mov	r1, r9
 8022abe:	9825      	ldr	r0, [sp, #148]	@ 0x94
 8022ac0:	ea4f 0849 	mov.w	r8, r9, lsl #1
 8022ac4:	eba3 0449 	sub.w	r4, r3, r9, lsl #1
 8022ac8:	9b2c      	ldr	r3, [sp, #176]	@ 0xb0
 8022aca:	441c      	add	r4, r3
 8022acc:	461a      	mov	r2, r3
 8022ace:	4623      	mov	r3, r4
 8022ad0:	f001 f956 	bl	8023d80 <align_factor_ch>
 8022ad4:	9b2c      	ldr	r3, [sp, #176]	@ 0xb0
 8022ad6:	eb03 03c9 	add.w	r3, r3, r9, lsl #3
 8022ada:	9312      	str	r3, [sp, #72]	@ 0x48
 8022adc:	9b2c      	ldr	r3, [sp, #176]	@ 0xb0
 8022ade:	eb03 0289 	add.w	r2, r3, r9, lsl #2
 8022ae2:	9211      	str	r2, [sp, #68]	@ 0x44
 8022ae4:	f1b9 0f00 	cmp.w	r9, #0
 8022ae8:	d062      	beq.n	8022bb0 <forward_lite_conv2d_deep_3x3_sssa8_ch+0x14c>
 8022aea:	4623      	mov	r3, r4
 8022aec:	1d10      	adds	r0, r2, #4
 8022aee:	f04f 0e01 	mov.w	lr, #1
 8022af2:	eb04 0c08 	add.w	ip, r4, r8
 8022af6:	f933 2b02 	ldrsh.w	r2, [r3], #2
 8022afa:	1e51      	subs	r1, r2, #1
 8022afc:	fa0e f402 	lsl.w	r4, lr, r2
 8022b00:	fa07 f202 	lsl.w	r2, r7, r2
 8022b04:	b289      	uxth	r1, r1
 8022b06:	eb02 0254 	add.w	r2, r2, r4, lsr #1
 8022b0a:	2914      	cmp	r1, #20
 8022b0c:	d844      	bhi.n	8022b98 <forward_lite_conv2d_deep_3x3_sssa8_ch+0x134>
 8022b0e:	459c      	cmp	ip, r3
 8022b10:	f840 2c04 	str.w	r2, [r0, #-4]
 8022b14:	f100 0004 	add.w	r0, r0, #4
 8022b18:	d1ed      	bne.n	8022af6 <forward_lite_conv2d_deep_3x3_sssa8_ch+0x92>
 8022b1a:	e9dd 232b 	ldrd	r2, r3, [sp, #172]	@ 0xac
 8022b1e:	189c      	adds	r4, r3, r2
 8022b20:	eba4 0408 	sub.w	r4, r4, r8
 8022b24:	e9dd 320d 	ldrd	r3, r2, [sp, #52]	@ 0x34
 8022b28:	fb13 f802 	smulbb	r8, r3, r2
 8022b2c:	9b15      	ldr	r3, [sp, #84]	@ 0x54
 8022b2e:	fa1f f888 	uxth.w	r8, r8
 8022b32:	2b00      	cmp	r3, #0
 8022b34:	d02d      	beq.n	8022b92 <forward_lite_conv2d_deep_3x3_sssa8_ch+0x12e>
 8022b36:	9a0f      	ldr	r2, [sp, #60]	@ 0x3c
 8022b38:	4659      	mov	r1, fp
 8022b3a:	2700      	movs	r7, #0
 8022b3c:	46cb      	mov	fp, r9
 8022b3e:	fb09 f002 	mul.w	r0, r9, r2
 8022b42:	4652      	mov	r2, sl
 8022b44:	4699      	mov	r9, r3
 8022b46:	46a2      	mov	sl, r4
 8022b48:	4644      	mov	r4, r8
 8022b4a:	4680      	mov	r8, r0
 8022b4c:	9b12      	ldr	r3, [sp, #72]	@ 0x48
 8022b4e:	3701      	adds	r7, #1
 8022b50:	4628      	mov	r0, r5
 8022b52:	f8cd a004 	str.w	sl, [sp, #4]
 8022b56:	930b      	str	r3, [sp, #44]	@ 0x2c
 8022b58:	4425      	add	r5, r4
 8022b5a:	9b11      	ldr	r3, [sp, #68]	@ 0x44
 8022b5c:	9222      	str	r2, [sp, #136]	@ 0x88
 8022b5e:	930a      	str	r3, [sp, #40]	@ 0x28
 8022b60:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 8022b62:	9120      	str	r1, [sp, #128]	@ 0x80
 8022b64:	9309      	str	r3, [sp, #36]	@ 0x24
 8022b66:	9b14      	ldr	r3, [sp, #80]	@ 0x50
 8022b68:	9308      	str	r3, [sp, #32]
 8022b6a:	9b13      	ldr	r3, [sp, #76]	@ 0x4c
 8022b6c:	e9cd 4306 	strd	r4, r3, [sp, #24]
 8022b70:	9b10      	ldr	r3, [sp, #64]	@ 0x40
 8022b72:	9305      	str	r3, [sp, #20]
 8022b74:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 8022b76:	9304      	str	r3, [sp, #16]
 8022b78:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 8022b7a:	e9cd b302 	strd	fp, r3, [sp, #8]
 8022b7e:	9b2c      	ldr	r3, [sp, #176]	@ 0xb0
 8022b80:	9300      	str	r3, [sp, #0]
 8022b82:	4633      	mov	r3, r6
 8022b84:	f00d fa3c 	bl	8030000 <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3>
 8022b88:	45b9      	cmp	r9, r7
 8022b8a:	4446      	add	r6, r8
 8022b8c:	9920      	ldr	r1, [sp, #128]	@ 0x80
 8022b8e:	9a22      	ldr	r2, [sp, #136]	@ 0x88
 8022b90:	d1dc      	bne.n	8022b4c <forward_lite_conv2d_deep_3x3_sssa8_ch+0xe8>
 8022b92:	b017      	add	sp, #92	@ 0x5c
 8022b94:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8022b98:	459c      	cmp	ip, r3
 8022b9a:	f840 7c04 	str.w	r7, [r0, #-4]
 8022b9e:	f100 0004 	add.w	r0, r0, #4
 8022ba2:	d1a8      	bne.n	8022af6 <forward_lite_conv2d_deep_3x3_sssa8_ch+0x92>
 8022ba4:	e7b9      	b.n	8022b1a <forward_lite_conv2d_deep_3x3_sssa8_ch+0xb6>
 8022ba6:	9b10      	ldr	r3, [sp, #64]	@ 0x40
 8022ba8:	9315      	str	r3, [sp, #84]	@ 0x54
 8022baa:	2301      	movs	r3, #1
 8022bac:	9310      	str	r3, [sp, #64]	@ 0x40
 8022bae:	e784      	b.n	8022aba <forward_lite_conv2d_deep_3x3_sssa8_ch+0x56>
 8022bb0:	9311      	str	r3, [sp, #68]	@ 0x44
 8022bb2:	e7b5      	b.n	8022b20 <forward_lite_conv2d_deep_3x3_sssa8_ch+0xbc>

08022bb4 <forward_lite_conv2d_sssa8_ch>:
 8022bb4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8022bb8:	ed2d 8b06 	vpush	{d8-d10}
 8022bbc:	b0e3      	sub	sp, #396	@ 0x18c
 8022bbe:	469a      	mov	sl, r3
 8022bc0:	4605      	mov	r5, r0
 8022bc2:	f8bd 3200 	ldrh.w	r3, [sp, #512]	@ 0x200
 8022bc6:	9215      	str	r2, [sp, #84]	@ 0x54
 8022bc8:	f8bd 2204 	ldrh.w	r2, [sp, #516]	@ 0x204
 8022bcc:	9126      	str	r1, [sp, #152]	@ 0x98
 8022bce:	9314      	str	r3, [sp, #80]	@ 0x50
 8022bd0:	f8bd 11cc 	ldrh.w	r1, [sp, #460]	@ 0x1cc
 8022bd4:	fb03 f302 	mul.w	r3, r3, r2
 8022bd8:	922f      	str	r2, [sp, #188]	@ 0xbc
 8022bda:	9a7f      	ldr	r2, [sp, #508]	@ 0x1fc
 8022bdc:	ee08 1a90 	vmov	s17, r1
 8022be0:	9320      	str	r3, [sp, #128]	@ 0x80
 8022be2:	fb01 2303 	mla	r3, r1, r3, r2
 8022be6:	f8bd 21d0 	ldrh.w	r2, [sp, #464]	@ 0x1d0
 8022bea:	f99d 91ec 	ldrsb.w	r9, [sp, #492]	@ 0x1ec
 8022bee:	922c      	str	r2, [sp, #176]	@ 0xb0
 8022bf0:	4298      	cmp	r0, r3
 8022bf2:	f8bd 21d4 	ldrh.w	r2, [sp, #468]	@ 0x1d4
 8022bf6:	f99d 61f0 	ldrsb.w	r6, [sp, #496]	@ 0x1f0
 8022bfa:	922b      	str	r2, [sp, #172]	@ 0xac
 8022bfc:	f8bd 21d8 	ldrh.w	r2, [sp, #472]	@ 0x1d8
 8022c00:	f8bd 8208 	ldrh.w	r8, [sp, #520]	@ 0x208
 8022c04:	9216      	str	r2, [sp, #88]	@ 0x58
 8022c06:	f8bd 21dc 	ldrh.w	r2, [sp, #476]	@ 0x1dc
 8022c0a:	f8dd b20c 	ldr.w	fp, [sp, #524]	@ 0x20c
 8022c0e:	9230      	str	r2, [sp, #192]	@ 0xc0
 8022c10:	f8bd 21e0 	ldrh.w	r2, [sp, #480]	@ 0x1e0
 8022c14:	922d      	str	r2, [sp, #180]	@ 0xb4
 8022c16:	f8bd 21e4 	ldrh.w	r2, [sp, #484]	@ 0x1e4
 8022c1a:	9234      	str	r2, [sp, #208]	@ 0xd0
 8022c1c:	f89d 21f8 	ldrb.w	r2, [sp, #504]	@ 0x1f8
 8022c20:	9227      	str	r2, [sp, #156]	@ 0x9c
 8022c22:	f0c0 82ef 	bcc.w	8023204 <forward_lite_conv2d_sssa8_ch+0x650>
 8022c26:	2300      	movs	r3, #0
 8022c28:	932e      	str	r3, [sp, #184]	@ 0xb8
 8022c2a:	ee18 1a90 	vmov	r1, s17
 8022c2e:	9a84      	ldr	r2, [sp, #528]	@ 0x210
 8022c30:	987d      	ldr	r0, [sp, #500]	@ 0x1f4
 8022c32:	ebab 0341 	sub.w	r3, fp, r1, lsl #1
 8022c36:	004f      	lsls	r7, r1, #1
 8022c38:	18d4      	adds	r4, r2, r3
 8022c3a:	9b27      	ldr	r3, [sp, #156]	@ 0x9c
 8022c3c:	9a2e      	ldr	r2, [sp, #184]	@ 0xb8
 8022c3e:	3b02      	subs	r3, #2
 8022c40:	2b01      	cmp	r3, #1
 8022c42:	4623      	mov	r3, r4
 8022c44:	bf98      	it	ls
 8022c46:	2200      	movls	r2, #0
 8022c48:	922e      	str	r2, [sp, #184]	@ 0xb8
 8022c4a:	9a84      	ldr	r2, [sp, #528]	@ 0x210
 8022c4c:	f001 f898 	bl	8023d80 <align_factor_ch>
 8022c50:	9b27      	ldr	r3, [sp, #156]	@ 0x9c
 8022c52:	07db      	lsls	r3, r3, #31
 8022c54:	d506      	bpl.n	8022c64 <forward_lite_conv2d_sssa8_ch+0xb0>
 8022c56:	9b14      	ldr	r3, [sp, #80]	@ 0x50
 8022c58:	9a2f      	ldr	r2, [sp, #188]	@ 0xbc
 8022c5a:	3302      	adds	r3, #2
 8022c5c:	3202      	adds	r2, #2
 8022c5e:	fb02 f303 	mul.w	r3, r2, r3
 8022c62:	9320      	str	r3, [sp, #128]	@ 0x80
 8022c64:	9b7a      	ldr	r3, [sp, #488]	@ 0x1e8
 8022c66:	ee18 2a90 	vmov	r2, s17
 8022c6a:	9972      	ldr	r1, [sp, #456]	@ 0x1c8
 8022c6c:	4650      	mov	r0, sl
 8022c6e:	9301      	str	r3, [sp, #4]
 8022c70:	9b84      	ldr	r3, [sp, #528]	@ 0x210
 8022c72:	e9cd 9302 	strd	r9, r3, [sp, #8]
 8022c76:	9b2b      	ldr	r3, [sp, #172]	@ 0xac
 8022c78:	9300      	str	r3, [sp, #0]
 8022c7a:	9b2c      	ldr	r3, [sp, #176]	@ 0xb0
 8022c7c:	f001 fb9c 	bl	80243b8 <st_sssa8_ch_convolve_rank1upd>
 8022c80:	ee18 2a90 	vmov	r2, s17
 8022c84:	9984      	ldr	r1, [sp, #528]	@ 0x210
 8022c86:	18bb      	adds	r3, r7, r2
 8022c88:	eb01 0183 	add.w	r1, r1, r3, lsl #2
 8022c8c:	e9dd 302b 	ldrd	r3, r0, [sp, #172]	@ 0xac
 8022c90:	911b      	str	r1, [sp, #108]	@ 0x6c
 8022c92:	fb10 f303 	smulbb	r3, r0, r3
 8022c96:	fb13 f30a 	smulbb	r3, r3, sl
 8022c9a:	b29b      	uxth	r3, r3
 8022c9c:	931f      	str	r3, [sp, #124]	@ 0x7c
 8022c9e:	ebc2 7342 	rsb	r3, r2, r2, lsl #29
 8022ca2:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
 8022ca6:	ee09 3a90 	vmov	s19, r3
 8022caa:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8022cae:	9325      	str	r3, [sp, #148]	@ 0x94
 8022cb0:	b1da      	cbz	r2, 8022cea <forward_lite_conv2d_sssa8_ch+0x136>
 8022cb2:	4622      	mov	r2, r4
 8022cb4:	1d18      	adds	r0, r3, #4
 8022cb6:	f04f 0c01 	mov.w	ip, #1
 8022cba:	eb04 0e07 	add.w	lr, r4, r7
 8022cbe:	f932 3b02 	ldrsh.w	r3, [r2], #2
 8022cc2:	1e59      	subs	r1, r3, #1
 8022cc4:	fa0c f403 	lsl.w	r4, ip, r3
 8022cc8:	fa06 f303 	lsl.w	r3, r6, r3
 8022ccc:	b289      	uxth	r1, r1
 8022cce:	eb03 0354 	add.w	r3, r3, r4, lsr #1
 8022cd2:	2914      	cmp	r1, #20
 8022cd4:	f200 8262 	bhi.w	802319c <forward_lite_conv2d_sssa8_ch+0x5e8>
 8022cd8:	4572      	cmp	r2, lr
 8022cda:	f840 3c04 	str.w	r3, [r0, #-4]
 8022cde:	f100 0004 	add.w	r0, r0, #4
 8022ce2:	d1ec      	bne.n	8022cbe <forward_lite_conv2d_sssa8_ch+0x10a>
 8022ce4:	9b84      	ldr	r3, [sp, #528]	@ 0x210
 8022ce6:	eb03 040b 	add.w	r4, r3, fp
 8022cea:	1be3      	subs	r3, r4, r7
 8022cec:	992b      	ldr	r1, [sp, #172]	@ 0xac
 8022cee:	9c2c      	ldr	r4, [sp, #176]	@ 0xb0
 8022cf0:	aa42      	add	r2, sp, #264	@ 0x108
 8022cf2:	9324      	str	r3, [sp, #144]	@ 0x90
 8022cf4:	a84e      	add	r0, sp, #312	@ 0x138
 8022cf6:	9b26      	ldr	r3, [sp, #152]	@ 0x98
 8022cf8:	fb01 f604 	mul.w	r6, r1, r4
 8022cfc:	914b      	str	r1, [sp, #300]	@ 0x12c
 8022cfe:	a958      	add	r1, sp, #352	@ 0x160
 8022d00:	9344      	str	r3, [sp, #272]	@ 0x110
 8022d02:	9b15      	ldr	r3, [sp, #84]	@ 0x54
 8022d04:	fb0a f704 	mul.w	r7, sl, r4
 8022d08:	944c      	str	r4, [sp, #304]	@ 0x130
 8022d0a:	9343      	str	r3, [sp, #268]	@ 0x10c
 8022d0c:	9b14      	ldr	r3, [sp, #80]	@ 0x50
 8022d0e:	9348      	str	r3, [sp, #288]	@ 0x120
 8022d10:	9b2f      	ldr	r3, [sp, #188]	@ 0xbc
 8022d12:	9347      	str	r3, [sp, #284]	@ 0x11c
 8022d14:	9b16      	ldr	r3, [sp, #88]	@ 0x58
 8022d16:	935a      	str	r3, [sp, #360]	@ 0x168
 8022d18:	9b30      	ldr	r3, [sp, #192]	@ 0xc0
 8022d1a:	935b      	str	r3, [sp, #364]	@ 0x16c
 8022d1c:	9b2d      	ldr	r3, [sp, #180]	@ 0xb4
 8022d1e:	935c      	str	r3, [sp, #368]	@ 0x170
 8022d20:	9b34      	ldr	r3, [sp, #208]	@ 0xd0
 8022d22:	935d      	str	r3, [sp, #372]	@ 0x174
 8022d24:	ab4a      	add	r3, sp, #296	@ 0x128
 8022d26:	9300      	str	r3, [sp, #0]
 8022d28:	ab46      	add	r3, sp, #280	@ 0x118
 8022d2a:	f001 faa3 	bl	8024274 <ai_padding_opt_init>
 8022d2e:	fb0a f306 	mul.w	r3, sl, r6
 8022d32:	ee18 2a90 	vmov	r2, s17
 8022d36:	992b      	ldr	r1, [sp, #172]	@ 0xac
 8022d38:	fb02 f403 	mul.w	r4, r2, r3
 8022d3c:	9a1b      	ldr	r2, [sp, #108]	@ 0x6c
 8022d3e:	fb07 f301 	mul.w	r3, r7, r1
 8022d42:	f5b4 6f20 	cmp.w	r4, #2560	@ 0xa00
 8022d46:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8022d4a:	bfa8      	it	ge
 8022d4c:	f44f 6420 	movge.w	r4, #2560	@ 0xa00
 8022d50:	f1b8 0f01 	cmp.w	r8, #1
 8022d54:	ee09 3a10 	vmov	s18, r3
 8022d58:	9b27      	ldr	r3, [sp, #156]	@ 0x9c
 8022d5a:	f003 0202 	and.w	r2, r3, #2
 8022d5e:	f3c3 0340 	ubfx	r3, r3, #1, #1
 8022d62:	9238      	str	r2, [sp, #224]	@ 0xe0
 8022d64:	9322      	str	r3, [sp, #136]	@ 0x88
 8022d66:	f000 8237 	beq.w	80231d8 <forward_lite_conv2d_sssa8_ch+0x624>
 8022d6a:	2300      	movs	r3, #0
 8022d6c:	9337      	str	r3, [sp, #220]	@ 0xdc
 8022d6e:	9b1f      	ldr	r3, [sp, #124]	@ 0x7c
 8022d70:	fbb4 f3f3 	udiv	r3, r4, r3
 8022d74:	b29b      	uxth	r3, r3
 8022d76:	4619      	mov	r1, r3
 8022d78:	ee18 3a90 	vmov	r3, s17
 8022d7c:	4299      	cmp	r1, r3
 8022d7e:	bf28      	it	cs
 8022d80:	4619      	movcs	r1, r3
 8022d82:	fbb3 f2f1 	udiv	r2, r3, r1
 8022d86:	fb01 3312 	mls	r3, r1, r2, r3
 8022d8a:	b292      	uxth	r2, r2
 8022d8c:	9121      	str	r1, [sp, #132]	@ 0x84
 8022d8e:	b29b      	uxth	r3, r3
 8022d90:	9239      	str	r2, [sp, #228]	@ 0xe4
 8022d92:	b11b      	cbz	r3, 8022d9c <forward_lite_conv2d_sssa8_ch+0x1e8>
 8022d94:	4613      	mov	r3, r2
 8022d96:	3301      	adds	r3, #1
 8022d98:	b29b      	uxth	r3, r3
 8022d9a:	9339      	str	r3, [sp, #228]	@ 0xe4
 8022d9c:	9b2e      	ldr	r3, [sp, #184]	@ 0xb8
 8022d9e:	2b01      	cmp	r3, #1
 8022da0:	f000 823d 	beq.w	802321e <forward_lite_conv2d_sssa8_ch+0x66a>
 8022da4:	9a39      	ldr	r2, [sp, #228]	@ 0xe4
 8022da6:	1e53      	subs	r3, r2, #1
 8022da8:	b29b      	uxth	r3, r3
 8022daa:	9335      	str	r3, [sp, #212]	@ 0xd4
 8022dac:	2a00      	cmp	r2, #0
 8022dae:	f000 8137 	beq.w	8023020 <forward_lite_conv2d_sssa8_ch+0x46c>
 8022db2:	fb0a f306 	mul.w	r3, sl, r6
 8022db6:	9a1b      	ldr	r2, [sp, #108]	@ 0x6c
 8022db8:	992d      	ldr	r1, [sp, #180]	@ 0xb4
 8022dba:	fa0f f689 	sxth.w	r6, r9
 8022dbe:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8022dc2:	9a26      	ldr	r2, [sp, #152]	@ 0x98
 8022dc4:	ee0a aa10 	vmov	s20, sl
 8022dc8:	46b1      	mov	r9, r6
 8022dca:	9319      	str	r3, [sp, #100]	@ 0x64
 8022dcc:	9b34      	ldr	r3, [sp, #208]	@ 0xd0
 8022dce:	edcd 8a36 	vstr	s17, [sp, #216]	@ 0xd8
 8022dd2:	fb03 f302 	mul.w	r3, r3, r2
 8022dd6:	425b      	negs	r3, r3
 8022dd8:	1a5b      	subs	r3, r3, r1
 8022dda:	fb0a 5303 	mla	r3, sl, r3, r5
 8022dde:	9339      	str	r3, [sp, #228]	@ 0xe4
 8022de0:	fb0a f302 	mul.w	r3, sl, r2
 8022de4:	9a27      	ldr	r2, [sp, #156]	@ 0x9c
 8022de6:	f1a2 0203 	sub.w	r2, r2, #3
 8022dea:	9312      	str	r3, [sp, #72]	@ 0x48
 8022dec:	fab2 f282 	clz	r2, r2
 8022df0:	0952      	lsrs	r2, r2, #5
 8022df2:	922a      	str	r2, [sp, #168]	@ 0xa8
 8022df4:	f00a 0203 	and.w	r2, sl, #3
 8022df8:	9213      	str	r2, [sp, #76]	@ 0x4c
 8022dfa:	007a      	lsls	r2, r7, #1
 8022dfc:	921c      	str	r2, [sp, #112]	@ 0x70
 8022dfe:	ea4f 024a 	mov.w	r2, sl, lsl #1
 8022e02:	9231      	str	r2, [sp, #196]	@ 0xc4
 8022e04:	9a30      	ldr	r2, [sp, #192]	@ 0xc0
 8022e06:	fb02 f303 	mul.w	r3, r2, r3
 8022e0a:	9332      	str	r3, [sp, #200]	@ 0xc8
 8022e0c:	424b      	negs	r3, r1
 8022e0e:	9333      	str	r3, [sp, #204]	@ 0xcc
 8022e10:	9b16      	ldr	r3, [sp, #88]	@ 0x58
 8022e12:	fb0a f303 	mul.w	r3, sl, r3
 8022e16:	46ba      	mov	sl, r7
 8022e18:	931a      	str	r3, [sp, #104]	@ 0x68
 8022e1a:	9b37      	ldr	r3, [sp, #220]	@ 0xdc
 8022e1c:	b953      	cbnz	r3, 8022e34 <forward_lite_conv2d_sssa8_ch+0x280>
 8022e1e:	9b13      	ldr	r3, [sp, #76]	@ 0x4c
 8022e20:	2b00      	cmp	r3, #0
 8022e22:	f040 81d1 	bne.w	80231c8 <forward_lite_conv2d_sssa8_ch+0x614>
 8022e26:	9b21      	ldr	r3, [sp, #132]	@ 0x84
 8022e28:	ee19 1a10 	vmov	r1, s18
 8022e2c:	9a1f      	ldr	r2, [sp, #124]	@ 0x7c
 8022e2e:	9872      	ldr	r0, [sp, #456]	@ 0x1c8
 8022e30:	f001 f966 	bl	8024100 <st_int8_to16_dual_interleaved>
 8022e34:	9b27      	ldr	r3, [sp, #156]	@ 0x9c
 8022e36:	2b03      	cmp	r3, #3
 8022e38:	f000 81ba 	beq.w	80231b0 <forward_lite_conv2d_sssa8_ch+0x5fc>
 8022e3c:	9b7f      	ldr	r3, [sp, #508]	@ 0x1fc
 8022e3e:	931e      	str	r3, [sp, #120]	@ 0x78
 8022e40:	9b2f      	ldr	r3, [sp, #188]	@ 0xbc
 8022e42:	2b00      	cmp	r3, #0
 8022e44:	f000 80b5 	beq.w	8022fb2 <forward_lite_conv2d_sssa8_ch+0x3fe>
 8022e48:	9b34      	ldr	r3, [sp, #208]	@ 0xd0
 8022e4a:	9a2b      	ldr	r2, [sp, #172]	@ 0xac
 8022e4c:	1ad2      	subs	r2, r2, r3
 8022e4e:	425b      	negs	r3, r3
 8022e50:	9317      	str	r3, [sp, #92]	@ 0x5c
 8022e52:	9b39      	ldr	r3, [sp, #228]	@ 0xe4
 8022e54:	9211      	str	r2, [sp, #68]	@ 0x44
 8022e56:	9323      	str	r3, [sp, #140]	@ 0x8c
 8022e58:	9b1b      	ldr	r3, [sp, #108]	@ 0x6c
 8022e5a:	930a      	str	r3, [sp, #40]	@ 0x28
 8022e5c:	9b2e      	ldr	r3, [sp, #184]	@ 0xb8
 8022e5e:	9329      	str	r3, [sp, #164]	@ 0xa4
 8022e60:	a84e      	add	r0, sp, #312	@ 0x138
 8022e62:	f001 fa61 	bl	8024328 <ai_padding_opt_phase1>
 8022e66:	9b14      	ldr	r3, [sp, #80]	@ 0x50
 8022e68:	2b00      	cmp	r3, #0
 8022e6a:	d074      	beq.n	8022f56 <forward_lite_conv2d_sssa8_ch+0x3a2>
 8022e6c:	9a17      	ldr	r2, [sp, #92]	@ 0x5c
 8022e6e:	9b11      	ldr	r3, [sp, #68]	@ 0x44
 8022e70:	991c      	ldr	r1, [sp, #112]	@ 0x70
 8022e72:	1a9b      	subs	r3, r3, r2
 8022e74:	fb01 f303 	mul.w	r3, r1, r3
 8022e78:	931d      	str	r3, [sp, #116]	@ 0x74
 8022e7a:	e9dd 312c 	ldrd	r3, r1, [sp, #176]	@ 0xb0
 8022e7e:	1a5f      	subs	r7, r3, r1
 8022e80:	9b2b      	ldr	r3, [sp, #172]	@ 0xac
 8022e82:	4413      	add	r3, r2
 8022e84:	9328      	str	r3, [sp, #160]	@ 0xa0
 8022e86:	9b33      	ldr	r3, [sp, #204]	@ 0xcc
 8022e88:	930c      	str	r3, [sp, #48]	@ 0x30
 8022e8a:	9b23      	ldr	r3, [sp, #140]	@ 0x8c
 8022e8c:	930f      	str	r3, [sp, #60]	@ 0x3c
 8022e8e:	9b2e      	ldr	r3, [sp, #184]	@ 0xb8
 8022e90:	9310      	str	r3, [sp, #64]	@ 0x40
 8022e92:	9b4e      	ldr	r3, [sp, #312]	@ 0x138
 8022e94:	2b00      	cmp	r3, #0
 8022e96:	f000 80d9 	beq.w	802304c <forward_lite_conv2d_sssa8_ch+0x498>
 8022e9a:	3b01      	subs	r3, #1
 8022e9c:	934e      	str	r3, [sp, #312]	@ 0x138
 8022e9e:	2301      	movs	r3, #1
 8022ea0:	f8ad 315e 	strh.w	r3, [sp, #350]	@ 0x15e
 8022ea4:	9b17      	ldr	r3, [sp, #92]	@ 0x5c
 8022ea6:	9a28      	ldr	r2, [sp, #160]	@ 0xa0
 8022ea8:	4293      	cmp	r3, r2
 8022eaa:	da40      	bge.n	8022f2e <forward_lite_conv2d_sssa8_ch+0x37a>
 8022eac:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 8022eae:	ee08 aa10 	vmov	s16, sl
 8022eb2:	9d31      	ldr	r5, [sp, #196]	@ 0xc4
 8022eb4:	ee1a 8a10 	vmov	r8, s20
 8022eb8:	1afb      	subs	r3, r7, r3
 8022eba:	9e26      	ldr	r6, [sp, #152]	@ 0x98
 8022ebc:	fb05 f303 	mul.w	r3, r5, r3
 8022ec0:	9318      	str	r3, [sp, #96]	@ 0x60
 8022ec2:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 8022ec4:	930d      	str	r3, [sp, #52]	@ 0x34
 8022ec6:	9b17      	ldr	r3, [sp, #92]	@ 0x5c
 8022ec8:	930e      	str	r3, [sp, #56]	@ 0x38
 8022eca:	9c0c      	ldr	r4, [sp, #48]	@ 0x30
 8022ecc:	42bc      	cmp	r4, r7
 8022ece:	da22      	bge.n	8022f16 <forward_lite_conv2d_sssa8_ch+0x362>
 8022ed0:	9b15      	ldr	r3, [sp, #84]	@ 0x54
 8022ed2:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
 8022ed4:	f8dd b034 	ldr.w	fp, [sp, #52]	@ 0x34
 8022ed8:	4293      	cmp	r3, r2
 8022eda:	f8dd a028 	ldr.w	sl, [sp, #40]	@ 0x28
 8022ede:	bf8c      	ite	hi
 8022ee0:	2300      	movhi	r3, #0
 8022ee2:	2301      	movls	r3, #1
 8022ee4:	930b      	str	r3, [sp, #44]	@ 0x2c
 8022ee6:	9b13      	ldr	r3, [sp, #76]	@ 0x4c
 8022ee8:	2b00      	cmp	r3, #0
 8022eea:	f000 809e 	beq.w	802302a <forward_lite_conv2d_sssa8_ch+0x476>
 8022eee:	42a6      	cmp	r6, r4
 8022ef0:	4651      	mov	r1, sl
 8022ef2:	4642      	mov	r2, r8
 8022ef4:	4648      	mov	r0, r9
 8022ef6:	d903      	bls.n	8022f00 <forward_lite_conv2d_sssa8_ch+0x34c>
 8022ef8:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 8022efa:	2b00      	cmp	r3, #0
 8022efc:	f000 8124 	beq.w	8023148 <forward_lite_conv2d_sssa8_ch+0x594>
 8022f00:	f001 fa2c 	bl	802435c <st_int16_fill>
 8022f04:	3401      	adds	r4, #1
 8022f06:	44aa      	add	sl, r5
 8022f08:	44c3      	add	fp, r8
 8022f0a:	42bc      	cmp	r4, r7
 8022f0c:	d1ef      	bne.n	8022eee <forward_lite_conv2d_sssa8_ch+0x33a>
 8022f0e:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8022f10:	9a18      	ldr	r2, [sp, #96]	@ 0x60
 8022f12:	4413      	add	r3, r2
 8022f14:	930a      	str	r3, [sp, #40]	@ 0x28
 8022f16:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
 8022f18:	9912      	ldr	r1, [sp, #72]	@ 0x48
 8022f1a:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 8022f1c:	440a      	add	r2, r1
 8022f1e:	3301      	adds	r3, #1
 8022f20:	920d      	str	r2, [sp, #52]	@ 0x34
 8022f22:	9a11      	ldr	r2, [sp, #68]	@ 0x44
 8022f24:	930e      	str	r3, [sp, #56]	@ 0x38
 8022f26:	4293      	cmp	r3, r2
 8022f28:	d1cf      	bne.n	8022eca <forward_lite_conv2d_sssa8_ch+0x316>
 8022f2a:	ee18 aa10 	vmov	sl, s16
 8022f2e:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 8022f30:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 8022f32:	4293      	cmp	r3, r2
 8022f34:	f000 80bf 	beq.w	80230b6 <forward_lite_conv2d_sssa8_ch+0x502>
 8022f38:	9a0f      	ldr	r2, [sp, #60]	@ 0x3c
 8022f3a:	991a      	ldr	r1, [sp, #104]	@ 0x68
 8022f3c:	9b10      	ldr	r3, [sp, #64]	@ 0x40
 8022f3e:	440a      	add	r2, r1
 8022f40:	9916      	ldr	r1, [sp, #88]	@ 0x58
 8022f42:	3301      	adds	r3, #1
 8022f44:	920f      	str	r2, [sp, #60]	@ 0x3c
 8022f46:	440f      	add	r7, r1
 8022f48:	9a0c      	ldr	r2, [sp, #48]	@ 0x30
 8022f4a:	9310      	str	r3, [sp, #64]	@ 0x40
 8022f4c:	440a      	add	r2, r1
 8022f4e:	920c      	str	r2, [sp, #48]	@ 0x30
 8022f50:	9a14      	ldr	r2, [sp, #80]	@ 0x50
 8022f52:	429a      	cmp	r2, r3
 8022f54:	d19d      	bne.n	8022e92 <forward_lite_conv2d_sssa8_ch+0x2de>
 8022f56:	9930      	ldr	r1, [sp, #192]	@ 0xc0
 8022f58:	9a11      	ldr	r2, [sp, #68]	@ 0x44
 8022f5a:	9b29      	ldr	r3, [sp, #164]	@ 0xa4
 8022f5c:	440a      	add	r2, r1
 8022f5e:	3301      	adds	r3, #1
 8022f60:	9211      	str	r2, [sp, #68]	@ 0x44
 8022f62:	9a17      	ldr	r2, [sp, #92]	@ 0x5c
 8022f64:	9329      	str	r3, [sp, #164]	@ 0xa4
 8022f66:	440a      	add	r2, r1
 8022f68:	9932      	ldr	r1, [sp, #200]	@ 0xc8
 8022f6a:	9217      	str	r2, [sp, #92]	@ 0x5c
 8022f6c:	9a23      	ldr	r2, [sp, #140]	@ 0x8c
 8022f6e:	440a      	add	r2, r1
 8022f70:	9223      	str	r2, [sp, #140]	@ 0x8c
 8022f72:	9a2f      	ldr	r2, [sp, #188]	@ 0xbc
 8022f74:	429a      	cmp	r2, r3
 8022f76:	f47f af73 	bne.w	8022e60 <forward_lite_conv2d_sssa8_ch+0x2ac>
 8022f7a:	991b      	ldr	r1, [sp, #108]	@ 0x6c
 8022f7c:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8022f7e:	4299      	cmp	r1, r3
 8022f80:	d017      	beq.n	8022fb2 <forward_lite_conv2d_sssa8_ch+0x3fe>
 8022f82:	9b1e      	ldr	r3, [sp, #120]	@ 0x78
 8022f84:	ee19 2a90 	vmov	r2, s19
 8022f88:	ee19 0a10 	vmov	r0, s18
 8022f8c:	9307      	str	r3, [sp, #28]
 8022f8e:	9b22      	ldr	r3, [sp, #136]	@ 0x88
 8022f90:	9306      	str	r3, [sp, #24]
 8022f92:	9b25      	ldr	r3, [sp, #148]	@ 0x94
 8022f94:	9305      	str	r3, [sp, #20]
 8022f96:	9b84      	ldr	r3, [sp, #528]	@ 0x210
 8022f98:	9304      	str	r3, [sp, #16]
 8022f9a:	9b24      	ldr	r3, [sp, #144]	@ 0x90
 8022f9c:	9303      	str	r3, [sp, #12]
 8022f9e:	9b1f      	ldr	r3, [sp, #124]	@ 0x7c
 8022fa0:	9302      	str	r3, [sp, #8]
 8022fa2:	9b21      	ldr	r3, [sp, #132]	@ 0x84
 8022fa4:	9301      	str	r3, [sp, #4]
 8022fa6:	9b20      	ldr	r3, [sp, #128]	@ 0x80
 8022fa8:	9300      	str	r3, [sp, #0]
 8022faa:	ee18 3a90 	vmov	r3, s17
 8022fae:	f001 fe41 	bl	8024c34 <st_sssa8_ch_nn_mat_mult_kernel_single_opt>
 8022fb2:	9a21      	ldr	r2, [sp, #132]	@ 0x84
 8022fb4:	9b36      	ldr	r3, [sp, #216]	@ 0xd8
 8022fb6:	1a9b      	subs	r3, r3, r2
 8022fb8:	b299      	uxth	r1, r3
 8022fba:	4613      	mov	r3, r2
 8022fbc:	428a      	cmp	r2, r1
 8022fbe:	9136      	str	r1, [sp, #216]	@ 0xd8
 8022fc0:	bf28      	it	cs
 8022fc2:	460b      	movcs	r3, r1
 8022fc4:	2b00      	cmp	r3, #0
 8022fc6:	f000 80f1 	beq.w	80231ac <forward_lite_conv2d_sssa8_ch+0x5f8>
 8022fca:	9972      	ldr	r1, [sp, #456]	@ 0x1c8
 8022fcc:	981f      	ldr	r0, [sp, #124]	@ 0x7c
 8022fce:	fb00 1102 	mla	r1, r0, r2, r1
 8022fd2:	9172      	str	r1, [sp, #456]	@ 0x1c8
 8022fd4:	ee19 1a90 	vmov	r1, s19
 8022fd8:	eb01 0182 	add.w	r1, r1, r2, lsl #2
 8022fdc:	ee09 1a90 	vmov	s19, r1
 8022fe0:	9924      	ldr	r1, [sp, #144]	@ 0x90
 8022fe2:	eb01 0142 	add.w	r1, r1, r2, lsl #1
 8022fe6:	9124      	str	r1, [sp, #144]	@ 0x90
 8022fe8:	9984      	ldr	r1, [sp, #528]	@ 0x210
 8022fea:	eb01 0182 	add.w	r1, r1, r2, lsl #2
 8022fee:	9184      	str	r1, [sp, #528]	@ 0x210
 8022ff0:	9925      	ldr	r1, [sp, #148]	@ 0x94
 8022ff2:	eb01 0182 	add.w	r1, r1, r2, lsl #2
 8022ff6:	9125      	str	r1, [sp, #148]	@ 0x94
 8022ff8:	9938      	ldr	r1, [sp, #224]	@ 0xe0
 8022ffa:	2900      	cmp	r1, #0
 8022ffc:	f000 80de 	beq.w	80231bc <forward_lite_conv2d_sssa8_ch+0x608>
 8023000:	997f      	ldr	r1, [sp, #508]	@ 0x1fc
 8023002:	9820      	ldr	r0, [sp, #128]	@ 0x80
 8023004:	9321      	str	r3, [sp, #132]	@ 0x84
 8023006:	fb00 1202 	mla	r2, r0, r2, r1
 802300a:	927f      	str	r2, [sp, #508]	@ 0x1fc
 802300c:	9b35      	ldr	r3, [sp, #212]	@ 0xd4
 802300e:	3b01      	subs	r3, #1
 8023010:	b29b      	uxth	r3, r3
 8023012:	461a      	mov	r2, r3
 8023014:	9335      	str	r3, [sp, #212]	@ 0xd4
 8023016:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 802301a:	429a      	cmp	r2, r3
 802301c:	f47f aefd 	bne.w	8022e1a <forward_lite_conv2d_sssa8_ch+0x266>
 8023020:	b063      	add	sp, #396	@ 0x18c
 8023022:	ecbd 8b06 	vpop	{d8-d10}
 8023026:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802302a:	42a6      	cmp	r6, r4
 802302c:	4642      	mov	r2, r8
 802302e:	4651      	mov	r1, sl
 8023030:	4648      	mov	r0, r9
 8023032:	d903      	bls.n	802303c <forward_lite_conv2d_sssa8_ch+0x488>
 8023034:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 8023036:	2b00      	cmp	r3, #0
 8023038:	f000 8082 	beq.w	8023140 <forward_lite_conv2d_sssa8_ch+0x58c>
 802303c:	f001 f98e 	bl	802435c <st_int16_fill>
 8023040:	3401      	adds	r4, #1
 8023042:	44aa      	add	sl, r5
 8023044:	44c3      	add	fp, r8
 8023046:	42bc      	cmp	r4, r7
 8023048:	d1ef      	bne.n	802302a <forward_lite_conv2d_sssa8_ch+0x476>
 802304a:	e760      	b.n	8022f0e <forward_lite_conv2d_sssa8_ch+0x35a>
 802304c:	9b4f      	ldr	r3, [sp, #316]	@ 0x13c
 802304e:	b933      	cbnz	r3, 802305e <forward_lite_conv2d_sssa8_ch+0x4aa>
 8023050:	9b50      	ldr	r3, [sp, #320]	@ 0x140
 8023052:	3b01      	subs	r3, #1
 8023054:	9350      	str	r3, [sp, #320]	@ 0x140
 8023056:	2301      	movs	r3, #1
 8023058:	f8ad 315e 	strh.w	r3, [sp, #350]	@ 0x15e
 802305c:	e722      	b.n	8022ea4 <forward_lite_conv2d_sssa8_ch+0x2f0>
 802305e:	3b01      	subs	r3, #1
 8023060:	934f      	str	r3, [sp, #316]	@ 0x13c
 8023062:	f8bd 315c 	ldrh.w	r3, [sp, #348]	@ 0x15c
 8023066:	2b01      	cmp	r3, #1
 8023068:	f8ad 315e 	strh.w	r3, [sp, #350]	@ 0x15e
 802306c:	f43f af1a 	beq.w	8022ea4 <forward_lite_conv2d_sssa8_ch+0x2f0>
 8023070:	9b13      	ldr	r3, [sp, #76]	@ 0x4c
 8023072:	9c17      	ldr	r4, [sp, #92]	@ 0x5c
 8023074:	2b00      	cmp	r3, #0
 8023076:	d148      	bne.n	802310a <forward_lite_conv2d_sssa8_ch+0x556>
 8023078:	9b11      	ldr	r3, [sp, #68]	@ 0x44
 802307a:	429c      	cmp	r4, r3
 802307c:	f6bf af57 	bge.w	8022f2e <forward_lite_conv2d_sssa8_ch+0x37a>
 8023080:	970b      	str	r7, [sp, #44]	@ 0x2c
 8023082:	4698      	mov	r8, r3
 8023084:	9e0f      	ldr	r6, [sp, #60]	@ 0x3c
 8023086:	9d0a      	ldr	r5, [sp, #40]	@ 0x28
 8023088:	f8dd b070 	ldr.w	fp, [sp, #112]	@ 0x70
 802308c:	9f12      	ldr	r7, [sp, #72]	@ 0x48
 802308e:	3401      	adds	r4, #1
 8023090:	4629      	mov	r1, r5
 8023092:	4630      	mov	r0, r6
 8023094:	4652      	mov	r2, sl
 8023096:	f000 ff05 	bl	8023ea4 <st_int8_to16_no_shift_interleaved>
 802309a:	4544      	cmp	r4, r8
 802309c:	445d      	add	r5, fp
 802309e:	443e      	add	r6, r7
 80230a0:	d1f5      	bne.n	802308e <forward_lite_conv2d_sssa8_ch+0x4da>
 80230a2:	9a1d      	ldr	r2, [sp, #116]	@ 0x74
 80230a4:	e9dd 370a 	ldrd	r3, r7, [sp, #40]	@ 0x28
 80230a8:	4413      	add	r3, r2
 80230aa:	930a      	str	r3, [sp, #40]	@ 0x28
 80230ac:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 80230ae:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 80230b0:	4293      	cmp	r3, r2
 80230b2:	f47f af41 	bne.w	8022f38 <forward_lite_conv2d_sssa8_ch+0x384>
 80230b6:	9b10      	ldr	r3, [sp, #64]	@ 0x40
 80230b8:	2b00      	cmp	r3, #0
 80230ba:	d149      	bne.n	8023150 <forward_lite_conv2d_sssa8_ch+0x59c>
 80230bc:	9b2a      	ldr	r3, [sp, #168]	@ 0xa8
 80230be:	2b00      	cmp	r3, #0
 80230c0:	d046      	beq.n	8023150 <forward_lite_conv2d_sssa8_ch+0x59c>
 80230c2:	9b1e      	ldr	r3, [sp, #120]	@ 0x78
 80230c4:	ee19 2a90 	vmov	r2, s19
 80230c8:	991b      	ldr	r1, [sp, #108]	@ 0x6c
 80230ca:	ee19 0a10 	vmov	r0, s18
 80230ce:	9308      	str	r3, [sp, #32]
 80230d0:	9b22      	ldr	r3, [sp, #136]	@ 0x88
 80230d2:	9307      	str	r3, [sp, #28]
 80230d4:	9b25      	ldr	r3, [sp, #148]	@ 0x94
 80230d6:	9306      	str	r3, [sp, #24]
 80230d8:	9b84      	ldr	r3, [sp, #528]	@ 0x210
 80230da:	9305      	str	r3, [sp, #20]
 80230dc:	9b24      	ldr	r3, [sp, #144]	@ 0x90
 80230de:	9304      	str	r3, [sp, #16]
 80230e0:	9b1f      	ldr	r3, [sp, #124]	@ 0x7c
 80230e2:	9303      	str	r3, [sp, #12]
 80230e4:	9b21      	ldr	r3, [sp, #132]	@ 0x84
 80230e6:	9302      	str	r3, [sp, #8]
 80230e8:	9b20      	ldr	r3, [sp, #128]	@ 0x80
 80230ea:	9300      	str	r3, [sp, #0]
 80230ec:	2302      	movs	r3, #2
 80230ee:	9301      	str	r3, [sp, #4]
 80230f0:	ee18 3a90 	vmov	r3, s17
 80230f4:	f00d fd3e 	bl	8030b74 <st_sssa8_ch_nn_mat_mult_kernel_opt>
 80230f8:	901e      	str	r0, [sp, #120]	@ 0x78
 80230fa:	9b14      	ldr	r3, [sp, #80]	@ 0x50
 80230fc:	9a10      	ldr	r2, [sp, #64]	@ 0x40
 80230fe:	3b01      	subs	r3, #1
 8023100:	4293      	cmp	r3, r2
 8023102:	d045      	beq.n	8023190 <forward_lite_conv2d_sssa8_ch+0x5dc>
 8023104:	9b1b      	ldr	r3, [sp, #108]	@ 0x6c
 8023106:	930a      	str	r3, [sp, #40]	@ 0x28
 8023108:	e716      	b.n	8022f38 <forward_lite_conv2d_sssa8_ch+0x384>
 802310a:	9b11      	ldr	r3, [sp, #68]	@ 0x44
 802310c:	429c      	cmp	r4, r3
 802310e:	f6bf af0e 	bge.w	8022f2e <forward_lite_conv2d_sssa8_ch+0x37a>
 8023112:	970b      	str	r7, [sp, #44]	@ 0x2c
 8023114:	4698      	mov	r8, r3
 8023116:	9e0f      	ldr	r6, [sp, #60]	@ 0x3c
 8023118:	9d0a      	ldr	r5, [sp, #40]	@ 0x28
 802311a:	f8dd b070 	ldr.w	fp, [sp, #112]	@ 0x70
 802311e:	9f12      	ldr	r7, [sp, #72]	@ 0x48
 8023120:	3401      	adds	r4, #1
 8023122:	4629      	mov	r1, r5
 8023124:	4630      	mov	r0, r6
 8023126:	4652      	mov	r2, sl
 8023128:	f000 fe5a 	bl	8023de0 <st_int8_to16_no_shift>
 802312c:	4544      	cmp	r4, r8
 802312e:	445d      	add	r5, fp
 8023130:	443e      	add	r6, r7
 8023132:	d1f5      	bne.n	8023120 <forward_lite_conv2d_sssa8_ch+0x56c>
 8023134:	9a1d      	ldr	r2, [sp, #116]	@ 0x74
 8023136:	e9dd 370a 	ldrd	r3, r7, [sp, #40]	@ 0x28
 802313a:	4413      	add	r3, r2
 802313c:	930a      	str	r3, [sp, #40]	@ 0x28
 802313e:	e7b5      	b.n	80230ac <forward_lite_conv2d_sssa8_ch+0x4f8>
 8023140:	4658      	mov	r0, fp
 8023142:	f000 feaf 	bl	8023ea4 <st_int8_to16_no_shift_interleaved>
 8023146:	e77b      	b.n	8023040 <forward_lite_conv2d_sssa8_ch+0x48c>
 8023148:	4658      	mov	r0, fp
 802314a:	f000 fe49 	bl	8023de0 <st_int8_to16_no_shift>
 802314e:	e6d9      	b.n	8022f04 <forward_lite_conv2d_sssa8_ch+0x350>
 8023150:	9b1e      	ldr	r3, [sp, #120]	@ 0x78
 8023152:	ee19 2a90 	vmov	r2, s19
 8023156:	991b      	ldr	r1, [sp, #108]	@ 0x6c
 8023158:	ee19 0a10 	vmov	r0, s18
 802315c:	9308      	str	r3, [sp, #32]
 802315e:	9b22      	ldr	r3, [sp, #136]	@ 0x88
 8023160:	9307      	str	r3, [sp, #28]
 8023162:	9b25      	ldr	r3, [sp, #148]	@ 0x94
 8023164:	9306      	str	r3, [sp, #24]
 8023166:	9b84      	ldr	r3, [sp, #528]	@ 0x210
 8023168:	9305      	str	r3, [sp, #20]
 802316a:	9b24      	ldr	r3, [sp, #144]	@ 0x90
 802316c:	9304      	str	r3, [sp, #16]
 802316e:	9b1f      	ldr	r3, [sp, #124]	@ 0x7c
 8023170:	9303      	str	r3, [sp, #12]
 8023172:	9b21      	ldr	r3, [sp, #132]	@ 0x84
 8023174:	9302      	str	r3, [sp, #8]
 8023176:	9b20      	ldr	r3, [sp, #128]	@ 0x80
 8023178:	9300      	str	r3, [sp, #0]
 802317a:	2300      	movs	r3, #0
 802317c:	9301      	str	r3, [sp, #4]
 802317e:	ee18 3a90 	vmov	r3, s17
 8023182:	f00d fcf7 	bl	8030b74 <st_sssa8_ch_nn_mat_mult_kernel_opt>
 8023186:	9b27      	ldr	r3, [sp, #156]	@ 0x9c
 8023188:	901e      	str	r0, [sp, #120]	@ 0x78
 802318a:	2b03      	cmp	r3, #3
 802318c:	d1ba      	bne.n	8023104 <forward_lite_conv2d_sssa8_ch+0x550>
 802318e:	e7b4      	b.n	80230fa <forward_lite_conv2d_sssa8_ch+0x546>
 8023190:	9b1e      	ldr	r3, [sp, #120]	@ 0x78
 8023192:	3302      	adds	r3, #2
 8023194:	931e      	str	r3, [sp, #120]	@ 0x78
 8023196:	9b1b      	ldr	r3, [sp, #108]	@ 0x6c
 8023198:	930a      	str	r3, [sp, #40]	@ 0x28
 802319a:	e6cd      	b.n	8022f38 <forward_lite_conv2d_sssa8_ch+0x384>
 802319c:	4572      	cmp	r2, lr
 802319e:	f840 6c04 	str.w	r6, [r0, #-4]
 80231a2:	f100 0004 	add.w	r0, r0, #4
 80231a6:	f47f ad8a 	bne.w	8022cbe <forward_lite_conv2d_sssa8_ch+0x10a>
 80231aa:	e59b      	b.n	8022ce4 <forward_lite_conv2d_sssa8_ch+0x130>
 80231ac:	9321      	str	r3, [sp, #132]	@ 0x84
 80231ae:	e72d      	b.n	802300c <forward_lite_conv2d_sssa8_ch+0x458>
 80231b0:	9b14      	ldr	r3, [sp, #80]	@ 0x50
 80231b2:	9a7f      	ldr	r2, [sp, #508]	@ 0x1fc
 80231b4:	3303      	adds	r3, #3
 80231b6:	18d3      	adds	r3, r2, r3
 80231b8:	931e      	str	r3, [sp, #120]	@ 0x78
 80231ba:	e641      	b.n	8022e40 <forward_lite_conv2d_sssa8_ch+0x28c>
 80231bc:	4611      	mov	r1, r2
 80231be:	9a7f      	ldr	r2, [sp, #508]	@ 0x1fc
 80231c0:	9321      	str	r3, [sp, #132]	@ 0x84
 80231c2:	440a      	add	r2, r1
 80231c4:	927f      	str	r2, [sp, #508]	@ 0x1fc
 80231c6:	e721      	b.n	802300c <forward_lite_conv2d_sssa8_ch+0x458>
 80231c8:	9b21      	ldr	r3, [sp, #132]	@ 0x84
 80231ca:	ee19 1a10 	vmov	r1, s18
 80231ce:	9a1f      	ldr	r2, [sp, #124]	@ 0x7c
 80231d0:	9872      	ldr	r0, [sp, #456]	@ 0x1c8
 80231d2:	f000 feab 	bl	8023f2c <st_int8_to16_dual>
 80231d6:	e62d      	b.n	8022e34 <forward_lite_conv2d_sssa8_ch+0x280>
 80231d8:	ee18 1a90 	vmov	r1, s17
 80231dc:	9a1f      	ldr	r2, [sp, #124]	@ 0x7c
 80231de:	fb02 f301 	mul.w	r3, r2, r1
 80231e2:	42a3      	cmp	r3, r4
 80231e4:	f73f adc1 	bgt.w	8022d6a <forward_lite_conv2d_sssa8_ch+0x1b6>
 80231e8:	f01a 0f03 	tst.w	sl, #3
 80231ec:	f8cd 80dc 	str.w	r8, [sp, #220]	@ 0xdc
 80231f0:	f040 822e 	bne.w	8023650 <forward_lite_conv2d_sssa8_ch+0xa9c>
 80231f4:	ee18 3a90 	vmov	r3, s17
 80231f8:	ee19 1a10 	vmov	r1, s18
 80231fc:	9872      	ldr	r0, [sp, #456]	@ 0x1c8
 80231fe:	f000 ff7f 	bl	8024100 <st_int8_to16_dual_interleaved>
 8023202:	e5b4      	b.n	8022d6e <forward_lite_conv2d_sssa8_ch+0x1ba>
 8023204:	9a26      	ldr	r2, [sp, #152]	@ 0x98
 8023206:	9b15      	ldr	r3, [sp, #84]	@ 0x54
 8023208:	fb02 f303 	mul.w	r3, r2, r3
 802320c:	9a7f      	ldr	r2, [sp, #508]	@ 0x1fc
 802320e:	fb0a 0303 	mla	r3, sl, r3, r0
 8023212:	429a      	cmp	r2, r3
 8023214:	bf2c      	ite	cs
 8023216:	2300      	movcs	r3, #0
 8023218:	2301      	movcc	r3, #1
 802321a:	932e      	str	r3, [sp, #184]	@ 0xb8
 802321c:	e505      	b.n	8022c2a <forward_lite_conv2d_sssa8_ch+0x76>
 802321e:	9b2f      	ldr	r3, [sp, #188]	@ 0xbc
 8023220:	2b00      	cmp	r3, #0
 8023222:	f43f aefd 	beq.w	8023020 <forward_lite_conv2d_sssa8_ch+0x46c>
 8023226:	9a2e      	ldr	r2, [sp, #184]	@ 0xb8
 8023228:	fb0a f306 	mul.w	r3, sl, r6
 802322c:	9926      	ldr	r1, [sp, #152]	@ 0x98
 802322e:	fa0f f989 	sxth.w	r9, r9
 8023232:	9238      	str	r2, [sp, #224]	@ 0xe0
 8023234:	ee0a aa90 	vmov	s21, sl
 8023238:	9a1b      	ldr	r2, [sp, #108]	@ 0x6c
 802323a:	fb01 f40a 	mul.w	r4, r1, sl
 802323e:	982d      	ldr	r0, [sp, #180]	@ 0xb4
 8023240:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8023244:	9a34      	ldr	r2, [sp, #208]	@ 0xd0
 8023246:	9413      	str	r4, [sp, #76]	@ 0x4c
 8023248:	931a      	str	r3, [sp, #104]	@ 0x68
 802324a:	fb01 f302 	mul.w	r3, r1, r2
 802324e:	9914      	ldr	r1, [sp, #80]	@ 0x50
 8023250:	425b      	negs	r3, r3
 8023252:	1a1b      	subs	r3, r3, r0
 8023254:	fb0a 5303 	mla	r3, sl, r3, r5
 8023258:	9d7f      	ldr	r5, [sp, #508]	@ 0x1fc
 802325a:	9335      	str	r3, [sp, #212]	@ 0xd4
 802325c:	9b39      	ldr	r3, [sp, #228]	@ 0xe4
 802325e:	953c      	str	r5, [sp, #240]	@ 0xf0
 8023260:	3b01      	subs	r3, #1
 8023262:	b29b      	uxth	r3, r3
 8023264:	9341      	str	r3, [sp, #260]	@ 0x104
 8023266:	1ccb      	adds	r3, r1, #3
 8023268:	18eb      	adds	r3, r5, r3
 802326a:	933b      	str	r3, [sp, #236]	@ 0xec
 802326c:	f00a 0303 	and.w	r3, sl, #3
 8023270:	9312      	str	r3, [sp, #72]	@ 0x48
 8023272:	007b      	lsls	r3, r7, #1
 8023274:	931c      	str	r3, [sp, #112]	@ 0x70
 8023276:	ea4f 034a 	mov.w	r3, sl, lsl #1
 802327a:	9334      	str	r3, [sp, #208]	@ 0xd0
 802327c:	9b2b      	ldr	r3, [sp, #172]	@ 0xac
 802327e:	1a9b      	subs	r3, r3, r2
 8023280:	9310      	str	r3, [sp, #64]	@ 0x40
 8023282:	4253      	negs	r3, r2
 8023284:	9318      	str	r3, [sp, #96]	@ 0x60
 8023286:	9b30      	ldr	r3, [sp, #192]	@ 0xc0
 8023288:	fb03 f304 	mul.w	r3, r3, r4
 802328c:	933e      	str	r3, [sp, #248]	@ 0xf8
 802328e:	4243      	negs	r3, r0
 8023290:	a84e      	add	r0, sp, #312	@ 0x138
 8023292:	933a      	str	r3, [sp, #232]	@ 0xe8
 8023294:	1c8b      	adds	r3, r1, #2
 8023296:	9340      	str	r3, [sp, #256]	@ 0x100
 8023298:	ee18 3a90 	vmov	r3, s17
 802329c:	fb01 f303 	mul.w	r3, r1, r3
 80232a0:	933f      	str	r3, [sp, #252]	@ 0xfc
 80232a2:	9b16      	ldr	r3, [sp, #88]	@ 0x58
 80232a4:	fb03 f30a 	mul.w	r3, r3, sl
 80232a8:	46ca      	mov	sl, r9
 80232aa:	9319      	str	r3, [sp, #100]	@ 0x64
 80232ac:	f001 f83c 	bl	8024328 <ai_padding_opt_phase1>
 80232b0:	9b27      	ldr	r3, [sp, #156]	@ 0x9c
 80232b2:	2b03      	cmp	r3, #3
 80232b4:	f000 81b6 	beq.w	8023624 <forward_lite_conv2d_sssa8_ch+0xa70>
 80232b8:	9b3c      	ldr	r3, [sp, #240]	@ 0xf0
 80232ba:	9328      	str	r3, [sp, #160]	@ 0xa0
 80232bc:	9b38      	ldr	r3, [sp, #224]	@ 0xe0
 80232be:	933d      	str	r3, [sp, #244]	@ 0xf4
 80232c0:	9b37      	ldr	r3, [sp, #220]	@ 0xdc
 80232c2:	b953      	cbnz	r3, 80232da <forward_lite_conv2d_sssa8_ch+0x726>
 80232c4:	9b12      	ldr	r3, [sp, #72]	@ 0x48
 80232c6:	2b00      	cmp	r3, #0
 80232c8:	f040 81ba 	bne.w	8023640 <forward_lite_conv2d_sssa8_ch+0xa8c>
 80232cc:	9b21      	ldr	r3, [sp, #132]	@ 0x84
 80232ce:	ee19 1a10 	vmov	r1, s18
 80232d2:	9a1f      	ldr	r2, [sp, #124]	@ 0x7c
 80232d4:	9872      	ldr	r0, [sp, #456]	@ 0x1c8
 80232d6:	f000 ff13 	bl	8024100 <st_int8_to16_dual_interleaved>
 80232da:	9b39      	ldr	r3, [sp, #228]	@ 0xe4
 80232dc:	2b00      	cmp	r3, #0
 80232de:	f000 817f 	beq.w	80235e0 <forward_lite_conv2d_sssa8_ch+0xa2c>
 80232e2:	9a18      	ldr	r2, [sp, #96]	@ 0x60
 80232e4:	eeb0 aa69 	vmov.f32	s20, s19
 80232e8:	9b10      	ldr	r3, [sp, #64]	@ 0x40
 80232ea:	46b8      	mov	r8, r7
 80232ec:	991c      	ldr	r1, [sp, #112]	@ 0x70
 80232ee:	1a9b      	subs	r3, r3, r2
 80232f0:	edcd 8a32 	vstr	s17, [sp, #200]	@ 0xc8
 80232f4:	fb01 f303 	mul.w	r3, r1, r3
 80232f8:	931d      	str	r3, [sp, #116]	@ 0x74
 80232fa:	9b2b      	ldr	r3, [sp, #172]	@ 0xac
 80232fc:	18d3      	adds	r3, r2, r3
 80232fe:	9333      	str	r3, [sp, #204]	@ 0xcc
 8023300:	9b41      	ldr	r3, [sp, #260]	@ 0x104
 8023302:	9331      	str	r3, [sp, #196]	@ 0xc4
 8023304:	9b21      	ldr	r3, [sp, #132]	@ 0x84
 8023306:	9323      	str	r3, [sp, #140]	@ 0x8c
 8023308:	9b72      	ldr	r3, [sp, #456]	@ 0x1c8
 802330a:	9336      	str	r3, [sp, #216]	@ 0xd8
 802330c:	9b25      	ldr	r3, [sp, #148]	@ 0x94
 802330e:	9329      	str	r3, [sp, #164]	@ 0xa4
 8023310:	9b24      	ldr	r3, [sp, #144]	@ 0x90
 8023312:	932e      	str	r3, [sp, #184]	@ 0xb8
 8023314:	9b84      	ldr	r3, [sp, #528]	@ 0x210
 8023316:	932a      	str	r3, [sp, #168]	@ 0xa8
 8023318:	9a52      	ldr	r2, [sp, #328]	@ 0x148
 802331a:	9b51      	ldr	r3, [sp, #324]	@ 0x144
 802331c:	924f      	str	r2, [sp, #316]	@ 0x13c
 802331e:	9a53      	ldr	r2, [sp, #332]	@ 0x14c
 8023320:	934e      	str	r3, [sp, #312]	@ 0x138
 8023322:	9250      	str	r2, [sp, #320]	@ 0x140
 8023324:	9a14      	ldr	r2, [sp, #80]	@ 0x50
 8023326:	2a00      	cmp	r2, #0
 8023328:	f000 8120 	beq.w	802356c <forward_lite_conv2d_sssa8_ch+0x9b8>
 802332c:	e9dd 212c 	ldrd	r2, r1, [sp, #176]	@ 0xb0
 8023330:	1a57      	subs	r7, r2, r1
 8023332:	9a3a      	ldr	r2, [sp, #232]	@ 0xe8
 8023334:	920c      	str	r2, [sp, #48]	@ 0x30
 8023336:	9a35      	ldr	r2, [sp, #212]	@ 0xd4
 8023338:	920f      	str	r2, [sp, #60]	@ 0x3c
 802333a:	9a28      	ldr	r2, [sp, #160]	@ 0xa0
 802333c:	921e      	str	r2, [sp, #120]	@ 0x78
 802333e:	9a1b      	ldr	r2, [sp, #108]	@ 0x6c
 8023340:	920b      	str	r2, [sp, #44]	@ 0x2c
 8023342:	2200      	movs	r2, #0
 8023344:	9211      	str	r2, [sp, #68]	@ 0x44
 8023346:	2b00      	cmp	r3, #0
 8023348:	d05f      	beq.n	802340a <forward_lite_conv2d_sssa8_ch+0x856>
 802334a:	3b01      	subs	r3, #1
 802334c:	934e      	str	r3, [sp, #312]	@ 0x138
 802334e:	2301      	movs	r3, #1
 8023350:	f8ad 315e 	strh.w	r3, [sp, #350]	@ 0x15e
 8023354:	9b33      	ldr	r3, [sp, #204]	@ 0xcc
 8023356:	9a18      	ldr	r2, [sp, #96]	@ 0x60
 8023358:	4293      	cmp	r3, r2
 802335a:	dd3f      	ble.n	80233dc <forward_lite_conv2d_sssa8_ch+0x828>
 802335c:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 802335e:	ee08 8a10 	vmov	s16, r8
 8023362:	9d34      	ldr	r5, [sp, #208]	@ 0xd0
 8023364:	ee1a 9a90 	vmov	r9, s21
 8023368:	1afb      	subs	r3, r7, r3
 802336a:	9e26      	ldr	r6, [sp, #152]	@ 0x98
 802336c:	fb05 f303 	mul.w	r3, r5, r3
 8023370:	9317      	str	r3, [sp, #92]	@ 0x5c
 8023372:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 8023374:	930d      	str	r3, [sp, #52]	@ 0x34
 8023376:	9b18      	ldr	r3, [sp, #96]	@ 0x60
 8023378:	930e      	str	r3, [sp, #56]	@ 0x38
 802337a:	9c0c      	ldr	r4, [sp, #48]	@ 0x30
 802337c:	42bc      	cmp	r4, r7
 802337e:	da21      	bge.n	80233c4 <forward_lite_conv2d_sssa8_ch+0x810>
 8023380:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 8023382:	9a15      	ldr	r2, [sp, #84]	@ 0x54
 8023384:	f8dd b034 	ldr.w	fp, [sp, #52]	@ 0x34
 8023388:	4293      	cmp	r3, r2
 802338a:	f8dd 802c 	ldr.w	r8, [sp, #44]	@ 0x2c
 802338e:	bf34      	ite	cc
 8023390:	2300      	movcc	r3, #0
 8023392:	2301      	movcs	r3, #1
 8023394:	930a      	str	r3, [sp, #40]	@ 0x28
 8023396:	9b12      	ldr	r3, [sp, #72]	@ 0x48
 8023398:	2b00      	cmp	r3, #0
 802339a:	d03f      	beq.n	802341c <forward_lite_conv2d_sssa8_ch+0x868>
 802339c:	42b4      	cmp	r4, r6
 802339e:	4641      	mov	r1, r8
 80233a0:	464a      	mov	r2, r9
 80233a2:	4650      	mov	r0, sl
 80233a4:	d203      	bcs.n	80233ae <forward_lite_conv2d_sssa8_ch+0x7fa>
 80233a6:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 80233a8:	2b00      	cmp	r3, #0
 80233aa:	f000 80bf 	beq.w	802352c <forward_lite_conv2d_sssa8_ch+0x978>
 80233ae:	f000 ffd5 	bl	802435c <st_int16_fill>
 80233b2:	3401      	adds	r4, #1
 80233b4:	44a8      	add	r8, r5
 80233b6:	44cb      	add	fp, r9
 80233b8:	42a7      	cmp	r7, r4
 80233ba:	d1ef      	bne.n	802339c <forward_lite_conv2d_sssa8_ch+0x7e8>
 80233bc:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 80233be:	9a17      	ldr	r2, [sp, #92]	@ 0x5c
 80233c0:	4413      	add	r3, r2
 80233c2:	930b      	str	r3, [sp, #44]	@ 0x2c
 80233c4:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
 80233c6:	9913      	ldr	r1, [sp, #76]	@ 0x4c
 80233c8:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 80233ca:	440a      	add	r2, r1
 80233cc:	3301      	adds	r3, #1
 80233ce:	920d      	str	r2, [sp, #52]	@ 0x34
 80233d0:	9a10      	ldr	r2, [sp, #64]	@ 0x40
 80233d2:	930e      	str	r3, [sp, #56]	@ 0x38
 80233d4:	4293      	cmp	r3, r2
 80233d6:	d1d0      	bne.n	802337a <forward_lite_conv2d_sssa8_ch+0x7c6>
 80233d8:	ee18 8a10 	vmov	r8, s16
 80233dc:	9b1a      	ldr	r3, [sp, #104]	@ 0x68
 80233de:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
 80233e0:	4293      	cmp	r3, r2
 80233e2:	d055      	beq.n	8023490 <forward_lite_conv2d_sssa8_ch+0x8dc>
 80233e4:	9a0f      	ldr	r2, [sp, #60]	@ 0x3c
 80233e6:	9919      	ldr	r1, [sp, #100]	@ 0x64
 80233e8:	9b11      	ldr	r3, [sp, #68]	@ 0x44
 80233ea:	440a      	add	r2, r1
 80233ec:	9916      	ldr	r1, [sp, #88]	@ 0x58
 80233ee:	3301      	adds	r3, #1
 80233f0:	920f      	str	r2, [sp, #60]	@ 0x3c
 80233f2:	440f      	add	r7, r1
 80233f4:	9a0c      	ldr	r2, [sp, #48]	@ 0x30
 80233f6:	9311      	str	r3, [sp, #68]	@ 0x44
 80233f8:	440a      	add	r2, r1
 80233fa:	920c      	str	r2, [sp, #48]	@ 0x30
 80233fc:	9a14      	ldr	r2, [sp, #80]	@ 0x50
 80233fe:	429a      	cmp	r2, r3
 8023400:	f000 8098 	beq.w	8023534 <forward_lite_conv2d_sssa8_ch+0x980>
 8023404:	9b4e      	ldr	r3, [sp, #312]	@ 0x138
 8023406:	2b00      	cmp	r3, #0
 8023408:	d19f      	bne.n	802334a <forward_lite_conv2d_sssa8_ch+0x796>
 802340a:	9b4f      	ldr	r3, [sp, #316]	@ 0x13c
 802340c:	b9b3      	cbnz	r3, 802343c <forward_lite_conv2d_sssa8_ch+0x888>
 802340e:	9b50      	ldr	r3, [sp, #320]	@ 0x140
 8023410:	3b01      	subs	r3, #1
 8023412:	9350      	str	r3, [sp, #320]	@ 0x140
 8023414:	2301      	movs	r3, #1
 8023416:	f8ad 315e 	strh.w	r3, [sp, #350]	@ 0x15e
 802341a:	e79b      	b.n	8023354 <forward_lite_conv2d_sssa8_ch+0x7a0>
 802341c:	42b4      	cmp	r4, r6
 802341e:	464a      	mov	r2, r9
 8023420:	4641      	mov	r1, r8
 8023422:	4650      	mov	r0, sl
 8023424:	d202      	bcs.n	802342c <forward_lite_conv2d_sssa8_ch+0x878>
 8023426:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8023428:	2b00      	cmp	r3, #0
 802342a:	d07b      	beq.n	8023524 <forward_lite_conv2d_sssa8_ch+0x970>
 802342c:	f000 ff96 	bl	802435c <st_int16_fill>
 8023430:	3401      	adds	r4, #1
 8023432:	44a8      	add	r8, r5
 8023434:	44cb      	add	fp, r9
 8023436:	42bc      	cmp	r4, r7
 8023438:	d1f0      	bne.n	802341c <forward_lite_conv2d_sssa8_ch+0x868>
 802343a:	e7bf      	b.n	80233bc <forward_lite_conv2d_sssa8_ch+0x808>
 802343c:	3b01      	subs	r3, #1
 802343e:	934f      	str	r3, [sp, #316]	@ 0x13c
 8023440:	f8bd 315c 	ldrh.w	r3, [sp, #348]	@ 0x15c
 8023444:	2b01      	cmp	r3, #1
 8023446:	f8ad 315e 	strh.w	r3, [sp, #350]	@ 0x15e
 802344a:	d083      	beq.n	8023354 <forward_lite_conv2d_sssa8_ch+0x7a0>
 802344c:	9b12      	ldr	r3, [sp, #72]	@ 0x48
 802344e:	9c18      	ldr	r4, [sp, #96]	@ 0x60
 8023450:	2b00      	cmp	r3, #0
 8023452:	d14b      	bne.n	80234ec <forward_lite_conv2d_sssa8_ch+0x938>
 8023454:	9b10      	ldr	r3, [sp, #64]	@ 0x40
 8023456:	429c      	cmp	r4, r3
 8023458:	dac0      	bge.n	80233dc <forward_lite_conv2d_sssa8_ch+0x828>
 802345a:	970a      	str	r7, [sp, #40]	@ 0x28
 802345c:	461f      	mov	r7, r3
 802345e:	9e0f      	ldr	r6, [sp, #60]	@ 0x3c
 8023460:	9d0b      	ldr	r5, [sp, #44]	@ 0x2c
 8023462:	f8dd b04c 	ldr.w	fp, [sp, #76]	@ 0x4c
 8023466:	f8dd 9070 	ldr.w	r9, [sp, #112]	@ 0x70
 802346a:	3401      	adds	r4, #1
 802346c:	4629      	mov	r1, r5
 802346e:	4630      	mov	r0, r6
 8023470:	4642      	mov	r2, r8
 8023472:	f000 fd17 	bl	8023ea4 <st_int8_to16_no_shift_interleaved>
 8023476:	42bc      	cmp	r4, r7
 8023478:	444d      	add	r5, r9
 802347a:	445e      	add	r6, fp
 802347c:	d1f5      	bne.n	802346a <forward_lite_conv2d_sssa8_ch+0x8b6>
 802347e:	9a1d      	ldr	r2, [sp, #116]	@ 0x74
 8023480:	e9dd 730a 	ldrd	r7, r3, [sp, #40]	@ 0x28
 8023484:	4413      	add	r3, r2
 8023486:	930b      	str	r3, [sp, #44]	@ 0x2c
 8023488:	9b1a      	ldr	r3, [sp, #104]	@ 0x68
 802348a:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
 802348c:	4293      	cmp	r3, r2
 802348e:	d1a9      	bne.n	80233e4 <forward_lite_conv2d_sssa8_ch+0x830>
 8023490:	9b1e      	ldr	r3, [sp, #120]	@ 0x78
 8023492:	ee19 0a10 	vmov	r0, s18
 8023496:	9a19      	ldr	r2, [sp, #100]	@ 0x64
 8023498:	9308      	str	r3, [sp, #32]
 802349a:	9b22      	ldr	r3, [sp, #136]	@ 0x88
 802349c:	9c11      	ldr	r4, [sp, #68]	@ 0x44
 802349e:	9307      	str	r3, [sp, #28]
 80234a0:	9b29      	ldr	r3, [sp, #164]	@ 0xa4
 80234a2:	3401      	adds	r4, #1
 80234a4:	991b      	ldr	r1, [sp, #108]	@ 0x6c
 80234a6:	9306      	str	r3, [sp, #24]
 80234a8:	9b2a      	ldr	r3, [sp, #168]	@ 0xa8
 80234aa:	9411      	str	r4, [sp, #68]	@ 0x44
 80234ac:	9305      	str	r3, [sp, #20]
 80234ae:	9b2e      	ldr	r3, [sp, #184]	@ 0xb8
 80234b0:	9304      	str	r3, [sp, #16]
 80234b2:	9b1f      	ldr	r3, [sp, #124]	@ 0x7c
 80234b4:	9303      	str	r3, [sp, #12]
 80234b6:	9b23      	ldr	r3, [sp, #140]	@ 0x8c
 80234b8:	9302      	str	r3, [sp, #8]
 80234ba:	9b20      	ldr	r3, [sp, #128]	@ 0x80
 80234bc:	9300      	str	r3, [sp, #0]
 80234be:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 80234c0:	4413      	add	r3, r2
 80234c2:	9a16      	ldr	r2, [sp, #88]	@ 0x58
 80234c4:	930f      	str	r3, [sp, #60]	@ 0x3c
 80234c6:	4417      	add	r7, r2
 80234c8:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 80234ca:	4413      	add	r3, r2
 80234cc:	ee1a 2a10 	vmov	r2, s20
 80234d0:	930c      	str	r3, [sp, #48]	@ 0x30
 80234d2:	2300      	movs	r3, #0
 80234d4:	9301      	str	r3, [sp, #4]
 80234d6:	ee18 3a90 	vmov	r3, s17
 80234da:	f00d fb4b 	bl	8030b74 <st_sssa8_ch_nn_mat_mult_kernel_opt>
 80234de:	9b14      	ldr	r3, [sp, #80]	@ 0x50
 80234e0:	901e      	str	r0, [sp, #120]	@ 0x78
 80234e2:	42a3      	cmp	r3, r4
 80234e4:	d042      	beq.n	802356c <forward_lite_conv2d_sssa8_ch+0x9b8>
 80234e6:	9b1b      	ldr	r3, [sp, #108]	@ 0x6c
 80234e8:	930b      	str	r3, [sp, #44]	@ 0x2c
 80234ea:	e78b      	b.n	8023404 <forward_lite_conv2d_sssa8_ch+0x850>
 80234ec:	9b10      	ldr	r3, [sp, #64]	@ 0x40
 80234ee:	429c      	cmp	r4, r3
 80234f0:	f6bf af74 	bge.w	80233dc <forward_lite_conv2d_sssa8_ch+0x828>
 80234f4:	970a      	str	r7, [sp, #40]	@ 0x28
 80234f6:	461f      	mov	r7, r3
 80234f8:	9e0f      	ldr	r6, [sp, #60]	@ 0x3c
 80234fa:	9d0b      	ldr	r5, [sp, #44]	@ 0x2c
 80234fc:	f8dd b04c 	ldr.w	fp, [sp, #76]	@ 0x4c
 8023500:	f8dd 9070 	ldr.w	r9, [sp, #112]	@ 0x70
 8023504:	3401      	adds	r4, #1
 8023506:	4629      	mov	r1, r5
 8023508:	4630      	mov	r0, r6
 802350a:	4642      	mov	r2, r8
 802350c:	f000 fc68 	bl	8023de0 <st_int8_to16_no_shift>
 8023510:	42bc      	cmp	r4, r7
 8023512:	444d      	add	r5, r9
 8023514:	445e      	add	r6, fp
 8023516:	d1f5      	bne.n	8023504 <forward_lite_conv2d_sssa8_ch+0x950>
 8023518:	9a1d      	ldr	r2, [sp, #116]	@ 0x74
 802351a:	e9dd 730a 	ldrd	r7, r3, [sp, #40]	@ 0x28
 802351e:	4413      	add	r3, r2
 8023520:	930b      	str	r3, [sp, #44]	@ 0x2c
 8023522:	e7b1      	b.n	8023488 <forward_lite_conv2d_sssa8_ch+0x8d4>
 8023524:	4658      	mov	r0, fp
 8023526:	f000 fcbd 	bl	8023ea4 <st_int8_to16_no_shift_interleaved>
 802352a:	e781      	b.n	8023430 <forward_lite_conv2d_sssa8_ch+0x87c>
 802352c:	4658      	mov	r0, fp
 802352e:	f000 fc57 	bl	8023de0 <st_int8_to16_no_shift>
 8023532:	e73e      	b.n	80233b2 <forward_lite_conv2d_sssa8_ch+0x7fe>
 8023534:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 8023536:	991b      	ldr	r1, [sp, #108]	@ 0x6c
 8023538:	428b      	cmp	r3, r1
 802353a:	d017      	beq.n	802356c <forward_lite_conv2d_sssa8_ch+0x9b8>
 802353c:	9b1e      	ldr	r3, [sp, #120]	@ 0x78
 802353e:	ee1a 2a10 	vmov	r2, s20
 8023542:	ee19 0a10 	vmov	r0, s18
 8023546:	9307      	str	r3, [sp, #28]
 8023548:	9b22      	ldr	r3, [sp, #136]	@ 0x88
 802354a:	9306      	str	r3, [sp, #24]
 802354c:	9b29      	ldr	r3, [sp, #164]	@ 0xa4
 802354e:	9305      	str	r3, [sp, #20]
 8023550:	9b2a      	ldr	r3, [sp, #168]	@ 0xa8
 8023552:	9304      	str	r3, [sp, #16]
 8023554:	9b2e      	ldr	r3, [sp, #184]	@ 0xb8
 8023556:	9303      	str	r3, [sp, #12]
 8023558:	9b1f      	ldr	r3, [sp, #124]	@ 0x7c
 802355a:	9302      	str	r3, [sp, #8]
 802355c:	9b23      	ldr	r3, [sp, #140]	@ 0x8c
 802355e:	9301      	str	r3, [sp, #4]
 8023560:	9b20      	ldr	r3, [sp, #128]	@ 0x80
 8023562:	9300      	str	r3, [sp, #0]
 8023564:	ee18 3a90 	vmov	r3, s17
 8023568:	f001 fb64 	bl	8024c34 <st_sssa8_ch_nn_mat_mult_kernel_single_opt>
 802356c:	9a23      	ldr	r2, [sp, #140]	@ 0x8c
 802356e:	9b32      	ldr	r3, [sp, #200]	@ 0xc8
 8023570:	9928      	ldr	r1, [sp, #160]	@ 0xa0
 8023572:	1a9b      	subs	r3, r3, r2
 8023574:	4411      	add	r1, r2
 8023576:	9128      	str	r1, [sp, #160]	@ 0xa0
 8023578:	b299      	uxth	r1, r3
 802357a:	4613      	mov	r3, r2
 802357c:	428a      	cmp	r2, r1
 802357e:	9132      	str	r1, [sp, #200]	@ 0xc8
 8023580:	bf28      	it	cs
 8023582:	460b      	movcs	r3, r1
 8023584:	b29b      	uxth	r3, r3
 8023586:	2b00      	cmp	r3, #0
 8023588:	d051      	beq.n	802362e <forward_lite_conv2d_sssa8_ch+0xa7a>
 802358a:	ee1a 4a10 	vmov	r4, s20
 802358e:	9836      	ldr	r0, [sp, #216]	@ 0xd8
 8023590:	991f      	ldr	r1, [sp, #124]	@ 0x7c
 8023592:	eb04 0482 	add.w	r4, r4, r2, lsl #2
 8023596:	fb01 0002 	mla	r0, r1, r2, r0
 802359a:	ee0a 4a10 	vmov	s20, r4
 802359e:	9c2e      	ldr	r4, [sp, #184]	@ 0xb8
 80235a0:	9036      	str	r0, [sp, #216]	@ 0xd8
 80235a2:	eb04 0442 	add.w	r4, r4, r2, lsl #1
 80235a6:	942e      	str	r4, [sp, #184]	@ 0xb8
 80235a8:	9c2a      	ldr	r4, [sp, #168]	@ 0xa8
 80235aa:	eb04 0482 	add.w	r4, r4, r2, lsl #2
 80235ae:	942a      	str	r4, [sp, #168]	@ 0xa8
 80235b0:	9c29      	ldr	r4, [sp, #164]	@ 0xa4
 80235b2:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 80235b6:	9229      	str	r2, [sp, #164]	@ 0xa4
 80235b8:	9a12      	ldr	r2, [sp, #72]	@ 0x48
 80235ba:	2a00      	cmp	r2, #0
 80235bc:	d139      	bne.n	8023632 <forward_lite_conv2d_sssa8_ch+0xa7e>
 80235be:	460a      	mov	r2, r1
 80235c0:	ee19 1a10 	vmov	r1, s18
 80235c4:	9323      	str	r3, [sp, #140]	@ 0x8c
 80235c6:	f000 fd9b 	bl	8024100 <st_int8_to16_dual_interleaved>
 80235ca:	9b31      	ldr	r3, [sp, #196]	@ 0xc4
 80235cc:	3b01      	subs	r3, #1
 80235ce:	b29b      	uxth	r3, r3
 80235d0:	461a      	mov	r2, r3
 80235d2:	9331      	str	r3, [sp, #196]	@ 0xc4
 80235d4:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 80235d8:	429a      	cmp	r2, r3
 80235da:	f47f ae9d 	bne.w	8023318 <forward_lite_conv2d_sssa8_ch+0x764>
 80235de:	4647      	mov	r7, r8
 80235e0:	9a30      	ldr	r2, [sp, #192]	@ 0xc0
 80235e2:	9b10      	ldr	r3, [sp, #64]	@ 0x40
 80235e4:	4413      	add	r3, r2
 80235e6:	9310      	str	r3, [sp, #64]	@ 0x40
 80235e8:	9b18      	ldr	r3, [sp, #96]	@ 0x60
 80235ea:	4413      	add	r3, r2
 80235ec:	9a3e      	ldr	r2, [sp, #248]	@ 0xf8
 80235ee:	9318      	str	r3, [sp, #96]	@ 0x60
 80235f0:	9b35      	ldr	r3, [sp, #212]	@ 0xd4
 80235f2:	4413      	add	r3, r2
 80235f4:	9a40      	ldr	r2, [sp, #256]	@ 0x100
 80235f6:	9335      	str	r3, [sp, #212]	@ 0xd4
 80235f8:	9b3b      	ldr	r3, [sp, #236]	@ 0xec
 80235fa:	4413      	add	r3, r2
 80235fc:	9a3f      	ldr	r2, [sp, #252]	@ 0xfc
 80235fe:	933b      	str	r3, [sp, #236]	@ 0xec
 8023600:	9b3c      	ldr	r3, [sp, #240]	@ 0xf0
 8023602:	4413      	add	r3, r2
 8023604:	9a3d      	ldr	r2, [sp, #244]	@ 0xf4
 8023606:	933c      	str	r3, [sp, #240]	@ 0xf0
 8023608:	9b38      	ldr	r3, [sp, #224]	@ 0xe0
 802360a:	3301      	adds	r3, #1
 802360c:	9338      	str	r3, [sp, #224]	@ 0xe0
 802360e:	9b2f      	ldr	r3, [sp, #188]	@ 0xbc
 8023610:	4293      	cmp	r3, r2
 8023612:	f77f ad05 	ble.w	8023020 <forward_lite_conv2d_sssa8_ch+0x46c>
 8023616:	a84e      	add	r0, sp, #312	@ 0x138
 8023618:	f000 fe86 	bl	8024328 <ai_padding_opt_phase1>
 802361c:	9b27      	ldr	r3, [sp, #156]	@ 0x9c
 802361e:	2b03      	cmp	r3, #3
 8023620:	f47f ae4a 	bne.w	80232b8 <forward_lite_conv2d_sssa8_ch+0x704>
 8023624:	9b38      	ldr	r3, [sp, #224]	@ 0xe0
 8023626:	933d      	str	r3, [sp, #244]	@ 0xf4
 8023628:	9b3b      	ldr	r3, [sp, #236]	@ 0xec
 802362a:	9328      	str	r3, [sp, #160]	@ 0xa0
 802362c:	e648      	b.n	80232c0 <forward_lite_conv2d_sssa8_ch+0x70c>
 802362e:	9323      	str	r3, [sp, #140]	@ 0x8c
 8023630:	e7cb      	b.n	80235ca <forward_lite_conv2d_sssa8_ch+0xa16>
 8023632:	460a      	mov	r2, r1
 8023634:	ee19 1a10 	vmov	r1, s18
 8023638:	9323      	str	r3, [sp, #140]	@ 0x8c
 802363a:	f000 fc77 	bl	8023f2c <st_int8_to16_dual>
 802363e:	e7c4      	b.n	80235ca <forward_lite_conv2d_sssa8_ch+0xa16>
 8023640:	9b21      	ldr	r3, [sp, #132]	@ 0x84
 8023642:	ee19 1a10 	vmov	r1, s18
 8023646:	9a1f      	ldr	r2, [sp, #124]	@ 0x7c
 8023648:	9872      	ldr	r0, [sp, #456]	@ 0x1c8
 802364a:	f000 fc6f 	bl	8023f2c <st_int8_to16_dual>
 802364e:	e644      	b.n	80232da <forward_lite_conv2d_sssa8_ch+0x726>
 8023650:	ee18 3a90 	vmov	r3, s17
 8023654:	ee19 1a10 	vmov	r1, s18
 8023658:	9872      	ldr	r0, [sp, #456]	@ 0x1c8
 802365a:	f000 fc67 	bl	8023f2c <st_int8_to16_dual>
 802365e:	f7ff bb86 	b.w	8022d6e <forward_lite_conv2d_sssa8_ch+0x1ba>
 8023662:	bf00      	nop

08023664 <forward_lite_maxpool_is8os8_scaleneg>:
 8023664:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8023668:	b095      	sub	sp, #84	@ 0x54
 802366a:	4614      	mov	r4, r2
 802366c:	e9cd 010a 	strd	r0, r1, [sp, #40]	@ 0x28
 8023670:	f8bd 107c 	ldrh.w	r1, [sp, #124]	@ 0x7c
 8023674:	f99d 009c 	ldrsb.w	r0, [sp, #156]	@ 0x9c
 8023678:	910d      	str	r1, [sp, #52]	@ 0x34
 802367a:	f8bd 1080 	ldrh.w	r1, [sp, #128]	@ 0x80
 802367e:	930c      	str	r3, [sp, #48]	@ 0x30
 8023680:	910e      	str	r1, [sp, #56]	@ 0x38
 8023682:	f8bd 1084 	ldrh.w	r1, [sp, #132]	@ 0x84
 8023686:	f8bd 3098 	ldrh.w	r3, [sp, #152]	@ 0x98
 802368a:	910f      	str	r1, [sp, #60]	@ 0x3c
 802368c:	f8bd 1088 	ldrh.w	r1, [sp, #136]	@ 0x88
 8023690:	9206      	str	r2, [sp, #24]
 8023692:	9110      	str	r1, [sp, #64]	@ 0x40
 8023694:	f8bd 108c 	ldrh.w	r1, [sp, #140]	@ 0x8c
 8023698:	f8bd a078 	ldrh.w	sl, [sp, #120]	@ 0x78
 802369c:	9111      	str	r1, [sp, #68]	@ 0x44
 802369e:	f8bd 1090 	ldrh.w	r1, [sp, #144]	@ 0x90
 80236a2:	f99d 20a0 	ldrsb.w	r2, [sp, #160]	@ 0xa0
 80236a6:	9112      	str	r1, [sp, #72]	@ 0x48
 80236a8:	f8bd 1094 	ldrh.w	r1, [sp, #148]	@ 0x94
 80236ac:	9313      	str	r3, [sp, #76]	@ 0x4c
 80236ae:	9107      	str	r1, [sp, #28]
 80236b0:	9003      	str	r0, [sp, #12]
 80236b2:	2b00      	cmp	r3, #0
 80236b4:	f000 8093 	beq.w	80237de <forward_lite_maxpool_is8os8_scaleneg+0x17a>
 80236b8:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 80236bc:	eeb4 0a67 	vcmp.f32	s0, s15
 80236c0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80236c4:	bf0c      	ite	eq
 80236c6:	2301      	moveq	r3, #1
 80236c8:	2300      	movne	r3, #0
 80236ca:	4290      	cmp	r0, r2
 80236cc:	bf14      	ite	ne
 80236ce:	2300      	movne	r3, #0
 80236d0:	f003 0301 	andeq.w	r3, r3, #1
 80236d4:	9301      	str	r3, [sp, #4]
 80236d6:	2900      	cmp	r1, #0
 80236d8:	f000 8081 	beq.w	80237de <forward_lite_maxpool_is8os8_scaleneg+0x17a>
 80236dc:	f1ba 0f00 	cmp.w	sl, #0
 80236e0:	d07d      	beq.n	80237de <forward_lite_maxpool_is8os8_scaleneg+0x17a>
 80236e2:	ee07 2a90 	vmov	s15, r2
 80236e6:	2300      	movs	r3, #0
 80236e8:	ed9f 6a4d 	vldr	s12, [pc, #308]	@ 8023820 <forward_lite_maxpool_is8os8_scaleneg+0x1bc>
 80236ec:	fb04 fb0a 	mul.w	fp, r4, sl
 80236f0:	eef8 6ae7 	vcvt.f32.s32	s13, s15
 80236f4:	9304      	str	r3, [sp, #16]
 80236f6:	9b04      	ldr	r3, [sp, #16]
 80236f8:	eef6 5a00 	vmov.f32	s11, #96	@ 0x3f000000  0.5
 80236fc:	9907      	ldr	r1, [sp, #28]
 80236fe:	9a12      	ldr	r2, [sp, #72]	@ 0x48
 8023700:	fb03 f202 	mul.w	r2, r3, r2
 8023704:	fb03 f301 	mul.w	r3, r3, r1
 8023708:	9910      	ldr	r1, [sp, #64]	@ 0x40
 802370a:	9308      	str	r3, [sp, #32]
 802370c:	2300      	movs	r3, #0
 802370e:	9305      	str	r3, [sp, #20]
 8023710:	1a53      	subs	r3, r2, r1
 8023712:	1a8a      	subs	r2, r1, r2
 8023714:	990c      	ldr	r1, [sp, #48]	@ 0x30
 8023716:	2b00      	cmp	r3, #0
 8023718:	eb02 0c01 	add.w	ip, r2, r1
 802371c:	bfd8      	it	le
 802371e:	4691      	movle	r9, r2
 8023720:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
 8023722:	bfc8      	it	gt
 8023724:	f04f 0900 	movgt.w	r9, #0
 8023728:	4594      	cmp	ip, r2
 802372a:	444b      	add	r3, r9
 802372c:	bfa8      	it	ge
 802372e:	4694      	movge	ip, r2
 8023730:	9a06      	ldr	r2, [sp, #24]
 8023732:	fb02 f303 	mul.w	r3, r2, r3
 8023736:	9309      	str	r3, [sp, #36]	@ 0x24
 8023738:	9a05      	ldr	r2, [sp, #20]
 802373a:	f04f 0e00 	mov.w	lr, #0
 802373e:	9908      	ldr	r1, [sp, #32]
 8023740:	9b11      	ldr	r3, [sp, #68]	@ 0x44
 8023742:	eb02 0801 	add.w	r8, r2, r1
 8023746:	990f      	ldr	r1, [sp, #60]	@ 0x3c
 8023748:	fb03 f302 	mul.w	r3, r3, r2
 802374c:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
 802374e:	9c0d      	ldr	r4, [sp, #52]	@ 0x34
 8023750:	fb0a 2808 	mla	r8, sl, r8, r2
 8023754:	1a5a      	subs	r2, r3, r1
 8023756:	1acb      	subs	r3, r1, r3
 8023758:	9906      	ldr	r1, [sp, #24]
 802375a:	2a00      	cmp	r2, #0
 802375c:	bfd8      	it	le
 802375e:	461f      	movle	r7, r3
 8023760:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8023762:	bfc8      	it	gt
 8023764:	2700      	movgt	r7, #0
 8023766:	18d3      	adds	r3, r2, r3
 8023768:	1a8a      	subs	r2, r1, r2
 802376a:	4294      	cmp	r4, r2
 802376c:	443b      	add	r3, r7
 802376e:	bfa8      	it	ge
 8023770:	4614      	movge	r4, r2
 8023772:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 8023774:	fb0a 2303 	mla	r3, sl, r3, r2
 8023778:	9302      	str	r3, [sp, #8]
 802377a:	45e1      	cmp	r9, ip
 802377c:	da4d      	bge.n	802381a <forward_lite_maxpool_is8os8_scaleneg+0x1b6>
 802377e:	9b02      	ldr	r3, [sp, #8]
 8023780:	464d      	mov	r5, r9
 8023782:	217f      	movs	r1, #127	@ 0x7f
 8023784:	eb03 060e 	add.w	r6, r3, lr
 8023788:	42a7      	cmp	r7, r4
 802378a:	da0a      	bge.n	80237a2 <forward_lite_maxpool_is8os8_scaleneg+0x13e>
 802378c:	4632      	mov	r2, r6
 802378e:	463b      	mov	r3, r7
 8023790:	f992 0000 	ldrsb.w	r0, [r2]
 8023794:	3301      	adds	r3, #1
 8023796:	4452      	add	r2, sl
 8023798:	4281      	cmp	r1, r0
 802379a:	bfa8      	it	ge
 802379c:	4601      	movge	r1, r0
 802379e:	429c      	cmp	r4, r3
 80237a0:	d1f6      	bne.n	8023790 <forward_lite_maxpool_is8os8_scaleneg+0x12c>
 80237a2:	3501      	adds	r5, #1
 80237a4:	445e      	add	r6, fp
 80237a6:	45ac      	cmp	ip, r5
 80237a8:	d1ee      	bne.n	8023788 <forward_lite_maxpool_is8os8_scaleneg+0x124>
 80237aa:	9b01      	ldr	r3, [sp, #4]
 80237ac:	b1d3      	cbz	r3, 80237e4 <forward_lite_maxpool_is8os8_scaleneg+0x180>
 80237ae:	f888 1000 	strb.w	r1, [r8]
 80237b2:	f10e 0e01 	add.w	lr, lr, #1
 80237b6:	f108 0801 	add.w	r8, r8, #1
 80237ba:	fa1f f38e 	uxth.w	r3, lr
 80237be:	459a      	cmp	sl, r3
 80237c0:	d8db      	bhi.n	802377a <forward_lite_maxpool_is8os8_scaleneg+0x116>
 80237c2:	9b05      	ldr	r3, [sp, #20]
 80237c4:	9a07      	ldr	r2, [sp, #28]
 80237c6:	3301      	adds	r3, #1
 80237c8:	b29b      	uxth	r3, r3
 80237ca:	429a      	cmp	r2, r3
 80237cc:	9305      	str	r3, [sp, #20]
 80237ce:	d8b3      	bhi.n	8023738 <forward_lite_maxpool_is8os8_scaleneg+0xd4>
 80237d0:	9b04      	ldr	r3, [sp, #16]
 80237d2:	9a13      	ldr	r2, [sp, #76]	@ 0x4c
 80237d4:	3301      	adds	r3, #1
 80237d6:	b29b      	uxth	r3, r3
 80237d8:	429a      	cmp	r2, r3
 80237da:	9304      	str	r3, [sp, #16]
 80237dc:	d88b      	bhi.n	80236f6 <forward_lite_maxpool_is8os8_scaleneg+0x92>
 80237de:	b015      	add	sp, #84	@ 0x54
 80237e0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80237e4:	9b03      	ldr	r3, [sp, #12]
 80237e6:	eeb0 7a66 	vmov.f32	s14, s13
 80237ea:	1ac9      	subs	r1, r1, r3
 80237ec:	ee07 1a90 	vmov	s15, r1
 80237f0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80237f4:	eea7 7a80 	vfma.f32	s14, s15, s0
 80237f8:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
 80237fc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8023800:	fe65 7a86 	vselge.f32	s15, s11, s12
 8023804:	ee77 7a87 	vadd.f32	s15, s15, s14
 8023808:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 802380c:	ee17 3a90 	vmov	r3, s15
 8023810:	f303 0307 	ssat	r3, #8, r3
 8023814:	f888 3000 	strb.w	r3, [r8]
 8023818:	e7cb      	b.n	80237b2 <forward_lite_maxpool_is8os8_scaleneg+0x14e>
 802381a:	217f      	movs	r1, #127	@ 0x7f
 802381c:	e7c5      	b.n	80237aa <forward_lite_maxpool_is8os8_scaleneg+0x146>
 802381e:	bf00      	nop
 8023820:	befffffc 	.word	0xbefffffc

08023824 <forward_lite_nl_softmax_is8os8>:
 8023824:	f00d bc30 	b.w	8031088 <_lite_kernel_nl_softmax_is8os8>

08023828 <forward_lite_nl_softmax_iu8ou8>:
 8023828:	f00e b854 	b.w	80318d4 <_lite_kernel_nl_softmax_iu8ou8>

0802382c <forward_lite_pad_8bit_ch1st_3x3_constant_P0022>:
 802382c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8023830:	b083      	sub	sp, #12
 8023832:	f992 0000 	ldrsb.w	r0, [r2]
 8023836:	f04f 0500 	mov.w	r5, #0
 802383a:	f8dd 9030 	ldr.w	r9, [sp, #48]	@ 0x30
 802383e:	f360 0507 	bfi	r5, r0, #0, #8
 8023842:	f1b9 0f00 	cmp.w	r9, #0
 8023846:	f360 250f 	bfi	r5, r0, #8, #8
 802384a:	dd20      	ble.n	802388e <forward_lite_pad_8bit_ch1st_3x3_constant_P0022+0x62>
 802384c:	461c      	mov	r4, r3
 802384e:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 8023850:	460f      	mov	r7, r1
 8023852:	f04f 0800 	mov.w	r8, #0
 8023856:	1c9e      	adds	r6, r3, #2
 8023858:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 802385a:	fb06 fb04 	mul.w	fp, r6, r4
 802385e:	ea4f 0a43 	mov.w	sl, r3, lsl #1
 8023862:	2c00      	cmp	r4, #0
 8023864:	dd08      	ble.n	8023878 <forward_lite_pad_8bit_ch1st_3x3_constant_P0022+0x4c>
 8023866:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 8023868:	18f9      	adds	r1, r7, r3
 802386a:	2300      	movs	r3, #0
 802386c:	3301      	adds	r3, #1
 802386e:	800d      	strh	r5, [r1, #0]
 8023870:	4431      	add	r1, r6
 8023872:	429c      	cmp	r4, r3
 8023874:	d1fa      	bne.n	802386c <forward_lite_pad_8bit_ch1st_3x3_constant_P0022+0x40>
 8023876:	445f      	add	r7, fp
 8023878:	f108 0801 	add.w	r8, r8, #1
 802387c:	4639      	mov	r1, r7
 802387e:	4652      	mov	r2, sl
 8023880:	9001      	str	r0, [sp, #4]
 8023882:	f001 f8bb 	bl	80249fc <st_int8_fill>
 8023886:	45c1      	cmp	r9, r8
 8023888:	4457      	add	r7, sl
 802388a:	9801      	ldr	r0, [sp, #4]
 802388c:	d1e9      	bne.n	8023862 <forward_lite_pad_8bit_ch1st_3x3_constant_P0022+0x36>
 802388e:	b003      	add	sp, #12
 8023890:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08023894 <forward_lite_pad_8bit_ch1st_3x3_constant_P1111>:
 8023894:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8023898:	461e      	mov	r6, r3
 802389a:	b085      	sub	sp, #20
 802389c:	f992 8000 	ldrsb.w	r8, [r2]
 80238a0:	f04f 0500 	mov.w	r5, #0
 80238a4:	9b11      	ldr	r3, [sp, #68]	@ 0x44
 80238a6:	2e06      	cmp	r6, #6
 80238a8:	f368 0507 	bfi	r5, r8, #0, #8
 80238ac:	9f0e      	ldr	r7, [sp, #56]	@ 0x38
 80238ae:	460c      	mov	r4, r1
 80238b0:	f8dd a040 	ldr.w	sl, [sp, #64]	@ 0x40
 80238b4:	f368 250f 	bfi	r5, r8, #8, #8
 80238b8:	9303      	str	r3, [sp, #12]
 80238ba:	d07a      	beq.n	80239b2 <forward_lite_pad_8bit_ch1st_3x3_constant_P1111+0x11e>
 80238bc:	2e03      	cmp	r6, #3
 80238be:	d04e      	beq.n	802395e <forward_lite_pad_8bit_ch1st_3x3_constant_P1111+0xca>
 80238c0:	2b00      	cmp	r3, #0
 80238c2:	db05      	blt.n	80238d0 <forward_lite_pad_8bit_ch1st_3x3_constant_P1111+0x3c>
 80238c4:	1c5a      	adds	r2, r3, #1
 80238c6:	4608      	mov	r0, r1
 80238c8:	4641      	mov	r1, r8
 80238ca:	4414      	add	r4, r2
 80238cc:	f00f fb98 	bl	8033000 <memset>
 80238d0:	1e7b      	subs	r3, r7, #1
 80238d2:	3e01      	subs	r6, #1
 80238d4:	2b00      	cmp	r3, #0
 80238d6:	9301      	str	r3, [sp, #4]
 80238d8:	dd27      	ble.n	802392a <forward_lite_pad_8bit_ch1st_3x3_constant_P1111+0x96>
 80238da:	9b03      	ldr	r3, [sp, #12]
 80238dc:	f10a 0702 	add.w	r7, sl, #2
 80238e0:	f04f 0b00 	mov.w	fp, #0
 80238e4:	1c5a      	adds	r2, r3, #1
 80238e6:	fb07 f306 	mul.w	r3, r7, r6
 80238ea:	ea4f 0942 	mov.w	r9, r2, lsl #1
 80238ee:	9302      	str	r3, [sp, #8]
 80238f0:	4643      	mov	r3, r8
 80238f2:	46c8      	mov	r8, r9
 80238f4:	4699      	mov	r9, r3
 80238f6:	2e00      	cmp	r6, #0
 80238f8:	eb04 010a 	add.w	r1, r4, sl
 80238fc:	dd09      	ble.n	8023912 <forward_lite_pad_8bit_ch1st_3x3_constant_P1111+0x7e>
 80238fe:	468c      	mov	ip, r1
 8023900:	2300      	movs	r3, #0
 8023902:	3301      	adds	r3, #1
 8023904:	f8ac 5000 	strh.w	r5, [ip]
 8023908:	44bc      	add	ip, r7
 802390a:	42b3      	cmp	r3, r6
 802390c:	d1f9      	bne.n	8023902 <forward_lite_pad_8bit_ch1st_3x3_constant_P1111+0x6e>
 802390e:	9b02      	ldr	r3, [sp, #8]
 8023910:	4419      	add	r1, r3
 8023912:	4642      	mov	r2, r8
 8023914:	4648      	mov	r0, r9
 8023916:	f10b 0b01 	add.w	fp, fp, #1
 802391a:	eb01 0408 	add.w	r4, r1, r8
 802391e:	f001 f86d 	bl	80249fc <st_int8_fill>
 8023922:	9b01      	ldr	r3, [sp, #4]
 8023924:	459b      	cmp	fp, r3
 8023926:	d1e6      	bne.n	80238f6 <forward_lite_pad_8bit_ch1st_3x3_constant_P1111+0x62>
 8023928:	46c8      	mov	r8, r9
 802392a:	2e00      	cmp	r6, #0
 802392c:	eb04 000a 	add.w	r0, r4, sl
 8023930:	dd0a      	ble.n	8023948 <forward_lite_pad_8bit_ch1st_3x3_constant_P1111+0xb4>
 8023932:	f10a 0702 	add.w	r7, sl, #2
 8023936:	4602      	mov	r2, r0
 8023938:	2300      	movs	r3, #0
 802393a:	3301      	adds	r3, #1
 802393c:	8015      	strh	r5, [r2, #0]
 802393e:	443a      	add	r2, r7
 8023940:	429e      	cmp	r6, r3
 8023942:	d1fa      	bne.n	802393a <forward_lite_pad_8bit_ch1st_3x3_constant_P1111+0xa6>
 8023944:	fb07 0006 	mla	r0, r7, r6, r0
 8023948:	9b03      	ldr	r3, [sp, #12]
 802394a:	2b00      	cmp	r3, #0
 802394c:	db2e      	blt.n	80239ac <forward_lite_pad_8bit_ch1st_3x3_constant_P1111+0x118>
 802394e:	461a      	mov	r2, r3
 8023950:	4641      	mov	r1, r8
 8023952:	3201      	adds	r2, #1
 8023954:	b005      	add	sp, #20
 8023956:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802395a:	f00f bb51 	b.w	8033000 <memset>
 802395e:	fa5f f388 	uxtb.w	r3, r8
 8023962:	2f00      	cmp	r7, #0
 8023964:	ea4f 2208 	mov.w	r2, r8, lsl #8
 8023968:	ea43 6308 	orr.w	r3, r3, r8, lsl #24
 802396c:	b292      	uxth	r2, r2
 802396e:	ea43 0302 	orr.w	r3, r3, r2
 8023972:	ea4f 4208 	mov.w	r2, r8, lsl #16
 8023976:	f402 027f 	and.w	r2, r2, #16711680	@ 0xff0000
 802397a:	ea42 0203 	orr.w	r2, r2, r3
 802397e:	b29b      	uxth	r3, r3
 8023980:	dd14      	ble.n	80239ac <forward_lite_pad_8bit_ch1st_3x3_constant_P1111+0x118>
 8023982:	eb07 0987 	add.w	r9, r7, r7, lsl #2
 8023986:	eb09 0989 	add.w	r9, r9, r9, lsl #2
 802398a:	4449      	add	r1, r9
 802398c:	6022      	str	r2, [r4, #0]
 802398e:	3419      	adds	r4, #25
 8023990:	f824 3c15 	strh.w	r3, [r4, #-21]
 8023994:	f824 5c10 	strh.w	r5, [r4, #-16]
 8023998:	f824 3c0b 	strh.w	r3, [r4, #-11]
 802399c:	f804 8c06 	strb.w	r8, [r4, #-6]
 80239a0:	f844 2c05 	str.w	r2, [r4, #-5]
 80239a4:	f804 8c01 	strb.w	r8, [r4, #-1]
 80239a8:	428c      	cmp	r4, r1
 80239aa:	d1ef      	bne.n	802398c <forward_lite_pad_8bit_ch1st_3x3_constant_P1111+0xf8>
 80239ac:	b005      	add	sp, #20
 80239ae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80239b2:	fa5f f388 	uxtb.w	r3, r8
 80239b6:	2f00      	cmp	r7, #0
 80239b8:	ea4f 2208 	mov.w	r2, r8, lsl #8
 80239bc:	ea43 6308 	orr.w	r3, r3, r8, lsl #24
 80239c0:	b292      	uxth	r2, r2
 80239c2:	ea43 0302 	orr.w	r3, r3, r2
 80239c6:	ea4f 4208 	mov.w	r2, r8, lsl #16
 80239ca:	f402 027f 	and.w	r2, r2, #16711680	@ 0xff0000
 80239ce:	ea43 0302 	orr.w	r3, r3, r2
 80239d2:	ddeb      	ble.n	80239ac <forward_lite_pad_8bit_ch1st_3x3_constant_P1111+0x118>
 80239d4:	340f      	adds	r4, #15
 80239d6:	2200      	movs	r2, #0
 80239d8:	3201      	adds	r2, #1
 80239da:	f844 3c0f 	str.w	r3, [r4, #-15]
 80239de:	f844 3c0b 	str.w	r3, [r4, #-11]
 80239e2:	3440      	adds	r4, #64	@ 0x40
 80239e4:	4297      	cmp	r7, r2
 80239e6:	f804 8c47 	strb.w	r8, [r4, #-71]
 80239ea:	f824 5c40 	strh.w	r5, [r4, #-64]
 80239ee:	f824 5c38 	strh.w	r5, [r4, #-56]
 80239f2:	f824 5c30 	strh.w	r5, [r4, #-48]
 80239f6:	f824 5c28 	strh.w	r5, [r4, #-40]
 80239fa:	f824 5c20 	strh.w	r5, [r4, #-32]
 80239fe:	f804 8c18 	strb.w	r8, [r4, #-24]
 8023a02:	f844 3c17 	str.w	r3, [r4, #-23]
 8023a06:	f844 3c13 	str.w	r3, [r4, #-19]
 8023a0a:	d1e5      	bne.n	80239d8 <forward_lite_pad_8bit_ch1st_3x3_constant_P1111+0x144>
 8023a0c:	b005      	add	sp, #20
 8023a0e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8023a12:	bf00      	nop

08023a14 <forward_lite_pad_constant>:
 8023a14:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8023a18:	b085      	sub	sp, #20
 8023a1a:	4616      	mov	r6, r2
 8023a1c:	4681      	mov	r9, r0
 8023a1e:	2b08      	cmp	r3, #8
 8023a20:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
 8023a22:	460c      	mov	r4, r1
 8023a24:	9201      	str	r2, [sp, #4]
 8023a26:	e9dd 2011 	ldrd	r2, r0, [sp, #68]	@ 0x44
 8023a2a:	e9dd 5a0f 	ldrd	r5, sl, [sp, #60]	@ 0x3c
 8023a2e:	e9dd 7813 	ldrd	r7, r8, [sp, #76]	@ 0x4c
 8023a32:	9002      	str	r0, [sp, #8]
 8023a34:	d051      	beq.n	8023ada <forward_lite_pad_constant+0xc6>
 8023a36:	2a00      	cmp	r2, #0
 8023a38:	dd11      	ble.n	8023a5e <forward_lite_pad_constant+0x4a>
 8023a3a:	f8cd 8000 	str.w	r8, [sp]
 8023a3e:	f04f 0b00 	mov.w	fp, #0
 8023a42:	46b8      	mov	r8, r7
 8023a44:	4617      	mov	r7, r2
 8023a46:	44ab      	add	fp, r5
 8023a48:	4621      	mov	r1, r4
 8023a4a:	462a      	mov	r2, r5
 8023a4c:	4630      	mov	r0, r6
 8023a4e:	f001 f833 	bl	8024ab8 <st_int8_copy>
 8023a52:	455f      	cmp	r7, fp
 8023a54:	442c      	add	r4, r5
 8023a56:	dcf6      	bgt.n	8023a46 <forward_lite_pad_constant+0x32>
 8023a58:	4647      	mov	r7, r8
 8023a5a:	f8dd 8000 	ldr.w	r8, [sp]
 8023a5e:	9b01      	ldr	r3, [sp, #4]
 8023a60:	2b00      	cmp	r3, #0
 8023a62:	dd29      	ble.n	8023ab8 <forward_lite_pad_constant+0xa4>
 8023a64:	2300      	movs	r3, #0
 8023a66:	9300      	str	r3, [sp, #0]
 8023a68:	2f00      	cmp	r7, #0
 8023a6a:	dd0a      	ble.n	8023a82 <forward_lite_pad_constant+0x6e>
 8023a6c:	f04f 0b00 	mov.w	fp, #0
 8023a70:	44ab      	add	fp, r5
 8023a72:	4621      	mov	r1, r4
 8023a74:	462a      	mov	r2, r5
 8023a76:	4630      	mov	r0, r6
 8023a78:	f001 f81e 	bl	8024ab8 <st_int8_copy>
 8023a7c:	455f      	cmp	r7, fp
 8023a7e:	442c      	add	r4, r5
 8023a80:	dcf6      	bgt.n	8023a70 <forward_lite_pad_constant+0x5c>
 8023a82:	4621      	mov	r1, r4
 8023a84:	4648      	mov	r0, r9
 8023a86:	4652      	mov	r2, sl
 8023a88:	4454      	add	r4, sl
 8023a8a:	f001 f815 	bl	8024ab8 <st_int8_copy>
 8023a8e:	f1b8 0f00 	cmp.w	r8, #0
 8023a92:	44d1      	add	r9, sl
 8023a94:	dd0a      	ble.n	8023aac <forward_lite_pad_constant+0x98>
 8023a96:	f04f 0b00 	mov.w	fp, #0
 8023a9a:	44ab      	add	fp, r5
 8023a9c:	4621      	mov	r1, r4
 8023a9e:	462a      	mov	r2, r5
 8023aa0:	4630      	mov	r0, r6
 8023aa2:	f001 f809 	bl	8024ab8 <st_int8_copy>
 8023aa6:	45d8      	cmp	r8, fp
 8023aa8:	442c      	add	r4, r5
 8023aaa:	dcf6      	bgt.n	8023a9a <forward_lite_pad_constant+0x86>
 8023aac:	9b00      	ldr	r3, [sp, #0]
 8023aae:	9a01      	ldr	r2, [sp, #4]
 8023ab0:	3301      	adds	r3, #1
 8023ab2:	429a      	cmp	r2, r3
 8023ab4:	9300      	str	r3, [sp, #0]
 8023ab6:	d1d7      	bne.n	8023a68 <forward_lite_pad_constant+0x54>
 8023ab8:	9b02      	ldr	r3, [sp, #8]
 8023aba:	2b00      	cmp	r3, #0
 8023abc:	dd0a      	ble.n	8023ad4 <forward_lite_pad_constant+0xc0>
 8023abe:	2700      	movs	r7, #0
 8023ac0:	4698      	mov	r8, r3
 8023ac2:	442f      	add	r7, r5
 8023ac4:	4621      	mov	r1, r4
 8023ac6:	462a      	mov	r2, r5
 8023ac8:	4630      	mov	r0, r6
 8023aca:	f000 fff5 	bl	8024ab8 <st_int8_copy>
 8023ace:	45b8      	cmp	r8, r7
 8023ad0:	442c      	add	r4, r5
 8023ad2:	dcf6      	bgt.n	8023ac2 <forward_lite_pad_constant+0xae>
 8023ad4:	b005      	add	sp, #20
 8023ad6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8023ada:	f996 5000 	ldrsb.w	r5, [r6]
 8023ade:	4414      	add	r4, r2
 8023ae0:	4628      	mov	r0, r5
 8023ae2:	9403      	str	r4, [sp, #12]
 8023ae4:	f000 ff8a 	bl	80249fc <st_int8_fill>
 8023ae8:	9b01      	ldr	r3, [sp, #4]
 8023aea:	2b00      	cmp	r3, #0
 8023aec:	dd26      	ble.n	8023b3c <forward_lite_pad_constant+0x128>
 8023aee:	eb08 030a 	add.w	r3, r8, sl
 8023af2:	2600      	movs	r6, #0
 8023af4:	eb03 0b07 	add.w	fp, r3, r7
 8023af8:	eb07 030a 	add.w	r3, r7, sl
 8023afc:	9300      	str	r3, [sp, #0]
 8023afe:	4643      	mov	r3, r8
 8023b00:	46b0      	mov	r8, r6
 8023b02:	461e      	mov	r6, r3
 8023b04:	4621      	mov	r1, r4
 8023b06:	4628      	mov	r0, r5
 8023b08:	463a      	mov	r2, r7
 8023b0a:	f108 0801 	add.w	r8, r8, #1
 8023b0e:	f000 ff75 	bl	80249fc <st_int8_fill>
 8023b12:	19e1      	adds	r1, r4, r7
 8023b14:	4648      	mov	r0, r9
 8023b16:	4652      	mov	r2, sl
 8023b18:	f000 ffce 	bl	8024ab8 <st_int8_copy>
 8023b1c:	9b00      	ldr	r3, [sp, #0]
 8023b1e:	4632      	mov	r2, r6
 8023b20:	4628      	mov	r0, r5
 8023b22:	18e1      	adds	r1, r4, r3
 8023b24:	44d1      	add	r9, sl
 8023b26:	f000 ff69 	bl	80249fc <st_int8_fill>
 8023b2a:	9b01      	ldr	r3, [sp, #4]
 8023b2c:	445c      	add	r4, fp
 8023b2e:	4543      	cmp	r3, r8
 8023b30:	d1e8      	bne.n	8023b04 <forward_lite_pad_constant+0xf0>
 8023b32:	461a      	mov	r2, r3
 8023b34:	9b03      	ldr	r3, [sp, #12]
 8023b36:	fb0b 3302 	mla	r3, fp, r2, r3
 8023b3a:	9303      	str	r3, [sp, #12]
 8023b3c:	4628      	mov	r0, r5
 8023b3e:	e9dd 2102 	ldrd	r2, r1, [sp, #8]
 8023b42:	b005      	add	sp, #20
 8023b44:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8023b48:	f000 bf58 	b.w	80249fc <st_int8_fill>

08023b4c <forward_lite_pad_edge>:
 8023b4c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8023b50:	ed2d 8b02 	vpush	{d8}
 8023b54:	b087      	sub	sp, #28
 8023b56:	9305      	str	r3, [sp, #20]
 8023b58:	9b16      	ldr	r3, [sp, #88]	@ 0x58
 8023b5a:	f9bd 8048 	ldrsh.w	r8, [sp, #72]	@ 0x48
 8023b5e:	18cd      	adds	r5, r1, r3
 8023b60:	1e13      	subs	r3, r2, #0
 8023b62:	f8dd 905c 	ldr.w	r9, [sp, #92]	@ 0x5c
 8023b66:	9103      	str	r1, [sp, #12]
 8023b68:	9504      	str	r5, [sp, #16]
 8023b6a:	9301      	str	r3, [sp, #4]
 8023b6c:	e9dd 4a14 	ldrd	r4, sl, [sp, #80]	@ 0x50
 8023b70:	dd36      	ble.n	8023be0 <forward_lite_pad_edge+0x94>
 8023b72:	fb04 f308 	mul.w	r3, r4, r8
 8023b76:	4607      	mov	r7, r0
 8023b78:	ee08 aa10 	vmov	s16, sl
 8023b7c:	9302      	str	r3, [sp, #8]
 8023b7e:	2300      	movs	r3, #0
 8023b80:	9300      	str	r3, [sp, #0]
 8023b82:	f1b9 0f00 	cmp.w	r9, #0
 8023b86:	dd09      	ble.n	8023b9c <forward_lite_pad_edge+0x50>
 8023b88:	2600      	movs	r6, #0
 8023b8a:	4426      	add	r6, r4
 8023b8c:	4629      	mov	r1, r5
 8023b8e:	4622      	mov	r2, r4
 8023b90:	4638      	mov	r0, r7
 8023b92:	f000 ff91 	bl	8024ab8 <st_int8_copy>
 8023b96:	45b1      	cmp	r9, r6
 8023b98:	4425      	add	r5, r4
 8023b9a:	dcf6      	bgt.n	8023b8a <forward_lite_pad_edge+0x3e>
 8023b9c:	9b13      	ldr	r3, [sp, #76]	@ 0x4c
 8023b9e:	4638      	mov	r0, r7
 8023ba0:	4629      	mov	r1, r5
 8023ba2:	461a      	mov	r2, r3
 8023ba4:	441f      	add	r7, r3
 8023ba6:	441d      	add	r5, r3
 8023ba8:	f000 ff86 	bl	8024ab8 <st_int8_copy>
 8023bac:	f1b8 0f00 	cmp.w	r8, #0
 8023bb0:	eba7 0a04 	sub.w	sl, r7, r4
 8023bb4:	dd0c      	ble.n	8023bd0 <forward_lite_pad_edge+0x84>
 8023bb6:	46ab      	mov	fp, r5
 8023bb8:	2600      	movs	r6, #0
 8023bba:	3601      	adds	r6, #1
 8023bbc:	4659      	mov	r1, fp
 8023bbe:	4622      	mov	r2, r4
 8023bc0:	4650      	mov	r0, sl
 8023bc2:	f000 ff79 	bl	8024ab8 <st_int8_copy>
 8023bc6:	4546      	cmp	r6, r8
 8023bc8:	44a3      	add	fp, r4
 8023bca:	d1f6      	bne.n	8023bba <forward_lite_pad_edge+0x6e>
 8023bcc:	9b02      	ldr	r3, [sp, #8]
 8023bce:	441d      	add	r5, r3
 8023bd0:	9b00      	ldr	r3, [sp, #0]
 8023bd2:	9a01      	ldr	r2, [sp, #4]
 8023bd4:	3301      	adds	r3, #1
 8023bd6:	429a      	cmp	r2, r3
 8023bd8:	9300      	str	r3, [sp, #0]
 8023bda:	d1d2      	bne.n	8023b82 <forward_lite_pad_edge+0x36>
 8023bdc:	ee18 aa10 	vmov	sl, s16
 8023be0:	e9dd 3203 	ldrd	r3, r2, [sp, #12]
 8023be4:	4293      	cmp	r3, r2
 8023be6:	d009      	beq.n	8023bfc <forward_lite_pad_edge+0xb0>
 8023be8:	461c      	mov	r4, r3
 8023bea:	4615      	mov	r5, r2
 8023bec:	4621      	mov	r1, r4
 8023bee:	4454      	add	r4, sl
 8023bf0:	4652      	mov	r2, sl
 8023bf2:	4628      	mov	r0, r5
 8023bf4:	f000 ff60 	bl	8024ab8 <st_int8_copy>
 8023bf8:	42a5      	cmp	r5, r4
 8023bfa:	d1f7      	bne.n	8023bec <forward_lite_pad_edge+0xa0>
 8023bfc:	9a01      	ldr	r2, [sp, #4]
 8023bfe:	9b05      	ldr	r3, [sp, #20]
 8023c00:	4413      	add	r3, r2
 8023c02:	9a03      	ldr	r2, [sp, #12]
 8023c04:	3b01      	subs	r3, #1
 8023c06:	fb0a 2503 	mla	r5, sl, r3, r2
 8023c0a:	9b18      	ldr	r3, [sp, #96]	@ 0x60
 8023c0c:	18ec      	adds	r4, r5, r3
 8023c0e:	42a5      	cmp	r5, r4
 8023c10:	d009      	beq.n	8023c26 <forward_lite_pad_edge+0xda>
 8023c12:	f1ca 0600 	rsb	r6, sl, #0
 8023c16:	4621      	mov	r1, r4
 8023c18:	4434      	add	r4, r6
 8023c1a:	4652      	mov	r2, sl
 8023c1c:	4628      	mov	r0, r5
 8023c1e:	f000 ff4b 	bl	8024ab8 <st_int8_copy>
 8023c22:	42a5      	cmp	r5, r4
 8023c24:	d1f7      	bne.n	8023c16 <forward_lite_pad_edge+0xca>
 8023c26:	b007      	add	sp, #28
 8023c28:	ecbd 8b02 	vpop	{d8}
 8023c2c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08023c30 <forward_lite_pad_reflect>:
 8023c30:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8023c34:	b08f      	sub	sp, #60	@ 0x3c
 8023c36:	460e      	mov	r6, r1
 8023c38:	2b00      	cmp	r3, #0
 8023c3a:	4684      	mov	ip, r0
 8023c3c:	f9bd 5080 	ldrsh.w	r5, [sp, #128]	@ 0x80
 8023c40:	9f22      	ldr	r7, [sp, #136]	@ 0x88
 8023c42:	f9bd e084 	ldrsh.w	lr, [sp, #132]	@ 0x84
 8023c46:	910b      	str	r1, [sp, #44]	@ 0x2c
 8023c48:	4437      	add	r7, r6
 8023c4a:	9002      	str	r0, [sp, #8]
 8023c4c:	950c      	str	r5, [sp, #48]	@ 0x30
 8023c4e:	9918      	ldr	r1, [sp, #96]	@ 0x60
 8023c50:	f8dd 8068 	ldr.w	r8, [sp, #104]	@ 0x68
 8023c54:	9c1c      	ldr	r4, [sp, #112]	@ 0x70
 8023c56:	f8dd 9078 	ldr.w	r9, [sp, #120]	@ 0x78
 8023c5a:	f9bd 007c 	ldrsh.w	r0, [sp, #124]	@ 0x7c
 8023c5e:	9d23      	ldr	r5, [sp, #140]	@ 0x8c
 8023c60:	f8cd e034 	str.w	lr, [sp, #52]	@ 0x34
 8023c64:	9307      	str	r3, [sp, #28]
 8023c66:	dd58      	ble.n	8023d1a <forward_lite_pad_reflect+0xea>
 8023c68:	4408      	add	r0, r1
 8023c6a:	9b24      	ldr	r3, [sp, #144]	@ 0x90
 8023c6c:	f1c9 0a00 	rsb	sl, r9, #0
 8023c70:	fb02 f200 	mul.w	r2, r2, r0
 8023c74:	981b      	ldr	r0, [sp, #108]	@ 0x6c
 8023c76:	4403      	add	r3, r0
 8023c78:	9206      	str	r2, [sp, #24]
 8023c7a:	442b      	add	r3, r5
 8023c7c:	930a      	str	r3, [sp, #40]	@ 0x28
 8023c7e:	197b      	adds	r3, r7, r5
 8023c80:	9d0c      	ldr	r5, [sp, #48]	@ 0x30
 8023c82:	9301      	str	r3, [sp, #4]
 8023c84:	1e8b      	subs	r3, r1, #2
 8023c86:	fb04 f101 	mul.w	r1, r4, r1
 8023c8a:	fb04 c303 	mla	r3, r4, r3, ip
 8023c8e:	9109      	str	r1, [sp, #36]	@ 0x24
 8023c90:	9304      	str	r3, [sp, #16]
 8023c92:	fb08 2305 	mla	r3, r8, r5, r2
 8023c96:	fb09 6303 	mla	r3, r9, r3, r6
 8023c9a:	9303      	str	r3, [sp, #12]
 8023c9c:	fb09 f308 	mul.w	r3, r9, r8
 8023ca0:	9308      	str	r3, [sp, #32]
 8023ca2:	2300      	movs	r3, #0
 8023ca4:	9305      	str	r3, [sp, #20]
 8023ca6:	9b01      	ldr	r3, [sp, #4]
 8023ca8:	42bb      	cmp	r3, r7
 8023caa:	d00a      	beq.n	8023cc2 <forward_lite_pad_reflect+0x92>
 8023cac:	461d      	mov	r5, r3
 8023cae:	9e02      	ldr	r6, [sp, #8]
 8023cb0:	4455      	add	r5, sl
 8023cb2:	4426      	add	r6, r4
 8023cb4:	4622      	mov	r2, r4
 8023cb6:	4629      	mov	r1, r5
 8023cb8:	4630      	mov	r0, r6
 8023cba:	f000 fefd 	bl	8024ab8 <st_int8_copy>
 8023cbe:	42bd      	cmp	r5, r7
 8023cc0:	d1f6      	bne.n	8023cb0 <forward_lite_pad_reflect+0x80>
 8023cc2:	9b02      	ldr	r3, [sp, #8]
 8023cc4:	9a1b      	ldr	r2, [sp, #108]	@ 0x6c
 8023cc6:	4618      	mov	r0, r3
 8023cc8:	9901      	ldr	r1, [sp, #4]
 8023cca:	4413      	add	r3, r2
 8023ccc:	9302      	str	r3, [sp, #8]
 8023cce:	f000 fef3 	bl	8024ab8 <st_int8_copy>
 8023cd2:	9b06      	ldr	r3, [sp, #24]
 8023cd4:	4543      	cmp	r3, r8
 8023cd6:	da0d      	bge.n	8023cf4 <forward_lite_pad_reflect+0xc4>
 8023cd8:	461d      	mov	r5, r3
 8023cda:	e9dd b603 	ldrd	fp, r6, [sp, #12]
 8023cde:	3501      	adds	r5, #1
 8023ce0:	4659      	mov	r1, fp
 8023ce2:	4630      	mov	r0, r6
 8023ce4:	4622      	mov	r2, r4
 8023ce6:	f000 fee7 	bl	8024ab8 <st_int8_copy>
 8023cea:	45a8      	cmp	r8, r5
 8023cec:	44cb      	add	fp, r9
 8023cee:	eba6 0604 	sub.w	r6, r6, r4
 8023cf2:	d1f4      	bne.n	8023cde <forward_lite_pad_reflect+0xae>
 8023cf4:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 8023cf6:	9901      	ldr	r1, [sp, #4]
 8023cf8:	4417      	add	r7, r2
 8023cfa:	9b05      	ldr	r3, [sp, #20]
 8023cfc:	4411      	add	r1, r2
 8023cfe:	9a04      	ldr	r2, [sp, #16]
 8023d00:	3301      	adds	r3, #1
 8023d02:	9101      	str	r1, [sp, #4]
 8023d04:	9909      	ldr	r1, [sp, #36]	@ 0x24
 8023d06:	9305      	str	r3, [sp, #20]
 8023d08:	440a      	add	r2, r1
 8023d0a:	9908      	ldr	r1, [sp, #32]
 8023d0c:	9204      	str	r2, [sp, #16]
 8023d0e:	9a03      	ldr	r2, [sp, #12]
 8023d10:	440a      	add	r2, r1
 8023d12:	9203      	str	r2, [sp, #12]
 8023d14:	9a07      	ldr	r2, [sp, #28]
 8023d16:	429a      	cmp	r2, r3
 8023d18:	d1c5      	bne.n	8023ca6 <forward_lite_pad_reflect+0x76>
 8023d1a:	9b1d      	ldr	r3, [sp, #116]	@ 0x74
 8023d1c:	9c0c      	ldr	r4, [sp, #48]	@ 0x30
 8023d1e:	fb03 f404 	mul.w	r4, r3, r4
 8023d22:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 8023d24:	eb03 0444 	add.w	r4, r3, r4, lsl #1
 8023d28:	42a3      	cmp	r3, r4
 8023d2a:	d00c      	beq.n	8023d46 <forward_lite_pad_reflect+0x116>
 8023d2c:	461d      	mov	r5, r3
 8023d2e:	9b1d      	ldr	r3, [sp, #116]	@ 0x74
 8023d30:	425e      	negs	r6, r3
 8023d32:	461f      	mov	r7, r3
 8023d34:	4629      	mov	r1, r5
 8023d36:	4620      	mov	r0, r4
 8023d38:	443d      	add	r5, r7
 8023d3a:	4434      	add	r4, r6
 8023d3c:	463a      	mov	r2, r7
 8023d3e:	f000 febb 	bl	8024ab8 <st_int8_copy>
 8023d42:	42a5      	cmp	r5, r4
 8023d44:	d1f6      	bne.n	8023d34 <forward_lite_pad_reflect+0x104>
 8023d46:	9a1d      	ldr	r2, [sp, #116]	@ 0x74
 8023d48:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 8023d4a:	9d0d      	ldr	r5, [sp, #52]	@ 0x34
 8023d4c:	3b01      	subs	r3, #1
 8023d4e:	991d      	ldr	r1, [sp, #116]	@ 0x74
 8023d50:	fb02 f505 	mul.w	r5, r2, r5
 8023d54:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
 8023d56:	fb01 2403 	mla	r4, r1, r3, r2
 8023d5a:	eba4 0545 	sub.w	r5, r4, r5, lsl #1
 8023d5e:	42ac      	cmp	r4, r5
 8023d60:	d00a      	beq.n	8023d78 <forward_lite_pad_reflect+0x148>
 8023d62:	424e      	negs	r6, r1
 8023d64:	460f      	mov	r7, r1
 8023d66:	4621      	mov	r1, r4
 8023d68:	4628      	mov	r0, r5
 8023d6a:	4434      	add	r4, r6
 8023d6c:	443d      	add	r5, r7
 8023d6e:	463a      	mov	r2, r7
 8023d70:	f000 fea2 	bl	8024ab8 <st_int8_copy>
 8023d74:	42ac      	cmp	r4, r5
 8023d76:	d1f6      	bne.n	8023d66 <forward_lite_pad_reflect+0x136>
 8023d78:	b00f      	add	sp, #60	@ 0x3c
 8023d7a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8023d7e:	bf00      	nop

08023d80 <align_factor_ch>:
 8023d80:	b361      	cbz	r1, 8023ddc <align_factor_ch+0x5c>
 8023d82:	ee80 7a20 	vdiv.f32	s14, s0, s1
 8023d86:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 8023d8a:	b570      	push	{r4, r5, r6, lr}
 8023d8c:	1e9d      	subs	r5, r3, #2
 8023d8e:	1f14      	subs	r4, r2, #4
 8023d90:	2600      	movs	r6, #0
 8023d92:	ecf0 7a01 	vldmia	r0!, {s15}
 8023d96:	ee67 7a27 	vmul.f32	s15, s14, s15
 8023d9a:	ee17 ea90 	vmov	lr, s15
 8023d9e:	f3ce 52c7 	ubfx	r2, lr, #23, #8
 8023da2:	f3ce 0c16 	ubfx	ip, lr, #0, #23
 8023da6:	f1be 0f00 	cmp.w	lr, #0
 8023daa:	f50c 0c00 	add.w	ip, ip, #8388608	@ 0x800000
 8023dae:	f1c2 027e 	rsb	r2, r2, #126	@ 0x7e
 8023db2:	bfb8      	it	lt
 8023db4:	f1cc 0c00 	rsblt	ip, ip, #0
 8023db8:	2a1f      	cmp	r2, #31
 8023dba:	ea4f 13cc 	mov.w	r3, ip, lsl #7
 8023dbe:	dc06      	bgt.n	8023dce <align_factor_ch+0x4e>
 8023dc0:	4281      	cmp	r1, r0
 8023dc2:	f825 2f02 	strh.w	r2, [r5, #2]!
 8023dc6:	f844 3f04 	str.w	r3, [r4, #4]!
 8023dca:	d1e2      	bne.n	8023d92 <align_factor_ch+0x12>
 8023dcc:	bd70      	pop	{r4, r5, r6, pc}
 8023dce:	4281      	cmp	r1, r0
 8023dd0:	f825 6f02 	strh.w	r6, [r5, #2]!
 8023dd4:	f844 6f04 	str.w	r6, [r4, #4]!
 8023dd8:	d1db      	bne.n	8023d92 <align_factor_ch+0x12>
 8023dda:	bd70      	pop	{r4, r5, r6, pc}
 8023ddc:	4770      	bx	lr
 8023dde:	bf00      	nop

08023de0 <st_int8_to16_no_shift>:
 8023de0:	b570      	push	{r4, r5, r6, lr}
 8023de2:	f1b2 0410 	subs.w	r4, r2, #16
 8023de6:	f04f 0e00 	mov.w	lr, #0
 8023dea:	d438      	bmi.n	8023e5e <st_int8_to16_no_shift+0x7e>
 8023dec:	f8d0 c000 	ldr.w	ip, [r0]
 8023df0:	6843      	ldr	r3, [r0, #4]
 8023df2:	fa2f f59c 	sxtb16	r5, ip, ror #8
 8023df6:	fa2f fc8c 	sxtb16	ip, ip
 8023dfa:	eac5 462c 	pkhtb	r6, r5, ip, asr #16
 8023dfe:	eacc 4c05 	pkhbt	ip, ip, r5, lsl #16
 8023e02:	fa2f f593 	sxtb16	r5, r3, ror #8
 8023e06:	3010      	adds	r0, #16
 8023e08:	604e      	str	r6, [r1, #4]
 8023e0a:	f8c1 c000 	str.w	ip, [r1]
 8023e0e:	fa2f f383 	sxtb16	r3, r3
 8023e12:	eac5 4623 	pkhtb	r6, r5, r3, asr #16
 8023e16:	eac3 4305 	pkhbt	r3, r3, r5, lsl #16
 8023e1a:	60ce      	str	r6, [r1, #12]
 8023e1c:	608b      	str	r3, [r1, #8]
 8023e1e:	f850 cc08 	ldr.w	ip, [r0, #-8]
 8023e22:	f850 3c04 	ldr.w	r3, [r0, #-4]
 8023e26:	fa2f f59c 	sxtb16	r5, ip, ror #8
 8023e2a:	fa2f fc8c 	sxtb16	ip, ip
 8023e2e:	eac5 462c 	pkhtb	r6, r5, ip, asr #16
 8023e32:	eacc 4c05 	pkhbt	ip, ip, r5, lsl #16
 8023e36:	fa2f f593 	sxtb16	r5, r3, ror #8
 8023e3a:	f10e 0e10 	add.w	lr, lr, #16
 8023e3e:	f8c1 c010 	str.w	ip, [r1, #16]
 8023e42:	614e      	str	r6, [r1, #20]
 8023e44:	3120      	adds	r1, #32
 8023e46:	45a6      	cmp	lr, r4
 8023e48:	fa2f f383 	sxtb16	r3, r3
 8023e4c:	eac5 4c23 	pkhtb	ip, r5, r3, asr #16
 8023e50:	eac3 4305 	pkhbt	r3, r3, r5, lsl #16
 8023e54:	f841 cc04 	str.w	ip, [r1, #-4]
 8023e58:	f841 3c08 	str.w	r3, [r1, #-8]
 8023e5c:	ddc6      	ble.n	8023dec <st_int8_to16_no_shift+0xc>
 8023e5e:	1f16      	subs	r6, r2, #4
 8023e60:	4576      	cmp	r6, lr
 8023e62:	db12      	blt.n	8023e8a <st_int8_to16_no_shift+0xaa>
 8023e64:	f850 3b04 	ldr.w	r3, [r0], #4
 8023e68:	fa2f f493 	sxtb16	r4, r3, ror #8
 8023e6c:	f10e 0e04 	add.w	lr, lr, #4
 8023e70:	3108      	adds	r1, #8
 8023e72:	fa2f f383 	sxtb16	r3, r3
 8023e76:	45b6      	cmp	lr, r6
 8023e78:	eac4 4523 	pkhtb	r5, r4, r3, asr #16
 8023e7c:	eac3 4304 	pkhbt	r3, r3, r4, lsl #16
 8023e80:	f841 5c04 	str.w	r5, [r1, #-4]
 8023e84:	f841 3c08 	str.w	r3, [r1, #-8]
 8023e88:	ddec      	ble.n	8023e64 <st_int8_to16_no_shift+0x84>
 8023e8a:	4572      	cmp	r2, lr
 8023e8c:	dd08      	ble.n	8023ea0 <st_int8_to16_no_shift+0xc0>
 8023e8e:	eba2 020e 	sub.w	r2, r2, lr
 8023e92:	4402      	add	r2, r0
 8023e94:	f910 3b01 	ldrsb.w	r3, [r0], #1
 8023e98:	4290      	cmp	r0, r2
 8023e9a:	f821 3b02 	strh.w	r3, [r1], #2
 8023e9e:	d1f9      	bne.n	8023e94 <st_int8_to16_no_shift+0xb4>
 8023ea0:	bd70      	pop	{r4, r5, r6, pc}
 8023ea2:	bf00      	nop

08023ea4 <st_int8_to16_no_shift_interleaved>:
 8023ea4:	b570      	push	{r4, r5, r6, lr}
 8023ea6:	f1b2 0510 	subs.w	r5, r2, #16
 8023eaa:	f04f 0e00 	mov.w	lr, #0
 8023eae:	d428      	bmi.n	8023f02 <st_int8_to16_no_shift_interleaved+0x5e>
 8023eb0:	f8d0 c000 	ldr.w	ip, [r0]
 8023eb4:	6843      	ldr	r3, [r0, #4]
 8023eb6:	fa2f f69c 	sxtb16	r6, ip, ror #8
 8023eba:	fa2f fc8c 	sxtb16	ip, ip
 8023ebe:	fa2f f493 	sxtb16	r4, r3, ror #8
 8023ec2:	3010      	adds	r0, #16
 8023ec4:	600e      	str	r6, [r1, #0]
 8023ec6:	f8c1 c004 	str.w	ip, [r1, #4]
 8023eca:	608c      	str	r4, [r1, #8]
 8023ecc:	fa2f f383 	sxtb16	r3, r3
 8023ed0:	60cb      	str	r3, [r1, #12]
 8023ed2:	f850 cc08 	ldr.w	ip, [r0, #-8]
 8023ed6:	f850 3c04 	ldr.w	r3, [r0, #-4]
 8023eda:	fa2f f69c 	sxtb16	r6, ip, ror #8
 8023ede:	fa2f fc8c 	sxtb16	ip, ip
 8023ee2:	fa2f f493 	sxtb16	r4, r3, ror #8
 8023ee6:	f10e 0e10 	add.w	lr, lr, #16
 8023eea:	610e      	str	r6, [r1, #16]
 8023eec:	f8c1 c014 	str.w	ip, [r1, #20]
 8023ef0:	3120      	adds	r1, #32
 8023ef2:	45ae      	cmp	lr, r5
 8023ef4:	f841 4c08 	str.w	r4, [r1, #-8]
 8023ef8:	fa2f f383 	sxtb16	r3, r3
 8023efc:	f841 3c04 	str.w	r3, [r1, #-4]
 8023f00:	ddd6      	ble.n	8023eb0 <st_int8_to16_no_shift_interleaved+0xc>
 8023f02:	3a04      	subs	r2, #4
 8023f04:	4572      	cmp	r2, lr
 8023f06:	db0f      	blt.n	8023f28 <st_int8_to16_no_shift_interleaved+0x84>
 8023f08:	ebae 0e00 	sub.w	lr, lr, r0
 8023f0c:	f850 3b04 	ldr.w	r3, [r0], #4
 8023f10:	fa2f f493 	sxtb16	r4, r3, ror #8
 8023f14:	eb00 0c0e 	add.w	ip, r0, lr
 8023f18:	600c      	str	r4, [r1, #0]
 8023f1a:	3108      	adds	r1, #8
 8023f1c:	4562      	cmp	r2, ip
 8023f1e:	fa2f f383 	sxtb16	r3, r3
 8023f22:	f841 3c04 	str.w	r3, [r1, #-4]
 8023f26:	daf1      	bge.n	8023f0c <st_int8_to16_no_shift_interleaved+0x68>
 8023f28:	bd70      	pop	{r4, r5, r6, pc}
 8023f2a:	bf00      	nop

08023f2c <st_int8_to16_dual>:
 8023f2c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8023f30:	4698      	mov	r8, r3
 8023f32:	085b      	lsrs	r3, r3, #1
 8023f34:	eb00 0c02 	add.w	ip, r0, r2
 8023f38:	f000 80b9 	beq.w	80240ae <st_int8_to16_dual+0x182>
 8023f3c:	f1a2 0710 	sub.w	r7, r2, #16
 8023f40:	1f16      	subs	r6, r2, #4
 8023f42:	2f00      	cmp	r7, #0
 8023f44:	f04f 0500 	mov.w	r5, #0
 8023f48:	db73      	blt.n	8024032 <st_int8_to16_dual+0x106>
 8023f4a:	f8d0 e000 	ldr.w	lr, [r0]
 8023f4e:	f8dc 4000 	ldr.w	r4, [ip]
 8023f52:	fa2f f99e 	sxtb16	r9, lr, ror #8
 8023f56:	fa2f fe8e 	sxtb16	lr, lr
 8023f5a:	eac9 4a2e 	pkhtb	sl, r9, lr, asr #16
 8023f5e:	eace 4e09 	pkhbt	lr, lr, r9, lsl #16
 8023f62:	fa2f f994 	sxtb16	r9, r4, ror #8
 8023f66:	f8c1 e000 	str.w	lr, [r1]
 8023f6a:	f8c1 a008 	str.w	sl, [r1, #8]
 8023f6e:	fa2f f484 	sxtb16	r4, r4
 8023f72:	eac9 4e24 	pkhtb	lr, r9, r4, asr #16
 8023f76:	eac4 4409 	pkhbt	r4, r4, r9, lsl #16
 8023f7a:	f8c1 e00c 	str.w	lr, [r1, #12]
 8023f7e:	604c      	str	r4, [r1, #4]
 8023f80:	f8d0 e004 	ldr.w	lr, [r0, #4]
 8023f84:	f8dc 4004 	ldr.w	r4, [ip, #4]
 8023f88:	fa2f f99e 	sxtb16	r9, lr, ror #8
 8023f8c:	fa2f fe8e 	sxtb16	lr, lr
 8023f90:	eac9 4a2e 	pkhtb	sl, r9, lr, asr #16
 8023f94:	eace 4e09 	pkhbt	lr, lr, r9, lsl #16
 8023f98:	fa2f f994 	sxtb16	r9, r4, ror #8
 8023f9c:	f8c1 e010 	str.w	lr, [r1, #16]
 8023fa0:	f8c1 a018 	str.w	sl, [r1, #24]
 8023fa4:	fa2f f484 	sxtb16	r4, r4
 8023fa8:	eac9 4e24 	pkhtb	lr, r9, r4, asr #16
 8023fac:	eac4 4409 	pkhbt	r4, r4, r9, lsl #16
 8023fb0:	f8c1 e01c 	str.w	lr, [r1, #28]
 8023fb4:	614c      	str	r4, [r1, #20]
 8023fb6:	f8d0 e008 	ldr.w	lr, [r0, #8]
 8023fba:	f8dc 4008 	ldr.w	r4, [ip, #8]
 8023fbe:	fa2f f99e 	sxtb16	r9, lr, ror #8
 8023fc2:	fa2f fe8e 	sxtb16	lr, lr
 8023fc6:	eac9 4a2e 	pkhtb	sl, r9, lr, asr #16
 8023fca:	eace 4e09 	pkhbt	lr, lr, r9, lsl #16
 8023fce:	fa2f f994 	sxtb16	r9, r4, ror #8
 8023fd2:	3010      	adds	r0, #16
 8023fd4:	f10c 0c10 	add.w	ip, ip, #16
 8023fd8:	f8c1 e020 	str.w	lr, [r1, #32]
 8023fdc:	f8c1 a028 	str.w	sl, [r1, #40]	@ 0x28
 8023fe0:	fa2f f484 	sxtb16	r4, r4
 8023fe4:	eac9 4e24 	pkhtb	lr, r9, r4, asr #16
 8023fe8:	eac4 4409 	pkhbt	r4, r4, r9, lsl #16
 8023fec:	f8c1 e02c 	str.w	lr, [r1, #44]	@ 0x2c
 8023ff0:	624c      	str	r4, [r1, #36]	@ 0x24
 8023ff2:	f850 ec04 	ldr.w	lr, [r0, #-4]
 8023ff6:	f85c 4c04 	ldr.w	r4, [ip, #-4]
 8023ffa:	fa2f fa9e 	sxtb16	sl, lr, ror #8
 8023ffe:	fa2f fe8e 	sxtb16	lr, lr
 8024002:	eaca 492e 	pkhtb	r9, sl, lr, asr #16
 8024006:	eace 4e0a 	pkhbt	lr, lr, sl, lsl #16
 802400a:	fa2f fa94 	sxtb16	sl, r4, ror #8
 802400e:	3510      	adds	r5, #16
 8024010:	f8c1 e030 	str.w	lr, [r1, #48]	@ 0x30
 8024014:	f8c1 9038 	str.w	r9, [r1, #56]	@ 0x38
 8024018:	3140      	adds	r1, #64	@ 0x40
 802401a:	42bd      	cmp	r5, r7
 802401c:	fa2f f484 	sxtb16	r4, r4
 8024020:	eaca 4e24 	pkhtb	lr, sl, r4, asr #16
 8024024:	eac4 440a 	pkhbt	r4, r4, sl, lsl #16
 8024028:	f841 ec04 	str.w	lr, [r1, #-4]
 802402c:	f841 4c0c 	str.w	r4, [r1, #-12]
 8024030:	dd8b      	ble.n	8023f4a <st_int8_to16_dual+0x1e>
 8024032:	42ae      	cmp	r6, r5
 8024034:	db1e      	blt.n	8024074 <st_int8_to16_dual+0x148>
 8024036:	f850 4b04 	ldr.w	r4, [r0], #4
 802403a:	f85c eb04 	ldr.w	lr, [ip], #4
 802403e:	fa2f fa94 	sxtb16	sl, r4, ror #8
 8024042:	fa2f f484 	sxtb16	r4, r4
 8024046:	eaca 4924 	pkhtb	r9, sl, r4, asr #16
 802404a:	eac4 440a 	pkhbt	r4, r4, sl, lsl #16
 802404e:	fa2f fa9e 	sxtb16	sl, lr, ror #8
 8024052:	3504      	adds	r5, #4
 8024054:	600c      	str	r4, [r1, #0]
 8024056:	f8c1 9008 	str.w	r9, [r1, #8]
 802405a:	3110      	adds	r1, #16
 802405c:	42b5      	cmp	r5, r6
 802405e:	fa2f fe8e 	sxtb16	lr, lr
 8024062:	eaca 442e 	pkhtb	r4, sl, lr, asr #16
 8024066:	eace 4e0a 	pkhbt	lr, lr, sl, lsl #16
 802406a:	f841 4c04 	str.w	r4, [r1, #-4]
 802406e:	f841 ec0c 	str.w	lr, [r1, #-12]
 8024072:	dde0      	ble.n	8024036 <st_int8_to16_dual+0x10a>
 8024074:	42aa      	cmp	r2, r5
 8024076:	dd40      	ble.n	80240fa <st_int8_to16_dual+0x1ce>
 8024078:	1b55      	subs	r5, r2, r5
 802407a:	1d0c      	adds	r4, r1, #4
 802407c:	46e6      	mov	lr, ip
 802407e:	eb00 0a05 	add.w	sl, r0, r5
 8024082:	f910 9b01 	ldrsb.w	r9, [r0], #1
 8024086:	3404      	adds	r4, #4
 8024088:	f824 9c08 	strh.w	r9, [r4, #-8]
 802408c:	4550      	cmp	r0, sl
 802408e:	f91e 9b01 	ldrsb.w	r9, [lr], #1
 8024092:	f824 9c06 	strh.w	r9, [r4, #-6]
 8024096:	d1f4      	bne.n	8024082 <st_int8_to16_dual+0x156>
 8024098:	44ac      	add	ip, r5
 802409a:	eb01 0185 	add.w	r1, r1, r5, lsl #2
 802409e:	3b01      	subs	r3, #1
 80240a0:	eb0a 0002 	add.w	r0, sl, r2
 80240a4:	4494      	add	ip, r2
 80240a6:	b29b      	uxth	r3, r3
 80240a8:	2b00      	cmp	r3, #0
 80240aa:	f47f af4a 	bne.w	8023f42 <st_int8_to16_dual+0x16>
 80240ae:	f018 0f01 	tst.w	r8, #1
 80240b2:	d020      	beq.n	80240f6 <st_int8_to16_dual+0x1ca>
 80240b4:	1f17      	subs	r7, r2, #4
 80240b6:	f04f 0400 	mov.w	r4, #0
 80240ba:	d411      	bmi.n	80240e0 <st_int8_to16_dual+0x1b4>
 80240bc:	f850 3b04 	ldr.w	r3, [r0], #4
 80240c0:	fa2f f593 	sxtb16	r5, r3, ror #8
 80240c4:	3404      	adds	r4, #4
 80240c6:	3108      	adds	r1, #8
 80240c8:	fa2f f383 	sxtb16	r3, r3
 80240cc:	42a7      	cmp	r7, r4
 80240ce:	eac5 4623 	pkhtb	r6, r5, r3, asr #16
 80240d2:	eac3 4305 	pkhbt	r3, r3, r5, lsl #16
 80240d6:	f841 6c04 	str.w	r6, [r1, #-4]
 80240da:	f841 3c08 	str.w	r3, [r1, #-8]
 80240de:	daed      	bge.n	80240bc <st_int8_to16_dual+0x190>
 80240e0:	42a2      	cmp	r2, r4
 80240e2:	dd08      	ble.n	80240f6 <st_int8_to16_dual+0x1ca>
 80240e4:	1b13      	subs	r3, r2, r4
 80240e6:	eb01 0343 	add.w	r3, r1, r3, lsl #1
 80240ea:	f910 2b01 	ldrsb.w	r2, [r0], #1
 80240ee:	f821 2b02 	strh.w	r2, [r1], #2
 80240f2:	428b      	cmp	r3, r1
 80240f4:	d1f9      	bne.n	80240ea <st_int8_to16_dual+0x1be>
 80240f6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80240fa:	4682      	mov	sl, r0
 80240fc:	e7cf      	b.n	802409e <st_int8_to16_dual+0x172>
 80240fe:	bf00      	nop

08024100 <st_int8_to16_dual_interleaved>:
 8024100:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8024104:	4698      	mov	r8, r3
 8024106:	085b      	lsrs	r3, r3, #1
 8024108:	eb00 0c02 	add.w	ip, r0, r2
 802410c:	f000 808f 	beq.w	802422e <st_int8_to16_dual_interleaved+0x12e>
 8024110:	f1a2 0710 	sub.w	r7, r2, #16
 8024114:	1f16      	subs	r6, r2, #4
 8024116:	2f00      	cmp	r7, #0
 8024118:	f04f 0e00 	mov.w	lr, #0
 802411c:	db4e      	blt.n	80241bc <st_int8_to16_dual_interleaved+0xbc>
 802411e:	6805      	ldr	r5, [r0, #0]
 8024120:	f8dc 4000 	ldr.w	r4, [ip]
 8024124:	fa2f fa95 	sxtb16	sl, r5, ror #8
 8024128:	fa2f f585 	sxtb16	r5, r5
 802412c:	fa2f f994 	sxtb16	r9, r4, ror #8
 8024130:	f8c1 a000 	str.w	sl, [r1]
 8024134:	f8c1 9004 	str.w	r9, [r1, #4]
 8024138:	608d      	str	r5, [r1, #8]
 802413a:	fa2f f484 	sxtb16	r4, r4
 802413e:	60cc      	str	r4, [r1, #12]
 8024140:	6845      	ldr	r5, [r0, #4]
 8024142:	f8dc 4004 	ldr.w	r4, [ip, #4]
 8024146:	fa2f fa95 	sxtb16	sl, r5, ror #8
 802414a:	fa2f f585 	sxtb16	r5, r5
 802414e:	fa2f f994 	sxtb16	r9, r4, ror #8
 8024152:	f8c1 a010 	str.w	sl, [r1, #16]
 8024156:	f8c1 9014 	str.w	r9, [r1, #20]
 802415a:	618d      	str	r5, [r1, #24]
 802415c:	fa2f f484 	sxtb16	r4, r4
 8024160:	61cc      	str	r4, [r1, #28]
 8024162:	6885      	ldr	r5, [r0, #8]
 8024164:	f8dc 4008 	ldr.w	r4, [ip, #8]
 8024168:	fa2f fa95 	sxtb16	sl, r5, ror #8
 802416c:	fa2f f585 	sxtb16	r5, r5
 8024170:	fa2f f994 	sxtb16	r9, r4, ror #8
 8024174:	3010      	adds	r0, #16
 8024176:	f10c 0c10 	add.w	ip, ip, #16
 802417a:	f8c1 a020 	str.w	sl, [r1, #32]
 802417e:	f8c1 9024 	str.w	r9, [r1, #36]	@ 0x24
 8024182:	628d      	str	r5, [r1, #40]	@ 0x28
 8024184:	fa2f f484 	sxtb16	r4, r4
 8024188:	62cc      	str	r4, [r1, #44]	@ 0x2c
 802418a:	f850 5c04 	ldr.w	r5, [r0, #-4]
 802418e:	f85c 4c04 	ldr.w	r4, [ip, #-4]
 8024192:	fa2f fa95 	sxtb16	sl, r5, ror #8
 8024196:	fa2f f585 	sxtb16	r5, r5
 802419a:	fa2f f994 	sxtb16	r9, r4, ror #8
 802419e:	f10e 0e10 	add.w	lr, lr, #16
 80241a2:	f8c1 a030 	str.w	sl, [r1, #48]	@ 0x30
 80241a6:	f8c1 9034 	str.w	r9, [r1, #52]	@ 0x34
 80241aa:	3140      	adds	r1, #64	@ 0x40
 80241ac:	45be      	cmp	lr, r7
 80241ae:	f841 5c08 	str.w	r5, [r1, #-8]
 80241b2:	fa2f f484 	sxtb16	r4, r4
 80241b6:	f841 4c04 	str.w	r4, [r1, #-4]
 80241ba:	ddb0      	ble.n	802411e <st_int8_to16_dual_interleaved+0x1e>
 80241bc:	4576      	cmp	r6, lr
 80241be:	db18      	blt.n	80241f2 <st_int8_to16_dual_interleaved+0xf2>
 80241c0:	f850 5b04 	ldr.w	r5, [r0], #4
 80241c4:	f85c 4b04 	ldr.w	r4, [ip], #4
 80241c8:	fa2f fa95 	sxtb16	sl, r5, ror #8
 80241cc:	fa2f f585 	sxtb16	r5, r5
 80241d0:	fa2f f994 	sxtb16	r9, r4, ror #8
 80241d4:	f10e 0e04 	add.w	lr, lr, #4
 80241d8:	f8c1 a000 	str.w	sl, [r1]
 80241dc:	f8c1 9004 	str.w	r9, [r1, #4]
 80241e0:	3110      	adds	r1, #16
 80241e2:	45b6      	cmp	lr, r6
 80241e4:	f841 5c08 	str.w	r5, [r1, #-8]
 80241e8:	fa2f f484 	sxtb16	r4, r4
 80241ec:	f841 4c04 	str.w	r4, [r1, #-4]
 80241f0:	dde6      	ble.n	80241c0 <st_int8_to16_dual_interleaved+0xc0>
 80241f2:	4572      	cmp	r2, lr
 80241f4:	dd3c      	ble.n	8024270 <st_int8_to16_dual_interleaved+0x170>
 80241f6:	eba2 0e0e 	sub.w	lr, r2, lr
 80241fa:	1d0c      	adds	r4, r1, #4
 80241fc:	4665      	mov	r5, ip
 80241fe:	eb00 0a0e 	add.w	sl, r0, lr
 8024202:	f910 9b01 	ldrsb.w	r9, [r0], #1
 8024206:	3404      	adds	r4, #4
 8024208:	f824 9c08 	strh.w	r9, [r4, #-8]
 802420c:	4550      	cmp	r0, sl
 802420e:	f915 9b01 	ldrsb.w	r9, [r5], #1
 8024212:	f824 9c06 	strh.w	r9, [r4, #-6]
 8024216:	d1f4      	bne.n	8024202 <st_int8_to16_dual_interleaved+0x102>
 8024218:	44f4      	add	ip, lr
 802421a:	eb01 018e 	add.w	r1, r1, lr, lsl #2
 802421e:	3b01      	subs	r3, #1
 8024220:	eb0a 0002 	add.w	r0, sl, r2
 8024224:	4494      	add	ip, r2
 8024226:	b29b      	uxth	r3, r3
 8024228:	2b00      	cmp	r3, #0
 802422a:	f47f af74 	bne.w	8024116 <st_int8_to16_dual_interleaved+0x16>
 802422e:	f018 0f01 	tst.w	r8, #1
 8024232:	d01b      	beq.n	802426c <st_int8_to16_dual_interleaved+0x16c>
 8024234:	1f16      	subs	r6, r2, #4
 8024236:	f04f 0400 	mov.w	r4, #0
 802423a:	d40c      	bmi.n	8024256 <st_int8_to16_dual_interleaved+0x156>
 802423c:	f850 3b04 	ldr.w	r3, [r0], #4
 8024240:	fa2f f593 	sxtb16	r5, r3, ror #8
 8024244:	3404      	adds	r4, #4
 8024246:	600d      	str	r5, [r1, #0]
 8024248:	3108      	adds	r1, #8
 802424a:	42a6      	cmp	r6, r4
 802424c:	fa2f f383 	sxtb16	r3, r3
 8024250:	f841 3c04 	str.w	r3, [r1, #-4]
 8024254:	daf2      	bge.n	802423c <st_int8_to16_dual_interleaved+0x13c>
 8024256:	42a2      	cmp	r2, r4
 8024258:	dd08      	ble.n	802426c <st_int8_to16_dual_interleaved+0x16c>
 802425a:	1b13      	subs	r3, r2, r4
 802425c:	eb01 0343 	add.w	r3, r1, r3, lsl #1
 8024260:	f910 2b01 	ldrsb.w	r2, [r0], #1
 8024264:	f821 2b02 	strh.w	r2, [r1], #2
 8024268:	428b      	cmp	r3, r1
 802426a:	d1f9      	bne.n	8024260 <st_int8_to16_dual_interleaved+0x160>
 802426c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8024270:	4682      	mov	sl, r0
 8024272:	e7d4      	b.n	802421e <st_int8_to16_dual_interleaved+0x11e>

08024274 <ai_padding_opt_init>:
 8024274:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8024278:	2700      	movs	r7, #0
 802427a:	9c07      	ldr	r4, [sp, #28]
 802427c:	e9c0 7700 	strd	r7, r7, [r0]
 8024280:	6087      	str	r7, [r0, #8]
 8024282:	46b9      	mov	r9, r7
 8024284:	690e      	ldr	r6, [r1, #16]
 8024286:	f1c6 0c00 	rsb	ip, r6, #0
 802428a:	689e      	ldr	r6, [r3, #8]
 802428c:	42be      	cmp	r6, r7
 802428e:	dd1c      	ble.n	80242ca <ai_padding_opt_init+0x56>
 8024290:	463e      	mov	r6, r7
 8024292:	46be      	mov	lr, r7
 8024294:	e010      	b.n	80242b8 <ai_padding_opt_init+0x44>
 8024296:	6895      	ldr	r5, [r2, #8]
 8024298:	eba5 080c 	sub.w	r8, r5, ip
 802429c:	68a5      	ldr	r5, [r4, #8]
 802429e:	45a8      	cmp	r8, r5
 80242a0:	da10      	bge.n	80242c4 <ai_padding_opt_init+0x50>
 80242a2:	f109 0901 	add.w	r9, r9, #1
 80242a6:	f8c0 9008 	str.w	r9, [r0, #8]
 80242aa:	688d      	ldr	r5, [r1, #8]
 80242ac:	f10e 0e01 	add.w	lr, lr, #1
 80242b0:	44ac      	add	ip, r5
 80242b2:	689d      	ldr	r5, [r3, #8]
 80242b4:	4575      	cmp	r5, lr
 80242b6:	dd09      	ble.n	80242cc <ai_padding_opt_init+0x58>
 80242b8:	f1bc 0f00 	cmp.w	ip, #0
 80242bc:	daeb      	bge.n	8024296 <ai_padding_opt_init+0x22>
 80242be:	3601      	adds	r6, #1
 80242c0:	6006      	str	r6, [r0, #0]
 80242c2:	e7f2      	b.n	80242aa <ai_padding_opt_init+0x36>
 80242c4:	3701      	adds	r7, #1
 80242c6:	6047      	str	r7, [r0, #4]
 80242c8:	e7ef      	b.n	80242aa <ai_padding_opt_init+0x36>
 80242ca:	463e      	mov	r6, r7
 80242cc:	2500      	movs	r5, #0
 80242ce:	f8c0 9014 	str.w	r9, [r0, #20]
 80242d2:	e9c0 6703 	strd	r6, r7, [r0, #12]
 80242d6:	e9c0 5506 	strd	r5, r5, [r0, #24]
 80242da:	6205      	str	r5, [r0, #32]
 80242dc:	694e      	ldr	r6, [r1, #20]
 80242de:	f1c6 0c00 	rsb	ip, r6, #0
 80242e2:	685e      	ldr	r6, [r3, #4]
 80242e4:	42ae      	cmp	r6, r5
 80242e6:	dd1c      	ble.n	8024322 <ai_padding_opt_init+0xae>
 80242e8:	46ae      	mov	lr, r5
 80242ea:	e00f      	b.n	802430c <ai_padding_opt_init+0x98>
 80242ec:	6855      	ldr	r5, [r2, #4]
 80242ee:	6866      	ldr	r6, [r4, #4]
 80242f0:	eba5 050c 	sub.w	r5, r5, ip
 80242f4:	42b5      	cmp	r5, r6
 80242f6:	da10      	bge.n	802431a <ai_padding_opt_init+0xa6>
 80242f8:	6a05      	ldr	r5, [r0, #32]
 80242fa:	3501      	adds	r5, #1
 80242fc:	6205      	str	r5, [r0, #32]
 80242fe:	68cd      	ldr	r5, [r1, #12]
 8024300:	f10e 0e01 	add.w	lr, lr, #1
 8024304:	44ac      	add	ip, r5
 8024306:	685d      	ldr	r5, [r3, #4]
 8024308:	4575      	cmp	r5, lr
 802430a:	dd0a      	ble.n	8024322 <ai_padding_opt_init+0xae>
 802430c:	f1bc 0f00 	cmp.w	ip, #0
 8024310:	daec      	bge.n	80242ec <ai_padding_opt_init+0x78>
 8024312:	6985      	ldr	r5, [r0, #24]
 8024314:	3501      	adds	r5, #1
 8024316:	6185      	str	r5, [r0, #24]
 8024318:	e7f1      	b.n	80242fe <ai_padding_opt_init+0x8a>
 802431a:	69c5      	ldr	r5, [r0, #28]
 802431c:	3501      	adds	r5, #1
 802431e:	61c5      	str	r5, [r0, #28]
 8024320:	e7ed      	b.n	80242fe <ai_padding_opt_init+0x8a>
 8024322:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8024326:	bf00      	nop

08024328 <ai_padding_opt_phase1>:
 8024328:	e9d0 3206 	ldrd	r3, r2, [r0, #24]
 802432c:	b923      	cbnz	r3, 8024338 <ai_padding_opt_phase1+0x10>
 802432e:	b17a      	cbz	r2, 8024350 <ai_padding_opt_phase1+0x28>
 8024330:	3a01      	subs	r2, #1
 8024332:	8483      	strh	r3, [r0, #36]	@ 0x24
 8024334:	61c2      	str	r2, [r0, #28]
 8024336:	e004      	b.n	8024342 <ai_padding_opt_phase1+0x1a>
 8024338:	b152      	cbz	r2, 8024350 <ai_padding_opt_phase1+0x28>
 802433a:	2201      	movs	r2, #1
 802433c:	3b01      	subs	r3, #1
 802433e:	8482      	strh	r2, [r0, #36]	@ 0x24
 8024340:	6183      	str	r3, [r0, #24]
 8024342:	68c3      	ldr	r3, [r0, #12]
 8024344:	e9d0 1204 	ldrd	r1, r2, [r0, #16]
 8024348:	6003      	str	r3, [r0, #0]
 802434a:	e9c0 1201 	strd	r1, r2, [r0, #4]
 802434e:	4770      	bx	lr
 8024350:	6a03      	ldr	r3, [r0, #32]
 8024352:	2201      	movs	r2, #1
 8024354:	3b01      	subs	r3, #1
 8024356:	8482      	strh	r2, [r0, #36]	@ 0x24
 8024358:	6203      	str	r3, [r0, #32]
 802435a:	e7f2      	b.n	8024342 <ai_padding_opt_phase1+0x1a>

0802435c <st_int16_fill>:
 802435c:	b510      	push	{r4, lr}
 802435e:	eac0 4400 	pkhbt	r4, r0, r0, lsl #16
 8024362:	ea5f 0e92 	movs.w	lr, r2, lsr #2
 8024366:	d013      	beq.n	8024390 <st_int16_fill+0x34>
 8024368:	f10e 33ff 	add.w	r3, lr, #4294967295
 802436c:	2b03      	cmp	r3, #3
 802436e:	460b      	mov	r3, r1
 8024370:	d919      	bls.n	80243a6 <st_int16_fill+0x4a>
 8024372:	f011 0f07 	tst.w	r1, #7
 8024376:	d116      	bne.n	80243a6 <st_int16_fill+0x4a>
 8024378:	f04f 0c00 	mov.w	ip, #0
 802437c:	f10c 0c01 	add.w	ip, ip, #1
 8024380:	45e6      	cmp	lr, ip
 8024382:	e9c3 4400 	strd	r4, r4, [r3]
 8024386:	f103 0308 	add.w	r3, r3, #8
 802438a:	d1f7      	bne.n	802437c <st_int16_fill+0x20>
 802438c:	eb01 01ce 	add.w	r1, r1, lr, lsl #3
 8024390:	f012 0203 	ands.w	r2, r2, #3
 8024394:	d006      	beq.n	80243a4 <st_int16_fill+0x48>
 8024396:	3a01      	subs	r2, #1
 8024398:	8008      	strh	r0, [r1, #0]
 802439a:	d003      	beq.n	80243a4 <st_int16_fill+0x48>
 802439c:	2a01      	cmp	r2, #1
 802439e:	8048      	strh	r0, [r1, #2]
 80243a0:	bf18      	it	ne
 80243a2:	8088      	strhne	r0, [r1, #4]
 80243a4:	bd10      	pop	{r4, pc}
 80243a6:	46f4      	mov	ip, lr
 80243a8:	f1bc 0c01 	subs.w	ip, ip, #1
 80243ac:	601c      	str	r4, [r3, #0]
 80243ae:	605c      	str	r4, [r3, #4]
 80243b0:	f103 0308 	add.w	r3, r3, #8
 80243b4:	d1f8      	bne.n	80243a8 <st_int16_fill+0x4c>
 80243b6:	e7e9      	b.n	802438c <st_int16_fill+0x30>

080243b8 <st_sssa8_ch_convolve_rank1upd>:
 80243b8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80243bc:	b085      	sub	sp, #20
 80243be:	f8bd 4038 	ldrh.w	r4, [sp, #56]	@ 0x38
 80243c2:	f99d b040 	ldrsb.w	fp, [sp, #64]	@ 0x40
 80243c6:	fb13 f304 	smulbb	r3, r3, r4
 80243ca:	460c      	mov	r4, r1
 80243cc:	990f      	ldr	r1, [sp, #60]	@ 0x3c
 80243ce:	fb13 f500 	smulbb	r5, r3, r0
 80243d2:	9b11      	ldr	r3, [sp, #68]	@ 0x44
 80243d4:	2a00      	cmp	r2, #0
 80243d6:	d070      	beq.n	80244ba <st_sssa8_ch_convolve_rank1upd+0x102>
 80243d8:	b2ad      	uxth	r5, r5
 80243da:	f1a1 0904 	sub.w	r9, r1, #4
 80243de:	eb03 0a82 	add.w	sl, r3, r2, lsl #2
 80243e2:	08af      	lsrs	r7, r5, #2
 80243e4:	f005 0503 	and.w	r5, r5, #3
 80243e8:	eb03 08c2 	add.w	r8, r3, r2, lsl #3
 80243ec:	1e69      	subs	r1, r5, #1
 80243ee:	f1a7 0381 	sub.w	r3, r7, #129	@ 0x81
 80243f2:	f1a7 0280 	sub.w	r2, r7, #128	@ 0x80
 80243f6:	f3c3 13c8 	ubfx	r3, r3, #7, #9
 80243fa:	b289      	uxth	r1, r1
 80243fc:	9100      	str	r1, [sp, #0]
 80243fe:	ebc3 2143 	rsb	r1, r3, r3, lsl #9
 8024402:	eb02 12c1 	add.w	r2, r2, r1, lsl #7
 8024406:	b292      	uxth	r2, r2
 8024408:	9202      	str	r2, [sp, #8]
 802440a:	025a      	lsls	r2, r3, #9
 802440c:	3301      	adds	r3, #1
 802440e:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8024412:	025b      	lsls	r3, r3, #9
 8024414:	9203      	str	r2, [sp, #12]
 8024416:	9301      	str	r3, [sp, #4]
 8024418:	2f80      	cmp	r7, #128	@ 0x80
 802441a:	d953      	bls.n	80244c4 <st_sssa8_ch_convolve_rank1upd+0x10c>
 802441c:	9b03      	ldr	r3, [sp, #12]
 802441e:	f504 7000 	add.w	r0, r4, #512	@ 0x200
 8024422:	2600      	movs	r6, #0
 8024424:	eb04 0c03 	add.w	ip, r4, r3
 8024428:	f5a0 7100 	sub.w	r1, r0, #512	@ 0x200
 802442c:	2200      	movs	r2, #0
 802442e:	f851 3b04 	ldr.w	r3, [r1], #4
 8024432:	fa2f fe83 	sxtb16	lr, r3
 8024436:	4281      	cmp	r1, r0
 8024438:	ea4f 2333 	mov.w	r3, r3, ror #8
 802443c:	fa92 f21e 	qadd16	r2, r2, lr
 8024440:	fa2f f383 	sxtb16	r3, r3
 8024444:	fa92 f213 	qadd16	r2, r2, r3
 8024448:	d1f1      	bne.n	802442e <st_sssa8_ch_convolve_rank1upd+0x76>
 802444a:	f501 7000 	add.w	r0, r1, #512	@ 0x200
 802444e:	b213      	sxth	r3, r2
 8024450:	4560      	cmp	r0, ip
 8024452:	eb03 4322 	add.w	r3, r3, r2, asr #16
 8024456:	441e      	add	r6, r3
 8024458:	d1e6      	bne.n	8024428 <st_sssa8_ch_convolve_rank1upd+0x70>
 802445a:	9b01      	ldr	r3, [sp, #4]
 802445c:	18e1      	adds	r1, r4, r3
 802445e:	9c02      	ldr	r4, [sp, #8]
 8024460:	b374      	cbz	r4, 80244c0 <st_sssa8_ch_convolve_rank1upd+0x108>
 8024462:	eb01 0484 	add.w	r4, r1, r4, lsl #2
 8024466:	2200      	movs	r2, #0
 8024468:	f851 3b04 	ldr.w	r3, [r1], #4
 802446c:	fa2f f083 	sxtb16	r0, r3
 8024470:	428c      	cmp	r4, r1
 8024472:	ea4f 2333 	mov.w	r3, r3, ror #8
 8024476:	fa92 f210 	qadd16	r2, r2, r0
 802447a:	fa2f f383 	sxtb16	r3, r3
 802447e:	fa92 f213 	qadd16	r2, r2, r3
 8024482:	d1f1      	bne.n	8024468 <st_sssa8_ch_convolve_rank1upd+0xb0>
 8024484:	b213      	sxth	r3, r2
 8024486:	eb03 4322 	add.w	r3, r3, r2, asr #16
 802448a:	441e      	add	r6, r3
 802448c:	b16d      	cbz	r5, 80244aa <st_sssa8_ch_convolve_rank1upd+0xf2>
 802448e:	f994 3000 	ldrsb.w	r3, [r4]
 8024492:	441e      	add	r6, r3
 8024494:	9b00      	ldr	r3, [sp, #0]
 8024496:	b13b      	cbz	r3, 80244a8 <st_sssa8_ch_convolve_rank1upd+0xf0>
 8024498:	f994 3001 	ldrsb.w	r3, [r4, #1]
 802449c:	2d02      	cmp	r5, #2
 802449e:	441e      	add	r6, r3
 80244a0:	d002      	beq.n	80244a8 <st_sssa8_ch_convolve_rank1upd+0xf0>
 80244a2:	f994 3002 	ldrsb.w	r3, [r4, #2]
 80244a6:	441e      	add	r6, r3
 80244a8:	442c      	add	r4, r5
 80244aa:	f859 3f04 	ldr.w	r3, [r9, #4]!
 80244ae:	fb06 331b 	mls	r3, r6, fp, r3
 80244b2:	f84a 3b04 	str.w	r3, [sl], #4
 80244b6:	45c2      	cmp	sl, r8
 80244b8:	d1ae      	bne.n	8024418 <st_sssa8_ch_convolve_rank1upd+0x60>
 80244ba:	b005      	add	sp, #20
 80244bc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80244c0:	460c      	mov	r4, r1
 80244c2:	e7e3      	b.n	802448c <st_sssa8_ch_convolve_rank1upd+0xd4>
 80244c4:	4621      	mov	r1, r4
 80244c6:	2600      	movs	r6, #0
 80244c8:	463c      	mov	r4, r7
 80244ca:	e7c9      	b.n	8024460 <st_sssa8_ch_convolve_rank1upd+0xa8>

080244cc <st_sssa8_ch_fully_connected>:
 80244cc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80244d0:	b097      	sub	sp, #92	@ 0x5c
 80244d2:	468a      	mov	sl, r1
 80244d4:	4693      	mov	fp, r2
 80244d6:	4619      	mov	r1, r3
 80244d8:	9a26      	ldr	r2, [sp, #152]	@ 0x98
 80244da:	9314      	str	r3, [sp, #80]	@ 0x50
 80244dc:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80244e0:	eb02 0581 	add.w	r5, r2, r1, lsl #2
 80244e4:	9f21      	ldr	r7, [sp, #132]	@ 0x84
 80244e6:	eb02 0343 	add.w	r3, r2, r3, lsl #1
 80244ea:	f99d e088 	ldrsb.w	lr, [sp, #136]	@ 0x88
 80244ee:	9512      	str	r5, [sp, #72]	@ 0x48
 80244f0:	930d      	str	r3, [sp, #52]	@ 0x34
 80244f2:	f99d 308c 	ldrsb.w	r3, [sp, #140]	@ 0x8c
 80244f6:	2900      	cmp	r1, #0
 80244f8:	f000 827b 	beq.w	80249f2 <st_sssa8_ch_fully_connected+0x526>
 80244fc:	463c      	mov	r4, r7
 80244fe:	3504      	adds	r5, #4
 8024500:	ea4f 0841 	mov.w	r8, r1, lsl #1
 8024504:	f04f 0c01 	mov.w	ip, #1
 8024508:	eb07 0741 	add.w	r7, r7, r1, lsl #1
 802450c:	f934 2b02 	ldrsh.w	r2, [r4], #2
 8024510:	1e51      	subs	r1, r2, #1
 8024512:	fa0c f602 	lsl.w	r6, ip, r2
 8024516:	fa03 f202 	lsl.w	r2, r3, r2
 802451a:	b289      	uxth	r1, r1
 802451c:	eb02 0256 	add.w	r2, r2, r6, lsr #1
 8024520:	2914      	cmp	r1, #20
 8024522:	f200 81e8 	bhi.w	80248f6 <st_sssa8_ch_fully_connected+0x42a>
 8024526:	42bc      	cmp	r4, r7
 8024528:	f845 2c04 	str.w	r2, [r5, #-4]
 802452c:	f105 0504 	add.w	r5, r5, #4
 8024530:	d1ec      	bne.n	802450c <st_sssa8_ch_fully_connected+0x40>
 8024532:	9a14      	ldr	r2, [sp, #80]	@ 0x50
 8024534:	fa1f f38e 	uxth.w	r3, lr
 8024538:	9e0d      	ldr	r6, [sp, #52]	@ 0x34
 802453a:	eba7 0508 	sub.w	r5, r7, r8
 802453e:	0852      	lsrs	r2, r2, #1
 8024540:	f8cd e000 	str.w	lr, [sp]
 8024544:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
 8024548:	4631      	mov	r1, r6
 802454a:	4614      	mov	r4, r2
 802454c:	9215      	str	r2, [sp, #84]	@ 0x54
 802454e:	465a      	mov	r2, fp
 8024550:	9513      	str	r5, [sp, #76]	@ 0x4c
 8024552:	f000 fb39 	bl	8024bc8 <st_int8_reordered_no_shift_zero>
 8024556:	2c00      	cmp	r4, #0
 8024558:	f000 8179 	beq.w	802484e <st_sssa8_ch_fully_connected+0x382>
 802455c:	9824      	ldr	r0, [sp, #144]	@ 0x90
 802455e:	1e62      	subs	r2, r4, #1
 8024560:	f1ab 0310 	sub.w	r3, fp, #16
 8024564:	46d9      	mov	r9, fp
 8024566:	b292      	uxth	r2, r2
 8024568:	f100 0110 	add.w	r1, r0, #16
 802456c:	091b      	lsrs	r3, r3, #4
 802456e:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
 8024572:	3301      	adds	r3, #1
 8024574:	920e      	str	r2, [sp, #56]	@ 0x38
 8024576:	f1ab 0203 	sub.w	r2, fp, #3
 802457a:	920f      	str	r2, [sp, #60]	@ 0x3c
 802457c:	4602      	mov	r2, r0
 802457e:	3208      	adds	r2, #8
 8024580:	9208      	str	r2, [sp, #32]
 8024582:	1d2a      	adds	r2, r5, #4
 8024584:	9207      	str	r2, [sp, #28]
 8024586:	9a25      	ldr	r2, [sp, #148]	@ 0x94
 8024588:	3202      	adds	r2, #2
 802458a:	9204      	str	r2, [sp, #16]
 802458c:	9a20      	ldr	r2, [sp, #128]	@ 0x80
 802458e:	3204      	adds	r2, #4
 8024590:	9205      	str	r2, [sp, #20]
 8024592:	9a12      	ldr	r2, [sp, #72]	@ 0x48
 8024594:	3204      	adds	r2, #4
 8024596:	9206      	str	r2, [sp, #24]
 8024598:	011a      	lsls	r2, r3, #4
 802459a:	eb06 1343 	add.w	r3, r6, r3, lsl #5
 802459e:	9209      	str	r2, [sp, #36]	@ 0x24
 80245a0:	9310      	str	r3, [sp, #64]	@ 0x40
 80245a2:	f1ab 0304 	sub.w	r3, fp, #4
 80245a6:	9311      	str	r3, [sp, #68]	@ 0x44
 80245a8:	9b08      	ldr	r3, [sp, #32]
 80245aa:	f1b9 0f0f 	cmp.w	r9, #15
 80245ae:	eb0a 0b09 	add.w	fp, sl, r9
 80245b2:	e953 1302 	ldrd	r1, r3, [r3, #-8]
 80245b6:	f340 81ef 	ble.w	8024998 <st_sssa8_ch_fully_connected+0x4cc>
 80245ba:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 80245bc:	465c      	mov	r4, fp
 80245be:	eb0a 0502 	add.w	r5, sl, r2
 80245c2:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
 80245c4:	f8da 6000 	ldr.w	r6, [sl]
 80245c8:	6820      	ldr	r0, [r4, #0]
 80245ca:	ea4f 2736 	mov.w	r7, r6, ror #8
 80245ce:	f8d2 e000 	ldr.w	lr, [r2]
 80245d2:	ea4f 2c30 	mov.w	ip, r0, ror #8
 80245d6:	fa2f f787 	sxtb16	r7, r7
 80245da:	fa2f f686 	sxtb16	r6, r6
 80245de:	fa2f fc8c 	sxtb16	ip, ip
 80245e2:	fa2f f080 	sxtb16	r0, r0
 80245e6:	fb2e 1106 	smlad	r1, lr, r6, r1
 80245ea:	fb2e 3300 	smlad	r3, lr, r0, r3
 80245ee:	f8d2 e004 	ldr.w	lr, [r2, #4]
 80245f2:	fb2e 1707 	smlad	r7, lr, r7, r1
 80245f6:	fb2e 3e0c 	smlad	lr, lr, ip, r3
 80245fa:	f8da 1004 	ldr.w	r1, [sl, #4]
 80245fe:	6860      	ldr	r0, [r4, #4]
 8024600:	ea4f 2631 	mov.w	r6, r1, ror #8
 8024604:	6893      	ldr	r3, [r2, #8]
 8024606:	ea4f 2c30 	mov.w	ip, r0, ror #8
 802460a:	fa2f f686 	sxtb16	r6, r6
 802460e:	fa2f f181 	sxtb16	r1, r1
 8024612:	fa2f fc8c 	sxtb16	ip, ip
 8024616:	fa2f f080 	sxtb16	r0, r0
 802461a:	fb23 7101 	smlad	r1, r3, r1, r7
 802461e:	fb23 e300 	smlad	r3, r3, r0, lr
 8024622:	f8d2 e00c 	ldr.w	lr, [r2, #12]
 8024626:	fb2e 1606 	smlad	r6, lr, r6, r1
 802462a:	fb2e 3e0c 	smlad	lr, lr, ip, r3
 802462e:	f8da 0008 	ldr.w	r0, [sl, #8]
 8024632:	68a1      	ldr	r1, [r4, #8]
 8024634:	ea4f 2c30 	mov.w	ip, r0, ror #8
 8024638:	6913      	ldr	r3, [r2, #16]
 802463a:	ea4f 2731 	mov.w	r7, r1, ror #8
 802463e:	fa2f fc8c 	sxtb16	ip, ip
 8024642:	fa2f f080 	sxtb16	r0, r0
 8024646:	fa2f f787 	sxtb16	r7, r7
 802464a:	fa2f f181 	sxtb16	r1, r1
 802464e:	fb23 6000 	smlad	r0, r3, r0, r6
 8024652:	fb23 e301 	smlad	r3, r3, r1, lr
 8024656:	6951      	ldr	r1, [r2, #20]
 8024658:	fb21 000c 	smlad	r0, r1, ip, r0
 802465c:	fb21 3c07 	smlad	ip, r1, r7, r3
 8024660:	f8da 100c 	ldr.w	r1, [sl, #12]
 8024664:	3410      	adds	r4, #16
 8024666:	f854 ec04 	ldr.w	lr, [r4, #-4]
 802466a:	f10a 0a10 	add.w	sl, sl, #16
 802466e:	ea4f 2731 	mov.w	r7, r1, ror #8
 8024672:	6993      	ldr	r3, [r2, #24]
 8024674:	ea4f 263e 	mov.w	r6, lr, ror #8
 8024678:	fa2f f787 	sxtb16	r7, r7
 802467c:	fa2f f181 	sxtb16	r1, r1
 8024680:	fa2f fe8e 	sxtb16	lr, lr
 8024684:	fa2f f686 	sxtb16	r6, r6
 8024688:	fb23 0101 	smlad	r1, r3, r1, r0
 802468c:	fb23 c00e 	smlad	r0, r3, lr, ip
 8024690:	69d3      	ldr	r3, [r2, #28]
 8024692:	3220      	adds	r2, #32
 8024694:	fb23 1107 	smlad	r1, r3, r7, r1
 8024698:	fb23 0306 	smlad	r3, r3, r6, r0
 802469c:	4555      	cmp	r5, sl
 802469e:	d191      	bne.n	80245c4 <st_sssa8_ch_fully_connected+0xf8>
 80246a0:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 80246a2:	9810      	ldr	r0, [sp, #64]	@ 0x40
 80246a4:	4493      	add	fp, r2
 80246a6:	4690      	mov	r8, r2
 80246a8:	9003      	str	r0, [sp, #12]
 80246aa:	9a0f      	ldr	r2, [sp, #60]	@ 0x3c
 80246ac:	4542      	cmp	r2, r8
 80246ae:	f340 8171 	ble.w	8024994 <st_sssa8_ch_fully_connected+0x4c8>
 80246b2:	9a11      	ldr	r2, [sp, #68]	@ 0x44
 80246b4:	46dc      	mov	ip, fp
 80246b6:	9d03      	ldr	r5, [sp, #12]
 80246b8:	eba2 0208 	sub.w	r2, r2, r8
 80246bc:	0892      	lsrs	r2, r2, #2
 80246be:	920c      	str	r2, [sp, #48]	@ 0x30
 80246c0:	3201      	adds	r2, #1
 80246c2:	0090      	lsls	r0, r2, #2
 80246c4:	920b      	str	r2, [sp, #44]	@ 0x2c
 80246c6:	eb0a 0e82 	add.w	lr, sl, r2, lsl #2
 80246ca:	900a      	str	r0, [sp, #40]	@ 0x28
 80246cc:	f85a 7b04 	ldr.w	r7, [sl], #4
 80246d0:	f85c 0b04 	ldr.w	r0, [ip], #4
 80246d4:	ea4f 2637 	mov.w	r6, r7, ror #8
 80246d8:	682a      	ldr	r2, [r5, #0]
 80246da:	ea4f 2430 	mov.w	r4, r0, ror #8
 80246de:	fa2f f686 	sxtb16	r6, r6
 80246e2:	fa2f f787 	sxtb16	r7, r7
 80246e6:	fa2f f484 	sxtb16	r4, r4
 80246ea:	fa2f f080 	sxtb16	r0, r0
 80246ee:	fb22 1107 	smlad	r1, r2, r7, r1
 80246f2:	fb22 3200 	smlad	r2, r2, r0, r3
 80246f6:	686b      	ldr	r3, [r5, #4]
 80246f8:	3508      	adds	r5, #8
 80246fa:	fb23 1106 	smlad	r1, r3, r6, r1
 80246fe:	fb23 2304 	smlad	r3, r3, r4, r2
 8024702:	45d6      	cmp	lr, sl
 8024704:	d1e2      	bne.n	80246cc <st_sssa8_ch_fully_connected+0x200>
 8024706:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 8024708:	f108 0804 	add.w	r8, r8, #4
 802470c:	980b      	ldr	r0, [sp, #44]	@ 0x2c
 802470e:	4493      	add	fp, r2
 8024710:	9a03      	ldr	r2, [sp, #12]
 8024712:	eb02 02c0 	add.w	r2, r2, r0, lsl #3
 8024716:	9203      	str	r2, [sp, #12]
 8024718:	9a0c      	ldr	r2, [sp, #48]	@ 0x30
 802471a:	eb08 0882 	add.w	r8, r8, r2, lsl #2
 802471e:	45c1      	cmp	r9, r8
 8024720:	dd37      	ble.n	8024792 <st_sssa8_ch_fully_connected+0x2c6>
 8024722:	9c03      	ldr	r4, [sp, #12]
 8024724:	f99e 0000 	ldrsb.w	r0, [lr]
 8024728:	f9b4 2000 	ldrsh.w	r2, [r4]
 802472c:	fb12 1100 	smlabb	r1, r2, r0, r1
 8024730:	f99b 0000 	ldrsb.w	r0, [fp]
 8024734:	fb12 3300 	smlabb	r3, r2, r0, r3
 8024738:	f108 0201 	add.w	r2, r8, #1
 802473c:	454a      	cmp	r2, r9
 802473e:	da25      	bge.n	802478c <st_sssa8_ch_fully_connected+0x2c0>
 8024740:	f9b4 2002 	ldrsh.w	r2, [r4, #2]
 8024744:	f99e 0001 	ldrsb.w	r0, [lr, #1]
 8024748:	fb12 1100 	smlabb	r1, r2, r0, r1
 802474c:	f99b 0001 	ldrsb.w	r0, [fp, #1]
 8024750:	fb12 3300 	smlabb	r3, r2, r0, r3
 8024754:	f108 0202 	add.w	r2, r8, #2
 8024758:	4591      	cmp	r9, r2
 802475a:	dd17      	ble.n	802478c <st_sssa8_ch_fully_connected+0x2c0>
 802475c:	f9b4 2004 	ldrsh.w	r2, [r4, #4]
 8024760:	f99e 0002 	ldrsb.w	r0, [lr, #2]
 8024764:	fb12 1100 	smlabb	r1, r2, r0, r1
 8024768:	f99b 0002 	ldrsb.w	r0, [fp, #2]
 802476c:	fb12 3300 	smlabb	r3, r2, r0, r3
 8024770:	f108 0203 	add.w	r2, r8, #3
 8024774:	4591      	cmp	r9, r2
 8024776:	dd09      	ble.n	802478c <st_sssa8_ch_fully_connected+0x2c0>
 8024778:	f9b4 2006 	ldrsh.w	r2, [r4, #6]
 802477c:	f99b 0003 	ldrsb.w	r0, [fp, #3]
 8024780:	fb12 3300 	smlabb	r3, r2, r0, r3
 8024784:	f99e 0003 	ldrsb.w	r0, [lr, #3]
 8024788:	fb12 1100 	smlabb	r1, r2, r0, r1
 802478c:	eba9 0808 	sub.w	r8, r9, r8
 8024790:	44c6      	add	lr, r8
 8024792:	9d07      	ldr	r5, [sp, #28]
 8024794:	f935 0c04 	ldrsh.w	r0, [r5, #-4]
 8024798:	2815      	cmp	r0, #21
 802479a:	f340 80c2 	ble.w	8024922 <st_sssa8_ch_fully_connected+0x456>
 802479e:	1e84      	subs	r4, r0, #2
 80247a0:	2201      	movs	r2, #1
 80247a2:	3801      	subs	r0, #1
 80247a4:	fa02 f404 	lsl.w	r4, r2, r4
 80247a8:	9a05      	ldr	r2, [sp, #20]
 80247aa:	f852 2c04 	ldr.w	r2, [r2, #-4]
 80247ae:	fb51 4202 	smmla	r2, r1, r2, r4
 80247b2:	9906      	ldr	r1, [sp, #24]
 80247b4:	4102      	asrs	r2, r0
 80247b6:	1eac      	subs	r4, r5, #2
 80247b8:	f851 1c04 	ldr.w	r1, [r1, #-4]
 80247bc:	440a      	add	r2, r1
 80247be:	f302 0207 	ssat	r2, #8, r2
 80247c2:	9904      	ldr	r1, [sp, #16]
 80247c4:	b252      	sxtb	r2, r2
 80247c6:	1e48      	subs	r0, r1, #1
 80247c8:	f801 2c02 	strb.w	r2, [r1, #-2]
 80247cc:	f9b4 4000 	ldrsh.w	r4, [r4]
 80247d0:	2c15      	cmp	r4, #21
 80247d2:	f340 8098 	ble.w	8024906 <st_sssa8_ch_fully_connected+0x43a>
 80247d6:	1ea1      	subs	r1, r4, #2
 80247d8:	2201      	movs	r2, #1
 80247da:	3c01      	subs	r4, #1
 80247dc:	fa02 f101 	lsl.w	r1, r2, r1
 80247e0:	9a05      	ldr	r2, [sp, #20]
 80247e2:	6812      	ldr	r2, [r2, #0]
 80247e4:	fb53 1302 	smmla	r3, r3, r2, r1
 80247e8:	9a06      	ldr	r2, [sp, #24]
 80247ea:	4123      	asrs	r3, r4
 80247ec:	6812      	ldr	r2, [r2, #0]
 80247ee:	4413      	add	r3, r2
 80247f0:	f303 0307 	ssat	r3, #8, r3
 80247f4:	b25b      	sxtb	r3, r3
 80247f6:	9a07      	ldr	r2, [sp, #28]
 80247f8:	eb0e 0a09 	add.w	sl, lr, r9
 80247fc:	7003      	strb	r3, [r0, #0]
 80247fe:	3204      	adds	r2, #4
 8024800:	9b08      	ldr	r3, [sp, #32]
 8024802:	9207      	str	r2, [sp, #28]
 8024804:	3308      	adds	r3, #8
 8024806:	9a04      	ldr	r2, [sp, #16]
 8024808:	9308      	str	r3, [sp, #32]
 802480a:	3202      	adds	r2, #2
 802480c:	9204      	str	r2, [sp, #16]
 802480e:	9a05      	ldr	r2, [sp, #20]
 8024810:	3208      	adds	r2, #8
 8024812:	9205      	str	r2, [sp, #20]
 8024814:	9a06      	ldr	r2, [sp, #24]
 8024816:	3208      	adds	r2, #8
 8024818:	9206      	str	r2, [sp, #24]
 802481a:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
 802481c:	429a      	cmp	r2, r3
 802481e:	f47f aec3 	bne.w	80245a8 <st_sssa8_ch_fully_connected+0xdc>
 8024822:	9b15      	ldr	r3, [sp, #84]	@ 0x54
 8024824:	46cb      	mov	fp, r9
 8024826:	9a20      	ldr	r2, [sp, #128]	@ 0x80
 8024828:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
 802482c:	9220      	str	r2, [sp, #128]	@ 0x80
 802482e:	9a13      	ldr	r2, [sp, #76]	@ 0x4c
 8024830:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 8024834:	9213      	str	r2, [sp, #76]	@ 0x4c
 8024836:	9a24      	ldr	r2, [sp, #144]	@ 0x90
 8024838:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
 802483c:	9224      	str	r2, [sp, #144]	@ 0x90
 802483e:	9a25      	ldr	r2, [sp, #148]	@ 0x94
 8024840:	eb02 0243 	add.w	r2, r2, r3, lsl #1
 8024844:	9225      	str	r2, [sp, #148]	@ 0x94
 8024846:	9a12      	ldr	r2, [sp, #72]	@ 0x48
 8024848:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 802484c:	9312      	str	r3, [sp, #72]	@ 0x48
 802484e:	9b14      	ldr	r3, [sp, #80]	@ 0x50
 8024850:	07db      	lsls	r3, r3, #31
 8024852:	d54c      	bpl.n	80248ee <st_sssa8_ch_fully_connected+0x422>
 8024854:	9b24      	ldr	r3, [sp, #144]	@ 0x90
 8024856:	ea5f 079b 	movs.w	r7, fp, lsr #2
 802485a:	681b      	ldr	r3, [r3, #0]
 802485c:	f000 80c7 	beq.w	80249ee <st_sssa8_ch_fully_connected+0x522>
 8024860:	eb0a 0687 	add.w	r6, sl, r7, lsl #2
 8024864:	980d      	ldr	r0, [sp, #52]	@ 0x34
 8024866:	f85a 2b04 	ldr.w	r2, [sl], #4
 802486a:	3008      	adds	r0, #8
 802486c:	f850 5c08 	ldr.w	r5, [r0, #-8]
 8024870:	ea4f 2132 	mov.w	r1, r2, ror #8
 8024874:	f850 4c04 	ldr.w	r4, [r0, #-4]
 8024878:	fa2f f282 	sxtb16	r2, r2
 802487c:	fa2f f181 	sxtb16	r1, r1
 8024880:	fb25 3302 	smlad	r3, r5, r2, r3
 8024884:	fb24 3301 	smlad	r3, r4, r1, r3
 8024888:	45b2      	cmp	sl, r6
 802488a:	d1ec      	bne.n	8024866 <st_sssa8_ch_fully_connected+0x39a>
 802488c:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
 802488e:	eb02 02c7 	add.w	r2, r2, r7, lsl #3
 8024892:	920d      	str	r2, [sp, #52]	@ 0x34
 8024894:	f01b 0203 	ands.w	r2, fp, #3
 8024898:	d014      	beq.n	80248c4 <st_sssa8_ch_fully_connected+0x3f8>
 802489a:	3a01      	subs	r2, #1
 802489c:	9c0d      	ldr	r4, [sp, #52]	@ 0x34
 802489e:	f996 1000 	ldrsb.w	r1, [r6]
 80248a2:	8820      	ldrh	r0, [r4, #0]
 80248a4:	b292      	uxth	r2, r2
 80248a6:	fb10 3301 	smlabb	r3, r0, r1, r3
 80248aa:	b15a      	cbz	r2, 80248c4 <st_sssa8_ch_fully_connected+0x3f8>
 80248ac:	f996 1001 	ldrsb.w	r1, [r6, #1]
 80248b0:	2a01      	cmp	r2, #1
 80248b2:	8860      	ldrh	r0, [r4, #2]
 80248b4:	fb10 3301 	smlabb	r3, r0, r1, r3
 80248b8:	d004      	beq.n	80248c4 <st_sssa8_ch_fully_connected+0x3f8>
 80248ba:	f996 2002 	ldrsb.w	r2, [r6, #2]
 80248be:	88a1      	ldrh	r1, [r4, #4]
 80248c0:	fb11 3302 	smlabb	r3, r1, r2, r3
 80248c4:	9a13      	ldr	r2, [sp, #76]	@ 0x4c
 80248c6:	f9b2 2000 	ldrsh.w	r2, [r2]
 80248ca:	2a15      	cmp	r2, #21
 80248cc:	dd69      	ble.n	80249a2 <st_sssa8_ch_fully_connected+0x4d6>
 80248ce:	9812      	ldr	r0, [sp, #72]	@ 0x48
 80248d0:	1e95      	subs	r5, r2, #2
 80248d2:	9920      	ldr	r1, [sp, #128]	@ 0x80
 80248d4:	3a01      	subs	r2, #1
 80248d6:	6804      	ldr	r4, [r0, #0]
 80248d8:	2001      	movs	r0, #1
 80248da:	6809      	ldr	r1, [r1, #0]
 80248dc:	40a8      	lsls	r0, r5
 80248de:	fb53 0301 	smmla	r3, r3, r1, r0
 80248e2:	4113      	asrs	r3, r2
 80248e4:	4423      	add	r3, r4
 80248e6:	f303 0307 	ssat	r3, #8, r3
 80248ea:	9a25      	ldr	r2, [sp, #148]	@ 0x94
 80248ec:	7013      	strb	r3, [r2, #0]
 80248ee:	2000      	movs	r0, #0
 80248f0:	b017      	add	sp, #92	@ 0x5c
 80248f2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80248f6:	42bc      	cmp	r4, r7
 80248f8:	f845 3c04 	str.w	r3, [r5, #-4]
 80248fc:	f105 0504 	add.w	r5, r5, #4
 8024900:	f47f ae04 	bne.w	802450c <st_sssa8_ch_fully_connected+0x40>
 8024904:	e615      	b.n	8024532 <st_sssa8_ch_fully_connected+0x66>
 8024906:	2c00      	cmp	r4, #0
 8024908:	dd1f      	ble.n	802494a <st_sssa8_ch_fully_connected+0x47e>
 802490a:	9a05      	ldr	r2, [sp, #20]
 802490c:	005b      	lsls	r3, r3, #1
 802490e:	9906      	ldr	r1, [sp, #24]
 8024910:	6812      	ldr	r2, [r2, #0]
 8024912:	6809      	ldr	r1, [r1, #0]
 8024914:	fb53 1302 	smmla	r3, r3, r2, r1
 8024918:	4123      	asrs	r3, r4
 802491a:	f303 0307 	ssat	r3, #8, r3
 802491e:	b25b      	sxtb	r3, r3
 8024920:	e769      	b.n	80247f6 <st_sssa8_ch_fully_connected+0x32a>
 8024922:	2800      	cmp	r0, #0
 8024924:	dd21      	ble.n	802496a <st_sssa8_ch_fully_connected+0x49e>
 8024926:	462c      	mov	r4, r5
 8024928:	9a05      	ldr	r2, [sp, #20]
 802492a:	004d      	lsls	r5, r1, #1
 802492c:	9906      	ldr	r1, [sp, #24]
 802492e:	f852 2c04 	ldr.w	r2, [r2, #-4]
 8024932:	3c02      	subs	r4, #2
 8024934:	f851 1c04 	ldr.w	r1, [r1, #-4]
 8024938:	fb55 1502 	smmla	r5, r5, r2, r1
 802493c:	4105      	asrs	r5, r0
 802493e:	f305 0207 	ssat	r2, #8, r5
 8024942:	9904      	ldr	r1, [sp, #16]
 8024944:	b252      	sxtb	r2, r2
 8024946:	1e48      	subs	r0, r1, #1
 8024948:	e73e      	b.n	80247c8 <st_sssa8_ch_fully_connected+0x2fc>
 802494a:	f1c4 0401 	rsb	r4, r4, #1
 802494e:	40a3      	lsls	r3, r4
 8024950:	f303 031f 	ssat	r3, #32, r3
 8024954:	9a05      	ldr	r2, [sp, #20]
 8024956:	6812      	ldr	r2, [r2, #0]
 8024958:	fb53 f212 	smmulr	r2, r3, r2
 802495c:	9b06      	ldr	r3, [sp, #24]
 802495e:	681b      	ldr	r3, [r3, #0]
 8024960:	4413      	add	r3, r2
 8024962:	f303 0307 	ssat	r3, #8, r3
 8024966:	b25b      	sxtb	r3, r3
 8024968:	e745      	b.n	80247f6 <st_sssa8_ch_fully_connected+0x32a>
 802496a:	f1c0 0001 	rsb	r0, r0, #1
 802496e:	1eac      	subs	r4, r5, #2
 8024970:	4081      	lsls	r1, r0
 8024972:	f301 011f 	ssat	r1, #32, r1
 8024976:	9a05      	ldr	r2, [sp, #20]
 8024978:	f852 2c04 	ldr.w	r2, [r2, #-4]
 802497c:	fb51 f212 	smmulr	r2, r1, r2
 8024980:	9906      	ldr	r1, [sp, #24]
 8024982:	f851 1c04 	ldr.w	r1, [r1, #-4]
 8024986:	440a      	add	r2, r1
 8024988:	f302 0207 	ssat	r2, #8, r2
 802498c:	9904      	ldr	r1, [sp, #16]
 802498e:	b252      	sxtb	r2, r2
 8024990:	1e48      	subs	r0, r1, #1
 8024992:	e719      	b.n	80247c8 <st_sssa8_ch_fully_connected+0x2fc>
 8024994:	46d6      	mov	lr, sl
 8024996:	e6c2      	b.n	802471e <st_sssa8_ch_fully_connected+0x252>
 8024998:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
 802499a:	f04f 0800 	mov.w	r8, #0
 802499e:	9203      	str	r2, [sp, #12]
 80249a0:	e683      	b.n	80246aa <st_sssa8_ch_fully_connected+0x1de>
 80249a2:	2a00      	cmp	r2, #0
 80249a4:	dd0f      	ble.n	80249c6 <st_sssa8_ch_fully_connected+0x4fa>
 80249a6:	9920      	ldr	r1, [sp, #128]	@ 0x80
 80249a8:	005b      	lsls	r3, r3, #1
 80249aa:	9812      	ldr	r0, [sp, #72]	@ 0x48
 80249ac:	6809      	ldr	r1, [r1, #0]
 80249ae:	6800      	ldr	r0, [r0, #0]
 80249b0:	fb53 0301 	smmla	r3, r3, r1, r0
 80249b4:	4113      	asrs	r3, r2
 80249b6:	f303 0307 	ssat	r3, #8, r3
 80249ba:	2000      	movs	r0, #0
 80249bc:	9a25      	ldr	r2, [sp, #148]	@ 0x94
 80249be:	7013      	strb	r3, [r2, #0]
 80249c0:	b017      	add	sp, #92	@ 0x5c
 80249c2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80249c6:	f1c2 0201 	rsb	r2, r2, #1
 80249ca:	4093      	lsls	r3, r2
 80249cc:	f303 031f 	ssat	r3, #32, r3
 80249d0:	9a20      	ldr	r2, [sp, #128]	@ 0x80
 80249d2:	6812      	ldr	r2, [r2, #0]
 80249d4:	fb53 f312 	smmulr	r3, r3, r2
 80249d8:	9a12      	ldr	r2, [sp, #72]	@ 0x48
 80249da:	6812      	ldr	r2, [r2, #0]
 80249dc:	4413      	add	r3, r2
 80249de:	f303 0307 	ssat	r3, #8, r3
 80249e2:	2000      	movs	r0, #0
 80249e4:	9a25      	ldr	r2, [sp, #148]	@ 0x94
 80249e6:	7013      	strb	r3, [r2, #0]
 80249e8:	b017      	add	sp, #92	@ 0x5c
 80249ea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80249ee:	4656      	mov	r6, sl
 80249f0:	e750      	b.n	8024894 <st_sssa8_ch_fully_connected+0x3c8>
 80249f2:	f8dd 8050 	ldr.w	r8, [sp, #80]	@ 0x50
 80249f6:	9212      	str	r2, [sp, #72]	@ 0x48
 80249f8:	e59b      	b.n	8024532 <st_sssa8_ch_fully_connected+0x66>
 80249fa:	bf00      	nop

080249fc <st_int8_fill>:
 80249fc:	0203      	lsls	r3, r0, #8
 80249fe:	468c      	mov	ip, r1
 8024a00:	b510      	push	{r4, lr}
 8024a02:	b2c4      	uxtb	r4, r0
 8024a04:	b29b      	uxth	r3, r3
 8024a06:	ea44 6400 	orr.w	r4, r4, r0, lsl #24
 8024a0a:	431c      	orrs	r4, r3
 8024a0c:	0403      	lsls	r3, r0, #16
 8024a0e:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
 8024a12:	431c      	orrs	r4, r3
 8024a14:	078b      	lsls	r3, r1, #30
 8024a16:	d007      	beq.n	8024a28 <st_int8_fill+0x2c>
 8024a18:	b3a2      	cbz	r2, 8024a84 <st_int8_fill+0x88>
 8024a1a:	f80c 0b01 	strb.w	r0, [ip], #1
 8024a1e:	f01c 0f03 	tst.w	ip, #3
 8024a22:	f102 32ff 	add.w	r2, r2, #4294967295
 8024a26:	d1f7      	bne.n	8024a18 <st_int8_fill+0x1c>
 8024a28:	0911      	lsrs	r1, r2, #4
 8024a2a:	d041      	beq.n	8024ab0 <st_int8_fill+0xb4>
 8024a2c:	1e4b      	subs	r3, r1, #1
 8024a2e:	2b01      	cmp	r3, #1
 8024a30:	d929      	bls.n	8024a86 <st_int8_fill+0x8a>
 8024a32:	f01c 0f07 	tst.w	ip, #7
 8024a36:	d126      	bne.n	8024a86 <st_int8_fill+0x8a>
 8024a38:	f10c 0310 	add.w	r3, ip, #16
 8024a3c:	ea4f 1e01 	mov.w	lr, r1, lsl #4
 8024a40:	eb03 1101 	add.w	r1, r3, r1, lsl #4
 8024a44:	e943 4404 	strd	r4, r4, [r3, #-16]
 8024a48:	e943 4402 	strd	r4, r4, [r3, #-8]
 8024a4c:	3310      	adds	r3, #16
 8024a4e:	428b      	cmp	r3, r1
 8024a50:	d1f8      	bne.n	8024a44 <st_int8_fill+0x48>
 8024a52:	f3c2 0381 	ubfx	r3, r2, #2, #2
 8024a56:	44f4      	add	ip, lr
 8024a58:	f002 0203 	and.w	r2, r2, #3
 8024a5c:	b15b      	cbz	r3, 8024a76 <st_int8_fill+0x7a>
 8024a5e:	1e59      	subs	r1, r3, #1
 8024a60:	f8cc 4000 	str.w	r4, [ip]
 8024a64:	d005      	beq.n	8024a72 <st_int8_fill+0x76>
 8024a66:	2901      	cmp	r1, #1
 8024a68:	f8cc 4004 	str.w	r4, [ip, #4]
 8024a6c:	bf18      	it	ne
 8024a6e:	f8cc 4008 	strne.w	r4, [ip, #8]
 8024a72:	eb0c 0c83 	add.w	ip, ip, r3, lsl #2
 8024a76:	b12a      	cbz	r2, 8024a84 <st_int8_fill+0x88>
 8024a78:	4601      	mov	r1, r0
 8024a7a:	4660      	mov	r0, ip
 8024a7c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8024a80:	f00e babe 	b.w	8033000 <memset>
 8024a84:	bd10      	pop	{r4, pc}
 8024a86:	ea4f 1e01 	mov.w	lr, r1, lsl #4
 8024a8a:	4663      	mov	r3, ip
 8024a8c:	eb0c 1101 	add.w	r1, ip, r1, lsl #4
 8024a90:	601c      	str	r4, [r3, #0]
 8024a92:	3310      	adds	r3, #16
 8024a94:	f843 4c0c 	str.w	r4, [r3, #-12]
 8024a98:	f843 4c08 	str.w	r4, [r3, #-8]
 8024a9c:	f843 4c04 	str.w	r4, [r3, #-4]
 8024aa0:	4299      	cmp	r1, r3
 8024aa2:	d1f5      	bne.n	8024a90 <st_int8_fill+0x94>
 8024aa4:	f3c2 0381 	ubfx	r3, r2, #2, #2
 8024aa8:	44f4      	add	ip, lr
 8024aaa:	f002 0203 	and.w	r2, r2, #3
 8024aae:	e7d5      	b.n	8024a5c <st_int8_fill+0x60>
 8024ab0:	0893      	lsrs	r3, r2, #2
 8024ab2:	f002 0203 	and.w	r2, r2, #3
 8024ab6:	e7d1      	b.n	8024a5c <st_int8_fill+0x60>

08024ab8 <st_int8_copy>:
 8024ab8:	4288      	cmp	r0, r1
 8024aba:	d010      	beq.n	8024ade <st_int8_copy+0x26>
 8024abc:	b17a      	cbz	r2, 8024ade <st_int8_copy+0x26>
 8024abe:	4288      	cmp	r0, r1
 8024ac0:	eb00 0302 	add.w	r3, r0, r2
 8024ac4:	d20c      	bcs.n	8024ae0 <st_int8_copy+0x28>
 8024ac6:	428b      	cmp	r3, r1
 8024ac8:	d90a      	bls.n	8024ae0 <st_int8_copy+0x28>
 8024aca:	4283      	cmp	r3, r0
 8024acc:	440a      	add	r2, r1
 8024ace:	d906      	bls.n	8024ade <st_int8_copy+0x26>
 8024ad0:	f913 1d01 	ldrsb.w	r1, [r3, #-1]!
 8024ad4:	4283      	cmp	r3, r0
 8024ad6:	f802 1d01 	strb.w	r1, [r2, #-1]!
 8024ada:	d1f9      	bne.n	8024ad0 <st_int8_copy+0x18>
 8024adc:	4770      	bx	lr
 8024ade:	4770      	bx	lr
 8024ae0:	078b      	lsls	r3, r1, #30
 8024ae2:	d102      	bne.n	8024aea <st_int8_copy+0x32>
 8024ae4:	e008      	b.n	8024af8 <st_int8_copy+0x40>
 8024ae6:	2a00      	cmp	r2, #0
 8024ae8:	d04c      	beq.n	8024b84 <st_int8_copy+0xcc>
 8024aea:	f910 3b01 	ldrsb.w	r3, [r0], #1
 8024aee:	3a01      	subs	r2, #1
 8024af0:	f801 3b01 	strb.w	r3, [r1], #1
 8024af4:	078b      	lsls	r3, r1, #30
 8024af6:	d1f6      	bne.n	8024ae6 <st_int8_copy+0x2e>
 8024af8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8024afc:	ea5f 1e12 	movs.w	lr, r2, lsr #4
 8024b00:	d05d      	beq.n	8024bbe <st_int8_copy+0x106>
 8024b02:	ea41 0300 	orr.w	r3, r1, r0
 8024b06:	075b      	lsls	r3, r3, #29
 8024b08:	d13d      	bne.n	8024b86 <st_int8_copy+0xce>
 8024b0a:	f1be 0f01 	cmp.w	lr, #1
 8024b0e:	d03a      	beq.n	8024b86 <st_int8_copy+0xce>
 8024b10:	f100 0310 	add.w	r3, r0, #16
 8024b14:	ea4f 140e 	mov.w	r4, lr, lsl #4
 8024b18:	f101 0c10 	add.w	ip, r1, #16
 8024b1c:	eb03 1e0e 	add.w	lr, r3, lr, lsl #4
 8024b20:	3310      	adds	r3, #16
 8024b22:	f10c 0c10 	add.w	ip, ip, #16
 8024b26:	ed13 6b08 	vldr	d6, [r3, #-32]	@ 0xffffffe0
 8024b2a:	ed13 7b06 	vldr	d7, [r3, #-24]	@ 0xffffffe8
 8024b2e:	4573      	cmp	r3, lr
 8024b30:	ed0c 6b08 	vstr	d6, [ip, #-32]	@ 0xffffffe0
 8024b34:	ed0c 7b06 	vstr	d7, [ip, #-24]	@ 0xffffffe8
 8024b38:	d1f2      	bne.n	8024b20 <st_int8_copy+0x68>
 8024b3a:	f3c2 0381 	ubfx	r3, r2, #2, #2
 8024b3e:	4421      	add	r1, r4
 8024b40:	4420      	add	r0, r4
 8024b42:	f002 0203 	and.w	r2, r2, #3
 8024b46:	b16b      	cbz	r3, 8024b64 <st_int8_copy+0xac>
 8024b48:	6804      	ldr	r4, [r0, #0]
 8024b4a:	600c      	str	r4, [r1, #0]
 8024b4c:	1e5c      	subs	r4, r3, #1
 8024b4e:	d005      	beq.n	8024b5c <st_int8_copy+0xa4>
 8024b50:	6845      	ldr	r5, [r0, #4]
 8024b52:	2c01      	cmp	r4, #1
 8024b54:	604d      	str	r5, [r1, #4]
 8024b56:	d001      	beq.n	8024b5c <st_int8_copy+0xa4>
 8024b58:	6884      	ldr	r4, [r0, #8]
 8024b5a:	608c      	str	r4, [r1, #8]
 8024b5c:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 8024b60:	eb01 0183 	add.w	r1, r1, r3, lsl #2
 8024b64:	b162      	cbz	r2, 8024b80 <st_int8_copy+0xc8>
 8024b66:	f990 3000 	ldrsb.w	r3, [r0]
 8024b6a:	3a01      	subs	r2, #1
 8024b6c:	700b      	strb	r3, [r1, #0]
 8024b6e:	d007      	beq.n	8024b80 <st_int8_copy+0xc8>
 8024b70:	f990 3001 	ldrsb.w	r3, [r0, #1]
 8024b74:	2a01      	cmp	r2, #1
 8024b76:	704b      	strb	r3, [r1, #1]
 8024b78:	d002      	beq.n	8024b80 <st_int8_copy+0xc8>
 8024b7a:	f990 3002 	ldrsb.w	r3, [r0, #2]
 8024b7e:	708b      	strb	r3, [r1, #2]
 8024b80:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8024b84:	4770      	bx	lr
 8024b86:	ea4f 140e 	mov.w	r4, lr, lsl #4
 8024b8a:	460b      	mov	r3, r1
 8024b8c:	eb01 1e0e 	add.w	lr, r1, lr, lsl #4
 8024b90:	4684      	mov	ip, r0
 8024b92:	f8dc 8000 	ldr.w	r8, [ip]
 8024b96:	3310      	adds	r3, #16
 8024b98:	f8dc 7004 	ldr.w	r7, [ip, #4]
 8024b9c:	f10c 0c10 	add.w	ip, ip, #16
 8024ba0:	f85c 6c08 	ldr.w	r6, [ip, #-8]
 8024ba4:	f85c 5c04 	ldr.w	r5, [ip, #-4]
 8024ba8:	f843 8c10 	str.w	r8, [r3, #-16]
 8024bac:	f843 7c0c 	str.w	r7, [r3, #-12]
 8024bb0:	f843 6c08 	str.w	r6, [r3, #-8]
 8024bb4:	f843 5c04 	str.w	r5, [r3, #-4]
 8024bb8:	459e      	cmp	lr, r3
 8024bba:	d1ea      	bne.n	8024b92 <st_int8_copy+0xda>
 8024bbc:	e7bd      	b.n	8024b3a <st_int8_copy+0x82>
 8024bbe:	0893      	lsrs	r3, r2, #2
 8024bc0:	f002 0203 	and.w	r2, r2, #3
 8024bc4:	e7bf      	b.n	8024b46 <st_int8_copy+0x8e>
 8024bc6:	bf00      	nop

08024bc8 <st_int8_reordered_no_shift_zero>:
 8024bc8:	b5f0      	push	{r4, r5, r6, r7, lr}
 8024bca:	0897      	lsrs	r7, r2, #2
 8024bcc:	f9bd 6014 	ldrsh.w	r6, [sp, #20]
 8024bd0:	d02d      	beq.n	8024c2e <st_int8_reordered_no_shift_zero+0x66>
 8024bd2:	eb00 0587 	add.w	r5, r0, r7, lsl #2
 8024bd6:	468e      	mov	lr, r1
 8024bd8:	f850 cb04 	ldr.w	ip, [r0], #4
 8024bdc:	fa2f f49c 	sxtb16	r4, ip, ror #8
 8024be0:	fad4 f403 	ssub16	r4, r4, r3
 8024be4:	fa2f fc8c 	sxtb16	ip, ip
 8024be8:	fadc fc03 	ssub16	ip, ip, r3
 8024bec:	42a8      	cmp	r0, r5
 8024bee:	f8ce c000 	str.w	ip, [lr]
 8024bf2:	f8ce 4004 	str.w	r4, [lr, #4]
 8024bf6:	f10e 0e08 	add.w	lr, lr, #8
 8024bfa:	d1ed      	bne.n	8024bd8 <st_int8_reordered_no_shift_zero+0x10>
 8024bfc:	eb01 01c7 	add.w	r1, r1, r7, lsl #3
 8024c00:	f012 0203 	ands.w	r2, r2, #3
 8024c04:	d012      	beq.n	8024c2c <st_int8_reordered_no_shift_zero+0x64>
 8024c06:	f995 0000 	ldrsb.w	r0, [r5]
 8024c0a:	b273      	sxtb	r3, r6
 8024c0c:	3a01      	subs	r2, #1
 8024c0e:	eba0 0003 	sub.w	r0, r0, r3
 8024c12:	8008      	strh	r0, [r1, #0]
 8024c14:	d00a      	beq.n	8024c2c <st_int8_reordered_no_shift_zero+0x64>
 8024c16:	f995 0001 	ldrsb.w	r0, [r5, #1]
 8024c1a:	2a01      	cmp	r2, #1
 8024c1c:	eba0 0003 	sub.w	r0, r0, r3
 8024c20:	8048      	strh	r0, [r1, #2]
 8024c22:	d003      	beq.n	8024c2c <st_int8_reordered_no_shift_zero+0x64>
 8024c24:	f995 2002 	ldrsb.w	r2, [r5, #2]
 8024c28:	1ad3      	subs	r3, r2, r3
 8024c2a:	808b      	strh	r3, [r1, #4]
 8024c2c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8024c2e:	4605      	mov	r5, r0
 8024c30:	e7e6      	b.n	8024c00 <st_int8_reordered_no_shift_zero+0x38>
 8024c32:	bf00      	nop

08024c34 <st_sssa8_ch_nn_mat_mult_kernel_single_opt>:
 8024c34:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8024c38:	b093      	sub	sp, #76	@ 0x4c
 8024c3a:	f8bd 4074 	ldrh.w	r4, [sp, #116]	@ 0x74
 8024c3e:	920a      	str	r2, [sp, #40]	@ 0x28
 8024c40:	f8bd 2078 	ldrh.w	r2, [sp, #120]	@ 0x78
 8024c44:	930f      	str	r3, [sp, #60]	@ 0x3c
 8024c46:	920d      	str	r2, [sp, #52]	@ 0x34
 8024c48:	0862      	lsrs	r2, r4, #1
 8024c4a:	f89d 3088 	ldrb.w	r3, [sp, #136]	@ 0x88
 8024c4e:	940c      	str	r4, [sp, #48]	@ 0x30
 8024c50:	9104      	str	r1, [sp, #16]
 8024c52:	930e      	str	r3, [sp, #56]	@ 0x38
 8024c54:	920b      	str	r2, [sp, #44]	@ 0x2c
 8024c56:	2b00      	cmp	r3, #0
 8024c58:	f000 8184 	beq.w	8024f64 <st_sssa8_ch_nn_mat_mult_kernel_single_opt+0x330>
 8024c5c:	9b1c      	ldr	r3, [sp, #112]	@ 0x70
 8024c5e:	b299      	uxth	r1, r3
 8024c60:	4613      	mov	r3, r2
 8024c62:	2b00      	cmp	r3, #0
 8024c64:	f000 80d7 	beq.w	8024e16 <st_sssa8_ch_nn_mat_mult_kernel_single_opt+0x1e2>
 8024c68:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
 8024c6a:	3b01      	subs	r3, #1
 8024c6c:	0897      	lsrs	r7, r2, #2
 8024c6e:	f002 0203 	and.w	r2, r2, #3
 8024c72:	b29b      	uxth	r3, r3
 8024c74:	9201      	str	r2, [sp, #4]
 8024c76:	1c4a      	adds	r2, r1, #1
 8024c78:	0049      	lsls	r1, r1, #1
 8024c7a:	9703      	str	r7, [sp, #12]
 8024c7c:	9105      	str	r1, [sp, #20]
 8024c7e:	9923      	ldr	r1, [sp, #140]	@ 0x8c
 8024c80:	4411      	add	r1, r2
 8024c82:	9102      	str	r1, [sp, #8]
 8024c84:	990a      	ldr	r1, [sp, #40]	@ 0x28
 8024c86:	f101 0210 	add.w	r2, r1, #16
 8024c8a:	f101 0c08 	add.w	ip, r1, #8
 8024c8e:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 8024c92:	9a01      	ldr	r2, [sp, #4]
 8024c94:	9306      	str	r3, [sp, #24]
 8024c96:	9b1f      	ldr	r3, [sp, #124]	@ 0x7c
 8024c98:	f103 0e04 	add.w	lr, r3, #4
 8024c9c:	9b20      	ldr	r3, [sp, #128]	@ 0x80
 8024c9e:	f103 0508 	add.w	r5, r3, #8
 8024ca2:	9b21      	ldr	r3, [sp, #132]	@ 0x84
 8024ca4:	f103 0408 	add.w	r4, r3, #8
 8024ca8:	9b23      	ldr	r3, [sp, #140]	@ 0x8c
 8024caa:	1c5e      	adds	r6, r3, #1
 8024cac:	013b      	lsls	r3, r7, #4
 8024cae:	9307      	str	r3, [sp, #28]
 8024cb0:	9b04      	ldr	r3, [sp, #16]
 8024cb2:	eb03 03c7 	add.w	r3, r3, r7, lsl #3
 8024cb6:	9308      	str	r3, [sp, #32]
 8024cb8:	0093      	lsls	r3, r2, #2
 8024cba:	9309      	str	r3, [sp, #36]	@ 0x24
 8024cbc:	f85c 3c08 	ldr.w	r3, [ip, #-8]
 8024cc0:	f85c 2c04 	ldr.w	r2, [ip, #-4]
 8024cc4:	9311      	str	r3, [sp, #68]	@ 0x44
 8024cc6:	9903      	ldr	r1, [sp, #12]
 8024cc8:	9b11      	ldr	r3, [sp, #68]	@ 0x44
 8024cca:	9211      	str	r2, [sp, #68]	@ 0x44
 8024ccc:	9a11      	ldr	r2, [sp, #68]	@ 0x44
 8024cce:	2900      	cmp	r1, #0
 8024cd0:	f000 8146 	beq.w	8024f60 <st_sssa8_ch_nn_mat_mult_kernel_single_opt+0x32c>
 8024cd4:	4688      	mov	r8, r1
 8024cd6:	9f04      	ldr	r7, [sp, #16]
 8024cd8:	4601      	mov	r1, r0
 8024cda:	f8d7 9000 	ldr.w	r9, [r7]
 8024cde:	f8d1 a000 	ldr.w	sl, [r1]
 8024ce2:	fb2a 3a09 	smlad	sl, sl, r9, r3
 8024ce6:	684b      	ldr	r3, [r1, #4]
 8024ce8:	fb23 2909 	smlad	r9, r3, r9, r2
 8024cec:	f8d7 b004 	ldr.w	fp, [r7, #4]
 8024cf0:	3110      	adds	r1, #16
 8024cf2:	f851 3c08 	ldr.w	r3, [r1, #-8]
 8024cf6:	3708      	adds	r7, #8
 8024cf8:	f851 2c04 	ldr.w	r2, [r1, #-4]
 8024cfc:	fb23 a30b 	smlad	r3, r3, fp, sl
 8024d00:	fb22 920b 	smlad	r2, r2, fp, r9
 8024d04:	f1b8 0801 	subs.w	r8, r8, #1
 8024d08:	d1e7      	bne.n	8024cda <st_sssa8_ch_nn_mat_mult_kernel_single_opt+0xa6>
 8024d0a:	9907      	ldr	r1, [sp, #28]
 8024d0c:	4408      	add	r0, r1
 8024d0e:	9908      	ldr	r1, [sp, #32]
 8024d10:	9f01      	ldr	r7, [sp, #4]
 8024d12:	b31f      	cbz	r7, 8024d5c <st_sssa8_ch_nn_mat_mult_kernel_single_opt+0x128>
 8024d14:	f9b1 7000 	ldrsh.w	r7, [r1]
 8024d18:	f8b0 8000 	ldrh.w	r8, [r0]
 8024d1c:	fb17 3308 	smlabb	r3, r7, r8, r3
 8024d20:	f8b0 8002 	ldrh.w	r8, [r0, #2]
 8024d24:	fb18 2207 	smlabb	r2, r8, r7, r2
 8024d28:	9f01      	ldr	r7, [sp, #4]
 8024d2a:	2f01      	cmp	r7, #1
 8024d2c:	d014      	beq.n	8024d58 <st_sssa8_ch_nn_mat_mult_kernel_single_opt+0x124>
 8024d2e:	f9b1 7002 	ldrsh.w	r7, [r1, #2]
 8024d32:	f8b0 8004 	ldrh.w	r8, [r0, #4]
 8024d36:	fb17 3308 	smlabb	r3, r7, r8, r3
 8024d3a:	f8b0 8006 	ldrh.w	r8, [r0, #6]
 8024d3e:	fb18 2207 	smlabb	r2, r8, r7, r2
 8024d42:	9f01      	ldr	r7, [sp, #4]
 8024d44:	2f02      	cmp	r7, #2
 8024d46:	d007      	beq.n	8024d58 <st_sssa8_ch_nn_mat_mult_kernel_single_opt+0x124>
 8024d48:	f9b1 1004 	ldrsh.w	r1, [r1, #4]
 8024d4c:	8907      	ldrh	r7, [r0, #8]
 8024d4e:	fb17 3301 	smlabb	r3, r7, r1, r3
 8024d52:	8947      	ldrh	r7, [r0, #10]
 8024d54:	fb11 2207 	smlabb	r2, r1, r7, r2
 8024d58:	9909      	ldr	r1, [sp, #36]	@ 0x24
 8024d5a:	4408      	add	r0, r1
 8024d5c:	f93e 9c04 	ldrsh.w	r9, [lr, #-4]
 8024d60:	f1b9 0f15 	cmp.w	r9, #21
 8024d64:	f340 80af 	ble.w	8024ec6 <st_sssa8_ch_nn_mat_mult_kernel_single_opt+0x292>
 8024d68:	f109 38ff 	add.w	r8, r9, #4294967295
 8024d6c:	f1a9 0702 	sub.w	r7, r9, #2
 8024d70:	2101      	movs	r1, #1
 8024d72:	fa01 f707 	lsl.w	r7, r1, r7
 8024d76:	f855 1c08 	ldr.w	r1, [r5, #-8]
 8024d7a:	fb53 7101 	smmla	r1, r3, r1, r7
 8024d7e:	f854 3c08 	ldr.w	r3, [r4, #-8]
 8024d82:	fa41 f108 	asr.w	r1, r1, r8
 8024d86:	1f27      	subs	r7, r4, #4
 8024d88:	f1a5 0804 	sub.w	r8, r5, #4
 8024d8c:	440b      	add	r3, r1
 8024d8e:	f1ae 0102 	sub.w	r1, lr, #2
 8024d92:	f303 0307 	ssat	r3, #8, r3
 8024d96:	b25b      	sxtb	r3, r3
 8024d98:	f806 3c01 	strb.w	r3, [r6, #-1]
 8024d9c:	f9b1 1000 	ldrsh.w	r1, [r1]
 8024da0:	2915      	cmp	r1, #21
 8024da2:	f340 80ab 	ble.w	8024efc <st_sssa8_ch_nn_mat_mult_kernel_single_opt+0x2c8>
 8024da6:	f8d8 3000 	ldr.w	r3, [r8]
 8024daa:	f04f 0901 	mov.w	r9, #1
 8024dae:	f8d7 8000 	ldr.w	r8, [r7]
 8024db2:	1e8f      	subs	r7, r1, #2
 8024db4:	3901      	subs	r1, #1
 8024db6:	fa09 f707 	lsl.w	r7, r9, r7
 8024dba:	fb52 7303 	smmla	r3, r2, r3, r7
 8024dbe:	410b      	asrs	r3, r1
 8024dc0:	4443      	add	r3, r8
 8024dc2:	f303 0307 	ssat	r3, #8, r3
 8024dc6:	b25b      	sxtb	r3, r3
 8024dc8:	9a02      	ldr	r2, [sp, #8]
 8024dca:	f10c 0c08 	add.w	ip, ip, #8
 8024dce:	f10e 0e04 	add.w	lr, lr, #4
 8024dd2:	3508      	adds	r5, #8
 8024dd4:	f802 3c01 	strb.w	r3, [r2, #-1]
 8024dd8:	3408      	adds	r4, #8
 8024dda:	9b05      	ldr	r3, [sp, #20]
 8024ddc:	441a      	add	r2, r3
 8024dde:	441e      	add	r6, r3
 8024de0:	9b06      	ldr	r3, [sp, #24]
 8024de2:	9202      	str	r2, [sp, #8]
 8024de4:	459c      	cmp	ip, r3
 8024de6:	f47f af69 	bne.w	8024cbc <st_sssa8_ch_nn_mat_mult_kernel_single_opt+0x88>
 8024dea:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 8024dec:	9a23      	ldr	r2, [sp, #140]	@ 0x8c
 8024dee:	9905      	ldr	r1, [sp, #20]
 8024df0:	fb03 2201 	mla	r2, r3, r1, r2
 8024df4:	9223      	str	r2, [sp, #140]	@ 0x8c
 8024df6:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 8024df8:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
 8024dfc:	920a      	str	r2, [sp, #40]	@ 0x28
 8024dfe:	9a1f      	ldr	r2, [sp, #124]	@ 0x7c
 8024e00:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 8024e04:	921f      	str	r2, [sp, #124]	@ 0x7c
 8024e06:	9a20      	ldr	r2, [sp, #128]	@ 0x80
 8024e08:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
 8024e0c:	9220      	str	r2, [sp, #128]	@ 0x80
 8024e0e:	9a21      	ldr	r2, [sp, #132]	@ 0x84
 8024e10:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 8024e14:	9321      	str	r3, [sp, #132]	@ 0x84
 8024e16:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 8024e18:	07db      	lsls	r3, r3, #31
 8024e1a:	d546      	bpl.n	8024eaa <st_sssa8_ch_nn_mat_mult_kernel_single_opt+0x276>
 8024e1c:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
 8024e1e:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8024e20:	0896      	lsrs	r6, r2, #2
 8024e22:	681b      	ldr	r3, [r3, #0]
 8024e24:	f000 80cd 	beq.w	8024fc2 <st_sssa8_ch_nn_mat_mult_kernel_single_opt+0x38e>
 8024e28:	00f7      	lsls	r7, r6, #3
 8024e2a:	9904      	ldr	r1, [sp, #16]
 8024e2c:	eb00 06c6 	add.w	r6, r0, r6, lsl #3
 8024e30:	6804      	ldr	r4, [r0, #0]
 8024e32:	3008      	adds	r0, #8
 8024e34:	f850 2c04 	ldr.w	r2, [r0, #-4]
 8024e38:	680d      	ldr	r5, [r1, #0]
 8024e3a:	fb24 3305 	smlad	r3, r4, r5, r3
 8024e3e:	684c      	ldr	r4, [r1, #4]
 8024e40:	3108      	adds	r1, #8
 8024e42:	fb22 3304 	smlad	r3, r2, r4, r3
 8024e46:	42b0      	cmp	r0, r6
 8024e48:	d1f2      	bne.n	8024e30 <st_sssa8_ch_nn_mat_mult_kernel_single_opt+0x1fc>
 8024e4a:	9a04      	ldr	r2, [sp, #16]
 8024e4c:	443a      	add	r2, r7
 8024e4e:	9204      	str	r2, [sp, #16]
 8024e50:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
 8024e52:	f012 0203 	ands.w	r2, r2, #3
 8024e56:	d011      	beq.n	8024e7c <st_sssa8_ch_nn_mat_mult_kernel_single_opt+0x248>
 8024e58:	3a01      	subs	r2, #1
 8024e5a:	9c04      	ldr	r4, [sp, #16]
 8024e5c:	8831      	ldrh	r1, [r6, #0]
 8024e5e:	8820      	ldrh	r0, [r4, #0]
 8024e60:	b292      	uxth	r2, r2
 8024e62:	fb10 3301 	smlabb	r3, r0, r1, r3
 8024e66:	b14a      	cbz	r2, 8024e7c <st_sssa8_ch_nn_mat_mult_kernel_single_opt+0x248>
 8024e68:	8860      	ldrh	r0, [r4, #2]
 8024e6a:	2a01      	cmp	r2, #1
 8024e6c:	8871      	ldrh	r1, [r6, #2]
 8024e6e:	fb10 3301 	smlabb	r3, r0, r1, r3
 8024e72:	d003      	beq.n	8024e7c <st_sssa8_ch_nn_mat_mult_kernel_single_opt+0x248>
 8024e74:	88b1      	ldrh	r1, [r6, #4]
 8024e76:	88a2      	ldrh	r2, [r4, #4]
 8024e78:	fb11 3302 	smlabb	r3, r1, r2, r3
 8024e7c:	9a1f      	ldr	r2, [sp, #124]	@ 0x7c
 8024e7e:	f9b2 2000 	ldrsh.w	r2, [r2]
 8024e82:	2a15      	cmp	r2, #21
 8024e84:	dd79      	ble.n	8024f7a <st_sssa8_ch_nn_mat_mult_kernel_single_opt+0x346>
 8024e86:	9821      	ldr	r0, [sp, #132]	@ 0x84
 8024e88:	1e95      	subs	r5, r2, #2
 8024e8a:	9920      	ldr	r1, [sp, #128]	@ 0x80
 8024e8c:	3a01      	subs	r2, #1
 8024e8e:	6804      	ldr	r4, [r0, #0]
 8024e90:	2001      	movs	r0, #1
 8024e92:	6809      	ldr	r1, [r1, #0]
 8024e94:	40a8      	lsls	r0, r5
 8024e96:	fb53 0301 	smmla	r3, r3, r1, r0
 8024e9a:	4113      	asrs	r3, r2
 8024e9c:	4423      	add	r3, r4
 8024e9e:	f303 0307 	ssat	r3, #8, r3
 8024ea2:	9a23      	ldr	r2, [sp, #140]	@ 0x8c
 8024ea4:	f802 3b01 	strb.w	r3, [r2], #1
 8024ea8:	9223      	str	r2, [sp, #140]	@ 0x8c
 8024eaa:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 8024eac:	2b00      	cmp	r3, #0
 8024eae:	d05c      	beq.n	8024f6a <st_sssa8_ch_nn_mat_mult_kernel_single_opt+0x336>
 8024eb0:	9a1c      	ldr	r2, [sp, #112]	@ 0x70
 8024eb2:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 8024eb4:	fb02 f303 	mul.w	r3, r2, r3
 8024eb8:	9a23      	ldr	r2, [sp, #140]	@ 0x8c
 8024eba:	f1c3 0301 	rsb	r3, r3, #1
 8024ebe:	18d0      	adds	r0, r2, r3
 8024ec0:	b013      	add	sp, #76	@ 0x4c
 8024ec2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8024ec6:	f1b9 0f00 	cmp.w	r9, #0
 8024eca:	dd24      	ble.n	8024f16 <st_sssa8_ch_nn_mat_mult_kernel_single_opt+0x2e2>
 8024ecc:	f855 1c08 	ldr.w	r1, [r5, #-8]
 8024ed0:	005b      	lsls	r3, r3, #1
 8024ed2:	f854 7c08 	ldr.w	r7, [r4, #-8]
 8024ed6:	f1a5 0804 	sub.w	r8, r5, #4
 8024eda:	fb53 7301 	smmla	r3, r3, r1, r7
 8024ede:	1f27      	subs	r7, r4, #4
 8024ee0:	fa43 f309 	asr.w	r3, r3, r9
 8024ee4:	f1ae 0102 	sub.w	r1, lr, #2
 8024ee8:	f303 0307 	ssat	r3, #8, r3
 8024eec:	b25b      	sxtb	r3, r3
 8024eee:	f806 3c01 	strb.w	r3, [r6, #-1]
 8024ef2:	f9b1 1000 	ldrsh.w	r1, [r1]
 8024ef6:	2915      	cmp	r1, #21
 8024ef8:	f73f af55 	bgt.w	8024da6 <st_sssa8_ch_nn_mat_mult_kernel_single_opt+0x172>
 8024efc:	2900      	cmp	r1, #0
 8024efe:	dd20      	ble.n	8024f42 <st_sssa8_ch_nn_mat_mult_kernel_single_opt+0x30e>
 8024f00:	0053      	lsls	r3, r2, #1
 8024f02:	683f      	ldr	r7, [r7, #0]
 8024f04:	f8d8 2000 	ldr.w	r2, [r8]
 8024f08:	fb53 7302 	smmla	r3, r3, r2, r7
 8024f0c:	410b      	asrs	r3, r1
 8024f0e:	f303 0307 	ssat	r3, #8, r3
 8024f12:	b25b      	sxtb	r3, r3
 8024f14:	e758      	b.n	8024dc8 <st_sssa8_ch_nn_mat_mult_kernel_single_opt+0x194>
 8024f16:	f1c9 0701 	rsb	r7, r9, #1
 8024f1a:	f1ae 0102 	sub.w	r1, lr, #2
 8024f1e:	fa03 f707 	lsl.w	r7, r3, r7
 8024f22:	f307 071f 	ssat	r7, #32, r7
 8024f26:	f1a5 0804 	sub.w	r8, r5, #4
 8024f2a:	f855 3c08 	ldr.w	r3, [r5, #-8]
 8024f2e:	fb57 f713 	smmulr	r7, r7, r3
 8024f32:	f854 3c08 	ldr.w	r3, [r4, #-8]
 8024f36:	443b      	add	r3, r7
 8024f38:	1f27      	subs	r7, r4, #4
 8024f3a:	f303 0307 	ssat	r3, #8, r3
 8024f3e:	b25b      	sxtb	r3, r3
 8024f40:	e72a      	b.n	8024d98 <st_sssa8_ch_nn_mat_mult_kernel_single_opt+0x164>
 8024f42:	f1c1 0101 	rsb	r1, r1, #1
 8024f46:	408a      	lsls	r2, r1
 8024f48:	f302 021f 	ssat	r2, #32, r2
 8024f4c:	f8d8 3000 	ldr.w	r3, [r8]
 8024f50:	fb52 f313 	smmulr	r3, r2, r3
 8024f54:	683a      	ldr	r2, [r7, #0]
 8024f56:	4413      	add	r3, r2
 8024f58:	f303 0307 	ssat	r3, #8, r3
 8024f5c:	b25b      	sxtb	r3, r3
 8024f5e:	e733      	b.n	8024dc8 <st_sssa8_ch_nn_mat_mult_kernel_single_opt+0x194>
 8024f60:	9904      	ldr	r1, [sp, #16]
 8024f62:	e6d5      	b.n	8024d10 <st_sssa8_ch_nn_mat_mult_kernel_single_opt+0xdc>
 8024f64:	2101      	movs	r1, #1
 8024f66:	4613      	mov	r3, r2
 8024f68:	e67b      	b.n	8024c62 <st_sssa8_ch_nn_mat_mult_kernel_single_opt+0x2e>
 8024f6a:	9a0c      	ldr	r2, [sp, #48]	@ 0x30
 8024f6c:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 8024f6e:	1a9b      	subs	r3, r3, r2
 8024f70:	9a23      	ldr	r2, [sp, #140]	@ 0x8c
 8024f72:	18d0      	adds	r0, r2, r3
 8024f74:	b013      	add	sp, #76	@ 0x4c
 8024f76:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8024f7a:	2a00      	cmp	r2, #0
 8024f7c:	dd0e      	ble.n	8024f9c <st_sssa8_ch_nn_mat_mult_kernel_single_opt+0x368>
 8024f7e:	9920      	ldr	r1, [sp, #128]	@ 0x80
 8024f80:	005b      	lsls	r3, r3, #1
 8024f82:	9821      	ldr	r0, [sp, #132]	@ 0x84
 8024f84:	6809      	ldr	r1, [r1, #0]
 8024f86:	6800      	ldr	r0, [r0, #0]
 8024f88:	fb53 0301 	smmla	r3, r3, r1, r0
 8024f8c:	4113      	asrs	r3, r2
 8024f8e:	f303 0307 	ssat	r3, #8, r3
 8024f92:	9a23      	ldr	r2, [sp, #140]	@ 0x8c
 8024f94:	f802 3b01 	strb.w	r3, [r2], #1
 8024f98:	9223      	str	r2, [sp, #140]	@ 0x8c
 8024f9a:	e786      	b.n	8024eaa <st_sssa8_ch_nn_mat_mult_kernel_single_opt+0x276>
 8024f9c:	f1c2 0201 	rsb	r2, r2, #1
 8024fa0:	4093      	lsls	r3, r2
 8024fa2:	f303 031f 	ssat	r3, #32, r3
 8024fa6:	9a20      	ldr	r2, [sp, #128]	@ 0x80
 8024fa8:	6812      	ldr	r2, [r2, #0]
 8024faa:	fb53 f312 	smmulr	r3, r3, r2
 8024fae:	9a21      	ldr	r2, [sp, #132]	@ 0x84
 8024fb0:	6812      	ldr	r2, [r2, #0]
 8024fb2:	4413      	add	r3, r2
 8024fb4:	f303 0307 	ssat	r3, #8, r3
 8024fb8:	9a23      	ldr	r2, [sp, #140]	@ 0x8c
 8024fba:	f802 3b01 	strb.w	r3, [r2], #1
 8024fbe:	9223      	str	r2, [sp, #140]	@ 0x8c
 8024fc0:	e773      	b.n	8024eaa <st_sssa8_ch_nn_mat_mult_kernel_single_opt+0x276>
 8024fc2:	4606      	mov	r6, r0
 8024fc4:	e744      	b.n	8024e50 <st_sssa8_ch_nn_mat_mult_kernel_single_opt+0x21c>
 8024fc6:	bf00      	nop
	...

08030000 <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3>:
 8030000:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8030004:	b0a4      	sub	sp, #144	@ 0x90
 8030006:	9e30      	ldr	r6, [sp, #192]	@ 0xc0
 8030008:	9313      	str	r3, [sp, #76]	@ 0x4c
 803000a:	9b35      	ldr	r3, [sp, #212]	@ 0xd4
 803000c:	9011      	str	r0, [sp, #68]	@ 0x44
 803000e:	9112      	str	r1, [sp, #72]	@ 0x48
 8030010:	9210      	str	r2, [sp, #64]	@ 0x40
 8030012:	f013 0801 	ands.w	r8, r3, #1
 8030016:	f8cd 807c 	str.w	r8, [sp, #124]	@ 0x7c
 803001a:	9c31      	ldr	r4, [sp, #196]	@ 0xc4
 803001c:	9d32      	ldr	r5, [sp, #200]	@ 0xc8
 803001e:	bf1c      	itt	ne
 8030020:	3402      	addne	r4, #2
 8030022:	3502      	addne	r5, #2
 8030024:	fb04 f405 	mul.w	r4, r4, r5
 8030028:	f013 0502 	ands.w	r5, r3, #2
 803002c:	9f2f      	ldr	r7, [sp, #188]	@ 0xbc
 803002e:	951e      	str	r5, [sp, #120]	@ 0x78
 8030030:	f04f 0c01 	mov.w	ip, #1
 8030034:	bf19      	ittee	ne
 8030036:	940b      	strne	r4, [sp, #44]	@ 0x2c
 8030038:	f8cd c028 	strne.w	ip, [sp, #40]	@ 0x28
 803003c:	f8cd c02c 	streq.w	ip, [sp, #44]	@ 0x2c
 8030040:	970a      	streq	r7, [sp, #40]	@ 0x28
 8030042:	f003 0803 	and.w	r8, r3, #3
 8030046:	f1b8 0f03 	cmp.w	r8, #3
 803004a:	bf0c      	ite	eq
 803004c:	2302      	moveq	r3, #2
 803004e:	2300      	movne	r3, #0
 8030050:	930c      	str	r3, [sp, #48]	@ 0x30
 8030052:	2f01      	cmp	r7, #1
 8030054:	f340 8231 	ble.w	80304ba <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x4ba>
 8030058:	9d33      	ldr	r5, [sp, #204]	@ 0xcc
 803005a:	eba6 0486 	sub.w	r4, r6, r6, lsl #2
 803005e:	eb05 0304 	add.w	r3, r5, r4
 8030062:	4433      	add	r3, r6
 8030064:	931b      	str	r3, [sp, #108]	@ 0x6c
 8030066:	f1c5 0302 	rsb	r3, r5, #2
 803006a:	eba3 0006 	sub.w	r0, r3, r6
 803006e:	eb04 0c43 	add.w	ip, r4, r3, lsl #1
 8030072:	44b4      	add	ip, r6
 8030074:	f8cd c070 	str.w	ip, [sp, #112]	@ 0x70
 8030078:	f1ac 0c03 	sub.w	ip, ip, #3
 803007c:	f8cd c074 	str.w	ip, [sp, #116]	@ 0x74
 8030080:	f006 0c03 	and.w	ip, r6, #3
 8030084:	f8cd c08c 	str.w	ip, [sp, #140]	@ 0x8c
 8030088:	eb0c 03cc 	add.w	r3, ip, ip, lsl #3
 803008c:	9321      	str	r3, [sp, #132]	@ 0x84
 803008e:	ea4f 03a6 	mov.w	r3, r6, asr #2
 8030092:	eb03 0cc3 	add.w	ip, r3, r3, lsl #3
 8030096:	f8cd c080 	str.w	ip, [sp, #128]	@ 0x80
 803009a:	eb06 0cc6 	add.w	ip, r6, r6, lsl #3
 803009e:	f8cd c088 	str.w	ip, [sp, #136]	@ 0x88
 80300a2:	f8dd b0bc 	ldr.w	fp, [sp, #188]	@ 0xbc
 80300a6:	9b2e      	ldr	r3, [sp, #184]	@ 0xb8
 80300a8:	ea4f 0b5b 	mov.w	fp, fp, lsr #1
 80300ac:	eb03 0c8b 	add.w	ip, r3, fp, lsl #2
 80300b0:	f8cd c058 	str.w	ip, [sp, #88]	@ 0x58
 80300b4:	982e      	ldr	r0, [sp, #184]	@ 0xb8
 80300b6:	992d      	ldr	r1, [sp, #180]	@ 0xb4
 80300b8:	9a37      	ldr	r2, [sp, #220]	@ 0xdc
 80300ba:	900e      	str	r0, [sp, #56]	@ 0x38
 80300bc:	910d      	str	r1, [sp, #52]	@ 0x34
 80300be:	920f      	str	r2, [sp, #60]	@ 0x3c
 80300c0:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
 80300c2:	f9b2 3000 	ldrsh.w	r3, [r2]
 80300c6:	f9b2 4002 	ldrsh.w	r4, [r2, #2]
 80300ca:	e9cd 3402 	strd	r3, r4, [sp, #8]
 80300ce:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
 80300d0:	e9d2 1200 	ldrd	r1, r2, [r2]
 80300d4:	e9cd 1200 	strd	r1, r2, [sp]
 80300d8:	9a0f      	ldr	r2, [sp, #60]	@ 0x3c
 80300da:	e9d2 1200 	ldrd	r1, r2, [r2]
 80300de:	e9cd 1204 	strd	r1, r2, [sp, #16]
 80300e2:	2b00      	cmp	r3, #0
 80300e4:	bfcc      	ite	gt
 80300e6:	2000      	movgt	r0, #0
 80300e8:	f04f 30ff 	movle.w	r0, #4294967295
 80300ec:	2b15      	cmp	r3, #21
 80300ee:	bfc8      	it	gt
 80300f0:	2001      	movgt	r0, #1
 80300f2:	2c00      	cmp	r4, #0
 80300f4:	bfcc      	ite	gt
 80300f6:	2100      	movgt	r1, #0
 80300f8:	f04f 31ff 	movle.w	r1, #4294967295
 80300fc:	2c15      	cmp	r4, #21
 80300fe:	bfc8      	it	gt
 8030100:	2101      	movgt	r1, #1
 8030102:	e9cd 0106 	strd	r0, r1, [sp, #24]
 8030106:	f000 bc59 	b.w	80309bc <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x9bc>
 803010a:	9b34      	ldr	r3, [sp, #208]	@ 0xd0
 803010c:	2b00      	cmp	r3, #0
 803010e:	f040 8426 	bne.w	803095e <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x95e>
 8030112:	4618      	mov	r0, r3
 8030114:	461a      	mov	r2, r3
 8030116:	9d35      	ldr	r5, [sp, #212]	@ 0xd4
 8030118:	9c10      	ldr	r4, [sp, #64]	@ 0x40
 803011a:	e9d4 1300 	ldrd	r1, r3, [r4]
 803011e:	4403      	add	r3, r0
 8030120:	440a      	add	r2, r1
 8030122:	e9cd 2308 	strd	r2, r3, [sp, #32]
 8030126:	2d03      	cmp	r5, #3
 8030128:	9a13      	ldr	r2, [sp, #76]	@ 0x4c
 803012a:	d103      	bne.n	8030134 <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x134>
 803012c:	9b31      	ldr	r3, [sp, #196]	@ 0xc4
 803012e:	f103 0303 	add.w	r3, r3, #3
 8030132:	441a      	add	r2, r3
 8030134:	9215      	str	r2, [sp, #84]	@ 0x54
 8030136:	f8dd 80c8 	ldr.w	r8, [sp, #200]	@ 0xc8
 803013a:	f1b8 0f00 	cmp.w	r8, #0
 803013e:	f000 819d 	beq.w	803047c <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x47c>
 8030142:	9c11      	ldr	r4, [sp, #68]	@ 0x44
 8030144:	f8cd 8068 	str.w	r8, [sp, #104]	@ 0x68
 8030148:	9417      	str	r4, [sp, #92]	@ 0x5c
 803014a:	9b31      	ldr	r3, [sp, #196]	@ 0xc4
 803014c:	105b      	asrs	r3, r3, #1
 803014e:	f000 8184 	beq.w	803045a <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x45a>
 8030152:	9418      	str	r4, [sp, #96]	@ 0x60
 8030154:	9319      	str	r3, [sp, #100]	@ 0x64
 8030156:	9c18      	ldr	r4, [sp, #96]	@ 0x60
 8030158:	9d38      	ldr	r5, [sp, #224]	@ 0xe0
 803015a:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 803015e:	4610      	mov	r0, r2
 8030160:	4619      	mov	r1, r3
 8030162:	2e04      	cmp	r6, #4
 8030164:	f340 8123 	ble.w	80303ae <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x3ae>
 8030168:	ea4f 0ea6 	mov.w	lr, r6, asr #2
 803016c:	e8b5 1e00 	ldmia.w	r5!, {r9, sl, fp, ip}
 8030170:	f8d4 8000 	ldr.w	r8, [r4]
 8030174:	fa2f f788 	sxtb16	r7, r8
 8030178:	fa2f f898 	sxtb16	r8, r8, ror #8
 803017c:	fb27 330b 	smlad	r3, r7, fp, r3
 8030180:	fb27 2209 	smlad	r2, r7, r9, r2
 8030184:	fb28 220a 	smlad	r2, r8, sl, r2
 8030188:	fb28 330c 	smlad	r3, r8, ip, r3
 803018c:	f854 8006 	ldr.w	r8, [r4, r6]
 8030190:	eb04 0446 	add.w	r4, r4, r6, lsl #1
 8030194:	fa2f f788 	sxtb16	r7, r8
 8030198:	fa2f f898 	sxtb16	r8, r8, ror #8
 803019c:	fb27 0009 	smlad	r0, r7, r9, r0
 80301a0:	f855 9b04 	ldr.w	r9, [r5], #4
 80301a4:	fb28 000a 	smlad	r0, r8, sl, r0
 80301a8:	f855 ab04 	ldr.w	sl, [r5], #4
 80301ac:	fb27 110b 	smlad	r1, r7, fp, r1
 80301b0:	f855 bb04 	ldr.w	fp, [r5], #4
 80301b4:	fb28 110c 	smlad	r1, r8, ip, r1
 80301b8:	f855 cb04 	ldr.w	ip, [r5], #4
 80301bc:	fb27 2209 	smlad	r2, r7, r9, r2
 80301c0:	fb27 330b 	smlad	r3, r7, fp, r3
 80301c4:	fb28 220a 	smlad	r2, r8, sl, r2
 80301c8:	fb28 330c 	smlad	r3, r8, ip, r3
 80301cc:	f8d4 8000 	ldr.w	r8, [r4]
 80301d0:	fa2f f788 	sxtb16	r7, r8
 80301d4:	fa2f f898 	sxtb16	r8, r8, ror #8
 80301d8:	fb27 0009 	smlad	r0, r7, r9, r0
 80301dc:	f855 9b04 	ldr.w	r9, [r5], #4
 80301e0:	fb28 000a 	smlad	r0, r8, sl, r0
 80301e4:	f855 ab04 	ldr.w	sl, [r5], #4
 80301e8:	fb27 110b 	smlad	r1, r7, fp, r1
 80301ec:	f855 bb04 	ldr.w	fp, [r5], #4
 80301f0:	fb28 110c 	smlad	r1, r8, ip, r1
 80301f4:	f855 cb04 	ldr.w	ip, [r5], #4
 80301f8:	fb27 2209 	smlad	r2, r7, r9, r2
 80301fc:	fb27 330b 	smlad	r3, r7, fp, r3
 8030200:	fb28 220a 	smlad	r2, r8, sl, r2
 8030204:	fb28 330c 	smlad	r3, r8, ip, r3
 8030208:	f854 8006 	ldr.w	r8, [r4, r6]
 803020c:	fa2f f788 	sxtb16	r7, r8
 8030210:	fa2f f898 	sxtb16	r8, r8, ror #8
 8030214:	fb27 0009 	smlad	r0, r7, r9, r0
 8030218:	fb27 110b 	smlad	r1, r7, fp, r1
 803021c:	f8dd 906c 	ldr.w	r9, [sp, #108]	@ 0x6c
 8030220:	fb28 000a 	smlad	r0, r8, sl, r0
 8030224:	fb28 110c 	smlad	r1, r8, ip, r1
 8030228:	444c      	add	r4, r9
 803022a:	e8b5 1e00 	ldmia.w	r5!, {r9, sl, fp, ip}
 803022e:	f8d4 8000 	ldr.w	r8, [r4]
 8030232:	fa2f f788 	sxtb16	r7, r8
 8030236:	fa2f f898 	sxtb16	r8, r8, ror #8
 803023a:	fb27 330b 	smlad	r3, r7, fp, r3
 803023e:	fb27 2209 	smlad	r2, r7, r9, r2
 8030242:	fb28 220a 	smlad	r2, r8, sl, r2
 8030246:	fb28 330c 	smlad	r3, r8, ip, r3
 803024a:	f854 8006 	ldr.w	r8, [r4, r6]
 803024e:	eb04 0446 	add.w	r4, r4, r6, lsl #1
 8030252:	fa2f f788 	sxtb16	r7, r8
 8030256:	fa2f f898 	sxtb16	r8, r8, ror #8
 803025a:	fb27 0009 	smlad	r0, r7, r9, r0
 803025e:	f855 9b04 	ldr.w	r9, [r5], #4
 8030262:	fb28 000a 	smlad	r0, r8, sl, r0
 8030266:	f855 ab04 	ldr.w	sl, [r5], #4
 803026a:	fb27 110b 	smlad	r1, r7, fp, r1
 803026e:	f855 bb04 	ldr.w	fp, [r5], #4
 8030272:	fb28 110c 	smlad	r1, r8, ip, r1
 8030276:	f855 cb04 	ldr.w	ip, [r5], #4
 803027a:	fb27 2209 	smlad	r2, r7, r9, r2
 803027e:	fb27 330b 	smlad	r3, r7, fp, r3
 8030282:	fb28 220a 	smlad	r2, r8, sl, r2
 8030286:	fb28 330c 	smlad	r3, r8, ip, r3
 803028a:	f8d4 8000 	ldr.w	r8, [r4]
 803028e:	fa2f f788 	sxtb16	r7, r8
 8030292:	fa2f f898 	sxtb16	r8, r8, ror #8
 8030296:	fb27 0009 	smlad	r0, r7, r9, r0
 803029a:	f855 9b04 	ldr.w	r9, [r5], #4
 803029e:	fb28 000a 	smlad	r0, r8, sl, r0
 80302a2:	f855 ab04 	ldr.w	sl, [r5], #4
 80302a6:	fb27 110b 	smlad	r1, r7, fp, r1
 80302aa:	f855 bb04 	ldr.w	fp, [r5], #4
 80302ae:	fb28 110c 	smlad	r1, r8, ip, r1
 80302b2:	f855 cb04 	ldr.w	ip, [r5], #4
 80302b6:	fb27 2209 	smlad	r2, r7, r9, r2
 80302ba:	fb27 330b 	smlad	r3, r7, fp, r3
 80302be:	fb28 220a 	smlad	r2, r8, sl, r2
 80302c2:	fb28 330c 	smlad	r3, r8, ip, r3
 80302c6:	f854 8006 	ldr.w	r8, [r4, r6]
 80302ca:	fa2f f788 	sxtb16	r7, r8
 80302ce:	fa2f f898 	sxtb16	r8, r8, ror #8
 80302d2:	fb27 0009 	smlad	r0, r7, r9, r0
 80302d6:	fb27 110b 	smlad	r1, r7, fp, r1
 80302da:	f8dd 906c 	ldr.w	r9, [sp, #108]	@ 0x6c
 80302de:	fb28 000a 	smlad	r0, r8, sl, r0
 80302e2:	fb28 110c 	smlad	r1, r8, ip, r1
 80302e6:	444c      	add	r4, r9
 80302e8:	e8b5 1e00 	ldmia.w	r5!, {r9, sl, fp, ip}
 80302ec:	f8d4 8000 	ldr.w	r8, [r4]
 80302f0:	fa2f f788 	sxtb16	r7, r8
 80302f4:	fa2f f898 	sxtb16	r8, r8, ror #8
 80302f8:	fb27 330b 	smlad	r3, r7, fp, r3
 80302fc:	fb27 2209 	smlad	r2, r7, r9, r2
 8030300:	fb28 220a 	smlad	r2, r8, sl, r2
 8030304:	fb28 330c 	smlad	r3, r8, ip, r3
 8030308:	f854 8006 	ldr.w	r8, [r4, r6]
 803030c:	eb04 0446 	add.w	r4, r4, r6, lsl #1
 8030310:	fa2f f788 	sxtb16	r7, r8
 8030314:	fa2f f898 	sxtb16	r8, r8, ror #8
 8030318:	fb27 0009 	smlad	r0, r7, r9, r0
 803031c:	f855 9b04 	ldr.w	r9, [r5], #4
 8030320:	fb28 000a 	smlad	r0, r8, sl, r0
 8030324:	f855 ab04 	ldr.w	sl, [r5], #4
 8030328:	fb27 110b 	smlad	r1, r7, fp, r1
 803032c:	f855 bb04 	ldr.w	fp, [r5], #4
 8030330:	fb28 110c 	smlad	r1, r8, ip, r1
 8030334:	f855 cb04 	ldr.w	ip, [r5], #4
 8030338:	fb27 2209 	smlad	r2, r7, r9, r2
 803033c:	fb27 330b 	smlad	r3, r7, fp, r3
 8030340:	fb28 220a 	smlad	r2, r8, sl, r2
 8030344:	fb28 330c 	smlad	r3, r8, ip, r3
 8030348:	f8d4 8000 	ldr.w	r8, [r4]
 803034c:	fa2f f788 	sxtb16	r7, r8
 8030350:	fa2f f898 	sxtb16	r8, r8, ror #8
 8030354:	fb27 0009 	smlad	r0, r7, r9, r0
 8030358:	f855 9b04 	ldr.w	r9, [r5], #4
 803035c:	fb28 000a 	smlad	r0, r8, sl, r0
 8030360:	f855 ab04 	ldr.w	sl, [r5], #4
 8030364:	fb27 110b 	smlad	r1, r7, fp, r1
 8030368:	f855 bb04 	ldr.w	fp, [r5], #4
 803036c:	fb28 110c 	smlad	r1, r8, ip, r1
 8030370:	f855 cb04 	ldr.w	ip, [r5], #4
 8030374:	fb27 2209 	smlad	r2, r7, r9, r2
 8030378:	fb27 330b 	smlad	r3, r7, fp, r3
 803037c:	fb28 220a 	smlad	r2, r8, sl, r2
 8030380:	fb28 330c 	smlad	r3, r8, ip, r3
 8030384:	f854 8006 	ldr.w	r8, [r4, r6]
 8030388:	fa2f f788 	sxtb16	r7, r8
 803038c:	fa2f f898 	sxtb16	r8, r8, ror #8
 8030390:	fb27 0009 	smlad	r0, r7, r9, r0
 8030394:	fb27 110b 	smlad	r1, r7, fp, r1
 8030398:	f8dd 9070 	ldr.w	r9, [sp, #112]	@ 0x70
 803039c:	fb28 000a 	smlad	r0, r8, sl, r0
 80303a0:	fb28 110c 	smlad	r1, r8, ip, r1
 80303a4:	f1be 0e01 	subs.w	lr, lr, #1
 80303a8:	444c      	add	r4, r9
 80303aa:	f47f aedf 	bne.w	803016c <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x16c>
 80303ae:	f016 0703 	ands.w	r7, r6, #3
 80303b2:	f300 80ff 	bgt.w	80305b4 <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x5b4>
 80303b6:	f8dd e010 	ldr.w	lr, [sp, #16]
 80303ba:	f8dd a000 	ldr.w	sl, [sp]
 80303be:	f8dd b008 	ldr.w	fp, [sp, #8]
 80303c2:	f8dd c018 	ldr.w	ip, [sp, #24]
 80303c6:	9d15      	ldr	r5, [sp, #84]	@ 0x54
 80303c8:	9f0a      	ldr	r7, [sp, #40]	@ 0x28
 80303ca:	f8dd 802c 	ldr.w	r8, [sp, #44]	@ 0x2c
 80303ce:	44a8      	add	r8, r5
 80303d0:	f1bc 0f00 	cmp.w	ip, #0
 80303d4:	f040 832d 	bne.w	8030a32 <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0xa32>
 80303d8:	ea4f 0242 	mov.w	r2, r2, lsl #1
 80303dc:	ea4f 0040 	mov.w	r0, r0, lsl #1
 80303e0:	fb52 e20a 	smmla	r2, r2, sl, lr
 80303e4:	fb50 e00a 	smmla	r0, r0, sl, lr
 80303e8:	fa42 f20b 	asr.w	r2, r2, fp
 80303ec:	fa40 f00b 	asr.w	r0, r0, fp
 80303f0:	f302 0207 	ssat	r2, #8, r2
 80303f4:	f300 0007 	ssat	r0, #8, r0
 80303f8:	702a      	strb	r2, [r5, #0]
 80303fa:	55e8      	strb	r0, [r5, r7]
 80303fc:	f8dd e014 	ldr.w	lr, [sp, #20]
 8030400:	f8dd a004 	ldr.w	sl, [sp, #4]
 8030404:	f8dd b00c 	ldr.w	fp, [sp, #12]
 8030408:	f8dd c01c 	ldr.w	ip, [sp, #28]
 803040c:	f1bc 0f00 	cmp.w	ip, #0
 8030410:	f040 8338 	bne.w	8030a84 <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0xa84>
 8030414:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8030418:	ea4f 0141 	mov.w	r1, r1, lsl #1
 803041c:	fb53 e30a 	smmla	r3, r3, sl, lr
 8030420:	fb51 e10a 	smmla	r1, r1, sl, lr
 8030424:	fa43 f30b 	asr.w	r3, r3, fp
 8030428:	fa41 f10b 	asr.w	r1, r1, fp
 803042c:	f303 0307 	ssat	r3, #8, r3
 8030430:	f301 0107 	ssat	r1, #8, r1
 8030434:	f888 3000 	strb.w	r3, [r8]
 8030438:	f808 1007 	strb.w	r1, [r8, r7]
 803043c:	9a15      	ldr	r2, [sp, #84]	@ 0x54
 803043e:	990a      	ldr	r1, [sp, #40]	@ 0x28
 8030440:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 8030442:	9e30      	ldr	r6, [sp, #192]	@ 0xc0
 8030444:	9d18      	ldr	r5, [sp, #96]	@ 0x60
 8030446:	eb02 0241 	add.w	r2, r2, r1, lsl #1
 803044a:	9215      	str	r2, [sp, #84]	@ 0x54
 803044c:	eb05 0546 	add.w	r5, r5, r6, lsl #1
 8030450:	9518      	str	r5, [sp, #96]	@ 0x60
 8030452:	3b01      	subs	r3, #1
 8030454:	9319      	str	r3, [sp, #100]	@ 0x64
 8030456:	f73f ae7e 	bgt.w	8030156 <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x156>
 803045a:	9b31      	ldr	r3, [sp, #196]	@ 0xc4
 803045c:	f013 0301 	ands.w	r3, r3, #1
 8030460:	f040 8141 	bne.w	80306e6 <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x6e6>
 8030464:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 8030466:	441a      	add	r2, r3
 8030468:	9215      	str	r2, [sp, #84]	@ 0x54
 803046a:	9c17      	ldr	r4, [sp, #92]	@ 0x5c
 803046c:	9933      	ldr	r1, [sp, #204]	@ 0xcc
 803046e:	9b1a      	ldr	r3, [sp, #104]	@ 0x68
 8030470:	440c      	add	r4, r1
 8030472:	9417      	str	r4, [sp, #92]	@ 0x5c
 8030474:	3b01      	subs	r3, #1
 8030476:	931a      	str	r3, [sp, #104]	@ 0x68
 8030478:	f47f ae67 	bne.w	803014a <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x14a>
 803047c:	9922      	ldr	r1, [sp, #136]	@ 0x88
 803047e:	9a12      	ldr	r2, [sp, #72]	@ 0x48
 8030480:	eb02 0241 	add.w	r2, r2, r1, lsl #1
 8030484:	9212      	str	r2, [sp, #72]	@ 0x48
 8030486:	990b      	ldr	r1, [sp, #44]	@ 0x2c
 8030488:	9a13      	ldr	r2, [sp, #76]	@ 0x4c
 803048a:	eb02 0241 	add.w	r2, r2, r1, lsl #1
 803048e:	9213      	str	r2, [sp, #76]	@ 0x4c
 8030490:	980d      	ldr	r0, [sp, #52]	@ 0x34
 8030492:	9a0f      	ldr	r2, [sp, #60]	@ 0x3c
 8030494:	9b10      	ldr	r3, [sp, #64]	@ 0x40
 8030496:	9c0e      	ldr	r4, [sp, #56]	@ 0x38
 8030498:	9d16      	ldr	r5, [sp, #88]	@ 0x58
 803049a:	f100 0008 	add.w	r0, r0, #8
 803049e:	900d      	str	r0, [sp, #52]	@ 0x34
 80304a0:	f102 0208 	add.w	r2, r2, #8
 80304a4:	920f      	str	r2, [sp, #60]	@ 0x3c
 80304a6:	f103 0308 	add.w	r3, r3, #8
 80304aa:	9310      	str	r3, [sp, #64]	@ 0x40
 80304ac:	f104 0404 	add.w	r4, r4, #4
 80304b0:	42a5      	cmp	r5, r4
 80304b2:	940e      	str	r4, [sp, #56]	@ 0x38
 80304b4:	f47f ae04 	bne.w	80300c0 <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0xc0>
 80304b8:	9f13      	ldr	r7, [sp, #76]	@ 0x4c
 80304ba:	9b2f      	ldr	r3, [sp, #188]	@ 0xbc
 80304bc:	9932      	ldr	r1, [sp, #200]	@ 0xc8
 80304be:	9d31      	ldr	r5, [sp, #196]	@ 0xc4
 80304c0:	f013 0301 	ands.w	r3, r3, #1
 80304c4:	d071      	beq.n	80305aa <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x5aa>
 80304c6:	2900      	cmp	r1, #0
 80304c8:	d06f      	beq.n	80305aa <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x5aa>
 80304ca:	911a      	str	r1, [sp, #104]	@ 0x68
 80304cc:	2d00      	cmp	r5, #0
 80304ce:	d06c      	beq.n	80305aa <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x5aa>
 80304d0:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 80304d2:	9c0d      	ldr	r4, [sp, #52]	@ 0x34
 80304d4:	f8dd 8038 	ldr.w	r8, [sp, #56]	@ 0x38
 80304d8:	6818      	ldr	r0, [r3, #0]
 80304da:	6821      	ldr	r1, [r4, #0]
 80304dc:	f9b8 b000 	ldrsh.w	fp, [r8]
 80304e0:	9100      	str	r1, [sp, #0]
 80304e2:	f1bb 0f00 	cmp.w	fp, #0
 80304e6:	bfcc      	ite	gt
 80304e8:	2200      	movgt	r2, #0
 80304ea:	f04f 32ff 	movle.w	r2, #4294967295
 80304ee:	f1bb 0f15 	cmp.w	fp, #21
 80304f2:	bfc8      	it	gt
 80304f4:	2201      	movgt	r2, #1
 80304f6:	9b35      	ldr	r3, [sp, #212]	@ 0xd4
 80304f8:	f003 0303 	and.w	r3, r3, #3
 80304fc:	2b03      	cmp	r3, #3
 80304fe:	bf03      	ittte	eq
 8030500:	3703      	addeq	r7, #3
 8030502:	197f      	addeq	r7, r7, r5
 8030504:	2602      	moveq	r6, #2
 8030506:	2600      	movne	r6, #0
 8030508:	960b      	str	r6, [sp, #44]	@ 0x2c
 803050a:	9b10      	ldr	r3, [sp, #64]	@ 0x40
 803050c:	f8dd a0cc 	ldr.w	sl, [sp, #204]	@ 0xcc
 8030510:	9e34      	ldr	r6, [sp, #208]	@ 0xd0
 8030512:	681c      	ldr	r4, [r3, #0]
 8030514:	f8dd 90c0 	ldr.w	r9, [sp, #192]	@ 0xc0
 8030518:	9b11      	ldr	r3, [sp, #68]	@ 0x44
 803051a:	9317      	str	r3, [sp, #92]	@ 0x5c
 803051c:	9410      	str	r4, [sp, #64]	@ 0x40
 803051e:	eb09 0949 	add.w	r9, r9, r9, lsl #1
 8030522:	f8dd c05c 	ldr.w	ip, [sp, #92]	@ 0x5c
 8030526:	9931      	ldr	r1, [sp, #196]	@ 0xc4
 8030528:	9119      	str	r1, [sp, #100]	@ 0x64
 803052a:	9910      	ldr	r1, [sp, #64]	@ 0x40
 803052c:	f8dd 8048 	ldr.w	r8, [sp, #72]	@ 0x48
 8030530:	f1b9 0f00 	cmp.w	r9, #0
 8030534:	dd1a      	ble.n	803056c <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x56c>
 8030536:	464d      	mov	r5, r9
 8030538:	f91c 301a 	ldrsb.w	r3, [ip, sl, lsl #1]
 803053c:	f918 4019 	ldrsb.w	r4, [r8, r9, lsl #1]
 8030540:	eba3 0306 	sub.w	r3, r3, r6
 8030544:	3d01      	subs	r5, #1
 8030546:	fb04 1103 	mla	r1, r4, r3, r1
 803054a:	f91c 300a 	ldrsb.w	r3, [ip, sl]
 803054e:	f918 4009 	ldrsb.w	r4, [r8, r9]
 8030552:	eba3 0306 	sub.w	r3, r3, r6
 8030556:	fb04 1103 	mla	r1, r4, r3, r1
 803055a:	f91c 3b01 	ldrsb.w	r3, [ip], #1
 803055e:	f918 4b01 	ldrsb.w	r4, [r8], #1
 8030562:	eba3 0306 	sub.w	r3, r3, r6
 8030566:	fb04 1103 	mla	r1, r4, r3, r1
 803056a:	d1e5      	bne.n	8030538 <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x538>
 803056c:	9c00      	ldr	r4, [sp, #0]
 803056e:	2a00      	cmp	r2, #0
 8030570:	f040 82b1 	bne.w	8030ad6 <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0xad6>
 8030574:	ea4f 0141 	mov.w	r1, r1, lsl #1
 8030578:	fb51 0104 	smmla	r1, r1, r4, r0
 803057c:	fa41 f10b 	asr.w	r1, r1, fp
 8030580:	f301 0107 	ssat	r1, #8, r1
 8030584:	7039      	strb	r1, [r7, #0]
 8030586:	9c0a      	ldr	r4, [sp, #40]	@ 0x28
 8030588:	9930      	ldr	r1, [sp, #192]	@ 0xc0
 803058a:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 803058c:	4427      	add	r7, r4
 803058e:	ebac 0c41 	sub.w	ip, ip, r1, lsl #1
 8030592:	3b01      	subs	r3, #1
 8030594:	9319      	str	r3, [sp, #100]	@ 0x64
 8030596:	d1c8      	bne.n	803052a <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x52a>
 8030598:	990b      	ldr	r1, [sp, #44]	@ 0x2c
 803059a:	9b1a      	ldr	r3, [sp, #104]	@ 0x68
 803059c:	9c17      	ldr	r4, [sp, #92]	@ 0x5c
 803059e:	440f      	add	r7, r1
 80305a0:	4454      	add	r4, sl
 80305a2:	9417      	str	r4, [sp, #92]	@ 0x5c
 80305a4:	3b01      	subs	r3, #1
 80305a6:	931a      	str	r3, [sp, #104]	@ 0x68
 80305a8:	d1bb      	bne.n	8030522 <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x522>
 80305aa:	f04f 0000 	mov.w	r0, #0
 80305ae:	b024      	add	sp, #144	@ 0x90
 80305b0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80305b4:	9f23      	ldr	r7, [sp, #140]	@ 0x8c
 80305b6:	2f00      	cmp	r7, #0
 80305b8:	f43f aefd 	beq.w	80303b6 <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x3b6>
 80305bc:	f8dd e06c 	ldr.w	lr, [sp, #108]	@ 0x6c
 80305c0:	f8dd 9074 	ldr.w	r9, [sp, #116]	@ 0x74
 80305c4:	f994 c000 	ldrsb.w	ip, [r4]
 80305c8:	f914 8006 	ldrsb.w	r8, [r4, r6]
 80305cc:	f935 bb02 	ldrsh.w	fp, [r5], #2
 80305d0:	f935 ab02 	ldrsh.w	sl, [r5], #2
 80305d4:	fb1b 220c 	smlabb	r2, fp, ip, r2
 80305d8:	fb1b 0008 	smlabb	r0, fp, r8, r0
 80305dc:	fb1a 330c 	smlabb	r3, sl, ip, r3
 80305e0:	fb1a 1108 	smlabb	r1, sl, r8, r1
 80305e4:	eb04 0446 	add.w	r4, r4, r6, lsl #1
 80305e8:	f935 bb02 	ldrsh.w	fp, [r5], #2
 80305ec:	f935 ab02 	ldrsh.w	sl, [r5], #2
 80305f0:	f994 c000 	ldrsb.w	ip, [r4]
 80305f4:	fb1b 2208 	smlabb	r2, fp, r8, r2
 80305f8:	fb1b 000c 	smlabb	r0, fp, ip, r0
 80305fc:	fb1a 3308 	smlabb	r3, sl, r8, r3
 8030600:	fb1a 110c 	smlabb	r1, sl, ip, r1
 8030604:	f914 8006 	ldrsb.w	r8, [r4, r6]
 8030608:	f935 bb02 	ldrsh.w	fp, [r5], #2
 803060c:	f935 ab02 	ldrsh.w	sl, [r5], #2
 8030610:	fb1b 0008 	smlabb	r0, fp, r8, r0
 8030614:	fb1b 220c 	smlabb	r2, fp, ip, r2
 8030618:	fb1a 330c 	smlabb	r3, sl, ip, r3
 803061c:	fb1a 1108 	smlabb	r1, sl, r8, r1
 8030620:	4474      	add	r4, lr
 8030622:	f994 c000 	ldrsb.w	ip, [r4]
 8030626:	f914 8006 	ldrsb.w	r8, [r4, r6]
 803062a:	f935 bb02 	ldrsh.w	fp, [r5], #2
 803062e:	f935 ab02 	ldrsh.w	sl, [r5], #2
 8030632:	fb1b 220c 	smlabb	r2, fp, ip, r2
 8030636:	fb1b 0008 	smlabb	r0, fp, r8, r0
 803063a:	fb1a 330c 	smlabb	r3, sl, ip, r3
 803063e:	fb1a 1108 	smlabb	r1, sl, r8, r1
 8030642:	eb04 0446 	add.w	r4, r4, r6, lsl #1
 8030646:	f935 bb02 	ldrsh.w	fp, [r5], #2
 803064a:	f935 ab02 	ldrsh.w	sl, [r5], #2
 803064e:	f994 c000 	ldrsb.w	ip, [r4]
 8030652:	fb1b 2208 	smlabb	r2, fp, r8, r2
 8030656:	fb1b 000c 	smlabb	r0, fp, ip, r0
 803065a:	fb1a 3308 	smlabb	r3, sl, r8, r3
 803065e:	fb1a 110c 	smlabb	r1, sl, ip, r1
 8030662:	f914 8006 	ldrsb.w	r8, [r4, r6]
 8030666:	f935 bb02 	ldrsh.w	fp, [r5], #2
 803066a:	f935 ab02 	ldrsh.w	sl, [r5], #2
 803066e:	fb1b 0008 	smlabb	r0, fp, r8, r0
 8030672:	fb1b 220c 	smlabb	r2, fp, ip, r2
 8030676:	fb1a 330c 	smlabb	r3, sl, ip, r3
 803067a:	fb1a 1108 	smlabb	r1, sl, r8, r1
 803067e:	4474      	add	r4, lr
 8030680:	f994 c000 	ldrsb.w	ip, [r4]
 8030684:	f914 8006 	ldrsb.w	r8, [r4, r6]
 8030688:	f935 bb02 	ldrsh.w	fp, [r5], #2
 803068c:	f935 ab02 	ldrsh.w	sl, [r5], #2
 8030690:	fb1b 220c 	smlabb	r2, fp, ip, r2
 8030694:	fb1b 0008 	smlabb	r0, fp, r8, r0
 8030698:	fb1a 330c 	smlabb	r3, sl, ip, r3
 803069c:	fb1a 1108 	smlabb	r1, sl, r8, r1
 80306a0:	eb04 0446 	add.w	r4, r4, r6, lsl #1
 80306a4:	f935 bb02 	ldrsh.w	fp, [r5], #2
 80306a8:	f935 ab02 	ldrsh.w	sl, [r5], #2
 80306ac:	f994 c000 	ldrsb.w	ip, [r4]
 80306b0:	fb1b 2208 	smlabb	r2, fp, r8, r2
 80306b4:	fb1b 000c 	smlabb	r0, fp, ip, r0
 80306b8:	fb1a 3308 	smlabb	r3, sl, r8, r3
 80306bc:	fb1a 110c 	smlabb	r1, sl, ip, r1
 80306c0:	f914 8006 	ldrsb.w	r8, [r4, r6]
 80306c4:	f935 bb02 	ldrsh.w	fp, [r5], #2
 80306c8:	f935 ab02 	ldrsh.w	sl, [r5], #2
 80306cc:	fb1b 0008 	smlabb	r0, fp, r8, r0
 80306d0:	fb1b 220c 	smlabb	r2, fp, ip, r2
 80306d4:	fb1a 330c 	smlabb	r3, sl, ip, r3
 80306d8:	fb1a 1108 	smlabb	r1, sl, r8, r1
 80306dc:	444c      	add	r4, r9
 80306de:	3f01      	subs	r7, #1
 80306e0:	f73f af70 	bgt.w	80305c4 <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x5c4>
 80306e4:	e667      	b.n	80303b6 <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x3b6>
 80306e6:	9817      	ldr	r0, [sp, #92]	@ 0x5c
 80306e8:	9b31      	ldr	r3, [sp, #196]	@ 0xc4
 80306ea:	2b01      	cmp	r3, #1
 80306ec:	bf1e      	ittt	ne
 80306ee:	9b1b      	ldrne	r3, [sp, #108]	@ 0x6c
 80306f0:	18c0      	addne	r0, r0, r3
 80306f2:	1b80      	subne	r0, r0, r6
 80306f4:	e9dd e508 	ldrd	lr, r5, [sp, #32]
 80306f8:	f8dd c0cc 	ldr.w	ip, [sp, #204]	@ 0xcc
 80306fc:	ea4f 0a4c 	mov.w	sl, ip, lsl #1
 8030700:	f1ca 0a04 	rsb	sl, sl, #4
 8030704:	9b38      	ldr	r3, [sp, #224]	@ 0xe0
 8030706:	ea5f 0ba6 	movs.w	fp, r6, asr #2
 803070a:	f000 8091 	beq.w	8030830 <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x830>
 803070e:	6802      	ldr	r2, [r0, #0]
 8030710:	fa2f f182 	sxtb16	r1, r2
 8030714:	fa2f f292 	sxtb16	r2, r2, ror #8
 8030718:	e8b3 0390 	ldmia.w	r3!, {r4, r7, r8, r9}
 803071c:	fb21 ee04 	smlad	lr, r1, r4, lr
 8030720:	fb22 ee07 	smlad	lr, r2, r7, lr
 8030724:	fb22 5509 	smlad	r5, r2, r9, r5
 8030728:	fb21 5508 	smlad	r5, r1, r8, r5
 803072c:	5982      	ldr	r2, [r0, r6]
 803072e:	fa2f f182 	sxtb16	r1, r2
 8030732:	fa2f f292 	sxtb16	r2, r2, ror #8
 8030736:	e8b3 0390 	ldmia.w	r3!, {r4, r7, r8, r9}
 803073a:	fb21 ee04 	smlad	lr, r1, r4, lr
 803073e:	fb22 ee07 	smlad	lr, r2, r7, lr
 8030742:	fb22 5509 	smlad	r5, r2, r9, r5
 8030746:	fb21 5508 	smlad	r5, r1, r8, r5
 803074a:	f850 2016 	ldr.w	r2, [r0, r6, lsl #1]
 803074e:	fa2f f182 	sxtb16	r1, r2
 8030752:	fa2f f292 	sxtb16	r2, r2, ror #8
 8030756:	e8b3 0390 	ldmia.w	r3!, {r4, r7, r8, r9}
 803075a:	fb21 ee04 	smlad	lr, r1, r4, lr
 803075e:	fb22 ee07 	smlad	lr, r2, r7, lr
 8030762:	fb22 5509 	smlad	r5, r2, r9, r5
 8030766:	fb21 5508 	smlad	r5, r1, r8, r5
 803076a:	4460      	add	r0, ip
 803076c:	6802      	ldr	r2, [r0, #0]
 803076e:	fa2f f182 	sxtb16	r1, r2
 8030772:	fa2f f292 	sxtb16	r2, r2, ror #8
 8030776:	e8b3 0390 	ldmia.w	r3!, {r4, r7, r8, r9}
 803077a:	fb21 ee04 	smlad	lr, r1, r4, lr
 803077e:	fb22 ee07 	smlad	lr, r2, r7, lr
 8030782:	fb22 5509 	smlad	r5, r2, r9, r5
 8030786:	fb21 5508 	smlad	r5, r1, r8, r5
 803078a:	5982      	ldr	r2, [r0, r6]
 803078c:	fa2f f182 	sxtb16	r1, r2
 8030790:	fa2f f292 	sxtb16	r2, r2, ror #8
 8030794:	e8b3 0390 	ldmia.w	r3!, {r4, r7, r8, r9}
 8030798:	fb21 ee04 	smlad	lr, r1, r4, lr
 803079c:	fb22 ee07 	smlad	lr, r2, r7, lr
 80307a0:	fb22 5509 	smlad	r5, r2, r9, r5
 80307a4:	fb21 5508 	smlad	r5, r1, r8, r5
 80307a8:	f850 2016 	ldr.w	r2, [r0, r6, lsl #1]
 80307ac:	fa2f f182 	sxtb16	r1, r2
 80307b0:	fa2f f292 	sxtb16	r2, r2, ror #8
 80307b4:	e8b3 0390 	ldmia.w	r3!, {r4, r7, r8, r9}
 80307b8:	fb21 ee04 	smlad	lr, r1, r4, lr
 80307bc:	fb22 ee07 	smlad	lr, r2, r7, lr
 80307c0:	fb22 5509 	smlad	r5, r2, r9, r5
 80307c4:	fb21 5508 	smlad	r5, r1, r8, r5
 80307c8:	4460      	add	r0, ip
 80307ca:	6802      	ldr	r2, [r0, #0]
 80307cc:	fa2f f182 	sxtb16	r1, r2
 80307d0:	fa2f f292 	sxtb16	r2, r2, ror #8
 80307d4:	e8b3 0390 	ldmia.w	r3!, {r4, r7, r8, r9}
 80307d8:	fb21 ee04 	smlad	lr, r1, r4, lr
 80307dc:	fb22 ee07 	smlad	lr, r2, r7, lr
 80307e0:	fb22 5509 	smlad	r5, r2, r9, r5
 80307e4:	fb21 5508 	smlad	r5, r1, r8, r5
 80307e8:	5982      	ldr	r2, [r0, r6]
 80307ea:	fa2f f182 	sxtb16	r1, r2
 80307ee:	fa2f f292 	sxtb16	r2, r2, ror #8
 80307f2:	e8b3 0390 	ldmia.w	r3!, {r4, r7, r8, r9}
 80307f6:	fb21 ee04 	smlad	lr, r1, r4, lr
 80307fa:	fb22 ee07 	smlad	lr, r2, r7, lr
 80307fe:	fb22 5509 	smlad	r5, r2, r9, r5
 8030802:	fb21 5508 	smlad	r5, r1, r8, r5
 8030806:	f850 2016 	ldr.w	r2, [r0, r6, lsl #1]
 803080a:	fa2f f182 	sxtb16	r1, r2
 803080e:	fa2f f292 	sxtb16	r2, r2, ror #8
 8030812:	e8b3 0390 	ldmia.w	r3!, {r4, r7, r8, r9}
 8030816:	fb21 ee04 	smlad	lr, r1, r4, lr
 803081a:	fb22 ee07 	smlad	lr, r2, r7, lr
 803081e:	fb22 5509 	smlad	r5, r2, r9, r5
 8030822:	fb21 5508 	smlad	r5, r1, r8, r5
 8030826:	4450      	add	r0, sl
 8030828:	f1bb 0b01 	subs.w	fp, fp, #1
 803082c:	f73f af6f 	bgt.w	803070e <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x70e>
 8030830:	f016 0b03 	ands.w	fp, r6, #3
 8030834:	d05f      	beq.n	80308f6 <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x8f6>
 8030836:	f990 1000 	ldrsb.w	r1, [r0]
 803083a:	5782      	ldrsb	r2, [r0, r6]
 803083c:	f910 a016 	ldrsb.w	sl, [r0, r6, lsl #1]
 8030840:	f933 4b02 	ldrsh.w	r4, [r3], #2
 8030844:	f933 7b02 	ldrsh.w	r7, [r3], #2
 8030848:	f933 8b02 	ldrsh.w	r8, [r3], #2
 803084c:	f933 9b02 	ldrsh.w	r9, [r3], #2
 8030850:	fb11 ee04 	smlabb	lr, r1, r4, lr
 8030854:	fb11 5507 	smlabb	r5, r1, r7, r5
 8030858:	fb12 ee08 	smlabb	lr, r2, r8, lr
 803085c:	fb12 5509 	smlabb	r5, r2, r9, r5
 8030860:	f933 4b02 	ldrsh.w	r4, [r3], #2
 8030864:	f933 7b02 	ldrsh.w	r7, [r3], #2
 8030868:	fb1a ee04 	smlabb	lr, sl, r4, lr
 803086c:	fb1a 5507 	smlabb	r5, sl, r7, r5
 8030870:	4460      	add	r0, ip
 8030872:	f990 1000 	ldrsb.w	r1, [r0]
 8030876:	5782      	ldrsb	r2, [r0, r6]
 8030878:	f910 a016 	ldrsb.w	sl, [r0, r6, lsl #1]
 803087c:	f933 4b02 	ldrsh.w	r4, [r3], #2
 8030880:	f933 7b02 	ldrsh.w	r7, [r3], #2
 8030884:	f933 8b02 	ldrsh.w	r8, [r3], #2
 8030888:	f933 9b02 	ldrsh.w	r9, [r3], #2
 803088c:	fb11 ee04 	smlabb	lr, r1, r4, lr
 8030890:	fb11 5507 	smlabb	r5, r1, r7, r5
 8030894:	fb12 ee08 	smlabb	lr, r2, r8, lr
 8030898:	fb12 5509 	smlabb	r5, r2, r9, r5
 803089c:	f933 4b02 	ldrsh.w	r4, [r3], #2
 80308a0:	f933 7b02 	ldrsh.w	r7, [r3], #2
 80308a4:	fb1a ee04 	smlabb	lr, sl, r4, lr
 80308a8:	fb1a 5507 	smlabb	r5, sl, r7, r5
 80308ac:	4460      	add	r0, ip
 80308ae:	f990 1000 	ldrsb.w	r1, [r0]
 80308b2:	5782      	ldrsb	r2, [r0, r6]
 80308b4:	f910 a016 	ldrsb.w	sl, [r0, r6, lsl #1]
 80308b8:	f933 4b02 	ldrsh.w	r4, [r3], #2
 80308bc:	f933 7b02 	ldrsh.w	r7, [r3], #2
 80308c0:	f933 8b02 	ldrsh.w	r8, [r3], #2
 80308c4:	f933 9b02 	ldrsh.w	r9, [r3], #2
 80308c8:	fb11 ee04 	smlabb	lr, r1, r4, lr
 80308cc:	fb11 5507 	smlabb	r5, r1, r7, r5
 80308d0:	fb12 ee08 	smlabb	lr, r2, r8, lr
 80308d4:	fb12 5509 	smlabb	r5, r2, r9, r5
 80308d8:	f933 4b02 	ldrsh.w	r4, [r3], #2
 80308dc:	f933 7b02 	ldrsh.w	r7, [r3], #2
 80308e0:	fb1a ee04 	smlabb	lr, sl, r4, lr
 80308e4:	fb1a 5507 	smlabb	r5, sl, r7, r5
 80308e8:	eba0 004c 	sub.w	r0, r0, ip, lsl #1
 80308ec:	f100 0001 	add.w	r0, r0, #1
 80308f0:	f1bb 0b01 	subs.w	fp, fp, #1
 80308f4:	dc9f      	bgt.n	8030836 <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x836>
 80308f6:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 80308f8:	9915      	ldr	r1, [sp, #84]	@ 0x54
 80308fa:	eb01 0203 	add.w	r2, r1, r3
 80308fe:	f8dd a000 	ldr.w	sl, [sp]
 8030902:	9c04      	ldr	r4, [sp, #16]
 8030904:	9b02      	ldr	r3, [sp, #8]
 8030906:	9806      	ldr	r0, [sp, #24]
 8030908:	2800      	cmp	r0, #0
 803090a:	f040 8118 	bne.w	8030b3e <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0xb3e>
 803090e:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
 8030912:	fb5e 4e0a 	smmla	lr, lr, sl, r4
 8030916:	fa4e fe03 	asr.w	lr, lr, r3
 803091a:	f30e 0e07 	ssat	lr, #8, lr
 803091e:	f881 e000 	strb.w	lr, [r1]
 8030922:	f8dd a004 	ldr.w	sl, [sp, #4]
 8030926:	9c05      	ldr	r4, [sp, #20]
 8030928:	9b03      	ldr	r3, [sp, #12]
 803092a:	9807      	ldr	r0, [sp, #28]
 803092c:	2800      	cmp	r0, #0
 803092e:	f040 80ec 	bne.w	8030b0a <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0xb0a>
 8030932:	ea4f 0545 	mov.w	r5, r5, lsl #1
 8030936:	fb55 450a 	smmla	r5, r5, sl, r4
 803093a:	fa45 f503 	asr.w	r5, r5, r3
 803093e:	f305 0507 	ssat	r5, #8, r5
 8030942:	7015      	strb	r5, [r2, #0]
 8030944:	9b1f      	ldr	r3, [sp, #124]	@ 0x7c
 8030946:	9d1e      	ldr	r5, [sp, #120]	@ 0x78
 8030948:	2b00      	cmp	r3, #0
 803094a:	bf14      	ite	ne
 803094c:	2303      	movne	r3, #3
 803094e:	2301      	moveq	r3, #1
 8030950:	2d00      	cmp	r5, #0
 8030952:	bf08      	it	eq
 8030954:	9b2f      	ldreq	r3, [sp, #188]	@ 0xbc
 8030956:	9a15      	ldr	r2, [sp, #84]	@ 0x54
 8030958:	441a      	add	r2, r3
 803095a:	9215      	str	r2, [sp, #84]	@ 0x54
 803095c:	e585      	b.n	803046a <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x46a>
 803095e:	9938      	ldr	r1, [sp, #224]	@ 0xe0
 8030960:	f04f 0300 	mov.w	r3, #0
 8030964:	461a      	mov	r2, r3
 8030966:	9820      	ldr	r0, [sp, #128]	@ 0x80
 8030968:	b198      	cbz	r0, 8030992 <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x992>
 803096a:	e8b1 1e00 	ldmia.w	r1!, {r9, sl, fp, ip}
 803096e:	fa02 f289 	sxtah	r2, r2, r9
 8030972:	fa02 f2a9 	sxtah	r2, r2, r9, ror #16
 8030976:	fa02 f28a 	sxtah	r2, r2, sl
 803097a:	fa02 f2aa 	sxtah	r2, r2, sl, ror #16
 803097e:	fa03 f38b 	sxtah	r3, r3, fp
 8030982:	fa03 f3ab 	sxtah	r3, r3, fp, ror #16
 8030986:	fa03 f38c 	sxtah	r3, r3, ip
 803098a:	fa03 f3ac 	sxtah	r3, r3, ip, ror #16
 803098e:	3801      	subs	r0, #1
 8030990:	d1eb      	bne.n	803096a <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x96a>
 8030992:	9821      	ldr	r0, [sp, #132]	@ 0x84
 8030994:	b138      	cbz	r0, 80309a6 <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x9a6>
 8030996:	f851 4b04 	ldr.w	r4, [r1], #4
 803099a:	fa02 f284 	sxtah	r2, r2, r4
 803099e:	fa03 f3a4 	sxtah	r3, r3, r4, ror #16
 80309a2:	3801      	subs	r0, #1
 80309a4:	d1f7      	bne.n	8030996 <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x996>
 80309a6:	f1c2 0200 	rsb	r2, r2, #0
 80309aa:	f1c3 0300 	rsb	r3, r3, #0
 80309ae:	9934      	ldr	r1, [sp, #208]	@ 0xd0
 80309b0:	fb01 f202 	mul.w	r2, r1, r2
 80309b4:	fb01 f003 	mul.w	r0, r1, r3
 80309b8:	f7ff bbad 	b.w	8030116 <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x116>
 80309bc:	9812      	ldr	r0, [sp, #72]	@ 0x48
 80309be:	9c22      	ldr	r4, [sp, #136]	@ 0x88
 80309c0:	9a38      	ldr	r2, [sp, #224]	@ 0xe0
 80309c2:	ea5f 0ba6 	movs.w	fp, r6, asr #2
 80309c6:	d019      	beq.n	80309fc <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x9fc>
 80309c8:	f04f 0a09 	mov.w	sl, #9
 80309cc:	6805      	ldr	r5, [r0, #0]
 80309ce:	f850 8004 	ldr.w	r8, [r0, r4]
 80309d2:	fa2f f795 	sxtb16	r7, r5, ror #8
 80309d6:	fa2f f585 	sxtb16	r5, r5
 80309da:	fa2f f998 	sxtb16	r9, r8, ror #8
 80309de:	fa2f f888 	sxtb16	r8, r8
 80309e2:	e8a2 03a0 	stmia.w	r2!, {r5, r7, r8, r9}
 80309e6:	4430      	add	r0, r6
 80309e8:	f1ba 0a01 	subs.w	sl, sl, #1
 80309ec:	dcee      	bgt.n	80309cc <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x9cc>
 80309ee:	eba0 0004 	sub.w	r0, r0, r4
 80309f2:	f100 0004 	add.w	r0, r0, #4
 80309f6:	f1bb 0b01 	subs.w	fp, fp, #1
 80309fa:	dce5      	bgt.n	80309c8 <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x9c8>
 80309fc:	f016 0b03 	ands.w	fp, r6, #3
 8030a00:	f43f ab83 	beq.w	803010a <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x10a>
 8030a04:	f04f 0a09 	mov.w	sl, #9
 8030a08:	f990 5000 	ldrsb.w	r5, [r0]
 8030a0c:	f910 8004 	ldrsb.w	r8, [r0, r4]
 8030a10:	f822 5b02 	strh.w	r5, [r2], #2
 8030a14:	f822 8b02 	strh.w	r8, [r2], #2
 8030a18:	4430      	add	r0, r6
 8030a1a:	f1ba 0a01 	subs.w	sl, sl, #1
 8030a1e:	dcf3      	bgt.n	8030a08 <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0xa08>
 8030a20:	eba0 0004 	sub.w	r0, r0, r4
 8030a24:	f100 0001 	add.w	r0, r0, #1
 8030a28:	f1bb 0b01 	subs.w	fp, fp, #1
 8030a2c:	dcea      	bgt.n	8030a04 <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0xa04>
 8030a2e:	f7ff bb6c 	b.w	803010a <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x10a>
 8030a32:	f11c 0c01 	adds.w	ip, ip, #1
 8030a36:	d014      	beq.n	8030a62 <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0xa62>
 8030a38:	f04f 0c01 	mov.w	ip, #1
 8030a3c:	fa0c fc0b 	lsl.w	ip, ip, fp
 8030a40:	ea4f 0cac 	mov.w	ip, ip, asr #2
 8030a44:	fb52 c20a 	smmla	r2, r2, sl, ip
 8030a48:	ea4f 0242 	mov.w	r2, r2, lsl #1
 8030a4c:	fa42 f20b 	asr.w	r2, r2, fp
 8030a50:	4472      	add	r2, lr
 8030a52:	fb50 c00a 	smmla	r0, r0, sl, ip
 8030a56:	ea4f 0040 	mov.w	r0, r0, lsl #1
 8030a5a:	fa40 f00b 	asr.w	r0, r0, fp
 8030a5e:	4470      	add	r0, lr
 8030a60:	e4c6      	b.n	80303f0 <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x3f0>
 8030a62:	f1cb 0c01 	rsb	ip, fp, #1
 8030a66:	fa02 f20c 	lsl.w	r2, r2, ip
 8030a6a:	f302 021f 	ssat	r2, #32, r2
 8030a6e:	fb52 f21a 	smmulr	r2, r2, sl
 8030a72:	fa00 f00c 	lsl.w	r0, r0, ip
 8030a76:	f300 001f 	ssat	r0, #32, r0
 8030a7a:	fb50 f01a 	smmulr	r0, r0, sl
 8030a7e:	4472      	add	r2, lr
 8030a80:	4470      	add	r0, lr
 8030a82:	e4b5      	b.n	80303f0 <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x3f0>
 8030a84:	f11c 0c01 	adds.w	ip, ip, #1
 8030a88:	d014      	beq.n	8030ab4 <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0xab4>
 8030a8a:	f04f 0c01 	mov.w	ip, #1
 8030a8e:	fa0c fc0b 	lsl.w	ip, ip, fp
 8030a92:	ea4f 0cac 	mov.w	ip, ip, asr #2
 8030a96:	fb53 c30a 	smmla	r3, r3, sl, ip
 8030a9a:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8030a9e:	fa43 f30b 	asr.w	r3, r3, fp
 8030aa2:	4473      	add	r3, lr
 8030aa4:	fb51 c10a 	smmla	r1, r1, sl, ip
 8030aa8:	ea4f 0141 	mov.w	r1, r1, lsl #1
 8030aac:	fa41 f10b 	asr.w	r1, r1, fp
 8030ab0:	4471      	add	r1, lr
 8030ab2:	e4bb      	b.n	803042c <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x42c>
 8030ab4:	f1cb 0c01 	rsb	ip, fp, #1
 8030ab8:	fa03 f30c 	lsl.w	r3, r3, ip
 8030abc:	f303 031f 	ssat	r3, #32, r3
 8030ac0:	fb53 f31a 	smmulr	r3, r3, sl
 8030ac4:	fa01 f10c 	lsl.w	r1, r1, ip
 8030ac8:	f301 011f 	ssat	r1, #32, r1
 8030acc:	fb51 f11a 	smmulr	r1, r1, sl
 8030ad0:	4473      	add	r3, lr
 8030ad2:	4471      	add	r1, lr
 8030ad4:	e4aa      	b.n	803042c <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x42c>
 8030ad6:	1c53      	adds	r3, r2, #1
 8030ad8:	d00d      	beq.n	8030af6 <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0xaf6>
 8030ada:	f04f 0301 	mov.w	r3, #1
 8030ade:	fa03 f30b 	lsl.w	r3, r3, fp
 8030ae2:	ea4f 03a3 	mov.w	r3, r3, asr #2
 8030ae6:	fb51 3104 	smmla	r1, r1, r4, r3
 8030aea:	ea4f 0141 	mov.w	r1, r1, lsl #1
 8030aee:	fa41 f10b 	asr.w	r1, r1, fp
 8030af2:	4401      	add	r1, r0
 8030af4:	e544      	b.n	8030580 <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x580>
 8030af6:	f1cb 0301 	rsb	r3, fp, #1
 8030afa:	fa01 f103 	lsl.w	r1, r1, r3
 8030afe:	f301 011f 	ssat	r1, #32, r1
 8030b02:	fb51 f114 	smmulr	r1, r1, r4
 8030b06:	4401      	add	r1, r0
 8030b08:	e53a      	b.n	8030580 <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x580>
 8030b0a:	3001      	adds	r0, #1
 8030b0c:	d00d      	beq.n	8030b2a <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0xb2a>
 8030b0e:	f04f 0001 	mov.w	r0, #1
 8030b12:	fa00 f003 	lsl.w	r0, r0, r3
 8030b16:	ea4f 00a0 	mov.w	r0, r0, asr #2
 8030b1a:	fb55 050a 	smmla	r5, r5, sl, r0
 8030b1e:	ea4f 0545 	mov.w	r5, r5, lsl #1
 8030b22:	fa45 f503 	asr.w	r5, r5, r3
 8030b26:	4425      	add	r5, r4
 8030b28:	e709      	b.n	803093e <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x93e>
 8030b2a:	f1c3 0001 	rsb	r0, r3, #1
 8030b2e:	fa05 f500 	lsl.w	r5, r5, r0
 8030b32:	f305 051f 	ssat	r5, #32, r5
 8030b36:	fb55 f51a 	smmulr	r5, r5, sl
 8030b3a:	4425      	add	r5, r4
 8030b3c:	e6ff      	b.n	803093e <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x93e>
 8030b3e:	3001      	adds	r0, #1
 8030b40:	d00d      	beq.n	8030b5e <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0xb5e>
 8030b42:	f04f 0001 	mov.w	r0, #1
 8030b46:	fa00 f003 	lsl.w	r0, r0, r3
 8030b4a:	ea4f 00a0 	mov.w	r0, r0, asr #2
 8030b4e:	fb5e 0e0a 	smmla	lr, lr, sl, r0
 8030b52:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
 8030b56:	fa4e fe03 	asr.w	lr, lr, r3
 8030b5a:	44a6      	add	lr, r4
 8030b5c:	e6dd      	b.n	803091a <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x91a>
 8030b5e:	f1c3 0001 	rsb	r0, r3, #1
 8030b62:	fa0e fe00 	lsl.w	lr, lr, r0
 8030b66:	f30e 0e1f 	ssat	lr, #32, lr
 8030b6a:	fb5e fe1a 	smmulr	lr, lr, sl
 8030b6e:	44a6      	add	lr, r4
 8030b70:	e6d3      	b.n	803091a <st_sssa8_ch_nn_mat_mult_deep_conv2d_3x3+0x91a>
 8030b72:	bf00      	nop

08030b74 <st_sssa8_ch_nn_mat_mult_kernel_opt>:
 8030b74:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8030b78:	b086      	sub	sp, #24
 8030b7a:	f89d 7058 	ldrb.w	r7, [sp, #88]	@ 0x58
 8030b7e:	9100      	str	r1, [sp, #0]
 8030b80:	9203      	str	r2, [sp, #12]
 8030b82:	2f00      	cmp	r7, #0
 8030b84:	9305      	str	r3, [sp, #20]
 8030b86:	bf18      	it	ne
 8030b88:	2301      	movne	r3, #1
 8030b8a:	9c10      	ldr	r4, [sp, #64]	@ 0x40
 8030b8c:	fb04 3303 	mla	r3, r4, r3, r3
 8030b90:	9304      	str	r3, [sp, #16]
 8030b92:	9d0f      	ldr	r5, [sp, #60]	@ 0x3c
 8030b94:	bf14      	ite	ne
 8030b96:	462f      	movne	r7, r5
 8030b98:	2701      	moveq	r7, #1
 8030b9a:	9701      	str	r7, [sp, #4]
 8030b9c:	f8bd 3044 	ldrh.w	r3, [sp, #68]	@ 0x44
 8030ba0:	085b      	lsrs	r3, r3, #1
 8030ba2:	f000 809f 	beq.w	8030ce4 <st_sssa8_ch_nn_mat_mult_kernel_opt+0x170>
 8030ba6:	f8dd b050 	ldr.w	fp, [sp, #80]	@ 0x50
 8030baa:	9a13      	ldr	r2, [sp, #76]	@ 0x4c
 8030bac:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8030bb0:	9302      	str	r3, [sp, #8]
 8030bb2:	f8dd e048 	ldr.w	lr, [sp, #72]	@ 0x48
 8030bb6:	9f03      	ldr	r7, [sp, #12]
 8030bb8:	ea5f 089e 	movs.w	r8, lr, lsr #2
 8030bbc:	f8dd c000 	ldr.w	ip, [sp]
 8030bc0:	f857 6b04 	ldr.w	r6, [r7], #4
 8030bc4:	f857 3b04 	ldr.w	r3, [r7], #4
 8030bc8:	9703      	str	r7, [sp, #12]
 8030bca:	461a      	mov	r2, r3
 8030bcc:	4631      	mov	r1, r6
 8030bce:	d022      	beq.n	8030c16 <st_sssa8_ch_nn_mat_mult_kernel_opt+0xa2>
 8030bd0:	f85c 701e 	ldr.w	r7, [ip, lr, lsl #1]
 8030bd4:	f85c 9b04 	ldr.w	r9, [ip], #4
 8030bd8:	f850 ab04 	ldr.w	sl, [r0], #4
 8030bdc:	fb2a 6609 	smlad	r6, sl, r9, r6
 8030be0:	f850 5b04 	ldr.w	r5, [r0], #4
 8030be4:	fb2a 1107 	smlad	r1, sl, r7, r1
 8030be8:	f850 ab04 	ldr.w	sl, [r0], #4
 8030bec:	fb25 2207 	smlad	r2, r5, r7, r2
 8030bf0:	f85c 701e 	ldr.w	r7, [ip, lr, lsl #1]
 8030bf4:	fb25 3309 	smlad	r3, r5, r9, r3
 8030bf8:	f85c 9b04 	ldr.w	r9, [ip], #4
 8030bfc:	fb2a 6609 	smlad	r6, sl, r9, r6
 8030c00:	fb2a 1107 	smlad	r1, sl, r7, r1
 8030c04:	f850 5b04 	ldr.w	r5, [r0], #4
 8030c08:	fb25 3309 	smlad	r3, r5, r9, r3
 8030c0c:	f1b8 0801 	subs.w	r8, r8, #1
 8030c10:	fb25 2207 	smlad	r2, r5, r7, r2
 8030c14:	d1dc      	bne.n	8030bd0 <st_sssa8_ch_nn_mat_mult_kernel_opt+0x5c>
 8030c16:	f00e 0703 	and.w	r7, lr, #3
 8030c1a:	b18f      	cbz	r7, 8030c40 <st_sssa8_ch_nn_mat_mult_kernel_opt+0xcc>
 8030c1c:	f93c 801e 	ldrsh.w	r8, [ip, lr, lsl #1]
 8030c20:	f93c ab02 	ldrsh.w	sl, [ip], #2
 8030c24:	f930 5b02 	ldrsh.w	r5, [r0], #2
 8030c28:	fb0a 6605 	mla	r6, sl, r5, r6
 8030c2c:	f930 9b02 	ldrsh.w	r9, [r0], #2
 8030c30:	fb09 330a 	mla	r3, r9, sl, r3
 8030c34:	fb08 1105 	mla	r1, r8, r5, r1
 8030c38:	3f01      	subs	r7, #1
 8030c3a:	fb09 2208 	mla	r2, r9, r8, r2
 8030c3e:	dced      	bgt.n	8030c1c <st_sssa8_ch_nn_mat_mult_kernel_opt+0xa8>
 8030c40:	f8dd a04c 	ldr.w	sl, [sp, #76]	@ 0x4c
 8030c44:	9f15      	ldr	r7, [sp, #84]	@ 0x54
 8030c46:	f93a 4b02 	ldrsh.w	r4, [sl], #2
 8030c4a:	f857 cb04 	ldr.w	ip, [r7], #4
 8030c4e:	f85b 5b04 	ldr.w	r5, [fp], #4
 8030c52:	f1c4 0915 	rsb	r9, r4, #21
 8030c56:	ea99 0904 	eors.w	r9, r9, r4
 8030c5a:	f340 80c8 	ble.w	8030dee <st_sssa8_ch_nn_mat_mult_kernel_opt+0x27a>
 8030c5e:	ea4f 0646 	mov.w	r6, r6, lsl #1
 8030c62:	ea4f 0141 	mov.w	r1, r1, lsl #1
 8030c66:	fb56 c605 	smmla	r6, r6, r5, ip
 8030c6a:	fb51 c105 	smmla	r1, r1, r5, ip
 8030c6e:	fa46 f604 	asr.w	r6, r6, r4
 8030c72:	fa41 f104 	asr.w	r1, r1, r4
 8030c76:	f93a 4b02 	ldrsh.w	r4, [sl], #2
 8030c7a:	f857 cb04 	ldr.w	ip, [r7], #4
 8030c7e:	f85b 5b04 	ldr.w	r5, [fp], #4
 8030c82:	f1c4 0915 	rsb	r9, r4, #21
 8030c86:	ea99 0904 	eors.w	r9, r9, r4
 8030c8a:	f340 8099 	ble.w	8030dc0 <st_sssa8_ch_nn_mat_mult_kernel_opt+0x24c>
 8030c8e:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8030c92:	ea4f 0242 	mov.w	r2, r2, lsl #1
 8030c96:	fb53 c305 	smmla	r3, r3, r5, ip
 8030c9a:	fb52 c205 	smmla	r2, r2, r5, ip
 8030c9e:	fa43 f304 	asr.w	r3, r3, r4
 8030ca2:	fa42 f204 	asr.w	r2, r2, r4
 8030ca6:	f306 0607 	ssat	r6, #8, r6
 8030caa:	f8dd 9004 	ldr.w	r9, [sp, #4]
 8030cae:	9c17      	ldr	r4, [sp, #92]	@ 0x5c
 8030cb0:	f8dd 8010 	ldr.w	r8, [sp, #16]
 8030cb4:	7026      	strb	r6, [r4, #0]
 8030cb6:	44a0      	add	r8, r4
 8030cb8:	f301 0107 	ssat	r1, #8, r1
 8030cbc:	f888 1000 	strb.w	r1, [r8]
 8030cc0:	f303 0307 	ssat	r3, #8, r3
 8030cc4:	f804 3009 	strb.w	r3, [r4, r9]
 8030cc8:	f302 0207 	ssat	r2, #8, r2
 8030ccc:	f808 2009 	strb.w	r2, [r8, r9]
 8030cd0:	eb04 0249 	add.w	r2, r4, r9, lsl #1
 8030cd4:	9217      	str	r2, [sp, #92]	@ 0x5c
 8030cd6:	f8cd a04c 	str.w	sl, [sp, #76]	@ 0x4c
 8030cda:	9c02      	ldr	r4, [sp, #8]
 8030cdc:	9715      	str	r7, [sp, #84]	@ 0x54
 8030cde:	45a2      	cmp	sl, r4
 8030ce0:	f47f af67 	bne.w	8030bb2 <st_sssa8_ch_nn_mat_mult_kernel_opt+0x3e>
 8030ce4:	9b11      	ldr	r3, [sp, #68]	@ 0x44
 8030ce6:	f013 0301 	ands.w	r3, r3, #1
 8030cea:	d054      	beq.n	8030d96 <st_sssa8_ch_nn_mat_mult_kernel_opt+0x222>
 8030cec:	f8bd e048 	ldrh.w	lr, [sp, #72]	@ 0x48
 8030cf0:	9b03      	ldr	r3, [sp, #12]
 8030cf2:	f8dd c000 	ldr.w	ip, [sp]
 8030cf6:	6819      	ldr	r1, [r3, #0]
 8030cf8:	ea5f 079e 	movs.w	r7, lr, lsr #2
 8030cfc:	eb0c 044e 	add.w	r4, ip, lr, lsl #1
 8030d00:	460e      	mov	r6, r1
 8030d02:	d015      	beq.n	8030d30 <st_sssa8_ch_nn_mat_mult_kernel_opt+0x1bc>
 8030d04:	f85c 501e 	ldr.w	r5, [ip, lr, lsl #1]
 8030d08:	f85c 8b04 	ldr.w	r8, [ip], #4
 8030d0c:	f850 ab04 	ldr.w	sl, [r0], #4
 8030d10:	f850 3b04 	ldr.w	r3, [r0], #4
 8030d14:	fb2a 6608 	smlad	r6, sl, r8, r6
 8030d18:	fb2a 1105 	smlad	r1, sl, r5, r1
 8030d1c:	f85c a01e 	ldr.w	sl, [ip, lr, lsl #1]
 8030d20:	f85c 8b04 	ldr.w	r8, [ip], #4
 8030d24:	fb23 6608 	smlad	r6, r3, r8, r6
 8030d28:	fb23 110a 	smlad	r1, r3, sl, r1
 8030d2c:	3f01      	subs	r7, #1
 8030d2e:	d1e9      	bne.n	8030d04 <st_sssa8_ch_nn_mat_mult_kernel_opt+0x190>
 8030d30:	f01e 0703 	ands.w	r7, lr, #3
 8030d34:	d00b      	beq.n	8030d4e <st_sssa8_ch_nn_mat_mult_kernel_opt+0x1da>
 8030d36:	f83c 301e 	ldrh.w	r3, [ip, lr, lsl #1]
 8030d3a:	f83c 9b02 	ldrh.w	r9, [ip], #2
 8030d3e:	f930 ab02 	ldrsh.w	sl, [r0], #2
 8030d42:	fb19 660a 	smlabb	r6, r9, sl, r6
 8030d46:	3f01      	subs	r7, #1
 8030d48:	fb13 110a 	smlabb	r1, r3, sl, r1
 8030d4c:	dcf3      	bgt.n	8030d36 <st_sssa8_ch_nn_mat_mult_kernel_opt+0x1c2>
 8030d4e:	f8dd a04c 	ldr.w	sl, [sp, #76]	@ 0x4c
 8030d52:	9f15      	ldr	r7, [sp, #84]	@ 0x54
 8030d54:	f9ba 4000 	ldrsh.w	r4, [sl]
 8030d58:	f8d7 c000 	ldr.w	ip, [r7]
 8030d5c:	f8db 5000 	ldr.w	r5, [fp]
 8030d60:	f1c4 0915 	rsb	r9, r4, #21
 8030d64:	ea99 0904 	eors.w	r9, r9, r4
 8030d68:	dd58      	ble.n	8030e1c <st_sssa8_ch_nn_mat_mult_kernel_opt+0x2a8>
 8030d6a:	ea4f 0646 	mov.w	r6, r6, lsl #1
 8030d6e:	ea4f 0141 	mov.w	r1, r1, lsl #1
 8030d72:	fb56 c605 	smmla	r6, r6, r5, ip
 8030d76:	fb51 c105 	smmla	r1, r1, r5, ip
 8030d7a:	fa46 f604 	asr.w	r6, r6, r4
 8030d7e:	fa41 f104 	asr.w	r1, r1, r4
 8030d82:	f306 0607 	ssat	r6, #8, r6
 8030d86:	9a17      	ldr	r2, [sp, #92]	@ 0x5c
 8030d88:	9c04      	ldr	r4, [sp, #16]
 8030d8a:	7016      	strb	r6, [r2, #0]
 8030d8c:	f301 0107 	ssat	r1, #8, r1
 8030d90:	5511      	strb	r1, [r2, r4]
 8030d92:	9b01      	ldr	r3, [sp, #4]
 8030d94:	441a      	add	r2, r3
 8030d96:	9911      	ldr	r1, [sp, #68]	@ 0x44
 8030d98:	9b16      	ldr	r3, [sp, #88]	@ 0x58
 8030d9a:	9c10      	ldr	r4, [sp, #64]	@ 0x40
 8030d9c:	b133      	cbz	r3, 8030dac <st_sssa8_ch_nn_mat_mult_kernel_opt+0x238>
 8030d9e:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 8030da0:	f104 0002 	add.w	r0, r4, #2
 8030da4:	fb03 0011 	mls	r0, r3, r1, r0
 8030da8:	4410      	add	r0, r2
 8030daa:	e006      	b.n	8030dba <st_sssa8_ch_nn_mat_mult_kernel_opt+0x246>
 8030dac:	eba2 0001 	sub.w	r0, r2, r1
 8030db0:	9a05      	ldr	r2, [sp, #20]
 8030db2:	f104 0402 	add.w	r4, r4, #2
 8030db6:	fb02 0004 	mla	r0, r2, r4, r0
 8030dba:	b006      	add	sp, #24
 8030dbc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8030dc0:	2c00      	cmp	r4, #0
 8030dc2:	dd42      	ble.n	8030e4a <st_sssa8_ch_nn_mat_mult_kernel_opt+0x2d6>
 8030dc4:	f04f 0901 	mov.w	r9, #1
 8030dc8:	fa09 f904 	lsl.w	r9, r9, r4
 8030dcc:	ea4f 09a9 	mov.w	r9, r9, asr #2
 8030dd0:	fb53 9305 	smmla	r3, r3, r5, r9
 8030dd4:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8030dd8:	fa43 f304 	asr.w	r3, r3, r4
 8030ddc:	4463      	add	r3, ip
 8030dde:	fb52 9205 	smmla	r2, r2, r5, r9
 8030de2:	ea4f 0242 	mov.w	r2, r2, lsl #1
 8030de6:	fa42 f204 	asr.w	r2, r2, r4
 8030dea:	4462      	add	r2, ip
 8030dec:	e75b      	b.n	8030ca6 <st_sssa8_ch_nn_mat_mult_kernel_opt+0x132>
 8030dee:	2c00      	cmp	r4, #0
 8030df0:	dd3c      	ble.n	8030e6c <st_sssa8_ch_nn_mat_mult_kernel_opt+0x2f8>
 8030df2:	f04f 0901 	mov.w	r9, #1
 8030df6:	fa09 f904 	lsl.w	r9, r9, r4
 8030dfa:	ea4f 09a9 	mov.w	r9, r9, asr #2
 8030dfe:	fb56 9605 	smmla	r6, r6, r5, r9
 8030e02:	ea4f 0646 	mov.w	r6, r6, lsl #1
 8030e06:	fa46 f604 	asr.w	r6, r6, r4
 8030e0a:	4466      	add	r6, ip
 8030e0c:	fb51 9105 	smmla	r1, r1, r5, r9
 8030e10:	ea4f 0141 	mov.w	r1, r1, lsl #1
 8030e14:	fa41 f104 	asr.w	r1, r1, r4
 8030e18:	4461      	add	r1, ip
 8030e1a:	e72c      	b.n	8030c76 <st_sssa8_ch_nn_mat_mult_kernel_opt+0x102>
 8030e1c:	2c00      	cmp	r4, #0
 8030e1e:	dd36      	ble.n	8030e8e <st_sssa8_ch_nn_mat_mult_kernel_opt+0x31a>
 8030e20:	f04f 0901 	mov.w	r9, #1
 8030e24:	fa09 f904 	lsl.w	r9, r9, r4
 8030e28:	ea4f 09a9 	mov.w	r9, r9, asr #2
 8030e2c:	fb56 9605 	smmla	r6, r6, r5, r9
 8030e30:	ea4f 0646 	mov.w	r6, r6, lsl #1
 8030e34:	fa46 f604 	asr.w	r6, r6, r4
 8030e38:	4466      	add	r6, ip
 8030e3a:	fb51 9105 	smmla	r1, r1, r5, r9
 8030e3e:	ea4f 0141 	mov.w	r1, r1, lsl #1
 8030e42:	fa41 f104 	asr.w	r1, r1, r4
 8030e46:	4461      	add	r1, ip
 8030e48:	e79b      	b.n	8030d82 <st_sssa8_ch_nn_mat_mult_kernel_opt+0x20e>
 8030e4a:	f1c4 0901 	rsb	r9, r4, #1
 8030e4e:	fa03 f309 	lsl.w	r3, r3, r9
 8030e52:	f303 031f 	ssat	r3, #32, r3
 8030e56:	fb53 f315 	smmulr	r3, r3, r5
 8030e5a:	fa02 f209 	lsl.w	r2, r2, r9
 8030e5e:	f302 021f 	ssat	r2, #32, r2
 8030e62:	fb52 f215 	smmulr	r2, r2, r5
 8030e66:	4463      	add	r3, ip
 8030e68:	4462      	add	r2, ip
 8030e6a:	e71c      	b.n	8030ca6 <st_sssa8_ch_nn_mat_mult_kernel_opt+0x132>
 8030e6c:	f1c4 0901 	rsb	r9, r4, #1
 8030e70:	fa06 f609 	lsl.w	r6, r6, r9
 8030e74:	f306 061f 	ssat	r6, #32, r6
 8030e78:	fb56 f615 	smmulr	r6, r6, r5
 8030e7c:	fa01 f109 	lsl.w	r1, r1, r9
 8030e80:	f301 011f 	ssat	r1, #32, r1
 8030e84:	fb51 f115 	smmulr	r1, r1, r5
 8030e88:	4466      	add	r6, ip
 8030e8a:	4461      	add	r1, ip
 8030e8c:	e6f3      	b.n	8030c76 <st_sssa8_ch_nn_mat_mult_kernel_opt+0x102>
 8030e8e:	f1c4 0901 	rsb	r9, r4, #1
 8030e92:	fa06 f609 	lsl.w	r6, r6, r9
 8030e96:	f306 061f 	ssat	r6, #32, r6
 8030e9a:	fb56 f615 	smmulr	r6, r6, r5
 8030e9e:	fa01 f109 	lsl.w	r1, r1, r9
 8030ea2:	f301 011f 	ssat	r1, #32, r1
 8030ea6:	fb51 f115 	smmulr	r1, r1, r5
 8030eaa:	4466      	add	r6, ip
 8030eac:	4461      	add	r1, ip
 8030eae:	e768      	b.n	8030d82 <st_sssa8_ch_nn_mat_mult_kernel_opt+0x20e>

08030eb0 <ai_array_to_buffer_fmt>:
 8030eb0:	f3c0 4343 	ubfx	r3, r0, #17, #4
 8030eb4:	2b02      	cmp	r3, #2
 8030eb6:	d053      	beq.n	8030f60 <ai_array_to_buffer_fmt+0xb0>
 8030eb8:	f020 437e 	bic.w	r3, r0, #4261412864	@ 0xfe000000
 8030ebc:	4a2b      	ldr	r2, [pc, #172]	@ (8030f6c <ai_array_to_buffer_fmt+0xbc>)
 8030ebe:	4293      	cmp	r3, r2
 8030ec0:	d010      	beq.n	8030ee4 <ai_array_to_buffer_fmt+0x34>
 8030ec2:	dc21      	bgt.n	8030f08 <ai_array_to_buffer_fmt+0x58>
 8030ec4:	4a2a      	ldr	r2, [pc, #168]	@ (8030f70 <ai_array_to_buffer_fmt+0xc0>)
 8030ec6:	4293      	cmp	r3, r2
 8030ec8:	d00c      	beq.n	8030ee4 <ai_array_to_buffer_fmt+0x34>
 8030eca:	dd0f      	ble.n	8030eec <ai_array_to_buffer_fmt+0x3c>
 8030ecc:	4a29      	ldr	r2, [pc, #164]	@ (8030f74 <ai_array_to_buffer_fmt+0xc4>)
 8030ece:	4293      	cmp	r3, r2
 8030ed0:	d008      	beq.n	8030ee4 <ai_array_to_buffer_fmt+0x34>
 8030ed2:	f502 32fa 	add.w	r2, r2, #128000	@ 0x1f400
 8030ed6:	4293      	cmp	r3, r2
 8030ed8:	d004      	beq.n	8030ee4 <ai_array_to_buffer_fmt+0x34>
 8030eda:	4a27      	ldr	r2, [pc, #156]	@ (8030f78 <ai_array_to_buffer_fmt+0xc8>)
 8030edc:	4293      	cmp	r3, r2
 8030ede:	bf0c      	ite	eq
 8030ee0:	4613      	moveq	r3, r2
 8030ee2:	2340      	movne	r3, #64	@ 0x40
 8030ee4:	f000 40d0 	and.w	r0, r0, #1744830464	@ 0x68000000
 8030ee8:	4318      	orrs	r0, r3
 8030eea:	4770      	bx	lr
 8030eec:	f5a2 6280 	sub.w	r2, r2, #1024	@ 0x400
 8030ef0:	4293      	cmp	r3, r2
 8030ef2:	d0f7      	beq.n	8030ee4 <ai_array_to_buffer_fmt+0x34>
 8030ef4:	dd2a      	ble.n	8030f4c <ai_array_to_buffer_fmt+0x9c>
 8030ef6:	4a21      	ldr	r2, [pc, #132]	@ (8030f7c <ai_array_to_buffer_fmt+0xcc>)
 8030ef8:	f000 40d0 	and.w	r0, r0, #1744830464	@ 0x68000000
 8030efc:	4293      	cmp	r3, r2
 8030efe:	bf0c      	ite	eq
 8030f00:	4613      	moveq	r3, r2
 8030f02:	2340      	movne	r3, #64	@ 0x40
 8030f04:	4318      	orrs	r0, r3
 8030f06:	4770      	bx	lr
 8030f08:	4a1d      	ldr	r2, [pc, #116]	@ (8030f80 <ai_array_to_buffer_fmt+0xd0>)
 8030f0a:	4293      	cmp	r3, r2
 8030f0c:	d0ea      	beq.n	8030ee4 <ai_array_to_buffer_fmt+0x34>
 8030f0e:	dd0f      	ble.n	8030f30 <ai_array_to_buffer_fmt+0x80>
 8030f10:	4a1c      	ldr	r2, [pc, #112]	@ (8030f84 <ai_array_to_buffer_fmt+0xd4>)
 8030f12:	4293      	cmp	r3, r2
 8030f14:	d0e6      	beq.n	8030ee4 <ai_array_to_buffer_fmt+0x34>
 8030f16:	f502 027e 	add.w	r2, r2, #16646144	@ 0xfe0000
 8030f1a:	4293      	cmp	r3, r2
 8030f1c:	d0e2      	beq.n	8030ee4 <ai_array_to_buffer_fmt+0x34>
 8030f1e:	4a1a      	ldr	r2, [pc, #104]	@ (8030f88 <ai_array_to_buffer_fmt+0xd8>)
 8030f20:	f000 40d0 	and.w	r0, r0, #1744830464	@ 0x68000000
 8030f24:	4293      	cmp	r3, r2
 8030f26:	bf0c      	ite	eq
 8030f28:	4613      	moveq	r3, r2
 8030f2a:	2340      	movne	r3, #64	@ 0x40
 8030f2c:	4318      	orrs	r0, r3
 8030f2e:	4770      	bx	lr
 8030f30:	f5a2 6280 	sub.w	r2, r2, #1024	@ 0x400
 8030f34:	4293      	cmp	r3, r2
 8030f36:	d0d5      	beq.n	8030ee4 <ai_array_to_buffer_fmt+0x34>
 8030f38:	3207      	adds	r2, #7
 8030f3a:	4293      	cmp	r3, r2
 8030f3c:	d0d2      	beq.n	8030ee4 <ai_array_to_buffer_fmt+0x34>
 8030f3e:	f2a2 3287 	subw	r2, r2, #903	@ 0x387
 8030f42:	4293      	cmp	r3, r2
 8030f44:	bf0c      	ite	eq
 8030f46:	4613      	moveq	r3, r2
 8030f48:	2340      	movne	r3, #64	@ 0x40
 8030f4a:	e7cb      	b.n	8030ee4 <ai_array_to_buffer_fmt+0x34>
 8030f4c:	f5a2 6280 	sub.w	r2, r2, #1024	@ 0x400
 8030f50:	4293      	cmp	r3, r2
 8030f52:	d0c7      	beq.n	8030ee4 <ai_array_to_buffer_fmt+0x34>
 8030f54:	3280      	adds	r2, #128	@ 0x80
 8030f56:	4293      	cmp	r3, r2
 8030f58:	bf0c      	ite	eq
 8030f5a:	4613      	moveq	r3, r2
 8030f5c:	2340      	movne	r3, #64	@ 0x40
 8030f5e:	e7c1      	b.n	8030ee4 <ai_array_to_buffer_fmt+0x34>
 8030f60:	4b0a      	ldr	r3, [pc, #40]	@ (8030f8c <ai_array_to_buffer_fmt+0xdc>)
 8030f62:	4003      	ands	r3, r0
 8030f64:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 8030f68:	e7bc      	b.n	8030ee4 <ai_array_to_buffer_fmt+0x34>
 8030f6a:	bf00      	nop
 8030f6c:	00840040 	.word	0x00840040
 8030f70:	00040840 	.word	0x00040840
 8030f74:	00041040 	.word	0x00041040
 8030f78:	0004084f 	.word	0x0004084f
 8030f7c:	00040447 	.word	0x00040447
 8030f80:	00840840 	.word	0x00840840
 8030f84:	00841040 	.word	0x00841040
 8030f88:	0084084f 	.word	0x0084084f
 8030f8c:	00803fff 	.word	0x00803fff

08030f90 <ai_array_get_byte_size>:
 8030f90:	b319      	cbz	r1, 8030fda <ai_array_get_byte_size+0x4a>
 8030f92:	f3c0 13c6 	ubfx	r3, r0, #7, #7
 8030f96:	f3c0 4243 	ubfx	r2, r0, #17, #4
 8030f9a:	f3c0 5c41 	ubfx	ip, r0, #21, #2
 8030f9e:	11c0      	asrs	r0, r0, #7
 8030fa0:	fb01 f303 	mul.w	r3, r1, r3
 8030fa4:	2a04      	cmp	r2, #4
 8030fa6:	f103 0307 	add.w	r3, r3, #7
 8030faa:	f023 0307 	bic.w	r3, r3, #7
 8030fae:	fa23 f10c 	lsr.w	r1, r3, ip
 8030fb2:	d00b      	beq.n	8030fcc <ai_array_get_byte_size+0x3c>
 8030fb4:	2a08      	cmp	r2, #8
 8030fb6:	d002      	beq.n	8030fbe <ai_array_get_byte_size+0x2e>
 8030fb8:	3107      	adds	r1, #7
 8030fba:	08c8      	lsrs	r0, r1, #3
 8030fbc:	4770      	bx	lr
 8030fbe:	f000 007f 	and.w	r0, r0, #127	@ 0x7f
 8030fc2:	eb01 2100 	add.w	r1, r1, r0, lsl #8
 8030fc6:	3107      	adds	r1, #7
 8030fc8:	08c8      	lsrs	r0, r1, #3
 8030fca:	4770      	bx	lr
 8030fcc:	f000 007f 	and.w	r0, r0, #127	@ 0x7f
 8030fd0:	eb01 1100 	add.w	r1, r1, r0, lsl #4
 8030fd4:	3107      	adds	r1, #7
 8030fd6:	08c8      	lsrs	r0, r1, #3
 8030fd8:	4770      	bx	lr
 8030fda:	4608      	mov	r0, r1
 8030fdc:	4770      	bx	lr
 8030fde:	bf00      	nop

08030fe0 <ai_version_get>:
 8030fe0:	0212      	lsls	r2, r2, #8
 8030fe2:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 8030fe6:	ea42 6000 	orr.w	r0, r2, r0, lsl #24
 8030fea:	4770      	bx	lr

08030fec <get_tensor_byte_size>:
 8030fec:	b430      	push	{r4, r5}
 8030fee:	6985      	ldr	r5, [r0, #24]
 8030ff0:	68c4      	ldr	r4, [r0, #12]
 8030ff2:	6941      	ldr	r1, [r0, #20]
 8030ff4:	4b06      	ldr	r3, [pc, #24]	@ (8031010 <get_tensor_byte_size+0x24>)
 8030ff6:	6828      	ldr	r0, [r5, #0]
 8030ff8:	4a06      	ldr	r2, [pc, #24]	@ (8031014 <get_tensor_byte_size+0x28>)
 8030ffa:	4003      	ands	r3, r0
 8030ffc:	68c9      	ldr	r1, [r1, #12]
 8030ffe:	68e0      	ldr	r0, [r4, #12]
 8031000:	4293      	cmp	r3, r2
 8031002:	fb01 f000 	mul.w	r0, r1, r0
 8031006:	d101      	bne.n	803100c <get_tensor_byte_size+0x20>
 8031008:	3007      	adds	r0, #7
 803100a:	08c0      	lsrs	r0, r0, #3
 803100c:	bc30      	pop	{r4, r5}
 803100e:	4770      	bx	lr
 8031010:	017fffff 	.word	0x017fffff
 8031014:	000400c0 	.word	0x000400c0

08031018 <core_tensor_clone>:
 8031018:	680b      	ldr	r3, [r1, #0]
 803101a:	6882      	ldr	r2, [r0, #8]
 803101c:	6003      	str	r3, [r0, #0]
 803101e:	684b      	ldr	r3, [r1, #4]
 8031020:	6043      	str	r3, [r0, #4]
 8031022:	698b      	ldr	r3, [r1, #24]
 8031024:	6183      	str	r3, [r0, #24]
 8031026:	688b      	ldr	r3, [r1, #8]
 8031028:	f3c3 2317 	ubfx	r3, r3, #8, #24
 803102c:	f363 221f 	bfi	r2, r3, #8, #24
 8031030:	b410      	push	{r4}
 8031032:	6082      	str	r2, [r0, #8]
 8031034:	b15b      	cbz	r3, 803104e <core_tensor_clone+0x36>
 8031036:	2300      	movs	r3, #0
 8031038:	68cc      	ldr	r4, [r1, #12]
 803103a:	68c2      	ldr	r2, [r0, #12]
 803103c:	f854 4023 	ldr.w	r4, [r4, r3, lsl #2]
 8031040:	f842 4023 	str.w	r4, [r2, r3, lsl #2]
 8031044:	3301      	adds	r3, #1
 8031046:	6882      	ldr	r2, [r0, #8]
 8031048:	ebb3 2f12 	cmp.w	r3, r2, lsr #8
 803104c:	d3f4      	bcc.n	8031038 <core_tensor_clone+0x20>
 803104e:	690b      	ldr	r3, [r1, #16]
 8031050:	6902      	ldr	r2, [r0, #16]
 8031052:	f3c3 2317 	ubfx	r3, r3, #8, #24
 8031056:	f363 221f 	bfi	r2, r3, #8, #24
 803105a:	6102      	str	r2, [r0, #16]
 803105c:	b15b      	cbz	r3, 8031076 <core_tensor_clone+0x5e>
 803105e:	2300      	movs	r3, #0
 8031060:	694c      	ldr	r4, [r1, #20]
 8031062:	6942      	ldr	r2, [r0, #20]
 8031064:	f854 4023 	ldr.w	r4, [r4, r3, lsl #2]
 8031068:	f842 4023 	str.w	r4, [r2, r3, lsl #2]
 803106c:	3301      	adds	r3, #1
 803106e:	6902      	ldr	r2, [r0, #16]
 8031070:	ebb3 2f12 	cmp.w	r3, r2, lsr #8
 8031074:	d3f4      	bcc.n	8031060 <core_tensor_clone+0x48>
 8031076:	f85d 4b04 	ldr.w	r4, [sp], #4
 803107a:	4770      	bx	lr

0803107c <core_array_clone>:
 803107c:	4684      	mov	ip, r0
 803107e:	c90f      	ldmia	r1, {r0, r1, r2, r3}
 8031080:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
 8031084:	4770      	bx	lr
 8031086:	bf00      	nop

08031088 <_lite_kernel_nl_softmax_is8os8>:
 8031088:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 803108c:	b099      	sub	sp, #100	@ 0x64
 803108e:	9013      	str	r0, [sp, #76]	@ 0x4c
 8031090:	1888      	adds	r0, r1, r2
 8031092:	9102      	str	r1, [sp, #8]
 8031094:	4281      	cmp	r1, r0
 8031096:	9303      	str	r3, [sp, #12]
 8031098:	9016      	str	r0, [sp, #88]	@ 0x58
 803109a:	f080 83c0 	bcs.w	803181e <_lite_kernel_nl_softmax_is8os8+0x796>
 803109e:	460a      	mov	r2, r1
 80310a0:	4619      	mov	r1, r3
 80310a2:	3b01      	subs	r3, #1
 80310a4:	18d3      	adds	r3, r2, r3
 80310a6:	9314      	str	r3, [sp, #80]	@ 0x50
 80310a8:	9b27      	ldr	r3, [sp, #156]	@ 0x9c
 80310aa:	3b04      	subs	r3, #4
 80310ac:	9315      	str	r3, [sp, #84]	@ 0x54
 80310ae:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 80310b2:	9317      	str	r3, [sp, #92]	@ 0x5c
 80310b4:	9b02      	ldr	r3, [sp, #8]
 80310b6:	9903      	ldr	r1, [sp, #12]
 80310b8:	f993 2000 	ldrsb.w	r2, [r3]
 80310bc:	2901      	cmp	r1, #1
 80310be:	9212      	str	r2, [sp, #72]	@ 0x48
 80310c0:	f240 83c5 	bls.w	803184e <_lite_kernel_nl_softmax_is8os8+0x7c6>
 80310c4:	9814      	ldr	r0, [sp, #80]	@ 0x50
 80310c6:	f913 1f01 	ldrsb.w	r1, [r3, #1]!
 80310ca:	428a      	cmp	r2, r1
 80310cc:	bfb8      	it	lt
 80310ce:	460a      	movlt	r2, r1
 80310d0:	4283      	cmp	r3, r0
 80310d2:	d1f8      	bne.n	80310c6 <_lite_kernel_nl_softmax_is8os8+0x3e>
 80310d4:	9b26      	ldr	r3, [sp, #152]	@ 0x98
 80310d6:	9212      	str	r2, [sp, #72]	@ 0x48
 80310d8:	4413      	add	r3, r2
 80310da:	9305      	str	r3, [sp, #20]
 80310dc:	9b02      	ldr	r3, [sp, #8]
 80310de:	f103 3bff 	add.w	fp, r3, #4294967295
 80310e2:	9b15      	ldr	r3, [sp, #84]	@ 0x54
 80310e4:	9301      	str	r3, [sp, #4]
 80310e6:	2300      	movs	r3, #0
 80310e8:	46dc      	mov	ip, fp
 80310ea:	9304      	str	r3, [sp, #16]
 80310ec:	e104      	b.n	80312f8 <_lite_kernel_nl_softmax_is8os8+0x270>
 80310ee:	9a12      	ldr	r2, [sp, #72]	@ 0x48
 80310f0:	1a9b      	subs	r3, r3, r2
 80310f2:	9a25      	ldr	r2, [sp, #148]	@ 0x94
 80310f4:	4093      	lsls	r3, r2
 80310f6:	9a24      	ldr	r2, [sp, #144]	@ 0x90
 80310f8:	405a      	eors	r2, r3
 80310fa:	0fd2      	lsrs	r2, r2, #31
 80310fc:	2a00      	cmp	r2, #0
 80310fe:	4ac8      	ldr	r2, [pc, #800]	@ (8031420 <_lite_kernel_nl_softmax_is8os8+0x398>)
 8031100:	bf0b      	itete	eq
 8031102:	f04f 4180 	moveq.w	r1, #1073741824	@ 0x40000000
 8031106:	4611      	movne	r1, r2
 8031108:	2200      	moveq	r2, #0
 803110a:	f04f 32ff 	movne.w	r2, #4294967295
 803110e:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 8031112:	f040 80fa 	bne.w	803130a <_lite_kernel_nl_softmax_is8os8+0x282>
 8031116:	9824      	ldr	r0, [sp, #144]	@ 0x90
 8031118:	4298      	cmp	r0, r3
 803111a:	f040 80f6 	bne.w	803130a <_lite_kernel_nl_softmax_is8os8+0x282>
 803111e:	4bc1      	ldr	r3, [pc, #772]	@ (8031424 <_lite_kernel_nl_softmax_is8os8+0x39c>)
 8031120:	2200      	movs	r2, #0
 8031122:	f04f 31ff 	mov.w	r1, #4294967295
 8031126:	4dc0      	ldr	r5, [pc, #768]	@ (8031428 <_lite_kernel_nl_softmax_is8os8+0x3a0>)
 8031128:	9310      	str	r3, [sp, #64]	@ 0x40
 803112a:	f44f 3600 	mov.w	r6, #131072	@ 0x20000
 803112e:	4bbf      	ldr	r3, [pc, #764]	@ (803142c <_lite_kernel_nl_softmax_is8os8+0x3a4>)
 8031130:	4696      	mov	lr, r2
 8031132:	460f      	mov	r7, r1
 8031134:	4689      	mov	r9, r1
 8031136:	9311      	str	r3, [sp, #68]	@ 0x44
 8031138:	468a      	mov	sl, r1
 803113a:	4bbd      	ldr	r3, [pc, #756]	@ (8031430 <_lite_kernel_nl_softmax_is8os8+0x3a8>)
 803113c:	4614      	mov	r4, r2
 803113e:	4693      	mov	fp, r2
 8031140:	2001      	movs	r0, #1
 8031142:	e9cd 220e 	strd	r2, r2, [sp, #56]	@ 0x38
 8031146:	e9cd 110c 	strd	r1, r1, [sp, #48]	@ 0x30
 803114a:	e9cd 110a 	strd	r1, r1, [sp, #40]	@ 0x28
 803114e:	e9cd 2208 	strd	r2, r2, [sp, #32]
 8031152:	e9cd 2206 	strd	r2, r2, [sp, #24]
 8031156:	4282      	cmp	r2, r0
 8031158:	4ab1      	ldr	r2, [pc, #708]	@ (8031420 <_lite_kernel_nl_softmax_is8os8+0x398>)
 803115a:	9811      	ldr	r0, [sp, #68]	@ 0x44
 803115c:	bfc8      	it	gt
 803115e:	3601      	addgt	r6, #1
 8031160:	f1be 0f00 	cmp.w	lr, #0
 8031164:	bf06      	itte	eq
 8031166:	f04f 4280 	moveq.w	r2, #1073741824	@ 0x40000000
 803116a:	f04f 0e00 	moveq.w	lr, #0
 803116e:	f04f 3eff 	movne.w	lr, #4294967295
 8031172:	1882      	adds	r2, r0, r2
 8031174:	eb43 0e0e 	adc.w	lr, r3, lr
 8031178:	f1be 0f00 	cmp.w	lr, #0
 803117c:	da05      	bge.n	803118a <_lite_kernel_nl_softmax_is8os8+0x102>
 803117e:	f06f 4300 	mvn.w	r3, #2147483648	@ 0x80000000
 8031182:	18d3      	adds	r3, r2, r3
 8031184:	461a      	mov	r2, r3
 8031186:	f14e 0e00 	adc.w	lr, lr, #0
 803118a:	0fd2      	lsrs	r2, r2, #31
 803118c:	48a9      	ldr	r0, [pc, #676]	@ (8031434 <_lite_kernel_nl_softmax_is8os8+0x3ac>)
 803118e:	ea42 024e 	orr.w	r2, r2, lr, lsl #1
 8031192:	4432      	add	r2, r6
 8031194:	0fd3      	lsrs	r3, r2, #31
 8031196:	2b00      	cmp	r3, #0
 8031198:	4ba1      	ldr	r3, [pc, #644]	@ (8031420 <_lite_kernel_nl_softmax_is8os8+0x398>)
 803119a:	bf06      	itte	eq
 803119c:	2600      	moveq	r6, #0
 803119e:	f04f 4380 	moveq.w	r3, #1073741824	@ 0x40000000
 80311a2:	f04f 36ff 	movne.w	r6, #4294967295
 80311a6:	fbc2 3600 	smlal	r3, r6, r2, r0
 80311aa:	2e00      	cmp	r6, #0
 80311ac:	da05      	bge.n	80311ba <_lite_kernel_nl_softmax_is8os8+0x132>
 80311ae:	f06f 4200 	mvn.w	r2, #2147483648	@ 0x80000000
 80311b2:	189a      	adds	r2, r3, r2
 80311b4:	4613      	mov	r3, r2
 80311b6:	f146 0600 	adc.w	r6, r6, #0
 80311ba:	0fdb      	lsrs	r3, r3, #31
 80311bc:	9a10      	ldr	r2, [sp, #64]	@ 0x40
 80311be:	ea43 0346 	orr.w	r3, r3, r6, lsl #1
 80311c2:	441a      	add	r2, r3
 80311c4:	07d0      	lsls	r0, r2, #31
 80311c6:	ea4f 0362 	mov.w	r3, r2, asr #1
 80311ca:	d502      	bpl.n	80311d2 <_lite_kernel_nl_softmax_is8os8+0x14a>
 80311cc:	2b00      	cmp	r3, #0
 80311ce:	bfa8      	it	ge
 80311d0:	3301      	addge	r3, #1
 80311d2:	442b      	add	r3, r5
 80311d4:	4898      	ldr	r0, [pc, #608]	@ (8031438 <_lite_kernel_nl_softmax_is8os8+0x3b0>)
 80311d6:	0fda      	lsrs	r2, r3, #31
 80311d8:	2a00      	cmp	r2, #0
 80311da:	4a91      	ldr	r2, [pc, #580]	@ (8031420 <_lite_kernel_nl_softmax_is8os8+0x398>)
 80311dc:	bf06      	itte	eq
 80311de:	2500      	moveq	r5, #0
 80311e0:	f04f 4280 	moveq.w	r2, #1073741824	@ 0x40000000
 80311e4:	f04f 35ff 	movne.w	r5, #4294967295
 80311e8:	fbc3 2500 	smlal	r2, r5, r3, r0
 80311ec:	2d00      	cmp	r5, #0
 80311ee:	da05      	bge.n	80311fc <_lite_kernel_nl_softmax_is8os8+0x174>
 80311f0:	f06f 4300 	mvn.w	r3, #2147483648	@ 0x80000000
 80311f4:	18d3      	adds	r3, r2, r3
 80311f6:	461a      	mov	r2, r3
 80311f8:	f145 0500 	adc.w	r5, r5, #0
 80311fc:	0fd2      	lsrs	r2, r2, #31
 80311fe:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8031202:	488e      	ldr	r0, [pc, #568]	@ (803143c <_lite_kernel_nl_softmax_is8os8+0x3b4>)
 8031204:	ea42 0245 	orr.w	r2, r2, r5, lsl #1
 8031208:	2500      	movs	r5, #0
 803120a:	461e      	mov	r6, r3
 803120c:	f102 42e2 	add.w	r2, r2, #1895825408	@ 0x71000000
 8031210:	46ae      	mov	lr, r5
 8031212:	f5a2 2225 	sub.w	r2, r2, #675840	@ 0xa5000
 8031216:	f2a2 726c 	subw	r2, r2, #1900	@ 0x76c
 803121a:	fbc2 6e00 	smlal	r6, lr, r2, r0
 803121e:	0ff6      	lsrs	r6, r6, #31
 8031220:	4017      	ands	r7, r2
 8031222:	4887      	ldr	r0, [pc, #540]	@ (8031440 <_lite_kernel_nl_softmax_is8os8+0x3b8>)
 8031224:	ea46 064e 	orr.w	r6, r6, lr, lsl #1
 8031228:	461a      	mov	r2, r3
 803122a:	4034      	ands	r4, r6
 803122c:	462e      	mov	r6, r5
 803122e:	407c      	eors	r4, r7
 8031230:	fbc4 2600 	smlal	r2, r6, r4, r0
 8031234:	0fd2      	lsrs	r2, r2, #31
 8031236:	9809      	ldr	r0, [sp, #36]	@ 0x24
 8031238:	ea09 0904 	and.w	r9, r9, r4
 803123c:	ea42 0246 	orr.w	r2, r2, r6, lsl #1
 8031240:	462c      	mov	r4, r5
 8031242:	4e80      	ldr	r6, [pc, #512]	@ (8031444 <_lite_kernel_nl_softmax_is8os8+0x3bc>)
 8031244:	4010      	ands	r0, r2
 8031246:	461a      	mov	r2, r3
 8031248:	ea89 0000 	eor.w	r0, r9, r0
 803124c:	fbc0 2406 	smlal	r2, r4, r0, r6
 8031250:	0fd2      	lsrs	r2, r2, #31
 8031252:	ea0a 0a00 	and.w	sl, sl, r0
 8031256:	4e7c      	ldr	r6, [pc, #496]	@ (8031448 <_lite_kernel_nl_softmax_is8os8+0x3c0>)
 8031258:	ea42 0244 	orr.w	r2, r2, r4, lsl #1
 803125c:	462c      	mov	r4, r5
 803125e:	ea0b 0b02 	and.w	fp, fp, r2
 8031262:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
 8031264:	ea8a 0b0b 	eor.w	fp, sl, fp
 8031268:	ea02 000b 	and.w	r0, r2, fp
 803126c:	461a      	mov	r2, r3
 803126e:	fbcb 2406 	smlal	r2, r4, fp, r6
 8031272:	0fd2      	lsrs	r2, r2, #31
 8031274:	4e75      	ldr	r6, [pc, #468]	@ (803144c <_lite_kernel_nl_softmax_is8os8+0x3c4>)
 8031276:	ea42 0244 	orr.w	r2, r2, r4, lsl #1
 803127a:	9c0e      	ldr	r4, [sp, #56]	@ 0x38
 803127c:	4014      	ands	r4, r2
 803127e:	4622      	mov	r2, r4
 8031280:	462c      	mov	r4, r5
 8031282:	4042      	eors	r2, r0
 8031284:	4618      	mov	r0, r3
 8031286:	fbc2 0406 	smlal	r0, r4, r2, r6
 803128a:	0fc0      	lsrs	r0, r0, #31
 803128c:	4011      	ands	r1, r2
 803128e:	9a08      	ldr	r2, [sp, #32]
 8031290:	ea40 0044 	orr.w	r0, r0, r4, lsl #1
 8031294:	4e6e      	ldr	r6, [pc, #440]	@ (8031450 <_lite_kernel_nl_softmax_is8os8+0x3c8>)
 8031296:	462c      	mov	r4, r5
 8031298:	4002      	ands	r2, r0
 803129a:	980c      	ldr	r0, [sp, #48]	@ 0x30
 803129c:	404a      	eors	r2, r1
 803129e:	4619      	mov	r1, r3
 80312a0:	fbc2 1406 	smlal	r1, r4, r2, r6
 80312a4:	0fc9      	lsrs	r1, r1, #31
 80312a6:	4010      	ands	r0, r2
 80312a8:	9a07      	ldr	r2, [sp, #28]
 80312aa:	ea41 0144 	orr.w	r1, r1, r4, lsl #1
 80312ae:	400a      	ands	r2, r1
 80312b0:	21f2      	movs	r1, #242	@ 0xf2
 80312b2:	4042      	eors	r2, r0
 80312b4:	fbc2 3501 	smlal	r3, r5, r2, r1
 80312b8:	990d      	ldr	r1, [sp, #52]	@ 0x34
 80312ba:	0fdb      	lsrs	r3, r3, #31
 80312bc:	4011      	ands	r1, r2
 80312be:	ea43 0345 	orr.w	r3, r3, r5, lsl #1
 80312c2:	460a      	mov	r2, r1
 80312c4:	9906      	ldr	r1, [sp, #24]
 80312c6:	4019      	ands	r1, r3
 80312c8:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 80312ca:	404a      	eors	r2, r1
 80312cc:	401a      	ands	r2, r3
 80312ce:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 80312d0:	405a      	eors	r2, r3
 80312d2:	1313      	asrs	r3, r2, #12
 80312d4:	0511      	lsls	r1, r2, #20
 80312d6:	9904      	ldr	r1, [sp, #16]
 80312d8:	bf48      	it	mi
 80312da:	3301      	addmi	r3, #1
 80312dc:	4419      	add	r1, r3
 80312de:	9104      	str	r1, [sp, #16]
 80312e0:	9b01      	ldr	r3, [sp, #4]
 80312e2:	f843 2f04 	str.w	r2, [r3, #4]!
 80312e6:	9a02      	ldr	r2, [sp, #8]
 80312e8:	9301      	str	r3, [sp, #4]
 80312ea:	f108 0302 	add.w	r3, r8, #2
 80312ee:	1a9b      	subs	r3, r3, r2
 80312f0:	9a03      	ldr	r2, [sp, #12]
 80312f2:	429a      	cmp	r2, r3
 80312f4:	f240 80ae 	bls.w	8031454 <_lite_kernel_nl_softmax_is8os8+0x3cc>
 80312f8:	46e0      	mov	r8, ip
 80312fa:	9a05      	ldr	r2, [sp, #20]
 80312fc:	f91c 3f01 	ldrsb.w	r3, [ip, #1]!
 8031300:	429a      	cmp	r2, r3
 8031302:	f77f aef4 	ble.w	80310ee <_lite_kernel_nl_softmax_is8os8+0x66>
 8031306:	2200      	movs	r2, #0
 8031308:	e7ea      	b.n	80312e0 <_lite_kernel_nl_softmax_is8os8+0x258>
 803130a:	9824      	ldr	r0, [sp, #144]	@ 0x90
 803130c:	fbc3 1200 	smlal	r1, r2, r3, r0
 8031310:	2a00      	cmp	r2, #0
 8031312:	da04      	bge.n	803131e <_lite_kernel_nl_softmax_is8os8+0x296>
 8031314:	f06f 4300 	mvn.w	r3, #2147483648	@ 0x80000000
 8031318:	18c9      	adds	r1, r1, r3
 803131a:	f142 0200 	adc.w	r2, r2, #0
 803131e:	0fc9      	lsrs	r1, r1, #31
 8031320:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8031324:	2600      	movs	r6, #0
 8031326:	ea41 0142 	orr.w	r1, r1, r2, lsl #1
 803132a:	f041 477f 	orr.w	r7, r1, #4278190080	@ 0xff000000
 803132e:	017d      	lsls	r5, r7, #5
 8031330:	1a7f      	subs	r7, r7, r1
 8031332:	f105 5580 	add.w	r5, r5, #268435456	@ 0x10000000
 8031336:	fbc5 3605 	smlal	r3, r6, r5, r5
 803133a:	2e00      	cmp	r6, #0
 803133c:	da05      	bge.n	803134a <_lite_kernel_nl_softmax_is8os8+0x2c2>
 803133e:	f06f 4200 	mvn.w	r2, #2147483648	@ 0x80000000
 8031342:	189a      	adds	r2, r3, r2
 8031344:	4613      	mov	r3, r2
 8031346:	f146 0600 	adc.w	r6, r6, #0
 803134a:	0fdb      	lsrs	r3, r3, #31
 803134c:	ea43 0346 	orr.w	r3, r3, r6, lsl #1
 8031350:	17f6      	asrs	r6, r6, #31
 8031352:	fba3 2003 	umull	r2, r0, r3, r3
 8031356:	fb03 f406 	mul.w	r4, r3, r6
 803135a:	f112 4280 	adds.w	r2, r2, #1073741824	@ 0x40000000
 803135e:	9310      	str	r3, [sp, #64]	@ 0x40
 8031360:	eb40 0044 	adc.w	r0, r0, r4, lsl #1
 8031364:	2800      	cmp	r0, #0
 8031366:	da05      	bge.n	8031374 <_lite_kernel_nl_softmax_is8os8+0x2ec>
 8031368:	f06f 4400 	mvn.w	r4, #2147483648	@ 0x80000000
 803136c:	1914      	adds	r4, r2, r4
 803136e:	4622      	mov	r2, r4
 8031370:	f140 0000 	adc.w	r0, r0, #0
 8031374:	0fd2      	lsrs	r2, r2, #31
 8031376:	fb05 f606 	mul.w	r6, r5, r6
 803137a:	ea83 0e05 	eor.w	lr, r3, r5
 803137e:	fab1 f181 	clz	r1, r1
 8031382:	ea42 0240 	orr.w	r2, r2, r0, lsl #1
 8031386:	f3c7 7940 	ubfx	r9, r7, #29, #1
 803138a:	17e8      	asrs	r0, r5, #31
 803138c:	f3c7 7a80 	ubfx	sl, r7, #30, #1
 8031390:	0949      	lsrs	r1, r1, #5
 8031392:	f3c7 6400 	ubfx	r4, r7, #24, #1
 8031396:	fb03 6600 	mla	r6, r3, r0, r6
 803139a:	f3c7 7000 	ubfx	r0, r7, #28, #1
 803139e:	f3c7 6b80 	ubfx	fp, r7, #26, #1
 80313a2:	ea4f 7ede 	mov.w	lr, lr, lsr #31
 80313a6:	9606      	str	r6, [sp, #24]
 80313a8:	fba5 6303 	umull	r6, r3, r5, r3
 80313ac:	9007      	str	r0, [sp, #28]
 80313ae:	f3c7 6040 	ubfx	r0, r7, #25, #1
 80313b2:	9611      	str	r6, [sp, #68]	@ 0x44
 80313b4:	9e06      	ldr	r6, [sp, #24]
 80313b6:	4433      	add	r3, r6
 80313b8:	424e      	negs	r6, r1
 80313ba:	3901      	subs	r1, #1
 80313bc:	910a      	str	r1, [sp, #40]	@ 0x28
 80313be:	f026 4100 	bic.w	r1, r6, #2147483648	@ 0x80000000
 80313c2:	f347 66c0 	sbfx	r6, r7, #27, #1
 80313c6:	910f      	str	r1, [sp, #60]	@ 0x3c
 80313c8:	f3c7 61c0 	ubfx	r1, r7, #27, #1
 80313cc:	9f07      	ldr	r7, [sp, #28]
 80313ce:	3901      	subs	r1, #1
 80313d0:	960e      	str	r6, [sp, #56]	@ 0x38
 80313d2:	1096      	asrs	r6, r2, #2
 80313d4:	f002 0203 	and.w	r2, r2, #3
 80313d8:	910b      	str	r1, [sp, #44]	@ 0x2c
 80313da:	f107 31ff 	add.w	r1, r7, #4294967295
 80313de:	f1c7 0700 	rsb	r7, r7, #0
 80313e2:	9708      	str	r7, [sp, #32]
 80313e4:	f10a 37ff 	add.w	r7, sl, #4294967295
 80313e8:	970d      	str	r7, [sp, #52]	@ 0x34
 80313ea:	f1ca 0700 	rsb	r7, sl, #0
 80313ee:	f10b 3aff 	add.w	sl, fp, #4294967295
 80313f2:	f1cb 0b00 	rsb	fp, fp, #0
 80313f6:	9706      	str	r7, [sp, #24]
 80313f8:	f109 37ff 	add.w	r7, r9, #4294967295
 80313fc:	970c      	str	r7, [sp, #48]	@ 0x30
 80313fe:	f1c9 0700 	rsb	r7, r9, #0
 8031402:	f100 39ff 	add.w	r9, r0, #4294967295
 8031406:	f1c0 0000 	rsb	r0, r0, #0
 803140a:	9707      	str	r7, [sp, #28]
 803140c:	f104 37ff 	add.w	r7, r4, #4294967295
 8031410:	9009      	str	r0, [sp, #36]	@ 0x24
 8031412:	f1c4 0400 	rsb	r4, r4, #0
 8031416:	bf54      	ite	pl
 8031418:	2001      	movpl	r0, #1
 803141a:	2002      	movmi	r0, #2
 803141c:	e69b      	b.n	8031156 <_lite_kernel_nl_softmax_is8os8+0xce>
 803141e:	bf00      	nop
 8031420:	c0000001 	.word	0xc0000001
 8031424:	01fffff8 	.word	0x01fffff8
 8031428:	0fffffe0 	.word	0x0fffffe0
 803142c:	40000100 	.word	0x40000100
 8031430:	001fffff 	.word	0x001fffff
 8031434:	2aaaaaab 	.word	0x2aaaaaab
 8031438:	70f5a894 	.word	0x70f5a894
 803143c:	63afbe7b 	.word	0x63afbe7b
 8031440:	4da2cbf2 	.word	0x4da2cbf2
 8031444:	2f16ac6c 	.word	0x2f16ac6c
 8031448:	1152aaa4 	.word	0x1152aaa4
 803144c:	02582ab7 	.word	0x02582ab7
 8031450:	000afe11 	.word	0x000afe11
 8031454:	9b04      	ldr	r3, [sp, #16]
 8031456:	2b00      	cmp	r3, #0
 8031458:	f000 81fa 	beq.w	8031850 <_lite_kernel_nl_softmax_is8os8+0x7c8>
 803145c:	fab3 f983 	clz	r9, r3
 8031460:	fa03 f209 	lsl.w	r2, r3, r9
 8031464:	f1c9 0a23 	rsb	sl, r9, #35	@ 0x23
 8031468:	f102 4300 	add.w	r3, r2, #2147483648	@ 0x80000000
 803146c:	17d9      	asrs	r1, r3, #31
 803146e:	f1b1 3fff 	cmp.w	r1, #4294967295
 8031472:	bf08      	it	eq
 8031474:	2a00      	cmpeq	r2, #0
 8031476:	f000 81ef 	beq.w	8031858 <_lite_kernel_nl_softmax_is8os8+0x7d0>
 803147a:	f113 4300 	adds.w	r3, r3, #2147483648	@ 0x80000000
 803147e:	4ac2      	ldr	r2, [pc, #776]	@ (8031788 <_lite_kernel_nl_softmax_is8os8+0x700>)
 8031480:	4dc2      	ldr	r5, [pc, #776]	@ (803178c <_lite_kernel_nl_softmax_is8os8+0x704>)
 8031482:	f141 0100 	adc.w	r1, r1, #0
 8031486:	085b      	lsrs	r3, r3, #1
 8031488:	ea43 73c1 	orr.w	r3, r3, r1, lsl #31
 803148c:	1049      	asrs	r1, r1, #1
 803148e:	4258      	negs	r0, r3
 8031490:	469c      	mov	ip, r3
 8031492:	fb02 0001 	mla	r0, r2, r1, r0
 8031496:	fba3 2402 	umull	r2, r4, r3, r2
 803149a:	1952      	adds	r2, r2, r5
 803149c:	4420      	add	r0, r4
 803149e:	f160 0000 	sbc.w	r0, r0, #0
 80314a2:	2800      	cmp	r0, #0
 80314a4:	da05      	bge.n	80314b2 <_lite_kernel_nl_softmax_is8os8+0x42a>
 80314a6:	f06f 4400 	mvn.w	r4, #2147483648	@ 0x80000000
 80314aa:	1914      	adds	r4, r2, r4
 80314ac:	4622      	mov	r2, r4
 80314ae:	f140 0000 	adc.w	r0, r0, #0
 80314b2:	0fd2      	lsrs	r2, r2, #31
 80314b4:	ea42 0440 	orr.w	r4, r2, r0, lsl #1
 80314b8:	f104 365a 	add.w	r6, r4, #1515870810	@ 0x5a5a5a5a
 80314bc:	17f0      	asrs	r0, r6, #31
 80314be:	fba3 2706 	umull	r2, r7, r3, r6
 80314c2:	4635      	mov	r5, r6
 80314c4:	fb03 fe00 	mul.w	lr, r3, r0
 80314c8:	f112 4280 	adds.w	r2, r2, #1073741824	@ 0x40000000
 80314cc:	fb06 ee01 	mla	lr, r6, r1, lr
 80314d0:	eb4e 0707 	adc.w	r7, lr, r7
 80314d4:	2f00      	cmp	r7, #0
 80314d6:	da06      	bge.n	80314e6 <_lite_kernel_nl_softmax_is8os8+0x45e>
 80314d8:	f06f 4e00 	mvn.w	lr, #2147483648	@ 0x80000000
 80314dc:	eb12 0e0e 	adds.w	lr, r2, lr
 80314e0:	4672      	mov	r2, lr
 80314e2:	f147 0700 	adc.w	r7, r7, #0
 80314e6:	0fd2      	lsrs	r2, r2, #31
 80314e8:	ea42 0247 	orr.w	r2, r2, r7, lsl #1
 80314ec:	4fa7      	ldr	r7, [pc, #668]	@ (803178c <_lite_kernel_nl_softmax_is8os8+0x704>)
 80314ee:	f1c2 5200 	rsb	r2, r2, #536870912	@ 0x20000000
 80314f2:	ea82 0e06 	eor.w	lr, r2, r6
 80314f6:	ea4f 7ede 	mov.w	lr, lr, lsr #31
 80314fa:	f1be 0f00 	cmp.w	lr, #0
 80314fe:	bf06      	itte	eq
 8031500:	f04f 4780 	moveq.w	r7, #1073741824	@ 0x40000000
 8031504:	f04f 0800 	moveq.w	r8, #0
 8031508:	f04f 38ff 	movne.w	r8, #4294967295
 803150c:	fb02 f000 	mul.w	r0, r2, r0
 8031510:	ea4f 7ee2 	mov.w	lr, r2, asr #31
 8031514:	fb05 000e 	mla	r0, r5, lr, r0
 8031518:	fba2 2505 	umull	r2, r5, r2, r5
 803151c:	19d2      	adds	r2, r2, r7
 803151e:	4428      	add	r0, r5
 8031520:	eb40 0508 	adc.w	r5, r0, r8
 8031524:	2d00      	cmp	r5, #0
 8031526:	da05      	bge.n	8031534 <_lite_kernel_nl_softmax_is8os8+0x4ac>
 8031528:	f06f 4000 	mvn.w	r0, #2147483648	@ 0x80000000
 803152c:	1810      	adds	r0, r2, r0
 803152e:	4602      	mov	r2, r0
 8031530:	f145 0500 	adc.w	r5, r5, #0
 8031534:	0fd2      	lsrs	r2, r2, #31
 8031536:	ea42 0245 	orr.w	r2, r2, r5, lsl #1
 803153a:	f1b2 4f60 	cmp.w	r2, #3758096384	@ 0xe0000000
 803153e:	dd7f      	ble.n	8031640 <_lite_kernel_nl_softmax_is8os8+0x5b8>
 8031540:	eb06 0082 	add.w	r0, r6, r2, lsl #2
 8031544:	4e91      	ldr	r6, [pc, #580]	@ (803178c <_lite_kernel_nl_softmax_is8os8+0x704>)
 8031546:	ea80 020c 	eor.w	r2, r0, ip
 803154a:	17c4      	asrs	r4, r0, #31
 803154c:	fb00 f501 	mul.w	r5, r0, r1
 8031550:	0fd2      	lsrs	r2, r2, #31
 8031552:	fb03 5504 	mla	r5, r3, r4, r5
 8031556:	2a00      	cmp	r2, #0
 8031558:	fba0 2e03 	umull	r2, lr, r0, r3
 803155c:	bf06      	itte	eq
 803155e:	f04f 4680 	moveq.w	r6, #1073741824	@ 0x40000000
 8031562:	2700      	moveq	r7, #0
 8031564:	f04f 37ff 	movne.w	r7, #4294967295
 8031568:	4475      	add	r5, lr
 803156a:	1992      	adds	r2, r2, r6
 803156c:	eb45 0507 	adc.w	r5, r5, r7
 8031570:	2d00      	cmp	r5, #0
 8031572:	da05      	bge.n	8031580 <_lite_kernel_nl_softmax_is8os8+0x4f8>
 8031574:	f06f 4600 	mvn.w	r6, #2147483648	@ 0x80000000
 8031578:	1996      	adds	r6, r2, r6
 803157a:	4632      	mov	r2, r6
 803157c:	f145 0500 	adc.w	r5, r5, #0
 8031580:	0fd2      	lsrs	r2, r2, #31
 8031582:	ea42 0245 	orr.w	r2, r2, r5, lsl #1
 8031586:	4d81      	ldr	r5, [pc, #516]	@ (803178c <_lite_kernel_nl_softmax_is8os8+0x704>)
 8031588:	f1c2 5200 	rsb	r2, r2, #536870912	@ 0x20000000
 803158c:	ea80 0602 	eor.w	r6, r0, r2
 8031590:	0ff6      	lsrs	r6, r6, #31
 8031592:	2e00      	cmp	r6, #0
 8031594:	bf06      	itte	eq
 8031596:	f04f 4580 	moveq.w	r5, #1073741824	@ 0x40000000
 803159a:	2600      	moveq	r6, #0
 803159c:	f04f 36ff 	movne.w	r6, #4294967295
 80315a0:	fb02 f404 	mul.w	r4, r2, r4
 80315a4:	17d7      	asrs	r7, r2, #31
 80315a6:	fb00 4407 	mla	r4, r0, r7, r4
 80315aa:	fba2 2700 	umull	r2, r7, r2, r0
 80315ae:	1952      	adds	r2, r2, r5
 80315b0:	443c      	add	r4, r7
 80315b2:	eb44 0406 	adc.w	r4, r4, r6
 80315b6:	2c00      	cmp	r4, #0
 80315b8:	da05      	bge.n	80315c6 <_lite_kernel_nl_softmax_is8os8+0x53e>
 80315ba:	f06f 4500 	mvn.w	r5, #2147483648	@ 0x80000000
 80315be:	1955      	adds	r5, r2, r5
 80315c0:	462a      	mov	r2, r5
 80315c2:	f144 0400 	adc.w	r4, r4, #0
 80315c6:	0fd2      	lsrs	r2, r2, #31
 80315c8:	ea42 0244 	orr.w	r2, r2, r4, lsl #1
 80315cc:	f1b2 5f00 	cmp.w	r2, #536870912	@ 0x20000000
 80315d0:	db65      	blt.n	803169e <_lite_kernel_nl_softmax_is8os8+0x616>
 80315d2:	f06f 4400 	mvn.w	r4, #2147483648	@ 0x80000000
 80315d6:	1902      	adds	r2, r0, r4
 80315d8:	ea92 0f0c 	teq	r2, ip
 80315dc:	f140 8133 	bpl.w	8031846 <_lite_kernel_nl_softmax_is8os8+0x7be>
 80315e0:	4c6a      	ldr	r4, [pc, #424]	@ (803178c <_lite_kernel_nl_softmax_is8os8+0x704>)
 80315e2:	f04f 35ff 	mov.w	r5, #4294967295
 80315e6:	fb02 f101 	mul.w	r1, r2, r1
 80315ea:	17d0      	asrs	r0, r2, #31
 80315ec:	fb03 1100 	mla	r1, r3, r0, r1
 80315f0:	fba2 3603 	umull	r3, r6, r2, r3
 80315f4:	191b      	adds	r3, r3, r4
 80315f6:	4431      	add	r1, r6
 80315f8:	eb41 0105 	adc.w	r1, r1, r5
 80315fc:	2900      	cmp	r1, #0
 80315fe:	da05      	bge.n	803160c <_lite_kernel_nl_softmax_is8os8+0x584>
 8031600:	f06f 4400 	mvn.w	r4, #2147483648	@ 0x80000000
 8031604:	191c      	adds	r4, r3, r4
 8031606:	4623      	mov	r3, r4
 8031608:	f141 0100 	adc.w	r1, r1, #0
 803160c:	0fdb      	lsrs	r3, r3, #31
 803160e:	ea43 0341 	orr.w	r3, r3, r1, lsl #1
 8031612:	495e      	ldr	r1, [pc, #376]	@ (803178c <_lite_kernel_nl_softmax_is8os8+0x704>)
 8031614:	f1c3 5300 	rsb	r3, r3, #536870912	@ 0x20000000
 8031618:	ea83 0402 	eor.w	r4, r3, r2
 803161c:	0fe4      	lsrs	r4, r4, #31
 803161e:	2c00      	cmp	r4, #0
 8031620:	bf06      	itte	eq
 8031622:	f04f 4180 	moveq.w	r1, #1073741824	@ 0x40000000
 8031626:	2400      	moveq	r4, #0
 8031628:	f04f 34ff 	movne.w	r4, #4294967295
 803162c:	4293      	cmp	r3, r2
 803162e:	d15d      	bne.n	80316ec <_lite_kernel_nl_softmax_is8os8+0x664>
 8031630:	f1b2 4f00 	cmp.w	r2, #2147483648	@ 0x80000000
 8031634:	d15a      	bne.n	80316ec <_lite_kernel_nl_softmax_is8os8+0x664>
 8031636:	f06f 4100 	mvn.w	r1, #2147483648	@ 0x80000000
 803163a:	4411      	add	r1, r2
 803163c:	0049      	lsls	r1, r1, #1
 803163e:	e076      	b.n	803172e <_lite_kernel_nl_softmax_is8os8+0x6a6>
 8031640:	4853      	ldr	r0, [pc, #332]	@ (8031790 <_lite_kernel_nl_softmax_is8os8+0x708>)
 8031642:	4420      	add	r0, r4
 8031644:	ea90 0f0c 	teq	r0, ip
 8031648:	f140 8114 	bpl.w	8031874 <_lite_kernel_nl_softmax_is8os8+0x7ec>
 803164c:	17c2      	asrs	r2, r0, #31
 803164e:	fb00 f401 	mul.w	r4, r0, r1
 8031652:	4d4e      	ldr	r5, [pc, #312]	@ (803178c <_lite_kernel_nl_softmax_is8os8+0x704>)
 8031654:	fb03 4402 	mla	r4, r3, r2, r4
 8031658:	fba0 2603 	umull	r2, r6, r0, r3
 803165c:	1952      	adds	r2, r2, r5
 803165e:	4434      	add	r4, r6
 8031660:	f164 0500 	sbc.w	r5, r4, #0
 8031664:	2d00      	cmp	r5, #0
 8031666:	da05      	bge.n	8031674 <_lite_kernel_nl_softmax_is8os8+0x5ec>
 8031668:	f06f 4400 	mvn.w	r4, #2147483648	@ 0x80000000
 803166c:	1914      	adds	r4, r2, r4
 803166e:	4622      	mov	r2, r4
 8031670:	f145 0500 	adc.w	r5, r5, #0
 8031674:	0fd2      	lsrs	r2, r2, #31
 8031676:	ea42 0245 	orr.w	r2, r2, r5, lsl #1
 803167a:	f04f 35ff 	mov.w	r5, #4294967295
 803167e:	f1c2 5400 	rsb	r4, r2, #536870912	@ 0x20000000
 8031682:	4a42      	ldr	r2, [pc, #264]	@ (803178c <_lite_kernel_nl_softmax_is8os8+0x704>)
 8031684:	fbc0 2504 	smlal	r2, r5, r0, r4
 8031688:	2d00      	cmp	r5, #0
 803168a:	da05      	bge.n	8031698 <_lite_kernel_nl_softmax_is8os8+0x610>
 803168c:	f06f 4400 	mvn.w	r4, #2147483648	@ 0x80000000
 8031690:	1914      	adds	r4, r2, r4
 8031692:	4622      	mov	r2, r4
 8031694:	f145 0500 	adc.w	r5, r5, #0
 8031698:	0fd2      	lsrs	r2, r2, #31
 803169a:	ea42 0245 	orr.w	r2, r2, r5, lsl #1
 803169e:	f1b2 4f60 	cmp.w	r2, #3758096384	@ 0xe0000000
 80316a2:	ea4f 0482 	mov.w	r4, r2, lsl #2
 80316a6:	dc96      	bgt.n	80315d6 <_lite_kernel_nl_softmax_is8os8+0x54e>
 80316a8:	f100 4200 	add.w	r2, r0, #2147483648	@ 0x80000000
 80316ac:	ea92 0f0c 	teq	r2, ip
 80316b0:	f140 80c9 	bpl.w	8031846 <_lite_kernel_nl_softmax_is8os8+0x7be>
 80316b4:	17d0      	asrs	r0, r2, #31
 80316b6:	4c35      	ldr	r4, [pc, #212]	@ (803178c <_lite_kernel_nl_softmax_is8os8+0x704>)
 80316b8:	fb03 f500 	mul.w	r5, r3, r0
 80316bc:	fb02 5101 	mla	r1, r2, r1, r5
 80316c0:	fba3 3502 	umull	r3, r5, r3, r2
 80316c4:	191b      	adds	r3, r3, r4
 80316c6:	4429      	add	r1, r5
 80316c8:	f161 0100 	sbc.w	r1, r1, #0
 80316cc:	2900      	cmp	r1, #0
 80316ce:	da05      	bge.n	80316dc <_lite_kernel_nl_softmax_is8os8+0x654>
 80316d0:	f06f 4400 	mvn.w	r4, #2147483648	@ 0x80000000
 80316d4:	191c      	adds	r4, r3, r4
 80316d6:	4623      	mov	r3, r4
 80316d8:	f141 0100 	adc.w	r1, r1, #0
 80316dc:	0fdb      	lsrs	r3, r3, #31
 80316de:	f04f 34ff 	mov.w	r4, #4294967295
 80316e2:	ea43 0341 	orr.w	r3, r3, r1, lsl #1
 80316e6:	4929      	ldr	r1, [pc, #164]	@ (803178c <_lite_kernel_nl_softmax_is8os8+0x704>)
 80316e8:	f1c3 5300 	rsb	r3, r3, #536870912	@ 0x20000000
 80316ec:	fb03 f000 	mul.w	r0, r3, r0
 80316f0:	17dd      	asrs	r5, r3, #31
 80316f2:	fb02 0005 	mla	r0, r2, r5, r0
 80316f6:	fba3 3502 	umull	r3, r5, r3, r2
 80316fa:	185b      	adds	r3, r3, r1
 80316fc:	4428      	add	r0, r5
 80316fe:	eb40 0004 	adc.w	r0, r0, r4
 8031702:	2800      	cmp	r0, #0
 8031704:	da05      	bge.n	8031712 <_lite_kernel_nl_softmax_is8os8+0x68a>
 8031706:	f06f 4100 	mvn.w	r1, #2147483648	@ 0x80000000
 803170a:	1859      	adds	r1, r3, r1
 803170c:	460b      	mov	r3, r1
 803170e:	f140 0000 	adc.w	r0, r0, #0
 8031712:	0fdb      	lsrs	r3, r3, #31
 8031714:	ea43 0340 	orr.w	r3, r3, r0, lsl #1
 8031718:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 803171c:	f2c0 8087 	blt.w	803182e <_lite_kernel_nl_softmax_is8os8+0x7a6>
 8031720:	f06f 4300 	mvn.w	r3, #2147483648	@ 0x80000000
 8031724:	18d1      	adds	r1, r2, r3
 8031726:	f1b1 4f80 	cmp.w	r1, #1073741824	@ 0x40000000
 803172a:	db87      	blt.n	803163c <_lite_kernel_nl_softmax_is8os8+0x5b4>
 803172c:	4619      	mov	r1, r3
 803172e:	f1ba 0f1f 	cmp.w	sl, #31
 8031732:	dd04      	ble.n	803173e <_lite_kernel_nl_softmax_is8os8+0x6b6>
 8031734:	f1c9 0304 	rsb	r3, r9, #4
 8031738:	f04f 0a1f 	mov.w	sl, #31
 803173c:	4119      	asrs	r1, r3
 803173e:	9b03      	ldr	r3, [sp, #12]
 8031740:	2b00      	cmp	r3, #0
 8031742:	d05c      	beq.n	80317fe <_lite_kernel_nl_softmax_is8os8+0x776>
 8031744:	2501      	movs	r5, #1
 8031746:	f06f 4700 	mvn.w	r7, #2147483648	@ 0x80000000
 803174a:	f1a1 4e00 	sub.w	lr, r1, #2147483648	@ 0x80000000
 803174e:	9815      	ldr	r0, [sp, #84]	@ 0x54
 8031750:	fa05 f50a 	lsl.w	r5, r5, sl
 8031754:	fa47 f90a 	asr.w	r9, r7, sl
 8031758:	fabe fe8e 	clz	lr, lr
 803175c:	4e0b      	ldr	r6, [pc, #44]	@ (803178c <_lite_kernel_nl_softmax_is8os8+0x704>)
 803175e:	3d01      	subs	r5, #1
 8031760:	f8cd 9010 	str.w	r9, [sp, #16]
 8031764:	ea4f 1e5e 	mov.w	lr, lr, lsr #5
 8031768:	f8dd 905c 	ldr.w	r9, [sp, #92]	@ 0x5c
 803176c:	ea05 0307 	and.w	r3, r5, r7
 8031770:	ea4f 0c65 	mov.w	ip, r5, asr #1
 8031774:	9301      	str	r3, [sp, #4]
 8031776:	f10c 0801 	add.w	r8, ip, #1
 803177a:	9b13      	ldr	r3, [sp, #76]	@ 0x4c
 803177c:	1e5c      	subs	r4, r3, #1
 803177e:	4673      	mov	r3, lr
 8031780:	46ae      	mov	lr, r5
 8031782:	461d      	mov	r5, r3
 8031784:	e013      	b.n	80317ae <_lite_kernel_nl_softmax_is8os8+0x726>
 8031786:	bf00      	nop
 8031788:	c3c3c3c4 	.word	0xc3c3c3c4
 803178c:	c0000001 	.word	0xc0000001
 8031790:	da5a5a5a 	.word	0xda5a5a5a
 8031794:	b1dd      	cbz	r5, 80317ce <_lite_kernel_nl_softmax_is8os8+0x746>
 8031796:	9b04      	ldr	r3, [sp, #16]
 8031798:	9a01      	ldr	r2, [sp, #4]
 803179a:	4594      	cmp	ip, r2
 803179c:	da00      	bge.n	80317a0 <_lite_kernel_nl_softmax_is8os8+0x718>
 803179e:	3301      	adds	r3, #1
 80317a0:	2bfe      	cmp	r3, #254	@ 0xfe
 80317a2:	dd3f      	ble.n	8031824 <_lite_kernel_nl_softmax_is8os8+0x79c>
 80317a4:	237f      	movs	r3, #127	@ 0x7f
 80317a6:	4581      	cmp	r9, r0
 80317a8:	f804 3f01 	strb.w	r3, [r4, #1]!
 80317ac:	d027      	beq.n	80317fe <_lite_kernel_nl_softmax_is8os8+0x776>
 80317ae:	f850 2f04 	ldr.w	r2, [r0, #4]!
 80317b2:	ea81 0302 	eor.w	r3, r1, r2
 80317b6:	0fdb      	lsrs	r3, r3, #31
 80317b8:	2b00      	cmp	r3, #0
 80317ba:	bf0b      	itete	eq
 80317bc:	f04f 4380 	moveq.w	r3, #1073741824	@ 0x40000000
 80317c0:	4633      	movne	r3, r6
 80317c2:	f04f 0b00 	moveq.w	fp, #0
 80317c6:	f04f 3bff 	movne.w	fp, #4294967295
 80317ca:	4291      	cmp	r1, r2
 80317cc:	d0e2      	beq.n	8031794 <_lite_kernel_nl_softmax_is8os8+0x70c>
 80317ce:	fbc2 3b01 	smlal	r3, fp, r2, r1
 80317d2:	f1bb 0f00 	cmp.w	fp, #0
 80317d6:	da02      	bge.n	80317de <_lite_kernel_nl_softmax_is8os8+0x756>
 80317d8:	19db      	adds	r3, r3, r7
 80317da:	f14b 0b00 	adc.w	fp, fp, #0
 80317de:	0fdb      	lsrs	r3, r3, #31
 80317e0:	ea43 034b 	orr.w	r3, r3, fp, lsl #1
 80317e4:	ea0e 0203 	and.w	r2, lr, r3
 80317e8:	fa53 f30a 	asrs.w	r3, r3, sl
 80317ec:	d5d5      	bpl.n	803179a <_lite_kernel_nl_softmax_is8os8+0x712>
 80317ee:	4590      	cmp	r8, r2
 80317f0:	dbd5      	blt.n	803179e <_lite_kernel_nl_softmax_is8os8+0x716>
 80317f2:	f06f 037f 	mvn.w	r3, #127	@ 0x7f
 80317f6:	4581      	cmp	r9, r0
 80317f8:	f804 3f01 	strb.w	r3, [r4, #1]!
 80317fc:	d1d7      	bne.n	80317ae <_lite_kernel_nl_softmax_is8os8+0x726>
 80317fe:	9b02      	ldr	r3, [sp, #8]
 8031800:	9a22      	ldr	r2, [sp, #136]	@ 0x88
 8031802:	9923      	ldr	r1, [sp, #140]	@ 0x8c
 8031804:	4413      	add	r3, r2
 8031806:	9a13      	ldr	r2, [sp, #76]	@ 0x4c
 8031808:	440a      	add	r2, r1
 803180a:	9922      	ldr	r1, [sp, #136]	@ 0x88
 803180c:	9302      	str	r3, [sp, #8]
 803180e:	9213      	str	r2, [sp, #76]	@ 0x4c
 8031810:	9a14      	ldr	r2, [sp, #80]	@ 0x50
 8031812:	440a      	add	r2, r1
 8031814:	9214      	str	r2, [sp, #80]	@ 0x50
 8031816:	9a16      	ldr	r2, [sp, #88]	@ 0x58
 8031818:	429a      	cmp	r2, r3
 803181a:	f63f ac4b 	bhi.w	80310b4 <_lite_kernel_nl_softmax_is8os8+0x2c>
 803181e:	b019      	add	sp, #100	@ 0x64
 8031820:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8031824:	2b00      	cmp	r3, #0
 8031826:	dde4      	ble.n	80317f2 <_lite_kernel_nl_softmax_is8os8+0x76a>
 8031828:	3b80      	subs	r3, #128	@ 0x80
 803182a:	b25b      	sxtb	r3, r3
 803182c:	e7bb      	b.n	80317a6 <_lite_kernel_nl_softmax_is8os8+0x71e>
 803182e:	f1b3 4f60 	cmp.w	r3, #3758096384	@ 0xe0000000
 8031832:	dc3b      	bgt.n	80318ac <_lite_kernel_nl_softmax_is8os8+0x824>
 8031834:	f102 4300 	add.w	r3, r2, #2147483648	@ 0x80000000
 8031838:	0051      	lsls	r1, r2, #1
 803183a:	f1b3 4f40 	cmp.w	r3, #3221225472	@ 0xc0000000
 803183e:	bfd8      	it	le
 8031840:	f04f 4100 	movle.w	r1, #2147483648	@ 0x80000000
 8031844:	e773      	b.n	803172e <_lite_kernel_nl_softmax_is8os8+0x6a6>
 8031846:	f04f 4480 	mov.w	r4, #1073741824	@ 0x40000000
 803184a:	2500      	movs	r5, #0
 803184c:	e6cb      	b.n	80315e6 <_lite_kernel_nl_softmax_is8os8+0x55e>
 803184e:	bbb9      	cbnz	r1, 80318c0 <_lite_kernel_nl_softmax_is8os8+0x838>
 8031850:	f04f 0a03 	mov.w	sl, #3
 8031854:	f04f 0920 	mov.w	r9, #32
 8031858:	2000      	movs	r0, #0
 803185a:	f04f 33ff 	mov.w	r3, #4294967295
 803185e:	f04f 355a 	mov.w	r5, #1515870810	@ 0x5a5a5a5a
 8031862:	4a1a      	ldr	r2, [pc, #104]	@ (80318cc <_lite_kernel_nl_softmax_is8os8+0x844>)
 8031864:	4604      	mov	r4, r0
 8031866:	4619      	mov	r1, r3
 8031868:	462e      	mov	r6, r5
 803186a:	469c      	mov	ip, r3
 803186c:	f04f 4780 	mov.w	r7, #1073741824	@ 0x40000000
 8031870:	4680      	mov	r8, r0
 8031872:	e64b      	b.n	803150c <_lite_kernel_nl_softmax_is8os8+0x484>
 8031874:	fba0 2503 	umull	r2, r5, r0, r3
 8031878:	17c4      	asrs	r4, r0, #31
 803187a:	fb00 f601 	mul.w	r6, r0, r1
 803187e:	f112 4280 	adds.w	r2, r2, #1073741824	@ 0x40000000
 8031882:	fb03 6604 	mla	r6, r3, r4, r6
 8031886:	eb46 0505 	adc.w	r5, r6, r5
 803188a:	2d00      	cmp	r5, #0
 803188c:	da05      	bge.n	803189a <_lite_kernel_nl_softmax_is8os8+0x812>
 803188e:	f06f 4600 	mvn.w	r6, #2147483648	@ 0x80000000
 8031892:	1996      	adds	r6, r2, r6
 8031894:	4632      	mov	r2, r6
 8031896:	f145 0500 	adc.w	r5, r5, #0
 803189a:	0fd2      	lsrs	r2, r2, #31
 803189c:	f04f 36ff 	mov.w	r6, #4294967295
 80318a0:	ea42 0245 	orr.w	r2, r2, r5, lsl #1
 80318a4:	4d0a      	ldr	r5, [pc, #40]	@ (80318d0 <_lite_kernel_nl_softmax_is8os8+0x848>)
 80318a6:	f1c2 5200 	rsb	r2, r2, #536870912	@ 0x20000000
 80318aa:	e679      	b.n	80315a0 <_lite_kernel_nl_softmax_is8os8+0x518>
 80318ac:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 80318b0:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 80318b4:	db02      	blt.n	80318bc <_lite_kernel_nl_softmax_is8os8+0x834>
 80318b6:	f06f 4100 	mvn.w	r1, #2147483648	@ 0x80000000
 80318ba:	e738      	b.n	803172e <_lite_kernel_nl_softmax_is8os8+0x6a6>
 80318bc:	0059      	lsls	r1, r3, #1
 80318be:	e7bc      	b.n	803183a <_lite_kernel_nl_softmax_is8os8+0x7b2>
 80318c0:	9b26      	ldr	r3, [sp, #152]	@ 0x98
 80318c2:	9a12      	ldr	r2, [sp, #72]	@ 0x48
 80318c4:	4413      	add	r3, r2
 80318c6:	9305      	str	r3, [sp, #20]
 80318c8:	e408      	b.n	80310dc <_lite_kernel_nl_softmax_is8os8+0x54>
 80318ca:	bf00      	nop
 80318cc:	20000001 	.word	0x20000001
 80318d0:	c0000001 	.word	0xc0000001

080318d4 <_lite_kernel_nl_softmax_iu8ou8>:
 80318d4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80318d8:	b099      	sub	sp, #100	@ 0x64
 80318da:	9013      	str	r0, [sp, #76]	@ 0x4c
 80318dc:	1888      	adds	r0, r1, r2
 80318de:	9102      	str	r1, [sp, #8]
 80318e0:	4281      	cmp	r1, r0
 80318e2:	9303      	str	r3, [sp, #12]
 80318e4:	9016      	str	r0, [sp, #88]	@ 0x58
 80318e6:	f080 83bd 	bcs.w	8032064 <_lite_kernel_nl_softmax_iu8ou8+0x790>
 80318ea:	460a      	mov	r2, r1
 80318ec:	4619      	mov	r1, r3
 80318ee:	3b01      	subs	r3, #1
 80318f0:	18d3      	adds	r3, r2, r3
 80318f2:	9314      	str	r3, [sp, #80]	@ 0x50
 80318f4:	9b27      	ldr	r3, [sp, #156]	@ 0x9c
 80318f6:	3b04      	subs	r3, #4
 80318f8:	9315      	str	r3, [sp, #84]	@ 0x54
 80318fa:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 80318fe:	9317      	str	r3, [sp, #92]	@ 0x5c
 8031900:	9b02      	ldr	r3, [sp, #8]
 8031902:	9903      	ldr	r1, [sp, #12]
 8031904:	781a      	ldrb	r2, [r3, #0]
 8031906:	2901      	cmp	r1, #1
 8031908:	9212      	str	r2, [sp, #72]	@ 0x48
 803190a:	f240 83c2 	bls.w	8032092 <_lite_kernel_nl_softmax_iu8ou8+0x7be>
 803190e:	9814      	ldr	r0, [sp, #80]	@ 0x50
 8031910:	f813 1f01 	ldrb.w	r1, [r3, #1]!
 8031914:	428a      	cmp	r2, r1
 8031916:	bfb8      	it	lt
 8031918:	460a      	movlt	r2, r1
 803191a:	4283      	cmp	r3, r0
 803191c:	d1f8      	bne.n	8031910 <_lite_kernel_nl_softmax_iu8ou8+0x3c>
 803191e:	9b26      	ldr	r3, [sp, #152]	@ 0x98
 8031920:	9212      	str	r2, [sp, #72]	@ 0x48
 8031922:	4413      	add	r3, r2
 8031924:	9305      	str	r3, [sp, #20]
 8031926:	9b02      	ldr	r3, [sp, #8]
 8031928:	f103 3bff 	add.w	fp, r3, #4294967295
 803192c:	9b15      	ldr	r3, [sp, #84]	@ 0x54
 803192e:	9301      	str	r3, [sp, #4]
 8031930:	2300      	movs	r3, #0
 8031932:	46dc      	mov	ip, fp
 8031934:	9304      	str	r3, [sp, #16]
 8031936:	e104      	b.n	8031b42 <_lite_kernel_nl_softmax_iu8ou8+0x26e>
 8031938:	9a12      	ldr	r2, [sp, #72]	@ 0x48
 803193a:	1a9b      	subs	r3, r3, r2
 803193c:	9a25      	ldr	r2, [sp, #148]	@ 0x94
 803193e:	4093      	lsls	r3, r2
 8031940:	9a24      	ldr	r2, [sp, #144]	@ 0x90
 8031942:	405a      	eors	r2, r3
 8031944:	0fd2      	lsrs	r2, r2, #31
 8031946:	2a00      	cmp	r2, #0
 8031948:	4ac7      	ldr	r2, [pc, #796]	@ (8031c68 <_lite_kernel_nl_softmax_iu8ou8+0x394>)
 803194a:	bf0b      	itete	eq
 803194c:	f04f 4180 	moveq.w	r1, #1073741824	@ 0x40000000
 8031950:	4611      	movne	r1, r2
 8031952:	2200      	moveq	r2, #0
 8031954:	f04f 32ff 	movne.w	r2, #4294967295
 8031958:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 803195c:	f040 80fa 	bne.w	8031b54 <_lite_kernel_nl_softmax_iu8ou8+0x280>
 8031960:	9824      	ldr	r0, [sp, #144]	@ 0x90
 8031962:	4298      	cmp	r0, r3
 8031964:	f040 80f6 	bne.w	8031b54 <_lite_kernel_nl_softmax_iu8ou8+0x280>
 8031968:	4bc0      	ldr	r3, [pc, #768]	@ (8031c6c <_lite_kernel_nl_softmax_iu8ou8+0x398>)
 803196a:	2200      	movs	r2, #0
 803196c:	f04f 31ff 	mov.w	r1, #4294967295
 8031970:	4dbf      	ldr	r5, [pc, #764]	@ (8031c70 <_lite_kernel_nl_softmax_iu8ou8+0x39c>)
 8031972:	9310      	str	r3, [sp, #64]	@ 0x40
 8031974:	f44f 3600 	mov.w	r6, #131072	@ 0x20000
 8031978:	4bbe      	ldr	r3, [pc, #760]	@ (8031c74 <_lite_kernel_nl_softmax_iu8ou8+0x3a0>)
 803197a:	4696      	mov	lr, r2
 803197c:	460f      	mov	r7, r1
 803197e:	4689      	mov	r9, r1
 8031980:	9311      	str	r3, [sp, #68]	@ 0x44
 8031982:	468a      	mov	sl, r1
 8031984:	4bbc      	ldr	r3, [pc, #752]	@ (8031c78 <_lite_kernel_nl_softmax_iu8ou8+0x3a4>)
 8031986:	4614      	mov	r4, r2
 8031988:	4693      	mov	fp, r2
 803198a:	2001      	movs	r0, #1
 803198c:	e9cd 220e 	strd	r2, r2, [sp, #56]	@ 0x38
 8031990:	e9cd 110c 	strd	r1, r1, [sp, #48]	@ 0x30
 8031994:	e9cd 110a 	strd	r1, r1, [sp, #40]	@ 0x28
 8031998:	e9cd 2208 	strd	r2, r2, [sp, #32]
 803199c:	e9cd 2206 	strd	r2, r2, [sp, #24]
 80319a0:	4282      	cmp	r2, r0
 80319a2:	4ab1      	ldr	r2, [pc, #708]	@ (8031c68 <_lite_kernel_nl_softmax_iu8ou8+0x394>)
 80319a4:	9811      	ldr	r0, [sp, #68]	@ 0x44
 80319a6:	bfc8      	it	gt
 80319a8:	3601      	addgt	r6, #1
 80319aa:	f1be 0f00 	cmp.w	lr, #0
 80319ae:	bf06      	itte	eq
 80319b0:	f04f 4280 	moveq.w	r2, #1073741824	@ 0x40000000
 80319b4:	f04f 0e00 	moveq.w	lr, #0
 80319b8:	f04f 3eff 	movne.w	lr, #4294967295
 80319bc:	1882      	adds	r2, r0, r2
 80319be:	eb43 0e0e 	adc.w	lr, r3, lr
 80319c2:	f1be 0f00 	cmp.w	lr, #0
 80319c6:	da05      	bge.n	80319d4 <_lite_kernel_nl_softmax_iu8ou8+0x100>
 80319c8:	f06f 4300 	mvn.w	r3, #2147483648	@ 0x80000000
 80319cc:	18d3      	adds	r3, r2, r3
 80319ce:	461a      	mov	r2, r3
 80319d0:	f14e 0e00 	adc.w	lr, lr, #0
 80319d4:	0fd2      	lsrs	r2, r2, #31
 80319d6:	48a9      	ldr	r0, [pc, #676]	@ (8031c7c <_lite_kernel_nl_softmax_iu8ou8+0x3a8>)
 80319d8:	ea42 024e 	orr.w	r2, r2, lr, lsl #1
 80319dc:	4432      	add	r2, r6
 80319de:	0fd3      	lsrs	r3, r2, #31
 80319e0:	2b00      	cmp	r3, #0
 80319e2:	4ba1      	ldr	r3, [pc, #644]	@ (8031c68 <_lite_kernel_nl_softmax_iu8ou8+0x394>)
 80319e4:	bf06      	itte	eq
 80319e6:	2600      	moveq	r6, #0
 80319e8:	f04f 4380 	moveq.w	r3, #1073741824	@ 0x40000000
 80319ec:	f04f 36ff 	movne.w	r6, #4294967295
 80319f0:	fbc2 3600 	smlal	r3, r6, r2, r0
 80319f4:	2e00      	cmp	r6, #0
 80319f6:	da05      	bge.n	8031a04 <_lite_kernel_nl_softmax_iu8ou8+0x130>
 80319f8:	f06f 4200 	mvn.w	r2, #2147483648	@ 0x80000000
 80319fc:	189a      	adds	r2, r3, r2
 80319fe:	4613      	mov	r3, r2
 8031a00:	f146 0600 	adc.w	r6, r6, #0
 8031a04:	0fdb      	lsrs	r3, r3, #31
 8031a06:	9a10      	ldr	r2, [sp, #64]	@ 0x40
 8031a08:	ea43 0346 	orr.w	r3, r3, r6, lsl #1
 8031a0c:	441a      	add	r2, r3
 8031a0e:	07d0      	lsls	r0, r2, #31
 8031a10:	ea4f 0362 	mov.w	r3, r2, asr #1
 8031a14:	d502      	bpl.n	8031a1c <_lite_kernel_nl_softmax_iu8ou8+0x148>
 8031a16:	2b00      	cmp	r3, #0
 8031a18:	bfa8      	it	ge
 8031a1a:	3301      	addge	r3, #1
 8031a1c:	442b      	add	r3, r5
 8031a1e:	4898      	ldr	r0, [pc, #608]	@ (8031c80 <_lite_kernel_nl_softmax_iu8ou8+0x3ac>)
 8031a20:	0fda      	lsrs	r2, r3, #31
 8031a22:	2a00      	cmp	r2, #0
 8031a24:	4a90      	ldr	r2, [pc, #576]	@ (8031c68 <_lite_kernel_nl_softmax_iu8ou8+0x394>)
 8031a26:	bf06      	itte	eq
 8031a28:	2500      	moveq	r5, #0
 8031a2a:	f04f 4280 	moveq.w	r2, #1073741824	@ 0x40000000
 8031a2e:	f04f 35ff 	movne.w	r5, #4294967295
 8031a32:	fbc3 2500 	smlal	r2, r5, r3, r0
 8031a36:	2d00      	cmp	r5, #0
 8031a38:	da05      	bge.n	8031a46 <_lite_kernel_nl_softmax_iu8ou8+0x172>
 8031a3a:	f06f 4300 	mvn.w	r3, #2147483648	@ 0x80000000
 8031a3e:	18d3      	adds	r3, r2, r3
 8031a40:	461a      	mov	r2, r3
 8031a42:	f145 0500 	adc.w	r5, r5, #0
 8031a46:	0fd2      	lsrs	r2, r2, #31
 8031a48:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8031a4c:	488d      	ldr	r0, [pc, #564]	@ (8031c84 <_lite_kernel_nl_softmax_iu8ou8+0x3b0>)
 8031a4e:	ea42 0245 	orr.w	r2, r2, r5, lsl #1
 8031a52:	2500      	movs	r5, #0
 8031a54:	461e      	mov	r6, r3
 8031a56:	f102 42e2 	add.w	r2, r2, #1895825408	@ 0x71000000
 8031a5a:	46ae      	mov	lr, r5
 8031a5c:	f5a2 2225 	sub.w	r2, r2, #675840	@ 0xa5000
 8031a60:	f2a2 726c 	subw	r2, r2, #1900	@ 0x76c
 8031a64:	fbc2 6e00 	smlal	r6, lr, r2, r0
 8031a68:	0ff6      	lsrs	r6, r6, #31
 8031a6a:	4017      	ands	r7, r2
 8031a6c:	4886      	ldr	r0, [pc, #536]	@ (8031c88 <_lite_kernel_nl_softmax_iu8ou8+0x3b4>)
 8031a6e:	ea46 064e 	orr.w	r6, r6, lr, lsl #1
 8031a72:	461a      	mov	r2, r3
 8031a74:	4034      	ands	r4, r6
 8031a76:	462e      	mov	r6, r5
 8031a78:	407c      	eors	r4, r7
 8031a7a:	fbc4 2600 	smlal	r2, r6, r4, r0
 8031a7e:	0fd2      	lsrs	r2, r2, #31
 8031a80:	9809      	ldr	r0, [sp, #36]	@ 0x24
 8031a82:	ea09 0904 	and.w	r9, r9, r4
 8031a86:	ea42 0246 	orr.w	r2, r2, r6, lsl #1
 8031a8a:	462c      	mov	r4, r5
 8031a8c:	4e7f      	ldr	r6, [pc, #508]	@ (8031c8c <_lite_kernel_nl_softmax_iu8ou8+0x3b8>)
 8031a8e:	4010      	ands	r0, r2
 8031a90:	461a      	mov	r2, r3
 8031a92:	ea89 0000 	eor.w	r0, r9, r0
 8031a96:	fbc0 2406 	smlal	r2, r4, r0, r6
 8031a9a:	0fd2      	lsrs	r2, r2, #31
 8031a9c:	ea0a 0a00 	and.w	sl, sl, r0
 8031aa0:	4e7b      	ldr	r6, [pc, #492]	@ (8031c90 <_lite_kernel_nl_softmax_iu8ou8+0x3bc>)
 8031aa2:	ea42 0244 	orr.w	r2, r2, r4, lsl #1
 8031aa6:	462c      	mov	r4, r5
 8031aa8:	ea0b 0b02 	and.w	fp, fp, r2
 8031aac:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
 8031aae:	ea8a 0b0b 	eor.w	fp, sl, fp
 8031ab2:	ea02 000b 	and.w	r0, r2, fp
 8031ab6:	461a      	mov	r2, r3
 8031ab8:	fbcb 2406 	smlal	r2, r4, fp, r6
 8031abc:	0fd2      	lsrs	r2, r2, #31
 8031abe:	4e75      	ldr	r6, [pc, #468]	@ (8031c94 <_lite_kernel_nl_softmax_iu8ou8+0x3c0>)
 8031ac0:	ea42 0244 	orr.w	r2, r2, r4, lsl #1
 8031ac4:	9c0e      	ldr	r4, [sp, #56]	@ 0x38
 8031ac6:	4014      	ands	r4, r2
 8031ac8:	4622      	mov	r2, r4
 8031aca:	462c      	mov	r4, r5
 8031acc:	4042      	eors	r2, r0
 8031ace:	4618      	mov	r0, r3
 8031ad0:	fbc2 0406 	smlal	r0, r4, r2, r6
 8031ad4:	0fc0      	lsrs	r0, r0, #31
 8031ad6:	4011      	ands	r1, r2
 8031ad8:	9a08      	ldr	r2, [sp, #32]
 8031ada:	ea40 0044 	orr.w	r0, r0, r4, lsl #1
 8031ade:	4e6e      	ldr	r6, [pc, #440]	@ (8031c98 <_lite_kernel_nl_softmax_iu8ou8+0x3c4>)
 8031ae0:	462c      	mov	r4, r5
 8031ae2:	4002      	ands	r2, r0
 8031ae4:	980c      	ldr	r0, [sp, #48]	@ 0x30
 8031ae6:	404a      	eors	r2, r1
 8031ae8:	4619      	mov	r1, r3
 8031aea:	fbc2 1406 	smlal	r1, r4, r2, r6
 8031aee:	0fc9      	lsrs	r1, r1, #31
 8031af0:	4010      	ands	r0, r2
 8031af2:	9a07      	ldr	r2, [sp, #28]
 8031af4:	ea41 0144 	orr.w	r1, r1, r4, lsl #1
 8031af8:	400a      	ands	r2, r1
 8031afa:	21f2      	movs	r1, #242	@ 0xf2
 8031afc:	4042      	eors	r2, r0
 8031afe:	fbc2 3501 	smlal	r3, r5, r2, r1
 8031b02:	990d      	ldr	r1, [sp, #52]	@ 0x34
 8031b04:	0fdb      	lsrs	r3, r3, #31
 8031b06:	4011      	ands	r1, r2
 8031b08:	ea43 0345 	orr.w	r3, r3, r5, lsl #1
 8031b0c:	460a      	mov	r2, r1
 8031b0e:	9906      	ldr	r1, [sp, #24]
 8031b10:	4019      	ands	r1, r3
 8031b12:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8031b14:	404a      	eors	r2, r1
 8031b16:	401a      	ands	r2, r3
 8031b18:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 8031b1a:	405a      	eors	r2, r3
 8031b1c:	1313      	asrs	r3, r2, #12
 8031b1e:	0511      	lsls	r1, r2, #20
 8031b20:	9904      	ldr	r1, [sp, #16]
 8031b22:	bf48      	it	mi
 8031b24:	3301      	addmi	r3, #1
 8031b26:	4419      	add	r1, r3
 8031b28:	9104      	str	r1, [sp, #16]
 8031b2a:	9b01      	ldr	r3, [sp, #4]
 8031b2c:	f843 2f04 	str.w	r2, [r3, #4]!
 8031b30:	9a02      	ldr	r2, [sp, #8]
 8031b32:	9301      	str	r3, [sp, #4]
 8031b34:	f108 0302 	add.w	r3, r8, #2
 8031b38:	1a9b      	subs	r3, r3, r2
 8031b3a:	9a03      	ldr	r2, [sp, #12]
 8031b3c:	429a      	cmp	r2, r3
 8031b3e:	f240 80ad 	bls.w	8031c9c <_lite_kernel_nl_softmax_iu8ou8+0x3c8>
 8031b42:	46e0      	mov	r8, ip
 8031b44:	9a05      	ldr	r2, [sp, #20]
 8031b46:	f81c 3f01 	ldrb.w	r3, [ip, #1]!
 8031b4a:	429a      	cmp	r2, r3
 8031b4c:	f77f aef4 	ble.w	8031938 <_lite_kernel_nl_softmax_iu8ou8+0x64>
 8031b50:	2200      	movs	r2, #0
 8031b52:	e7ea      	b.n	8031b2a <_lite_kernel_nl_softmax_iu8ou8+0x256>
 8031b54:	9824      	ldr	r0, [sp, #144]	@ 0x90
 8031b56:	fbc3 1200 	smlal	r1, r2, r3, r0
 8031b5a:	2a00      	cmp	r2, #0
 8031b5c:	da04      	bge.n	8031b68 <_lite_kernel_nl_softmax_iu8ou8+0x294>
 8031b5e:	f06f 4300 	mvn.w	r3, #2147483648	@ 0x80000000
 8031b62:	18c9      	adds	r1, r1, r3
 8031b64:	f142 0200 	adc.w	r2, r2, #0
 8031b68:	0fc9      	lsrs	r1, r1, #31
 8031b6a:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8031b6e:	2600      	movs	r6, #0
 8031b70:	ea41 0142 	orr.w	r1, r1, r2, lsl #1
 8031b74:	f041 477f 	orr.w	r7, r1, #4278190080	@ 0xff000000
 8031b78:	017d      	lsls	r5, r7, #5
 8031b7a:	1a7f      	subs	r7, r7, r1
 8031b7c:	f105 5580 	add.w	r5, r5, #268435456	@ 0x10000000
 8031b80:	fbc5 3605 	smlal	r3, r6, r5, r5
 8031b84:	2e00      	cmp	r6, #0
 8031b86:	da05      	bge.n	8031b94 <_lite_kernel_nl_softmax_iu8ou8+0x2c0>
 8031b88:	f06f 4200 	mvn.w	r2, #2147483648	@ 0x80000000
 8031b8c:	189a      	adds	r2, r3, r2
 8031b8e:	4613      	mov	r3, r2
 8031b90:	f146 0600 	adc.w	r6, r6, #0
 8031b94:	0fdb      	lsrs	r3, r3, #31
 8031b96:	ea43 0346 	orr.w	r3, r3, r6, lsl #1
 8031b9a:	17f6      	asrs	r6, r6, #31
 8031b9c:	fba3 2003 	umull	r2, r0, r3, r3
 8031ba0:	fb03 f406 	mul.w	r4, r3, r6
 8031ba4:	f112 4280 	adds.w	r2, r2, #1073741824	@ 0x40000000
 8031ba8:	9310      	str	r3, [sp, #64]	@ 0x40
 8031baa:	eb40 0044 	adc.w	r0, r0, r4, lsl #1
 8031bae:	2800      	cmp	r0, #0
 8031bb0:	da05      	bge.n	8031bbe <_lite_kernel_nl_softmax_iu8ou8+0x2ea>
 8031bb2:	f06f 4400 	mvn.w	r4, #2147483648	@ 0x80000000
 8031bb6:	1914      	adds	r4, r2, r4
 8031bb8:	4622      	mov	r2, r4
 8031bba:	f140 0000 	adc.w	r0, r0, #0
 8031bbe:	0fd2      	lsrs	r2, r2, #31
 8031bc0:	fb05 f606 	mul.w	r6, r5, r6
 8031bc4:	ea83 0e05 	eor.w	lr, r3, r5
 8031bc8:	fab1 f181 	clz	r1, r1
 8031bcc:	ea42 0240 	orr.w	r2, r2, r0, lsl #1
 8031bd0:	f3c7 7940 	ubfx	r9, r7, #29, #1
 8031bd4:	17e8      	asrs	r0, r5, #31
 8031bd6:	f3c7 7a80 	ubfx	sl, r7, #30, #1
 8031bda:	0949      	lsrs	r1, r1, #5
 8031bdc:	f3c7 6400 	ubfx	r4, r7, #24, #1
 8031be0:	fb03 6600 	mla	r6, r3, r0, r6
 8031be4:	f3c7 7000 	ubfx	r0, r7, #28, #1
 8031be8:	f3c7 6b80 	ubfx	fp, r7, #26, #1
 8031bec:	ea4f 7ede 	mov.w	lr, lr, lsr #31
 8031bf0:	9606      	str	r6, [sp, #24]
 8031bf2:	fba5 6303 	umull	r6, r3, r5, r3
 8031bf6:	9007      	str	r0, [sp, #28]
 8031bf8:	f3c7 6040 	ubfx	r0, r7, #25, #1
 8031bfc:	9611      	str	r6, [sp, #68]	@ 0x44
 8031bfe:	9e06      	ldr	r6, [sp, #24]
 8031c00:	4433      	add	r3, r6
 8031c02:	424e      	negs	r6, r1
 8031c04:	3901      	subs	r1, #1
 8031c06:	910a      	str	r1, [sp, #40]	@ 0x28
 8031c08:	f026 4100 	bic.w	r1, r6, #2147483648	@ 0x80000000
 8031c0c:	f347 66c0 	sbfx	r6, r7, #27, #1
 8031c10:	910f      	str	r1, [sp, #60]	@ 0x3c
 8031c12:	f3c7 61c0 	ubfx	r1, r7, #27, #1
 8031c16:	9f07      	ldr	r7, [sp, #28]
 8031c18:	3901      	subs	r1, #1
 8031c1a:	960e      	str	r6, [sp, #56]	@ 0x38
 8031c1c:	1096      	asrs	r6, r2, #2
 8031c1e:	f002 0203 	and.w	r2, r2, #3
 8031c22:	910b      	str	r1, [sp, #44]	@ 0x2c
 8031c24:	f107 31ff 	add.w	r1, r7, #4294967295
 8031c28:	f1c7 0700 	rsb	r7, r7, #0
 8031c2c:	9708      	str	r7, [sp, #32]
 8031c2e:	f10a 37ff 	add.w	r7, sl, #4294967295
 8031c32:	970d      	str	r7, [sp, #52]	@ 0x34
 8031c34:	f1ca 0700 	rsb	r7, sl, #0
 8031c38:	f10b 3aff 	add.w	sl, fp, #4294967295
 8031c3c:	f1cb 0b00 	rsb	fp, fp, #0
 8031c40:	9706      	str	r7, [sp, #24]
 8031c42:	f109 37ff 	add.w	r7, r9, #4294967295
 8031c46:	970c      	str	r7, [sp, #48]	@ 0x30
 8031c48:	f1c9 0700 	rsb	r7, r9, #0
 8031c4c:	f100 39ff 	add.w	r9, r0, #4294967295
 8031c50:	f1c0 0000 	rsb	r0, r0, #0
 8031c54:	9707      	str	r7, [sp, #28]
 8031c56:	f104 37ff 	add.w	r7, r4, #4294967295
 8031c5a:	9009      	str	r0, [sp, #36]	@ 0x24
 8031c5c:	f1c4 0400 	rsb	r4, r4, #0
 8031c60:	bf54      	ite	pl
 8031c62:	2001      	movpl	r0, #1
 8031c64:	2002      	movmi	r0, #2
 8031c66:	e69b      	b.n	80319a0 <_lite_kernel_nl_softmax_iu8ou8+0xcc>
 8031c68:	c0000001 	.word	0xc0000001
 8031c6c:	01fffff8 	.word	0x01fffff8
 8031c70:	0fffffe0 	.word	0x0fffffe0
 8031c74:	40000100 	.word	0x40000100
 8031c78:	001fffff 	.word	0x001fffff
 8031c7c:	2aaaaaab 	.word	0x2aaaaaab
 8031c80:	70f5a894 	.word	0x70f5a894
 8031c84:	63afbe7b 	.word	0x63afbe7b
 8031c88:	4da2cbf2 	.word	0x4da2cbf2
 8031c8c:	2f16ac6c 	.word	0x2f16ac6c
 8031c90:	1152aaa4 	.word	0x1152aaa4
 8031c94:	02582ab7 	.word	0x02582ab7
 8031c98:	000afe11 	.word	0x000afe11
 8031c9c:	9b04      	ldr	r3, [sp, #16]
 8031c9e:	2b00      	cmp	r3, #0
 8031ca0:	f000 81f8 	beq.w	8032094 <_lite_kernel_nl_softmax_iu8ou8+0x7c0>
 8031ca4:	fab3 f983 	clz	r9, r3
 8031ca8:	fa03 f209 	lsl.w	r2, r3, r9
 8031cac:	f1c9 0a23 	rsb	sl, r9, #35	@ 0x23
 8031cb0:	f102 4300 	add.w	r3, r2, #2147483648	@ 0x80000000
 8031cb4:	17d9      	asrs	r1, r3, #31
 8031cb6:	f1b1 3fff 	cmp.w	r1, #4294967295
 8031cba:	bf08      	it	eq
 8031cbc:	2a00      	cmpeq	r2, #0
 8031cbe:	f000 81ed 	beq.w	803209c <_lite_kernel_nl_softmax_iu8ou8+0x7c8>
 8031cc2:	f113 4300 	adds.w	r3, r3, #2147483648	@ 0x80000000
 8031cc6:	4ac2      	ldr	r2, [pc, #776]	@ (8031fd0 <_lite_kernel_nl_softmax_iu8ou8+0x6fc>)
 8031cc8:	4dc2      	ldr	r5, [pc, #776]	@ (8031fd4 <_lite_kernel_nl_softmax_iu8ou8+0x700>)
 8031cca:	f141 0100 	adc.w	r1, r1, #0
 8031cce:	085b      	lsrs	r3, r3, #1
 8031cd0:	ea43 73c1 	orr.w	r3, r3, r1, lsl #31
 8031cd4:	1049      	asrs	r1, r1, #1
 8031cd6:	4258      	negs	r0, r3
 8031cd8:	469c      	mov	ip, r3
 8031cda:	fb02 0001 	mla	r0, r2, r1, r0
 8031cde:	fba3 2402 	umull	r2, r4, r3, r2
 8031ce2:	1952      	adds	r2, r2, r5
 8031ce4:	4420      	add	r0, r4
 8031ce6:	f160 0000 	sbc.w	r0, r0, #0
 8031cea:	2800      	cmp	r0, #0
 8031cec:	da05      	bge.n	8031cfa <_lite_kernel_nl_softmax_iu8ou8+0x426>
 8031cee:	f06f 4400 	mvn.w	r4, #2147483648	@ 0x80000000
 8031cf2:	1914      	adds	r4, r2, r4
 8031cf4:	4622      	mov	r2, r4
 8031cf6:	f140 0000 	adc.w	r0, r0, #0
 8031cfa:	0fd2      	lsrs	r2, r2, #31
 8031cfc:	ea42 0440 	orr.w	r4, r2, r0, lsl #1
 8031d00:	f104 365a 	add.w	r6, r4, #1515870810	@ 0x5a5a5a5a
 8031d04:	17f0      	asrs	r0, r6, #31
 8031d06:	fba3 2706 	umull	r2, r7, r3, r6
 8031d0a:	4635      	mov	r5, r6
 8031d0c:	fb03 fe00 	mul.w	lr, r3, r0
 8031d10:	f112 4280 	adds.w	r2, r2, #1073741824	@ 0x40000000
 8031d14:	fb06 ee01 	mla	lr, r6, r1, lr
 8031d18:	eb4e 0707 	adc.w	r7, lr, r7
 8031d1c:	2f00      	cmp	r7, #0
 8031d1e:	da06      	bge.n	8031d2e <_lite_kernel_nl_softmax_iu8ou8+0x45a>
 8031d20:	f06f 4e00 	mvn.w	lr, #2147483648	@ 0x80000000
 8031d24:	eb12 0e0e 	adds.w	lr, r2, lr
 8031d28:	4672      	mov	r2, lr
 8031d2a:	f147 0700 	adc.w	r7, r7, #0
 8031d2e:	0fd2      	lsrs	r2, r2, #31
 8031d30:	ea42 0247 	orr.w	r2, r2, r7, lsl #1
 8031d34:	4fa7      	ldr	r7, [pc, #668]	@ (8031fd4 <_lite_kernel_nl_softmax_iu8ou8+0x700>)
 8031d36:	f1c2 5200 	rsb	r2, r2, #536870912	@ 0x20000000
 8031d3a:	ea82 0e06 	eor.w	lr, r2, r6
 8031d3e:	ea4f 7ede 	mov.w	lr, lr, lsr #31
 8031d42:	f1be 0f00 	cmp.w	lr, #0
 8031d46:	bf06      	itte	eq
 8031d48:	f04f 4780 	moveq.w	r7, #1073741824	@ 0x40000000
 8031d4c:	f04f 0800 	moveq.w	r8, #0
 8031d50:	f04f 38ff 	movne.w	r8, #4294967295
 8031d54:	fb02 f000 	mul.w	r0, r2, r0
 8031d58:	ea4f 7ee2 	mov.w	lr, r2, asr #31
 8031d5c:	fb05 000e 	mla	r0, r5, lr, r0
 8031d60:	fba2 2505 	umull	r2, r5, r2, r5
 8031d64:	19d2      	adds	r2, r2, r7
 8031d66:	4428      	add	r0, r5
 8031d68:	eb40 0508 	adc.w	r5, r0, r8
 8031d6c:	2d00      	cmp	r5, #0
 8031d6e:	da05      	bge.n	8031d7c <_lite_kernel_nl_softmax_iu8ou8+0x4a8>
 8031d70:	f06f 4000 	mvn.w	r0, #2147483648	@ 0x80000000
 8031d74:	1810      	adds	r0, r2, r0
 8031d76:	4602      	mov	r2, r0
 8031d78:	f145 0500 	adc.w	r5, r5, #0
 8031d7c:	0fd2      	lsrs	r2, r2, #31
 8031d7e:	ea42 0245 	orr.w	r2, r2, r5, lsl #1
 8031d82:	f1b2 4f60 	cmp.w	r2, #3758096384	@ 0xe0000000
 8031d86:	dd7f      	ble.n	8031e88 <_lite_kernel_nl_softmax_iu8ou8+0x5b4>
 8031d88:	eb06 0082 	add.w	r0, r6, r2, lsl #2
 8031d8c:	4e91      	ldr	r6, [pc, #580]	@ (8031fd4 <_lite_kernel_nl_softmax_iu8ou8+0x700>)
 8031d8e:	ea80 020c 	eor.w	r2, r0, ip
 8031d92:	17c4      	asrs	r4, r0, #31
 8031d94:	fb00 f501 	mul.w	r5, r0, r1
 8031d98:	0fd2      	lsrs	r2, r2, #31
 8031d9a:	fb03 5504 	mla	r5, r3, r4, r5
 8031d9e:	2a00      	cmp	r2, #0
 8031da0:	fba0 2e03 	umull	r2, lr, r0, r3
 8031da4:	bf06      	itte	eq
 8031da6:	f04f 4680 	moveq.w	r6, #1073741824	@ 0x40000000
 8031daa:	2700      	moveq	r7, #0
 8031dac:	f04f 37ff 	movne.w	r7, #4294967295
 8031db0:	4475      	add	r5, lr
 8031db2:	1992      	adds	r2, r2, r6
 8031db4:	eb45 0507 	adc.w	r5, r5, r7
 8031db8:	2d00      	cmp	r5, #0
 8031dba:	da05      	bge.n	8031dc8 <_lite_kernel_nl_softmax_iu8ou8+0x4f4>
 8031dbc:	f06f 4600 	mvn.w	r6, #2147483648	@ 0x80000000
 8031dc0:	1996      	adds	r6, r2, r6
 8031dc2:	4632      	mov	r2, r6
 8031dc4:	f145 0500 	adc.w	r5, r5, #0
 8031dc8:	0fd2      	lsrs	r2, r2, #31
 8031dca:	ea42 0245 	orr.w	r2, r2, r5, lsl #1
 8031dce:	4d81      	ldr	r5, [pc, #516]	@ (8031fd4 <_lite_kernel_nl_softmax_iu8ou8+0x700>)
 8031dd0:	f1c2 5200 	rsb	r2, r2, #536870912	@ 0x20000000
 8031dd4:	ea80 0602 	eor.w	r6, r0, r2
 8031dd8:	0ff6      	lsrs	r6, r6, #31
 8031dda:	2e00      	cmp	r6, #0
 8031ddc:	bf06      	itte	eq
 8031dde:	f04f 4580 	moveq.w	r5, #1073741824	@ 0x40000000
 8031de2:	2600      	moveq	r6, #0
 8031de4:	f04f 36ff 	movne.w	r6, #4294967295
 8031de8:	fb02 f404 	mul.w	r4, r2, r4
 8031dec:	17d7      	asrs	r7, r2, #31
 8031dee:	fb00 4407 	mla	r4, r0, r7, r4
 8031df2:	fba2 2700 	umull	r2, r7, r2, r0
 8031df6:	1952      	adds	r2, r2, r5
 8031df8:	443c      	add	r4, r7
 8031dfa:	eb44 0406 	adc.w	r4, r4, r6
 8031dfe:	2c00      	cmp	r4, #0
 8031e00:	da05      	bge.n	8031e0e <_lite_kernel_nl_softmax_iu8ou8+0x53a>
 8031e02:	f06f 4500 	mvn.w	r5, #2147483648	@ 0x80000000
 8031e06:	1955      	adds	r5, r2, r5
 8031e08:	462a      	mov	r2, r5
 8031e0a:	f144 0400 	adc.w	r4, r4, #0
 8031e0e:	0fd2      	lsrs	r2, r2, #31
 8031e10:	ea42 0244 	orr.w	r2, r2, r4, lsl #1
 8031e14:	f1b2 5f00 	cmp.w	r2, #536870912	@ 0x20000000
 8031e18:	db65      	blt.n	8031ee6 <_lite_kernel_nl_softmax_iu8ou8+0x612>
 8031e1a:	f06f 4400 	mvn.w	r4, #2147483648	@ 0x80000000
 8031e1e:	1902      	adds	r2, r0, r4
 8031e20:	ea92 0f0c 	teq	r2, ip
 8031e24:	f140 8131 	bpl.w	803208a <_lite_kernel_nl_softmax_iu8ou8+0x7b6>
 8031e28:	4c6a      	ldr	r4, [pc, #424]	@ (8031fd4 <_lite_kernel_nl_softmax_iu8ou8+0x700>)
 8031e2a:	f04f 35ff 	mov.w	r5, #4294967295
 8031e2e:	fb02 f101 	mul.w	r1, r2, r1
 8031e32:	17d0      	asrs	r0, r2, #31
 8031e34:	fb03 1100 	mla	r1, r3, r0, r1
 8031e38:	fba2 3603 	umull	r3, r6, r2, r3
 8031e3c:	191b      	adds	r3, r3, r4
 8031e3e:	4431      	add	r1, r6
 8031e40:	eb41 0105 	adc.w	r1, r1, r5
 8031e44:	2900      	cmp	r1, #0
 8031e46:	da05      	bge.n	8031e54 <_lite_kernel_nl_softmax_iu8ou8+0x580>
 8031e48:	f06f 4400 	mvn.w	r4, #2147483648	@ 0x80000000
 8031e4c:	191c      	adds	r4, r3, r4
 8031e4e:	4623      	mov	r3, r4
 8031e50:	f141 0100 	adc.w	r1, r1, #0
 8031e54:	0fdb      	lsrs	r3, r3, #31
 8031e56:	ea43 0341 	orr.w	r3, r3, r1, lsl #1
 8031e5a:	495e      	ldr	r1, [pc, #376]	@ (8031fd4 <_lite_kernel_nl_softmax_iu8ou8+0x700>)
 8031e5c:	f1c3 5300 	rsb	r3, r3, #536870912	@ 0x20000000
 8031e60:	ea83 0402 	eor.w	r4, r3, r2
 8031e64:	0fe4      	lsrs	r4, r4, #31
 8031e66:	2c00      	cmp	r4, #0
 8031e68:	bf06      	itte	eq
 8031e6a:	f04f 4180 	moveq.w	r1, #1073741824	@ 0x40000000
 8031e6e:	2400      	moveq	r4, #0
 8031e70:	f04f 34ff 	movne.w	r4, #4294967295
 8031e74:	4293      	cmp	r3, r2
 8031e76:	d15d      	bne.n	8031f34 <_lite_kernel_nl_softmax_iu8ou8+0x660>
 8031e78:	f1b2 4f00 	cmp.w	r2, #2147483648	@ 0x80000000
 8031e7c:	d15a      	bne.n	8031f34 <_lite_kernel_nl_softmax_iu8ou8+0x660>
 8031e7e:	f06f 4100 	mvn.w	r1, #2147483648	@ 0x80000000
 8031e82:	4411      	add	r1, r2
 8031e84:	0049      	lsls	r1, r1, #1
 8031e86:	e076      	b.n	8031f76 <_lite_kernel_nl_softmax_iu8ou8+0x6a2>
 8031e88:	4853      	ldr	r0, [pc, #332]	@ (8031fd8 <_lite_kernel_nl_softmax_iu8ou8+0x704>)
 8031e8a:	4420      	add	r0, r4
 8031e8c:	ea90 0f0c 	teq	r0, ip
 8031e90:	f140 8112 	bpl.w	80320b8 <_lite_kernel_nl_softmax_iu8ou8+0x7e4>
 8031e94:	17c2      	asrs	r2, r0, #31
 8031e96:	fb00 f401 	mul.w	r4, r0, r1
 8031e9a:	4d4e      	ldr	r5, [pc, #312]	@ (8031fd4 <_lite_kernel_nl_softmax_iu8ou8+0x700>)
 8031e9c:	fb03 4402 	mla	r4, r3, r2, r4
 8031ea0:	fba0 2603 	umull	r2, r6, r0, r3
 8031ea4:	1952      	adds	r2, r2, r5
 8031ea6:	4434      	add	r4, r6
 8031ea8:	f164 0500 	sbc.w	r5, r4, #0
 8031eac:	2d00      	cmp	r5, #0
 8031eae:	da05      	bge.n	8031ebc <_lite_kernel_nl_softmax_iu8ou8+0x5e8>
 8031eb0:	f06f 4400 	mvn.w	r4, #2147483648	@ 0x80000000
 8031eb4:	1914      	adds	r4, r2, r4
 8031eb6:	4622      	mov	r2, r4
 8031eb8:	f145 0500 	adc.w	r5, r5, #0
 8031ebc:	0fd2      	lsrs	r2, r2, #31
 8031ebe:	ea42 0245 	orr.w	r2, r2, r5, lsl #1
 8031ec2:	f04f 35ff 	mov.w	r5, #4294967295
 8031ec6:	f1c2 5400 	rsb	r4, r2, #536870912	@ 0x20000000
 8031eca:	4a42      	ldr	r2, [pc, #264]	@ (8031fd4 <_lite_kernel_nl_softmax_iu8ou8+0x700>)
 8031ecc:	fbc0 2504 	smlal	r2, r5, r0, r4
 8031ed0:	2d00      	cmp	r5, #0
 8031ed2:	da05      	bge.n	8031ee0 <_lite_kernel_nl_softmax_iu8ou8+0x60c>
 8031ed4:	f06f 4400 	mvn.w	r4, #2147483648	@ 0x80000000
 8031ed8:	1914      	adds	r4, r2, r4
 8031eda:	4622      	mov	r2, r4
 8031edc:	f145 0500 	adc.w	r5, r5, #0
 8031ee0:	0fd2      	lsrs	r2, r2, #31
 8031ee2:	ea42 0245 	orr.w	r2, r2, r5, lsl #1
 8031ee6:	f1b2 4f60 	cmp.w	r2, #3758096384	@ 0xe0000000
 8031eea:	ea4f 0482 	mov.w	r4, r2, lsl #2
 8031eee:	dc96      	bgt.n	8031e1e <_lite_kernel_nl_softmax_iu8ou8+0x54a>
 8031ef0:	f100 4200 	add.w	r2, r0, #2147483648	@ 0x80000000
 8031ef4:	ea92 0f0c 	teq	r2, ip
 8031ef8:	f140 80c7 	bpl.w	803208a <_lite_kernel_nl_softmax_iu8ou8+0x7b6>
 8031efc:	17d0      	asrs	r0, r2, #31
 8031efe:	4c35      	ldr	r4, [pc, #212]	@ (8031fd4 <_lite_kernel_nl_softmax_iu8ou8+0x700>)
 8031f00:	fb03 f500 	mul.w	r5, r3, r0
 8031f04:	fb02 5101 	mla	r1, r2, r1, r5
 8031f08:	fba3 3502 	umull	r3, r5, r3, r2
 8031f0c:	191b      	adds	r3, r3, r4
 8031f0e:	4429      	add	r1, r5
 8031f10:	f161 0100 	sbc.w	r1, r1, #0
 8031f14:	2900      	cmp	r1, #0
 8031f16:	da05      	bge.n	8031f24 <_lite_kernel_nl_softmax_iu8ou8+0x650>
 8031f18:	f06f 4400 	mvn.w	r4, #2147483648	@ 0x80000000
 8031f1c:	191c      	adds	r4, r3, r4
 8031f1e:	4623      	mov	r3, r4
 8031f20:	f141 0100 	adc.w	r1, r1, #0
 8031f24:	0fdb      	lsrs	r3, r3, #31
 8031f26:	f04f 34ff 	mov.w	r4, #4294967295
 8031f2a:	ea43 0341 	orr.w	r3, r3, r1, lsl #1
 8031f2e:	4929      	ldr	r1, [pc, #164]	@ (8031fd4 <_lite_kernel_nl_softmax_iu8ou8+0x700>)
 8031f30:	f1c3 5300 	rsb	r3, r3, #536870912	@ 0x20000000
 8031f34:	fb03 f000 	mul.w	r0, r3, r0
 8031f38:	17dd      	asrs	r5, r3, #31
 8031f3a:	fb02 0005 	mla	r0, r2, r5, r0
 8031f3e:	fba3 3502 	umull	r3, r5, r3, r2
 8031f42:	185b      	adds	r3, r3, r1
 8031f44:	4428      	add	r0, r5
 8031f46:	eb40 0004 	adc.w	r0, r0, r4
 8031f4a:	2800      	cmp	r0, #0
 8031f4c:	da05      	bge.n	8031f5a <_lite_kernel_nl_softmax_iu8ou8+0x686>
 8031f4e:	f06f 4100 	mvn.w	r1, #2147483648	@ 0x80000000
 8031f52:	1859      	adds	r1, r3, r1
 8031f54:	460b      	mov	r3, r1
 8031f56:	f140 0000 	adc.w	r0, r0, #0
 8031f5a:	0fdb      	lsrs	r3, r3, #31
 8031f5c:	ea43 0340 	orr.w	r3, r3, r0, lsl #1
 8031f60:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8031f64:	f2c0 8085 	blt.w	8032072 <_lite_kernel_nl_softmax_iu8ou8+0x79e>
 8031f68:	f06f 4300 	mvn.w	r3, #2147483648	@ 0x80000000
 8031f6c:	18d1      	adds	r1, r2, r3
 8031f6e:	f1b1 4f80 	cmp.w	r1, #1073741824	@ 0x40000000
 8031f72:	db87      	blt.n	8031e84 <_lite_kernel_nl_softmax_iu8ou8+0x5b0>
 8031f74:	4619      	mov	r1, r3
 8031f76:	f1ba 0f1f 	cmp.w	sl, #31
 8031f7a:	dd04      	ble.n	8031f86 <_lite_kernel_nl_softmax_iu8ou8+0x6b2>
 8031f7c:	f1c9 0304 	rsb	r3, r9, #4
 8031f80:	f04f 0a1f 	mov.w	sl, #31
 8031f84:	4119      	asrs	r1, r3
 8031f86:	9b03      	ldr	r3, [sp, #12]
 8031f88:	2b00      	cmp	r3, #0
 8031f8a:	d05b      	beq.n	8032044 <_lite_kernel_nl_softmax_iu8ou8+0x770>
 8031f8c:	2501      	movs	r5, #1
 8031f8e:	f06f 4700 	mvn.w	r7, #2147483648	@ 0x80000000
 8031f92:	f1a1 4e00 	sub.w	lr, r1, #2147483648	@ 0x80000000
 8031f96:	9815      	ldr	r0, [sp, #84]	@ 0x54
 8031f98:	fa05 f50a 	lsl.w	r5, r5, sl
 8031f9c:	fa47 f90a 	asr.w	r9, r7, sl
 8031fa0:	fabe fe8e 	clz	lr, lr
 8031fa4:	4e0b      	ldr	r6, [pc, #44]	@ (8031fd4 <_lite_kernel_nl_softmax_iu8ou8+0x700>)
 8031fa6:	3d01      	subs	r5, #1
 8031fa8:	f8cd 9010 	str.w	r9, [sp, #16]
 8031fac:	ea4f 1e5e 	mov.w	lr, lr, lsr #5
 8031fb0:	f8dd 905c 	ldr.w	r9, [sp, #92]	@ 0x5c
 8031fb4:	ea05 0307 	and.w	r3, r5, r7
 8031fb8:	ea4f 0c65 	mov.w	ip, r5, asr #1
 8031fbc:	9301      	str	r3, [sp, #4]
 8031fbe:	f10c 0801 	add.w	r8, ip, #1
 8031fc2:	9b13      	ldr	r3, [sp, #76]	@ 0x4c
 8031fc4:	1e5c      	subs	r4, r3, #1
 8031fc6:	4673      	mov	r3, lr
 8031fc8:	46ae      	mov	lr, r5
 8031fca:	461d      	mov	r5, r3
 8031fcc:	e013      	b.n	8031ff6 <_lite_kernel_nl_softmax_iu8ou8+0x722>
 8031fce:	bf00      	nop
 8031fd0:	c3c3c3c4 	.word	0xc3c3c3c4
 8031fd4:	c0000001 	.word	0xc0000001
 8031fd8:	da5a5a5a 	.word	0xda5a5a5a
 8031fdc:	b1dd      	cbz	r5, 8032016 <_lite_kernel_nl_softmax_iu8ou8+0x742>
 8031fde:	9b04      	ldr	r3, [sp, #16]
 8031fe0:	9a01      	ldr	r2, [sp, #4]
 8031fe2:	4594      	cmp	ip, r2
 8031fe4:	da00      	bge.n	8031fe8 <_lite_kernel_nl_softmax_iu8ou8+0x714>
 8031fe6:	3301      	adds	r3, #1
 8031fe8:	2bfe      	cmp	r3, #254	@ 0xfe
 8031fea:	dd3e      	ble.n	803206a <_lite_kernel_nl_softmax_iu8ou8+0x796>
 8031fec:	23ff      	movs	r3, #255	@ 0xff
 8031fee:	4581      	cmp	r9, r0
 8031ff0:	f804 3f01 	strb.w	r3, [r4, #1]!
 8031ff4:	d026      	beq.n	8032044 <_lite_kernel_nl_softmax_iu8ou8+0x770>
 8031ff6:	f850 2f04 	ldr.w	r2, [r0, #4]!
 8031ffa:	ea81 0302 	eor.w	r3, r1, r2
 8031ffe:	0fdb      	lsrs	r3, r3, #31
 8032000:	2b00      	cmp	r3, #0
 8032002:	bf0b      	itete	eq
 8032004:	f04f 4380 	moveq.w	r3, #1073741824	@ 0x40000000
 8032008:	4633      	movne	r3, r6
 803200a:	f04f 0b00 	moveq.w	fp, #0
 803200e:	f04f 3bff 	movne.w	fp, #4294967295
 8032012:	4291      	cmp	r1, r2
 8032014:	d0e2      	beq.n	8031fdc <_lite_kernel_nl_softmax_iu8ou8+0x708>
 8032016:	fbc2 3b01 	smlal	r3, fp, r2, r1
 803201a:	f1bb 0f00 	cmp.w	fp, #0
 803201e:	da02      	bge.n	8032026 <_lite_kernel_nl_softmax_iu8ou8+0x752>
 8032020:	19db      	adds	r3, r3, r7
 8032022:	f14b 0b00 	adc.w	fp, fp, #0
 8032026:	0fdb      	lsrs	r3, r3, #31
 8032028:	ea43 034b 	orr.w	r3, r3, fp, lsl #1
 803202c:	ea0e 0203 	and.w	r2, lr, r3
 8032030:	fa53 f30a 	asrs.w	r3, r3, sl
 8032034:	d5d5      	bpl.n	8031fe2 <_lite_kernel_nl_softmax_iu8ou8+0x70e>
 8032036:	4590      	cmp	r8, r2
 8032038:	dbd5      	blt.n	8031fe6 <_lite_kernel_nl_softmax_iu8ou8+0x712>
 803203a:	2300      	movs	r3, #0
 803203c:	4581      	cmp	r9, r0
 803203e:	f804 3f01 	strb.w	r3, [r4, #1]!
 8032042:	d1d8      	bne.n	8031ff6 <_lite_kernel_nl_softmax_iu8ou8+0x722>
 8032044:	9b02      	ldr	r3, [sp, #8]
 8032046:	9a22      	ldr	r2, [sp, #136]	@ 0x88
 8032048:	9923      	ldr	r1, [sp, #140]	@ 0x8c
 803204a:	4413      	add	r3, r2
 803204c:	9a13      	ldr	r2, [sp, #76]	@ 0x4c
 803204e:	440a      	add	r2, r1
 8032050:	9922      	ldr	r1, [sp, #136]	@ 0x88
 8032052:	9302      	str	r3, [sp, #8]
 8032054:	9213      	str	r2, [sp, #76]	@ 0x4c
 8032056:	9a14      	ldr	r2, [sp, #80]	@ 0x50
 8032058:	440a      	add	r2, r1
 803205a:	9214      	str	r2, [sp, #80]	@ 0x50
 803205c:	9a16      	ldr	r2, [sp, #88]	@ 0x58
 803205e:	429a      	cmp	r2, r3
 8032060:	f63f ac4e 	bhi.w	8031900 <_lite_kernel_nl_softmax_iu8ou8+0x2c>
 8032064:	b019      	add	sp, #100	@ 0x64
 8032066:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 803206a:	2b00      	cmp	r3, #0
 803206c:	dde5      	ble.n	803203a <_lite_kernel_nl_softmax_iu8ou8+0x766>
 803206e:	b2db      	uxtb	r3, r3
 8032070:	e7bd      	b.n	8031fee <_lite_kernel_nl_softmax_iu8ou8+0x71a>
 8032072:	f1b3 4f60 	cmp.w	r3, #3758096384	@ 0xe0000000
 8032076:	dc3b      	bgt.n	80320f0 <_lite_kernel_nl_softmax_iu8ou8+0x81c>
 8032078:	f102 4300 	add.w	r3, r2, #2147483648	@ 0x80000000
 803207c:	0051      	lsls	r1, r2, #1
 803207e:	f1b3 4f40 	cmp.w	r3, #3221225472	@ 0xc0000000
 8032082:	bfd8      	it	le
 8032084:	f04f 4100 	movle.w	r1, #2147483648	@ 0x80000000
 8032088:	e775      	b.n	8031f76 <_lite_kernel_nl_softmax_iu8ou8+0x6a2>
 803208a:	f04f 4480 	mov.w	r4, #1073741824	@ 0x40000000
 803208e:	2500      	movs	r5, #0
 8032090:	e6cd      	b.n	8031e2e <_lite_kernel_nl_softmax_iu8ou8+0x55a>
 8032092:	bbb9      	cbnz	r1, 8032104 <_lite_kernel_nl_softmax_iu8ou8+0x830>
 8032094:	f04f 0a03 	mov.w	sl, #3
 8032098:	f04f 0920 	mov.w	r9, #32
 803209c:	2000      	movs	r0, #0
 803209e:	f04f 33ff 	mov.w	r3, #4294967295
 80320a2:	f04f 355a 	mov.w	r5, #1515870810	@ 0x5a5a5a5a
 80320a6:	4a1a      	ldr	r2, [pc, #104]	@ (8032110 <_lite_kernel_nl_softmax_iu8ou8+0x83c>)
 80320a8:	4604      	mov	r4, r0
 80320aa:	4619      	mov	r1, r3
 80320ac:	462e      	mov	r6, r5
 80320ae:	469c      	mov	ip, r3
 80320b0:	f04f 4780 	mov.w	r7, #1073741824	@ 0x40000000
 80320b4:	4680      	mov	r8, r0
 80320b6:	e64d      	b.n	8031d54 <_lite_kernel_nl_softmax_iu8ou8+0x480>
 80320b8:	17c4      	asrs	r4, r0, #31
 80320ba:	fba3 2500 	umull	r2, r5, r3, r0
 80320be:	fb03 f604 	mul.w	r6, r3, r4
 80320c2:	f112 4280 	adds.w	r2, r2, #1073741824	@ 0x40000000
 80320c6:	fb00 6601 	mla	r6, r0, r1, r6
 80320ca:	eb46 0505 	adc.w	r5, r6, r5
 80320ce:	2d00      	cmp	r5, #0
 80320d0:	da05      	bge.n	80320de <_lite_kernel_nl_softmax_iu8ou8+0x80a>
 80320d2:	f06f 4600 	mvn.w	r6, #2147483648	@ 0x80000000
 80320d6:	1996      	adds	r6, r2, r6
 80320d8:	4632      	mov	r2, r6
 80320da:	f145 0500 	adc.w	r5, r5, #0
 80320de:	0fd2      	lsrs	r2, r2, #31
 80320e0:	f04f 36ff 	mov.w	r6, #4294967295
 80320e4:	ea42 0245 	orr.w	r2, r2, r5, lsl #1
 80320e8:	4d0a      	ldr	r5, [pc, #40]	@ (8032114 <_lite_kernel_nl_softmax_iu8ou8+0x840>)
 80320ea:	f1c2 5200 	rsb	r2, r2, #536870912	@ 0x20000000
 80320ee:	e67b      	b.n	8031de8 <_lite_kernel_nl_softmax_iu8ou8+0x514>
 80320f0:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 80320f4:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 80320f8:	db02      	blt.n	8032100 <_lite_kernel_nl_softmax_iu8ou8+0x82c>
 80320fa:	f06f 4100 	mvn.w	r1, #2147483648	@ 0x80000000
 80320fe:	e73a      	b.n	8031f76 <_lite_kernel_nl_softmax_iu8ou8+0x6a2>
 8032100:	0059      	lsls	r1, r3, #1
 8032102:	e7bc      	b.n	803207e <_lite_kernel_nl_softmax_iu8ou8+0x7aa>
 8032104:	9b26      	ldr	r3, [sp, #152]	@ 0x98
 8032106:	9a12      	ldr	r2, [sp, #72]	@ 0x48
 8032108:	4413      	add	r3, r2
 803210a:	9305      	str	r3, [sp, #20]
 803210c:	e40b      	b.n	8031926 <_lite_kernel_nl_softmax_iu8ou8+0x52>
 803210e:	bf00      	nop
 8032110:	20000001 	.word	0x20000001
 8032114:	c0000001 	.word	0xc0000001

08032118 <abort>:
 8032118:	b508      	push	{r3, lr}
 803211a:	2006      	movs	r0, #6
 803211c:	f000 ffa0 	bl	8033060 <raise>
 8032120:	2001      	movs	r0, #1
 8032122:	f002 fd3b 	bl	8034b9c <_exit>
	...

08032128 <__assert_func>:
 8032128:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 803212a:	4614      	mov	r4, r2
 803212c:	461a      	mov	r2, r3
 803212e:	4b09      	ldr	r3, [pc, #36]	@ (8032154 <__assert_func+0x2c>)
 8032130:	681b      	ldr	r3, [r3, #0]
 8032132:	4605      	mov	r5, r0
 8032134:	68d8      	ldr	r0, [r3, #12]
 8032136:	b954      	cbnz	r4, 803214e <__assert_func+0x26>
 8032138:	4b07      	ldr	r3, [pc, #28]	@ (8032158 <__assert_func+0x30>)
 803213a:	461c      	mov	r4, r3
 803213c:	e9cd 3401 	strd	r3, r4, [sp, #4]
 8032140:	9100      	str	r1, [sp, #0]
 8032142:	462b      	mov	r3, r5
 8032144:	4905      	ldr	r1, [pc, #20]	@ (803215c <__assert_func+0x34>)
 8032146:	f000 fde3 	bl	8032d10 <fiprintf>
 803214a:	f7ff ffe5 	bl	8032118 <abort>
 803214e:	4b04      	ldr	r3, [pc, #16]	@ (8032160 <__assert_func+0x38>)
 8032150:	e7f4      	b.n	803213c <__assert_func+0x14>
 8032152:	bf00      	nop
 8032154:	20000e9c 	.word	0x20000e9c
 8032158:	0808397b 	.word	0x0808397b
 803215c:	0808394d 	.word	0x0808394d
 8032160:	08083940 	.word	0x08083940

08032164 <calloc>:
 8032164:	4b02      	ldr	r3, [pc, #8]	@ (8032170 <calloc+0xc>)
 8032166:	460a      	mov	r2, r1
 8032168:	4601      	mov	r1, r0
 803216a:	6818      	ldr	r0, [r3, #0]
 803216c:	f000 b802 	b.w	8032174 <_calloc_r>
 8032170:	20000e9c 	.word	0x20000e9c

08032174 <_calloc_r>:
 8032174:	b570      	push	{r4, r5, r6, lr}
 8032176:	fba1 5402 	umull	r5, r4, r1, r2
 803217a:	b93c      	cbnz	r4, 803218c <_calloc_r+0x18>
 803217c:	4629      	mov	r1, r5
 803217e:	f000 f83f 	bl	8032200 <_malloc_r>
 8032182:	4606      	mov	r6, r0
 8032184:	b928      	cbnz	r0, 8032192 <_calloc_r+0x1e>
 8032186:	2600      	movs	r6, #0
 8032188:	4630      	mov	r0, r6
 803218a:	bd70      	pop	{r4, r5, r6, pc}
 803218c:	220c      	movs	r2, #12
 803218e:	6002      	str	r2, [r0, #0]
 8032190:	e7f9      	b.n	8032186 <_calloc_r+0x12>
 8032192:	462a      	mov	r2, r5
 8032194:	4621      	mov	r1, r4
 8032196:	f000 ff33 	bl	8033000 <memset>
 803219a:	e7f5      	b.n	8032188 <_calloc_r+0x14>

0803219c <malloc>:
 803219c:	4b02      	ldr	r3, [pc, #8]	@ (80321a8 <malloc+0xc>)
 803219e:	4601      	mov	r1, r0
 80321a0:	6818      	ldr	r0, [r3, #0]
 80321a2:	f000 b82d 	b.w	8032200 <_malloc_r>
 80321a6:	bf00      	nop
 80321a8:	20000e9c 	.word	0x20000e9c

080321ac <free>:
 80321ac:	4b02      	ldr	r3, [pc, #8]	@ (80321b8 <free+0xc>)
 80321ae:	4601      	mov	r1, r0
 80321b0:	6818      	ldr	r0, [r3, #0]
 80321b2:	f001 be55 	b.w	8033e60 <_free_r>
 80321b6:	bf00      	nop
 80321b8:	20000e9c 	.word	0x20000e9c

080321bc <sbrk_aligned>:
 80321bc:	b570      	push	{r4, r5, r6, lr}
 80321be:	4e0f      	ldr	r6, [pc, #60]	@ (80321fc <sbrk_aligned+0x40>)
 80321c0:	460c      	mov	r4, r1
 80321c2:	6831      	ldr	r1, [r6, #0]
 80321c4:	4605      	mov	r5, r0
 80321c6:	b911      	cbnz	r1, 80321ce <sbrk_aligned+0x12>
 80321c8:	f000 ff9e 	bl	8033108 <_sbrk_r>
 80321cc:	6030      	str	r0, [r6, #0]
 80321ce:	4621      	mov	r1, r4
 80321d0:	4628      	mov	r0, r5
 80321d2:	f000 ff99 	bl	8033108 <_sbrk_r>
 80321d6:	1c43      	adds	r3, r0, #1
 80321d8:	d103      	bne.n	80321e2 <sbrk_aligned+0x26>
 80321da:	f04f 34ff 	mov.w	r4, #4294967295
 80321de:	4620      	mov	r0, r4
 80321e0:	bd70      	pop	{r4, r5, r6, pc}
 80321e2:	1cc4      	adds	r4, r0, #3
 80321e4:	f024 0403 	bic.w	r4, r4, #3
 80321e8:	42a0      	cmp	r0, r4
 80321ea:	d0f8      	beq.n	80321de <sbrk_aligned+0x22>
 80321ec:	1a21      	subs	r1, r4, r0
 80321ee:	4628      	mov	r0, r5
 80321f0:	f000 ff8a 	bl	8033108 <_sbrk_r>
 80321f4:	3001      	adds	r0, #1
 80321f6:	d1f2      	bne.n	80321de <sbrk_aligned+0x22>
 80321f8:	e7ef      	b.n	80321da <sbrk_aligned+0x1e>
 80321fa:	bf00      	nop
 80321fc:	2001224c 	.word	0x2001224c

08032200 <_malloc_r>:
 8032200:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8032204:	1ccd      	adds	r5, r1, #3
 8032206:	f025 0503 	bic.w	r5, r5, #3
 803220a:	3508      	adds	r5, #8
 803220c:	2d0c      	cmp	r5, #12
 803220e:	bf38      	it	cc
 8032210:	250c      	movcc	r5, #12
 8032212:	2d00      	cmp	r5, #0
 8032214:	4606      	mov	r6, r0
 8032216:	db01      	blt.n	803221c <_malloc_r+0x1c>
 8032218:	42a9      	cmp	r1, r5
 803221a:	d904      	bls.n	8032226 <_malloc_r+0x26>
 803221c:	230c      	movs	r3, #12
 803221e:	6033      	str	r3, [r6, #0]
 8032220:	2000      	movs	r0, #0
 8032222:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8032226:	f8df 80d4 	ldr.w	r8, [pc, #212]	@ 80322fc <_malloc_r+0xfc>
 803222a:	f000 f869 	bl	8032300 <__malloc_lock>
 803222e:	f8d8 3000 	ldr.w	r3, [r8]
 8032232:	461c      	mov	r4, r3
 8032234:	bb44      	cbnz	r4, 8032288 <_malloc_r+0x88>
 8032236:	4629      	mov	r1, r5
 8032238:	4630      	mov	r0, r6
 803223a:	f7ff ffbf 	bl	80321bc <sbrk_aligned>
 803223e:	1c43      	adds	r3, r0, #1
 8032240:	4604      	mov	r4, r0
 8032242:	d158      	bne.n	80322f6 <_malloc_r+0xf6>
 8032244:	f8d8 4000 	ldr.w	r4, [r8]
 8032248:	4627      	mov	r7, r4
 803224a:	2f00      	cmp	r7, #0
 803224c:	d143      	bne.n	80322d6 <_malloc_r+0xd6>
 803224e:	2c00      	cmp	r4, #0
 8032250:	d04b      	beq.n	80322ea <_malloc_r+0xea>
 8032252:	6823      	ldr	r3, [r4, #0]
 8032254:	4639      	mov	r1, r7
 8032256:	4630      	mov	r0, r6
 8032258:	eb04 0903 	add.w	r9, r4, r3
 803225c:	f000 ff54 	bl	8033108 <_sbrk_r>
 8032260:	4581      	cmp	r9, r0
 8032262:	d142      	bne.n	80322ea <_malloc_r+0xea>
 8032264:	6821      	ldr	r1, [r4, #0]
 8032266:	1a6d      	subs	r5, r5, r1
 8032268:	4629      	mov	r1, r5
 803226a:	4630      	mov	r0, r6
 803226c:	f7ff ffa6 	bl	80321bc <sbrk_aligned>
 8032270:	3001      	adds	r0, #1
 8032272:	d03a      	beq.n	80322ea <_malloc_r+0xea>
 8032274:	6823      	ldr	r3, [r4, #0]
 8032276:	442b      	add	r3, r5
 8032278:	6023      	str	r3, [r4, #0]
 803227a:	f8d8 3000 	ldr.w	r3, [r8]
 803227e:	685a      	ldr	r2, [r3, #4]
 8032280:	bb62      	cbnz	r2, 80322dc <_malloc_r+0xdc>
 8032282:	f8c8 7000 	str.w	r7, [r8]
 8032286:	e00f      	b.n	80322a8 <_malloc_r+0xa8>
 8032288:	6822      	ldr	r2, [r4, #0]
 803228a:	1b52      	subs	r2, r2, r5
 803228c:	d420      	bmi.n	80322d0 <_malloc_r+0xd0>
 803228e:	2a0b      	cmp	r2, #11
 8032290:	d917      	bls.n	80322c2 <_malloc_r+0xc2>
 8032292:	1961      	adds	r1, r4, r5
 8032294:	42a3      	cmp	r3, r4
 8032296:	6025      	str	r5, [r4, #0]
 8032298:	bf18      	it	ne
 803229a:	6059      	strne	r1, [r3, #4]
 803229c:	6863      	ldr	r3, [r4, #4]
 803229e:	bf08      	it	eq
 80322a0:	f8c8 1000 	streq.w	r1, [r8]
 80322a4:	5162      	str	r2, [r4, r5]
 80322a6:	604b      	str	r3, [r1, #4]
 80322a8:	4630      	mov	r0, r6
 80322aa:	f000 f82f 	bl	803230c <__malloc_unlock>
 80322ae:	f104 000b 	add.w	r0, r4, #11
 80322b2:	1d23      	adds	r3, r4, #4
 80322b4:	f020 0007 	bic.w	r0, r0, #7
 80322b8:	1ac2      	subs	r2, r0, r3
 80322ba:	bf1c      	itt	ne
 80322bc:	1a1b      	subne	r3, r3, r0
 80322be:	50a3      	strne	r3, [r4, r2]
 80322c0:	e7af      	b.n	8032222 <_malloc_r+0x22>
 80322c2:	6862      	ldr	r2, [r4, #4]
 80322c4:	42a3      	cmp	r3, r4
 80322c6:	bf0c      	ite	eq
 80322c8:	f8c8 2000 	streq.w	r2, [r8]
 80322cc:	605a      	strne	r2, [r3, #4]
 80322ce:	e7eb      	b.n	80322a8 <_malloc_r+0xa8>
 80322d0:	4623      	mov	r3, r4
 80322d2:	6864      	ldr	r4, [r4, #4]
 80322d4:	e7ae      	b.n	8032234 <_malloc_r+0x34>
 80322d6:	463c      	mov	r4, r7
 80322d8:	687f      	ldr	r7, [r7, #4]
 80322da:	e7b6      	b.n	803224a <_malloc_r+0x4a>
 80322dc:	461a      	mov	r2, r3
 80322de:	685b      	ldr	r3, [r3, #4]
 80322e0:	42a3      	cmp	r3, r4
 80322e2:	d1fb      	bne.n	80322dc <_malloc_r+0xdc>
 80322e4:	2300      	movs	r3, #0
 80322e6:	6053      	str	r3, [r2, #4]
 80322e8:	e7de      	b.n	80322a8 <_malloc_r+0xa8>
 80322ea:	230c      	movs	r3, #12
 80322ec:	6033      	str	r3, [r6, #0]
 80322ee:	4630      	mov	r0, r6
 80322f0:	f000 f80c 	bl	803230c <__malloc_unlock>
 80322f4:	e794      	b.n	8032220 <_malloc_r+0x20>
 80322f6:	6005      	str	r5, [r0, #0]
 80322f8:	e7d6      	b.n	80322a8 <_malloc_r+0xa8>
 80322fa:	bf00      	nop
 80322fc:	20012250 	.word	0x20012250

08032300 <__malloc_lock>:
 8032300:	4801      	ldr	r0, [pc, #4]	@ (8032308 <__malloc_lock+0x8>)
 8032302:	f000 bf4e 	b.w	80331a2 <__retarget_lock_acquire_recursive>
 8032306:	bf00      	nop
 8032308:	20012394 	.word	0x20012394

0803230c <__malloc_unlock>:
 803230c:	4801      	ldr	r0, [pc, #4]	@ (8032314 <__malloc_unlock+0x8>)
 803230e:	f000 bf49 	b.w	80331a4 <__retarget_lock_release_recursive>
 8032312:	bf00      	nop
 8032314:	20012394 	.word	0x20012394

08032318 <__cvt>:
 8032318:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 803231c:	ec57 6b10 	vmov	r6, r7, d0
 8032320:	2f00      	cmp	r7, #0
 8032322:	460c      	mov	r4, r1
 8032324:	4619      	mov	r1, r3
 8032326:	463b      	mov	r3, r7
 8032328:	bfbb      	ittet	lt
 803232a:	f107 4300 	addlt.w	r3, r7, #2147483648	@ 0x80000000
 803232e:	461f      	movlt	r7, r3
 8032330:	2300      	movge	r3, #0
 8032332:	232d      	movlt	r3, #45	@ 0x2d
 8032334:	700b      	strb	r3, [r1, #0]
 8032336:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 8032338:	f8dd a030 	ldr.w	sl, [sp, #48]	@ 0x30
 803233c:	4691      	mov	r9, r2
 803233e:	f023 0820 	bic.w	r8, r3, #32
 8032342:	bfbc      	itt	lt
 8032344:	4632      	movlt	r2, r6
 8032346:	4616      	movlt	r6, r2
 8032348:	f1b8 0f46 	cmp.w	r8, #70	@ 0x46
 803234c:	d005      	beq.n	803235a <__cvt+0x42>
 803234e:	f1b8 0f45 	cmp.w	r8, #69	@ 0x45
 8032352:	d100      	bne.n	8032356 <__cvt+0x3e>
 8032354:	3401      	adds	r4, #1
 8032356:	2102      	movs	r1, #2
 8032358:	e000      	b.n	803235c <__cvt+0x44>
 803235a:	2103      	movs	r1, #3
 803235c:	ab03      	add	r3, sp, #12
 803235e:	9301      	str	r3, [sp, #4]
 8032360:	ab02      	add	r3, sp, #8
 8032362:	9300      	str	r3, [sp, #0]
 8032364:	ec47 6b10 	vmov	d0, r6, r7
 8032368:	4653      	mov	r3, sl
 803236a:	4622      	mov	r2, r4
 803236c:	f000 ffb4 	bl	80332d8 <_dtoa_r>
 8032370:	f1b8 0f47 	cmp.w	r8, #71	@ 0x47
 8032374:	4605      	mov	r5, r0
 8032376:	d119      	bne.n	80323ac <__cvt+0x94>
 8032378:	f019 0f01 	tst.w	r9, #1
 803237c:	d00e      	beq.n	803239c <__cvt+0x84>
 803237e:	eb00 0904 	add.w	r9, r0, r4
 8032382:	2200      	movs	r2, #0
 8032384:	2300      	movs	r3, #0
 8032386:	4630      	mov	r0, r6
 8032388:	4639      	mov	r1, r7
 803238a:	f7de fad5 	bl	8010938 <__aeabi_dcmpeq>
 803238e:	b108      	cbz	r0, 8032394 <__cvt+0x7c>
 8032390:	f8cd 900c 	str.w	r9, [sp, #12]
 8032394:	2230      	movs	r2, #48	@ 0x30
 8032396:	9b03      	ldr	r3, [sp, #12]
 8032398:	454b      	cmp	r3, r9
 803239a:	d31e      	bcc.n	80323da <__cvt+0xc2>
 803239c:	9b03      	ldr	r3, [sp, #12]
 803239e:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
 80323a0:	1b5b      	subs	r3, r3, r5
 80323a2:	4628      	mov	r0, r5
 80323a4:	6013      	str	r3, [r2, #0]
 80323a6:	b004      	add	sp, #16
 80323a8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80323ac:	f1b8 0f46 	cmp.w	r8, #70	@ 0x46
 80323b0:	eb00 0904 	add.w	r9, r0, r4
 80323b4:	d1e5      	bne.n	8032382 <__cvt+0x6a>
 80323b6:	7803      	ldrb	r3, [r0, #0]
 80323b8:	2b30      	cmp	r3, #48	@ 0x30
 80323ba:	d10a      	bne.n	80323d2 <__cvt+0xba>
 80323bc:	2200      	movs	r2, #0
 80323be:	2300      	movs	r3, #0
 80323c0:	4630      	mov	r0, r6
 80323c2:	4639      	mov	r1, r7
 80323c4:	f7de fab8 	bl	8010938 <__aeabi_dcmpeq>
 80323c8:	b918      	cbnz	r0, 80323d2 <__cvt+0xba>
 80323ca:	f1c4 0401 	rsb	r4, r4, #1
 80323ce:	f8ca 4000 	str.w	r4, [sl]
 80323d2:	f8da 3000 	ldr.w	r3, [sl]
 80323d6:	4499      	add	r9, r3
 80323d8:	e7d3      	b.n	8032382 <__cvt+0x6a>
 80323da:	1c59      	adds	r1, r3, #1
 80323dc:	9103      	str	r1, [sp, #12]
 80323de:	701a      	strb	r2, [r3, #0]
 80323e0:	e7d9      	b.n	8032396 <__cvt+0x7e>

080323e2 <__exponent>:
 80323e2:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 80323e4:	2900      	cmp	r1, #0
 80323e6:	bfba      	itte	lt
 80323e8:	4249      	neglt	r1, r1
 80323ea:	232d      	movlt	r3, #45	@ 0x2d
 80323ec:	232b      	movge	r3, #43	@ 0x2b
 80323ee:	2909      	cmp	r1, #9
 80323f0:	7002      	strb	r2, [r0, #0]
 80323f2:	7043      	strb	r3, [r0, #1]
 80323f4:	dd29      	ble.n	803244a <__exponent+0x68>
 80323f6:	f10d 0307 	add.w	r3, sp, #7
 80323fa:	461d      	mov	r5, r3
 80323fc:	270a      	movs	r7, #10
 80323fe:	461a      	mov	r2, r3
 8032400:	fbb1 f6f7 	udiv	r6, r1, r7
 8032404:	fb07 1416 	mls	r4, r7, r6, r1
 8032408:	3430      	adds	r4, #48	@ 0x30
 803240a:	f802 4c01 	strb.w	r4, [r2, #-1]
 803240e:	460c      	mov	r4, r1
 8032410:	2c63      	cmp	r4, #99	@ 0x63
 8032412:	f103 33ff 	add.w	r3, r3, #4294967295
 8032416:	4631      	mov	r1, r6
 8032418:	dcf1      	bgt.n	80323fe <__exponent+0x1c>
 803241a:	3130      	adds	r1, #48	@ 0x30
 803241c:	1e94      	subs	r4, r2, #2
 803241e:	f803 1c01 	strb.w	r1, [r3, #-1]
 8032422:	1c41      	adds	r1, r0, #1
 8032424:	4623      	mov	r3, r4
 8032426:	42ab      	cmp	r3, r5
 8032428:	d30a      	bcc.n	8032440 <__exponent+0x5e>
 803242a:	f10d 0309 	add.w	r3, sp, #9
 803242e:	1a9b      	subs	r3, r3, r2
 8032430:	42ac      	cmp	r4, r5
 8032432:	bf88      	it	hi
 8032434:	2300      	movhi	r3, #0
 8032436:	3302      	adds	r3, #2
 8032438:	4403      	add	r3, r0
 803243a:	1a18      	subs	r0, r3, r0
 803243c:	b003      	add	sp, #12
 803243e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8032440:	f813 6b01 	ldrb.w	r6, [r3], #1
 8032444:	f801 6f01 	strb.w	r6, [r1, #1]!
 8032448:	e7ed      	b.n	8032426 <__exponent+0x44>
 803244a:	2330      	movs	r3, #48	@ 0x30
 803244c:	3130      	adds	r1, #48	@ 0x30
 803244e:	7083      	strb	r3, [r0, #2]
 8032450:	70c1      	strb	r1, [r0, #3]
 8032452:	1d03      	adds	r3, r0, #4
 8032454:	e7f1      	b.n	803243a <__exponent+0x58>
	...

08032458 <_printf_float>:
 8032458:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 803245c:	b08d      	sub	sp, #52	@ 0x34
 803245e:	460c      	mov	r4, r1
 8032460:	f8dd 8058 	ldr.w	r8, [sp, #88]	@ 0x58
 8032464:	4616      	mov	r6, r2
 8032466:	461f      	mov	r7, r3
 8032468:	4605      	mov	r5, r0
 803246a:	f000 fe01 	bl	8033070 <_localeconv_r>
 803246e:	6803      	ldr	r3, [r0, #0]
 8032470:	9304      	str	r3, [sp, #16]
 8032472:	4618      	mov	r0, r3
 8032474:	f7dd fe34 	bl	80100e0 <strlen>
 8032478:	2300      	movs	r3, #0
 803247a:	930a      	str	r3, [sp, #40]	@ 0x28
 803247c:	f8d8 3000 	ldr.w	r3, [r8]
 8032480:	9005      	str	r0, [sp, #20]
 8032482:	3307      	adds	r3, #7
 8032484:	f023 0307 	bic.w	r3, r3, #7
 8032488:	f103 0208 	add.w	r2, r3, #8
 803248c:	f894 a018 	ldrb.w	sl, [r4, #24]
 8032490:	f8d4 b000 	ldr.w	fp, [r4]
 8032494:	f8c8 2000 	str.w	r2, [r8]
 8032498:	e9d3 8900 	ldrd	r8, r9, [r3]
 803249c:	f029 4300 	bic.w	r3, r9, #2147483648	@ 0x80000000
 80324a0:	9307      	str	r3, [sp, #28]
 80324a2:	f8cd 8018 	str.w	r8, [sp, #24]
 80324a6:	e9c4 8912 	strd	r8, r9, [r4, #72]	@ 0x48
 80324aa:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 80324ae:	4b9c      	ldr	r3, [pc, #624]	@ (8032720 <_printf_float+0x2c8>)
 80324b0:	f04f 32ff 	mov.w	r2, #4294967295
 80324b4:	f7de fa72 	bl	801099c <__aeabi_dcmpun>
 80324b8:	bb70      	cbnz	r0, 8032518 <_printf_float+0xc0>
 80324ba:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 80324be:	4b98      	ldr	r3, [pc, #608]	@ (8032720 <_printf_float+0x2c8>)
 80324c0:	f04f 32ff 	mov.w	r2, #4294967295
 80324c4:	f7de fa4c 	bl	8010960 <__aeabi_dcmple>
 80324c8:	bb30      	cbnz	r0, 8032518 <_printf_float+0xc0>
 80324ca:	2200      	movs	r2, #0
 80324cc:	2300      	movs	r3, #0
 80324ce:	4640      	mov	r0, r8
 80324d0:	4649      	mov	r1, r9
 80324d2:	f7de fa3b 	bl	801094c <__aeabi_dcmplt>
 80324d6:	b110      	cbz	r0, 80324de <_printf_float+0x86>
 80324d8:	232d      	movs	r3, #45	@ 0x2d
 80324da:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 80324de:	4a91      	ldr	r2, [pc, #580]	@ (8032724 <_printf_float+0x2cc>)
 80324e0:	4b91      	ldr	r3, [pc, #580]	@ (8032728 <_printf_float+0x2d0>)
 80324e2:	f1ba 0f47 	cmp.w	sl, #71	@ 0x47
 80324e6:	bf94      	ite	ls
 80324e8:	4690      	movls	r8, r2
 80324ea:	4698      	movhi	r8, r3
 80324ec:	2303      	movs	r3, #3
 80324ee:	6123      	str	r3, [r4, #16]
 80324f0:	f02b 0304 	bic.w	r3, fp, #4
 80324f4:	6023      	str	r3, [r4, #0]
 80324f6:	f04f 0900 	mov.w	r9, #0
 80324fa:	9700      	str	r7, [sp, #0]
 80324fc:	4633      	mov	r3, r6
 80324fe:	aa0b      	add	r2, sp, #44	@ 0x2c
 8032500:	4621      	mov	r1, r4
 8032502:	4628      	mov	r0, r5
 8032504:	f000 f9d2 	bl	80328ac <_printf_common>
 8032508:	3001      	adds	r0, #1
 803250a:	f040 808d 	bne.w	8032628 <_printf_float+0x1d0>
 803250e:	f04f 30ff 	mov.w	r0, #4294967295
 8032512:	b00d      	add	sp, #52	@ 0x34
 8032514:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8032518:	4642      	mov	r2, r8
 803251a:	464b      	mov	r3, r9
 803251c:	4640      	mov	r0, r8
 803251e:	4649      	mov	r1, r9
 8032520:	f7de fa3c 	bl	801099c <__aeabi_dcmpun>
 8032524:	b140      	cbz	r0, 8032538 <_printf_float+0xe0>
 8032526:	464b      	mov	r3, r9
 8032528:	2b00      	cmp	r3, #0
 803252a:	bfbc      	itt	lt
 803252c:	232d      	movlt	r3, #45	@ 0x2d
 803252e:	f884 3043 	strblt.w	r3, [r4, #67]	@ 0x43
 8032532:	4a7e      	ldr	r2, [pc, #504]	@ (803272c <_printf_float+0x2d4>)
 8032534:	4b7e      	ldr	r3, [pc, #504]	@ (8032730 <_printf_float+0x2d8>)
 8032536:	e7d4      	b.n	80324e2 <_printf_float+0x8a>
 8032538:	6863      	ldr	r3, [r4, #4]
 803253a:	f00a 02df 	and.w	r2, sl, #223	@ 0xdf
 803253e:	9206      	str	r2, [sp, #24]
 8032540:	1c5a      	adds	r2, r3, #1
 8032542:	d13b      	bne.n	80325bc <_printf_float+0x164>
 8032544:	2306      	movs	r3, #6
 8032546:	6063      	str	r3, [r4, #4]
 8032548:	f44b 6280 	orr.w	r2, fp, #1024	@ 0x400
 803254c:	2300      	movs	r3, #0
 803254e:	6022      	str	r2, [r4, #0]
 8032550:	9303      	str	r3, [sp, #12]
 8032552:	ab0a      	add	r3, sp, #40	@ 0x28
 8032554:	e9cd a301 	strd	sl, r3, [sp, #4]
 8032558:	ab09      	add	r3, sp, #36	@ 0x24
 803255a:	9300      	str	r3, [sp, #0]
 803255c:	6861      	ldr	r1, [r4, #4]
 803255e:	ec49 8b10 	vmov	d0, r8, r9
 8032562:	f10d 0323 	add.w	r3, sp, #35	@ 0x23
 8032566:	4628      	mov	r0, r5
 8032568:	f7ff fed6 	bl	8032318 <__cvt>
 803256c:	9b06      	ldr	r3, [sp, #24]
 803256e:	9909      	ldr	r1, [sp, #36]	@ 0x24
 8032570:	2b47      	cmp	r3, #71	@ 0x47
 8032572:	4680      	mov	r8, r0
 8032574:	d129      	bne.n	80325ca <_printf_float+0x172>
 8032576:	1cc8      	adds	r0, r1, #3
 8032578:	db02      	blt.n	8032580 <_printf_float+0x128>
 803257a:	6863      	ldr	r3, [r4, #4]
 803257c:	4299      	cmp	r1, r3
 803257e:	dd41      	ble.n	8032604 <_printf_float+0x1ac>
 8032580:	f1aa 0a02 	sub.w	sl, sl, #2
 8032584:	fa5f fa8a 	uxtb.w	sl, sl
 8032588:	3901      	subs	r1, #1
 803258a:	4652      	mov	r2, sl
 803258c:	f104 0050 	add.w	r0, r4, #80	@ 0x50
 8032590:	9109      	str	r1, [sp, #36]	@ 0x24
 8032592:	f7ff ff26 	bl	80323e2 <__exponent>
 8032596:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 8032598:	1813      	adds	r3, r2, r0
 803259a:	2a01      	cmp	r2, #1
 803259c:	4681      	mov	r9, r0
 803259e:	6123      	str	r3, [r4, #16]
 80325a0:	dc02      	bgt.n	80325a8 <_printf_float+0x150>
 80325a2:	6822      	ldr	r2, [r4, #0]
 80325a4:	07d2      	lsls	r2, r2, #31
 80325a6:	d501      	bpl.n	80325ac <_printf_float+0x154>
 80325a8:	3301      	adds	r3, #1
 80325aa:	6123      	str	r3, [r4, #16]
 80325ac:	f89d 3023 	ldrb.w	r3, [sp, #35]	@ 0x23
 80325b0:	2b00      	cmp	r3, #0
 80325b2:	d0a2      	beq.n	80324fa <_printf_float+0xa2>
 80325b4:	232d      	movs	r3, #45	@ 0x2d
 80325b6:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 80325ba:	e79e      	b.n	80324fa <_printf_float+0xa2>
 80325bc:	9a06      	ldr	r2, [sp, #24]
 80325be:	2a47      	cmp	r2, #71	@ 0x47
 80325c0:	d1c2      	bne.n	8032548 <_printf_float+0xf0>
 80325c2:	2b00      	cmp	r3, #0
 80325c4:	d1c0      	bne.n	8032548 <_printf_float+0xf0>
 80325c6:	2301      	movs	r3, #1
 80325c8:	e7bd      	b.n	8032546 <_printf_float+0xee>
 80325ca:	f1ba 0f65 	cmp.w	sl, #101	@ 0x65
 80325ce:	d9db      	bls.n	8032588 <_printf_float+0x130>
 80325d0:	f1ba 0f66 	cmp.w	sl, #102	@ 0x66
 80325d4:	d118      	bne.n	8032608 <_printf_float+0x1b0>
 80325d6:	2900      	cmp	r1, #0
 80325d8:	6863      	ldr	r3, [r4, #4]
 80325da:	dd0b      	ble.n	80325f4 <_printf_float+0x19c>
 80325dc:	6121      	str	r1, [r4, #16]
 80325de:	b913      	cbnz	r3, 80325e6 <_printf_float+0x18e>
 80325e0:	6822      	ldr	r2, [r4, #0]
 80325e2:	07d0      	lsls	r0, r2, #31
 80325e4:	d502      	bpl.n	80325ec <_printf_float+0x194>
 80325e6:	3301      	adds	r3, #1
 80325e8:	440b      	add	r3, r1
 80325ea:	6123      	str	r3, [r4, #16]
 80325ec:	65a1      	str	r1, [r4, #88]	@ 0x58
 80325ee:	f04f 0900 	mov.w	r9, #0
 80325f2:	e7db      	b.n	80325ac <_printf_float+0x154>
 80325f4:	b913      	cbnz	r3, 80325fc <_printf_float+0x1a4>
 80325f6:	6822      	ldr	r2, [r4, #0]
 80325f8:	07d2      	lsls	r2, r2, #31
 80325fa:	d501      	bpl.n	8032600 <_printf_float+0x1a8>
 80325fc:	3302      	adds	r3, #2
 80325fe:	e7f4      	b.n	80325ea <_printf_float+0x192>
 8032600:	2301      	movs	r3, #1
 8032602:	e7f2      	b.n	80325ea <_printf_float+0x192>
 8032604:	f04f 0a67 	mov.w	sl, #103	@ 0x67
 8032608:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 803260a:	4299      	cmp	r1, r3
 803260c:	db05      	blt.n	803261a <_printf_float+0x1c2>
 803260e:	6823      	ldr	r3, [r4, #0]
 8032610:	6121      	str	r1, [r4, #16]
 8032612:	07d8      	lsls	r0, r3, #31
 8032614:	d5ea      	bpl.n	80325ec <_printf_float+0x194>
 8032616:	1c4b      	adds	r3, r1, #1
 8032618:	e7e7      	b.n	80325ea <_printf_float+0x192>
 803261a:	2900      	cmp	r1, #0
 803261c:	bfd4      	ite	le
 803261e:	f1c1 0202 	rsble	r2, r1, #2
 8032622:	2201      	movgt	r2, #1
 8032624:	4413      	add	r3, r2
 8032626:	e7e0      	b.n	80325ea <_printf_float+0x192>
 8032628:	6823      	ldr	r3, [r4, #0]
 803262a:	055a      	lsls	r2, r3, #21
 803262c:	d407      	bmi.n	803263e <_printf_float+0x1e6>
 803262e:	6923      	ldr	r3, [r4, #16]
 8032630:	4642      	mov	r2, r8
 8032632:	4631      	mov	r1, r6
 8032634:	4628      	mov	r0, r5
 8032636:	47b8      	blx	r7
 8032638:	3001      	adds	r0, #1
 803263a:	d12b      	bne.n	8032694 <_printf_float+0x23c>
 803263c:	e767      	b.n	803250e <_printf_float+0xb6>
 803263e:	f1ba 0f65 	cmp.w	sl, #101	@ 0x65
 8032642:	f240 80dd 	bls.w	8032800 <_printf_float+0x3a8>
 8032646:	e9d4 0112 	ldrd	r0, r1, [r4, #72]	@ 0x48
 803264a:	2200      	movs	r2, #0
 803264c:	2300      	movs	r3, #0
 803264e:	f7de f973 	bl	8010938 <__aeabi_dcmpeq>
 8032652:	2800      	cmp	r0, #0
 8032654:	d033      	beq.n	80326be <_printf_float+0x266>
 8032656:	4a37      	ldr	r2, [pc, #220]	@ (8032734 <_printf_float+0x2dc>)
 8032658:	2301      	movs	r3, #1
 803265a:	4631      	mov	r1, r6
 803265c:	4628      	mov	r0, r5
 803265e:	47b8      	blx	r7
 8032660:	3001      	adds	r0, #1
 8032662:	f43f af54 	beq.w	803250e <_printf_float+0xb6>
 8032666:	e9dd 3809 	ldrd	r3, r8, [sp, #36]	@ 0x24
 803266a:	4543      	cmp	r3, r8
 803266c:	db02      	blt.n	8032674 <_printf_float+0x21c>
 803266e:	6823      	ldr	r3, [r4, #0]
 8032670:	07d8      	lsls	r0, r3, #31
 8032672:	d50f      	bpl.n	8032694 <_printf_float+0x23c>
 8032674:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8032678:	4631      	mov	r1, r6
 803267a:	4628      	mov	r0, r5
 803267c:	47b8      	blx	r7
 803267e:	3001      	adds	r0, #1
 8032680:	f43f af45 	beq.w	803250e <_printf_float+0xb6>
 8032684:	f04f 0900 	mov.w	r9, #0
 8032688:	f108 38ff 	add.w	r8, r8, #4294967295
 803268c:	f104 0a1a 	add.w	sl, r4, #26
 8032690:	45c8      	cmp	r8, r9
 8032692:	dc09      	bgt.n	80326a8 <_printf_float+0x250>
 8032694:	6823      	ldr	r3, [r4, #0]
 8032696:	079b      	lsls	r3, r3, #30
 8032698:	f100 8103 	bmi.w	80328a2 <_printf_float+0x44a>
 803269c:	68e0      	ldr	r0, [r4, #12]
 803269e:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 80326a0:	4298      	cmp	r0, r3
 80326a2:	bfb8      	it	lt
 80326a4:	4618      	movlt	r0, r3
 80326a6:	e734      	b.n	8032512 <_printf_float+0xba>
 80326a8:	2301      	movs	r3, #1
 80326aa:	4652      	mov	r2, sl
 80326ac:	4631      	mov	r1, r6
 80326ae:	4628      	mov	r0, r5
 80326b0:	47b8      	blx	r7
 80326b2:	3001      	adds	r0, #1
 80326b4:	f43f af2b 	beq.w	803250e <_printf_float+0xb6>
 80326b8:	f109 0901 	add.w	r9, r9, #1
 80326bc:	e7e8      	b.n	8032690 <_printf_float+0x238>
 80326be:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80326c0:	2b00      	cmp	r3, #0
 80326c2:	dc39      	bgt.n	8032738 <_printf_float+0x2e0>
 80326c4:	4a1b      	ldr	r2, [pc, #108]	@ (8032734 <_printf_float+0x2dc>)
 80326c6:	2301      	movs	r3, #1
 80326c8:	4631      	mov	r1, r6
 80326ca:	4628      	mov	r0, r5
 80326cc:	47b8      	blx	r7
 80326ce:	3001      	adds	r0, #1
 80326d0:	f43f af1d 	beq.w	803250e <_printf_float+0xb6>
 80326d4:	e9dd 3909 	ldrd	r3, r9, [sp, #36]	@ 0x24
 80326d8:	ea59 0303 	orrs.w	r3, r9, r3
 80326dc:	d102      	bne.n	80326e4 <_printf_float+0x28c>
 80326de:	6823      	ldr	r3, [r4, #0]
 80326e0:	07d9      	lsls	r1, r3, #31
 80326e2:	d5d7      	bpl.n	8032694 <_printf_float+0x23c>
 80326e4:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 80326e8:	4631      	mov	r1, r6
 80326ea:	4628      	mov	r0, r5
 80326ec:	47b8      	blx	r7
 80326ee:	3001      	adds	r0, #1
 80326f0:	f43f af0d 	beq.w	803250e <_printf_float+0xb6>
 80326f4:	f04f 0a00 	mov.w	sl, #0
 80326f8:	f104 0b1a 	add.w	fp, r4, #26
 80326fc:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80326fe:	425b      	negs	r3, r3
 8032700:	4553      	cmp	r3, sl
 8032702:	dc01      	bgt.n	8032708 <_printf_float+0x2b0>
 8032704:	464b      	mov	r3, r9
 8032706:	e793      	b.n	8032630 <_printf_float+0x1d8>
 8032708:	2301      	movs	r3, #1
 803270a:	465a      	mov	r2, fp
 803270c:	4631      	mov	r1, r6
 803270e:	4628      	mov	r0, r5
 8032710:	47b8      	blx	r7
 8032712:	3001      	adds	r0, #1
 8032714:	f43f aefb 	beq.w	803250e <_printf_float+0xb6>
 8032718:	f10a 0a01 	add.w	sl, sl, #1
 803271c:	e7ee      	b.n	80326fc <_printf_float+0x2a4>
 803271e:	bf00      	nop
 8032720:	7fefffff 	.word	0x7fefffff
 8032724:	08083a7d 	.word	0x08083a7d
 8032728:	08083a81 	.word	0x08083a81
 803272c:	08083a85 	.word	0x08083a85
 8032730:	08083a89 	.word	0x08083a89
 8032734:	08083a8d 	.word	0x08083a8d
 8032738:	6da3      	ldr	r3, [r4, #88]	@ 0x58
 803273a:	f8dd a028 	ldr.w	sl, [sp, #40]	@ 0x28
 803273e:	4553      	cmp	r3, sl
 8032740:	bfa8      	it	ge
 8032742:	4653      	movge	r3, sl
 8032744:	2b00      	cmp	r3, #0
 8032746:	4699      	mov	r9, r3
 8032748:	dc36      	bgt.n	80327b8 <_printf_float+0x360>
 803274a:	f04f 0b00 	mov.w	fp, #0
 803274e:	ea29 79e9 	bic.w	r9, r9, r9, asr #31
 8032752:	f104 021a 	add.w	r2, r4, #26
 8032756:	6da3      	ldr	r3, [r4, #88]	@ 0x58
 8032758:	9306      	str	r3, [sp, #24]
 803275a:	eba3 0309 	sub.w	r3, r3, r9
 803275e:	455b      	cmp	r3, fp
 8032760:	dc31      	bgt.n	80327c6 <_printf_float+0x36e>
 8032762:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8032764:	459a      	cmp	sl, r3
 8032766:	dc3a      	bgt.n	80327de <_printf_float+0x386>
 8032768:	6823      	ldr	r3, [r4, #0]
 803276a:	07da      	lsls	r2, r3, #31
 803276c:	d437      	bmi.n	80327de <_printf_float+0x386>
 803276e:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8032770:	ebaa 0903 	sub.w	r9, sl, r3
 8032774:	9b06      	ldr	r3, [sp, #24]
 8032776:	ebaa 0303 	sub.w	r3, sl, r3
 803277a:	4599      	cmp	r9, r3
 803277c:	bfa8      	it	ge
 803277e:	4699      	movge	r9, r3
 8032780:	f1b9 0f00 	cmp.w	r9, #0
 8032784:	dc33      	bgt.n	80327ee <_printf_float+0x396>
 8032786:	f04f 0800 	mov.w	r8, #0
 803278a:	ea29 79e9 	bic.w	r9, r9, r9, asr #31
 803278e:	f104 0b1a 	add.w	fp, r4, #26
 8032792:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8032794:	ebaa 0303 	sub.w	r3, sl, r3
 8032798:	eba3 0309 	sub.w	r3, r3, r9
 803279c:	4543      	cmp	r3, r8
 803279e:	f77f af79 	ble.w	8032694 <_printf_float+0x23c>
 80327a2:	2301      	movs	r3, #1
 80327a4:	465a      	mov	r2, fp
 80327a6:	4631      	mov	r1, r6
 80327a8:	4628      	mov	r0, r5
 80327aa:	47b8      	blx	r7
 80327ac:	3001      	adds	r0, #1
 80327ae:	f43f aeae 	beq.w	803250e <_printf_float+0xb6>
 80327b2:	f108 0801 	add.w	r8, r8, #1
 80327b6:	e7ec      	b.n	8032792 <_printf_float+0x33a>
 80327b8:	4642      	mov	r2, r8
 80327ba:	4631      	mov	r1, r6
 80327bc:	4628      	mov	r0, r5
 80327be:	47b8      	blx	r7
 80327c0:	3001      	adds	r0, #1
 80327c2:	d1c2      	bne.n	803274a <_printf_float+0x2f2>
 80327c4:	e6a3      	b.n	803250e <_printf_float+0xb6>
 80327c6:	2301      	movs	r3, #1
 80327c8:	4631      	mov	r1, r6
 80327ca:	4628      	mov	r0, r5
 80327cc:	9206      	str	r2, [sp, #24]
 80327ce:	47b8      	blx	r7
 80327d0:	3001      	adds	r0, #1
 80327d2:	f43f ae9c 	beq.w	803250e <_printf_float+0xb6>
 80327d6:	9a06      	ldr	r2, [sp, #24]
 80327d8:	f10b 0b01 	add.w	fp, fp, #1
 80327dc:	e7bb      	b.n	8032756 <_printf_float+0x2fe>
 80327de:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 80327e2:	4631      	mov	r1, r6
 80327e4:	4628      	mov	r0, r5
 80327e6:	47b8      	blx	r7
 80327e8:	3001      	adds	r0, #1
 80327ea:	d1c0      	bne.n	803276e <_printf_float+0x316>
 80327ec:	e68f      	b.n	803250e <_printf_float+0xb6>
 80327ee:	9a06      	ldr	r2, [sp, #24]
 80327f0:	464b      	mov	r3, r9
 80327f2:	4442      	add	r2, r8
 80327f4:	4631      	mov	r1, r6
 80327f6:	4628      	mov	r0, r5
 80327f8:	47b8      	blx	r7
 80327fa:	3001      	adds	r0, #1
 80327fc:	d1c3      	bne.n	8032786 <_printf_float+0x32e>
 80327fe:	e686      	b.n	803250e <_printf_float+0xb6>
 8032800:	f8dd a028 	ldr.w	sl, [sp, #40]	@ 0x28
 8032804:	f1ba 0f01 	cmp.w	sl, #1
 8032808:	dc01      	bgt.n	803280e <_printf_float+0x3b6>
 803280a:	07db      	lsls	r3, r3, #31
 803280c:	d536      	bpl.n	803287c <_printf_float+0x424>
 803280e:	2301      	movs	r3, #1
 8032810:	4642      	mov	r2, r8
 8032812:	4631      	mov	r1, r6
 8032814:	4628      	mov	r0, r5
 8032816:	47b8      	blx	r7
 8032818:	3001      	adds	r0, #1
 803281a:	f43f ae78 	beq.w	803250e <_printf_float+0xb6>
 803281e:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8032822:	4631      	mov	r1, r6
 8032824:	4628      	mov	r0, r5
 8032826:	47b8      	blx	r7
 8032828:	3001      	adds	r0, #1
 803282a:	f43f ae70 	beq.w	803250e <_printf_float+0xb6>
 803282e:	e9d4 0112 	ldrd	r0, r1, [r4, #72]	@ 0x48
 8032832:	2200      	movs	r2, #0
 8032834:	2300      	movs	r3, #0
 8032836:	f10a 3aff 	add.w	sl, sl, #4294967295
 803283a:	f7de f87d 	bl	8010938 <__aeabi_dcmpeq>
 803283e:	b9c0      	cbnz	r0, 8032872 <_printf_float+0x41a>
 8032840:	4653      	mov	r3, sl
 8032842:	f108 0201 	add.w	r2, r8, #1
 8032846:	4631      	mov	r1, r6
 8032848:	4628      	mov	r0, r5
 803284a:	47b8      	blx	r7
 803284c:	3001      	adds	r0, #1
 803284e:	d10c      	bne.n	803286a <_printf_float+0x412>
 8032850:	e65d      	b.n	803250e <_printf_float+0xb6>
 8032852:	2301      	movs	r3, #1
 8032854:	465a      	mov	r2, fp
 8032856:	4631      	mov	r1, r6
 8032858:	4628      	mov	r0, r5
 803285a:	47b8      	blx	r7
 803285c:	3001      	adds	r0, #1
 803285e:	f43f ae56 	beq.w	803250e <_printf_float+0xb6>
 8032862:	f108 0801 	add.w	r8, r8, #1
 8032866:	45d0      	cmp	r8, sl
 8032868:	dbf3      	blt.n	8032852 <_printf_float+0x3fa>
 803286a:	464b      	mov	r3, r9
 803286c:	f104 0250 	add.w	r2, r4, #80	@ 0x50
 8032870:	e6df      	b.n	8032632 <_printf_float+0x1da>
 8032872:	f04f 0800 	mov.w	r8, #0
 8032876:	f104 0b1a 	add.w	fp, r4, #26
 803287a:	e7f4      	b.n	8032866 <_printf_float+0x40e>
 803287c:	2301      	movs	r3, #1
 803287e:	4642      	mov	r2, r8
 8032880:	e7e1      	b.n	8032846 <_printf_float+0x3ee>
 8032882:	2301      	movs	r3, #1
 8032884:	464a      	mov	r2, r9
 8032886:	4631      	mov	r1, r6
 8032888:	4628      	mov	r0, r5
 803288a:	47b8      	blx	r7
 803288c:	3001      	adds	r0, #1
 803288e:	f43f ae3e 	beq.w	803250e <_printf_float+0xb6>
 8032892:	f108 0801 	add.w	r8, r8, #1
 8032896:	68e3      	ldr	r3, [r4, #12]
 8032898:	990b      	ldr	r1, [sp, #44]	@ 0x2c
 803289a:	1a5b      	subs	r3, r3, r1
 803289c:	4543      	cmp	r3, r8
 803289e:	dcf0      	bgt.n	8032882 <_printf_float+0x42a>
 80328a0:	e6fc      	b.n	803269c <_printf_float+0x244>
 80328a2:	f04f 0800 	mov.w	r8, #0
 80328a6:	f104 0919 	add.w	r9, r4, #25
 80328aa:	e7f4      	b.n	8032896 <_printf_float+0x43e>

080328ac <_printf_common>:
 80328ac:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80328b0:	4616      	mov	r6, r2
 80328b2:	4698      	mov	r8, r3
 80328b4:	688a      	ldr	r2, [r1, #8]
 80328b6:	690b      	ldr	r3, [r1, #16]
 80328b8:	f8dd 9020 	ldr.w	r9, [sp, #32]
 80328bc:	4293      	cmp	r3, r2
 80328be:	bfb8      	it	lt
 80328c0:	4613      	movlt	r3, r2
 80328c2:	6033      	str	r3, [r6, #0]
 80328c4:	f891 2043 	ldrb.w	r2, [r1, #67]	@ 0x43
 80328c8:	4607      	mov	r7, r0
 80328ca:	460c      	mov	r4, r1
 80328cc:	b10a      	cbz	r2, 80328d2 <_printf_common+0x26>
 80328ce:	3301      	adds	r3, #1
 80328d0:	6033      	str	r3, [r6, #0]
 80328d2:	6823      	ldr	r3, [r4, #0]
 80328d4:	0699      	lsls	r1, r3, #26
 80328d6:	bf42      	ittt	mi
 80328d8:	6833      	ldrmi	r3, [r6, #0]
 80328da:	3302      	addmi	r3, #2
 80328dc:	6033      	strmi	r3, [r6, #0]
 80328de:	6825      	ldr	r5, [r4, #0]
 80328e0:	f015 0506 	ands.w	r5, r5, #6
 80328e4:	d106      	bne.n	80328f4 <_printf_common+0x48>
 80328e6:	f104 0a19 	add.w	sl, r4, #25
 80328ea:	68e3      	ldr	r3, [r4, #12]
 80328ec:	6832      	ldr	r2, [r6, #0]
 80328ee:	1a9b      	subs	r3, r3, r2
 80328f0:	42ab      	cmp	r3, r5
 80328f2:	dc26      	bgt.n	8032942 <_printf_common+0x96>
 80328f4:	f894 3043 	ldrb.w	r3, [r4, #67]	@ 0x43
 80328f8:	6822      	ldr	r2, [r4, #0]
 80328fa:	3b00      	subs	r3, #0
 80328fc:	bf18      	it	ne
 80328fe:	2301      	movne	r3, #1
 8032900:	0692      	lsls	r2, r2, #26
 8032902:	d42b      	bmi.n	803295c <_printf_common+0xb0>
 8032904:	f104 0243 	add.w	r2, r4, #67	@ 0x43
 8032908:	4641      	mov	r1, r8
 803290a:	4638      	mov	r0, r7
 803290c:	47c8      	blx	r9
 803290e:	3001      	adds	r0, #1
 8032910:	d01e      	beq.n	8032950 <_printf_common+0xa4>
 8032912:	6823      	ldr	r3, [r4, #0]
 8032914:	6922      	ldr	r2, [r4, #16]
 8032916:	f003 0306 	and.w	r3, r3, #6
 803291a:	2b04      	cmp	r3, #4
 803291c:	bf02      	ittt	eq
 803291e:	68e5      	ldreq	r5, [r4, #12]
 8032920:	6833      	ldreq	r3, [r6, #0]
 8032922:	1aed      	subeq	r5, r5, r3
 8032924:	68a3      	ldr	r3, [r4, #8]
 8032926:	bf0c      	ite	eq
 8032928:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 803292c:	2500      	movne	r5, #0
 803292e:	4293      	cmp	r3, r2
 8032930:	bfc4      	itt	gt
 8032932:	1a9b      	subgt	r3, r3, r2
 8032934:	18ed      	addgt	r5, r5, r3
 8032936:	2600      	movs	r6, #0
 8032938:	341a      	adds	r4, #26
 803293a:	42b5      	cmp	r5, r6
 803293c:	d11a      	bne.n	8032974 <_printf_common+0xc8>
 803293e:	2000      	movs	r0, #0
 8032940:	e008      	b.n	8032954 <_printf_common+0xa8>
 8032942:	2301      	movs	r3, #1
 8032944:	4652      	mov	r2, sl
 8032946:	4641      	mov	r1, r8
 8032948:	4638      	mov	r0, r7
 803294a:	47c8      	blx	r9
 803294c:	3001      	adds	r0, #1
 803294e:	d103      	bne.n	8032958 <_printf_common+0xac>
 8032950:	f04f 30ff 	mov.w	r0, #4294967295
 8032954:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8032958:	3501      	adds	r5, #1
 803295a:	e7c6      	b.n	80328ea <_printf_common+0x3e>
 803295c:	18e1      	adds	r1, r4, r3
 803295e:	1c5a      	adds	r2, r3, #1
 8032960:	2030      	movs	r0, #48	@ 0x30
 8032962:	f881 0043 	strb.w	r0, [r1, #67]	@ 0x43
 8032966:	4422      	add	r2, r4
 8032968:	f894 1045 	ldrb.w	r1, [r4, #69]	@ 0x45
 803296c:	f882 1043 	strb.w	r1, [r2, #67]	@ 0x43
 8032970:	3302      	adds	r3, #2
 8032972:	e7c7      	b.n	8032904 <_printf_common+0x58>
 8032974:	2301      	movs	r3, #1
 8032976:	4622      	mov	r2, r4
 8032978:	4641      	mov	r1, r8
 803297a:	4638      	mov	r0, r7
 803297c:	47c8      	blx	r9
 803297e:	3001      	adds	r0, #1
 8032980:	d0e6      	beq.n	8032950 <_printf_common+0xa4>
 8032982:	3601      	adds	r6, #1
 8032984:	e7d9      	b.n	803293a <_printf_common+0x8e>
	...

08032988 <_printf_i>:
 8032988:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 803298c:	7e0f      	ldrb	r7, [r1, #24]
 803298e:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
 8032990:	2f78      	cmp	r7, #120	@ 0x78
 8032992:	4691      	mov	r9, r2
 8032994:	4680      	mov	r8, r0
 8032996:	460c      	mov	r4, r1
 8032998:	469a      	mov	sl, r3
 803299a:	f101 0243 	add.w	r2, r1, #67	@ 0x43
 803299e:	d807      	bhi.n	80329b0 <_printf_i+0x28>
 80329a0:	2f62      	cmp	r7, #98	@ 0x62
 80329a2:	d80a      	bhi.n	80329ba <_printf_i+0x32>
 80329a4:	2f00      	cmp	r7, #0
 80329a6:	f000 80d2 	beq.w	8032b4e <_printf_i+0x1c6>
 80329aa:	2f58      	cmp	r7, #88	@ 0x58
 80329ac:	f000 80b9 	beq.w	8032b22 <_printf_i+0x19a>
 80329b0:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 80329b4:	f884 7042 	strb.w	r7, [r4, #66]	@ 0x42
 80329b8:	e03a      	b.n	8032a30 <_printf_i+0xa8>
 80329ba:	f1a7 0363 	sub.w	r3, r7, #99	@ 0x63
 80329be:	2b15      	cmp	r3, #21
 80329c0:	d8f6      	bhi.n	80329b0 <_printf_i+0x28>
 80329c2:	a101      	add	r1, pc, #4	@ (adr r1, 80329c8 <_printf_i+0x40>)
 80329c4:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 80329c8:	08032a21 	.word	0x08032a21
 80329cc:	08032a35 	.word	0x08032a35
 80329d0:	080329b1 	.word	0x080329b1
 80329d4:	080329b1 	.word	0x080329b1
 80329d8:	080329b1 	.word	0x080329b1
 80329dc:	080329b1 	.word	0x080329b1
 80329e0:	08032a35 	.word	0x08032a35
 80329e4:	080329b1 	.word	0x080329b1
 80329e8:	080329b1 	.word	0x080329b1
 80329ec:	080329b1 	.word	0x080329b1
 80329f0:	080329b1 	.word	0x080329b1
 80329f4:	08032b35 	.word	0x08032b35
 80329f8:	08032a5f 	.word	0x08032a5f
 80329fc:	08032aef 	.word	0x08032aef
 8032a00:	080329b1 	.word	0x080329b1
 8032a04:	080329b1 	.word	0x080329b1
 8032a08:	08032b57 	.word	0x08032b57
 8032a0c:	080329b1 	.word	0x080329b1
 8032a10:	08032a5f 	.word	0x08032a5f
 8032a14:	080329b1 	.word	0x080329b1
 8032a18:	080329b1 	.word	0x080329b1
 8032a1c:	08032af7 	.word	0x08032af7
 8032a20:	6833      	ldr	r3, [r6, #0]
 8032a22:	1d1a      	adds	r2, r3, #4
 8032a24:	681b      	ldr	r3, [r3, #0]
 8032a26:	6032      	str	r2, [r6, #0]
 8032a28:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 8032a2c:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
 8032a30:	2301      	movs	r3, #1
 8032a32:	e09d      	b.n	8032b70 <_printf_i+0x1e8>
 8032a34:	6833      	ldr	r3, [r6, #0]
 8032a36:	6820      	ldr	r0, [r4, #0]
 8032a38:	1d19      	adds	r1, r3, #4
 8032a3a:	6031      	str	r1, [r6, #0]
 8032a3c:	0606      	lsls	r6, r0, #24
 8032a3e:	d501      	bpl.n	8032a44 <_printf_i+0xbc>
 8032a40:	681d      	ldr	r5, [r3, #0]
 8032a42:	e003      	b.n	8032a4c <_printf_i+0xc4>
 8032a44:	0645      	lsls	r5, r0, #25
 8032a46:	d5fb      	bpl.n	8032a40 <_printf_i+0xb8>
 8032a48:	f9b3 5000 	ldrsh.w	r5, [r3]
 8032a4c:	2d00      	cmp	r5, #0
 8032a4e:	da03      	bge.n	8032a58 <_printf_i+0xd0>
 8032a50:	232d      	movs	r3, #45	@ 0x2d
 8032a52:	426d      	negs	r5, r5
 8032a54:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 8032a58:	4859      	ldr	r0, [pc, #356]	@ (8032bc0 <_printf_i+0x238>)
 8032a5a:	230a      	movs	r3, #10
 8032a5c:	e011      	b.n	8032a82 <_printf_i+0xfa>
 8032a5e:	6821      	ldr	r1, [r4, #0]
 8032a60:	6833      	ldr	r3, [r6, #0]
 8032a62:	0608      	lsls	r0, r1, #24
 8032a64:	f853 5b04 	ldr.w	r5, [r3], #4
 8032a68:	d402      	bmi.n	8032a70 <_printf_i+0xe8>
 8032a6a:	0649      	lsls	r1, r1, #25
 8032a6c:	bf48      	it	mi
 8032a6e:	b2ad      	uxthmi	r5, r5
 8032a70:	2f6f      	cmp	r7, #111	@ 0x6f
 8032a72:	4853      	ldr	r0, [pc, #332]	@ (8032bc0 <_printf_i+0x238>)
 8032a74:	6033      	str	r3, [r6, #0]
 8032a76:	bf14      	ite	ne
 8032a78:	230a      	movne	r3, #10
 8032a7a:	2308      	moveq	r3, #8
 8032a7c:	2100      	movs	r1, #0
 8032a7e:	f884 1043 	strb.w	r1, [r4, #67]	@ 0x43
 8032a82:	6866      	ldr	r6, [r4, #4]
 8032a84:	60a6      	str	r6, [r4, #8]
 8032a86:	2e00      	cmp	r6, #0
 8032a88:	bfa2      	ittt	ge
 8032a8a:	6821      	ldrge	r1, [r4, #0]
 8032a8c:	f021 0104 	bicge.w	r1, r1, #4
 8032a90:	6021      	strge	r1, [r4, #0]
 8032a92:	b90d      	cbnz	r5, 8032a98 <_printf_i+0x110>
 8032a94:	2e00      	cmp	r6, #0
 8032a96:	d04b      	beq.n	8032b30 <_printf_i+0x1a8>
 8032a98:	4616      	mov	r6, r2
 8032a9a:	fbb5 f1f3 	udiv	r1, r5, r3
 8032a9e:	fb03 5711 	mls	r7, r3, r1, r5
 8032aa2:	5dc7      	ldrb	r7, [r0, r7]
 8032aa4:	f806 7d01 	strb.w	r7, [r6, #-1]!
 8032aa8:	462f      	mov	r7, r5
 8032aaa:	42bb      	cmp	r3, r7
 8032aac:	460d      	mov	r5, r1
 8032aae:	d9f4      	bls.n	8032a9a <_printf_i+0x112>
 8032ab0:	2b08      	cmp	r3, #8
 8032ab2:	d10b      	bne.n	8032acc <_printf_i+0x144>
 8032ab4:	6823      	ldr	r3, [r4, #0]
 8032ab6:	07df      	lsls	r7, r3, #31
 8032ab8:	d508      	bpl.n	8032acc <_printf_i+0x144>
 8032aba:	6923      	ldr	r3, [r4, #16]
 8032abc:	6861      	ldr	r1, [r4, #4]
 8032abe:	4299      	cmp	r1, r3
 8032ac0:	bfde      	ittt	le
 8032ac2:	2330      	movle	r3, #48	@ 0x30
 8032ac4:	f806 3c01 	strble.w	r3, [r6, #-1]
 8032ac8:	f106 36ff 	addle.w	r6, r6, #4294967295
 8032acc:	1b92      	subs	r2, r2, r6
 8032ace:	6122      	str	r2, [r4, #16]
 8032ad0:	f8cd a000 	str.w	sl, [sp]
 8032ad4:	464b      	mov	r3, r9
 8032ad6:	aa03      	add	r2, sp, #12
 8032ad8:	4621      	mov	r1, r4
 8032ada:	4640      	mov	r0, r8
 8032adc:	f7ff fee6 	bl	80328ac <_printf_common>
 8032ae0:	3001      	adds	r0, #1
 8032ae2:	d14a      	bne.n	8032b7a <_printf_i+0x1f2>
 8032ae4:	f04f 30ff 	mov.w	r0, #4294967295
 8032ae8:	b004      	add	sp, #16
 8032aea:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8032aee:	6823      	ldr	r3, [r4, #0]
 8032af0:	f043 0320 	orr.w	r3, r3, #32
 8032af4:	6023      	str	r3, [r4, #0]
 8032af6:	4833      	ldr	r0, [pc, #204]	@ (8032bc4 <_printf_i+0x23c>)
 8032af8:	2778      	movs	r7, #120	@ 0x78
 8032afa:	f884 7045 	strb.w	r7, [r4, #69]	@ 0x45
 8032afe:	6823      	ldr	r3, [r4, #0]
 8032b00:	6831      	ldr	r1, [r6, #0]
 8032b02:	061f      	lsls	r7, r3, #24
 8032b04:	f851 5b04 	ldr.w	r5, [r1], #4
 8032b08:	d402      	bmi.n	8032b10 <_printf_i+0x188>
 8032b0a:	065f      	lsls	r7, r3, #25
 8032b0c:	bf48      	it	mi
 8032b0e:	b2ad      	uxthmi	r5, r5
 8032b10:	6031      	str	r1, [r6, #0]
 8032b12:	07d9      	lsls	r1, r3, #31
 8032b14:	bf44      	itt	mi
 8032b16:	f043 0320 	orrmi.w	r3, r3, #32
 8032b1a:	6023      	strmi	r3, [r4, #0]
 8032b1c:	b11d      	cbz	r5, 8032b26 <_printf_i+0x19e>
 8032b1e:	2310      	movs	r3, #16
 8032b20:	e7ac      	b.n	8032a7c <_printf_i+0xf4>
 8032b22:	4827      	ldr	r0, [pc, #156]	@ (8032bc0 <_printf_i+0x238>)
 8032b24:	e7e9      	b.n	8032afa <_printf_i+0x172>
 8032b26:	6823      	ldr	r3, [r4, #0]
 8032b28:	f023 0320 	bic.w	r3, r3, #32
 8032b2c:	6023      	str	r3, [r4, #0]
 8032b2e:	e7f6      	b.n	8032b1e <_printf_i+0x196>
 8032b30:	4616      	mov	r6, r2
 8032b32:	e7bd      	b.n	8032ab0 <_printf_i+0x128>
 8032b34:	6833      	ldr	r3, [r6, #0]
 8032b36:	6825      	ldr	r5, [r4, #0]
 8032b38:	6961      	ldr	r1, [r4, #20]
 8032b3a:	1d18      	adds	r0, r3, #4
 8032b3c:	6030      	str	r0, [r6, #0]
 8032b3e:	062e      	lsls	r6, r5, #24
 8032b40:	681b      	ldr	r3, [r3, #0]
 8032b42:	d501      	bpl.n	8032b48 <_printf_i+0x1c0>
 8032b44:	6019      	str	r1, [r3, #0]
 8032b46:	e002      	b.n	8032b4e <_printf_i+0x1c6>
 8032b48:	0668      	lsls	r0, r5, #25
 8032b4a:	d5fb      	bpl.n	8032b44 <_printf_i+0x1bc>
 8032b4c:	8019      	strh	r1, [r3, #0]
 8032b4e:	2300      	movs	r3, #0
 8032b50:	6123      	str	r3, [r4, #16]
 8032b52:	4616      	mov	r6, r2
 8032b54:	e7bc      	b.n	8032ad0 <_printf_i+0x148>
 8032b56:	6833      	ldr	r3, [r6, #0]
 8032b58:	1d1a      	adds	r2, r3, #4
 8032b5a:	6032      	str	r2, [r6, #0]
 8032b5c:	681e      	ldr	r6, [r3, #0]
 8032b5e:	6862      	ldr	r2, [r4, #4]
 8032b60:	2100      	movs	r1, #0
 8032b62:	4630      	mov	r0, r6
 8032b64:	f7dd fa6c 	bl	8010040 <memchr>
 8032b68:	b108      	cbz	r0, 8032b6e <_printf_i+0x1e6>
 8032b6a:	1b80      	subs	r0, r0, r6
 8032b6c:	6060      	str	r0, [r4, #4]
 8032b6e:	6863      	ldr	r3, [r4, #4]
 8032b70:	6123      	str	r3, [r4, #16]
 8032b72:	2300      	movs	r3, #0
 8032b74:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 8032b78:	e7aa      	b.n	8032ad0 <_printf_i+0x148>
 8032b7a:	6923      	ldr	r3, [r4, #16]
 8032b7c:	4632      	mov	r2, r6
 8032b7e:	4649      	mov	r1, r9
 8032b80:	4640      	mov	r0, r8
 8032b82:	47d0      	blx	sl
 8032b84:	3001      	adds	r0, #1
 8032b86:	d0ad      	beq.n	8032ae4 <_printf_i+0x15c>
 8032b88:	6823      	ldr	r3, [r4, #0]
 8032b8a:	079b      	lsls	r3, r3, #30
 8032b8c:	d413      	bmi.n	8032bb6 <_printf_i+0x22e>
 8032b8e:	68e0      	ldr	r0, [r4, #12]
 8032b90:	9b03      	ldr	r3, [sp, #12]
 8032b92:	4298      	cmp	r0, r3
 8032b94:	bfb8      	it	lt
 8032b96:	4618      	movlt	r0, r3
 8032b98:	e7a6      	b.n	8032ae8 <_printf_i+0x160>
 8032b9a:	2301      	movs	r3, #1
 8032b9c:	4632      	mov	r2, r6
 8032b9e:	4649      	mov	r1, r9
 8032ba0:	4640      	mov	r0, r8
 8032ba2:	47d0      	blx	sl
 8032ba4:	3001      	adds	r0, #1
 8032ba6:	d09d      	beq.n	8032ae4 <_printf_i+0x15c>
 8032ba8:	3501      	adds	r5, #1
 8032baa:	68e3      	ldr	r3, [r4, #12]
 8032bac:	9903      	ldr	r1, [sp, #12]
 8032bae:	1a5b      	subs	r3, r3, r1
 8032bb0:	42ab      	cmp	r3, r5
 8032bb2:	dcf2      	bgt.n	8032b9a <_printf_i+0x212>
 8032bb4:	e7eb      	b.n	8032b8e <_printf_i+0x206>
 8032bb6:	2500      	movs	r5, #0
 8032bb8:	f104 0619 	add.w	r6, r4, #25
 8032bbc:	e7f5      	b.n	8032baa <_printf_i+0x222>
 8032bbe:	bf00      	nop
 8032bc0:	08083a8f 	.word	0x08083a8f
 8032bc4:	08083aa0 	.word	0x08083aa0

08032bc8 <std>:
 8032bc8:	2300      	movs	r3, #0
 8032bca:	b510      	push	{r4, lr}
 8032bcc:	4604      	mov	r4, r0
 8032bce:	e9c0 3300 	strd	r3, r3, [r0]
 8032bd2:	e9c0 3304 	strd	r3, r3, [r0, #16]
 8032bd6:	6083      	str	r3, [r0, #8]
 8032bd8:	8181      	strh	r1, [r0, #12]
 8032bda:	6643      	str	r3, [r0, #100]	@ 0x64
 8032bdc:	81c2      	strh	r2, [r0, #14]
 8032bde:	6183      	str	r3, [r0, #24]
 8032be0:	4619      	mov	r1, r3
 8032be2:	2208      	movs	r2, #8
 8032be4:	305c      	adds	r0, #92	@ 0x5c
 8032be6:	f000 fa0b 	bl	8033000 <memset>
 8032bea:	4b0d      	ldr	r3, [pc, #52]	@ (8032c20 <std+0x58>)
 8032bec:	6263      	str	r3, [r4, #36]	@ 0x24
 8032bee:	4b0d      	ldr	r3, [pc, #52]	@ (8032c24 <std+0x5c>)
 8032bf0:	62a3      	str	r3, [r4, #40]	@ 0x28
 8032bf2:	4b0d      	ldr	r3, [pc, #52]	@ (8032c28 <std+0x60>)
 8032bf4:	62e3      	str	r3, [r4, #44]	@ 0x2c
 8032bf6:	4b0d      	ldr	r3, [pc, #52]	@ (8032c2c <std+0x64>)
 8032bf8:	6323      	str	r3, [r4, #48]	@ 0x30
 8032bfa:	4b0d      	ldr	r3, [pc, #52]	@ (8032c30 <std+0x68>)
 8032bfc:	6224      	str	r4, [r4, #32]
 8032bfe:	429c      	cmp	r4, r3
 8032c00:	d006      	beq.n	8032c10 <std+0x48>
 8032c02:	f103 0268 	add.w	r2, r3, #104	@ 0x68
 8032c06:	4294      	cmp	r4, r2
 8032c08:	d002      	beq.n	8032c10 <std+0x48>
 8032c0a:	33d0      	adds	r3, #208	@ 0xd0
 8032c0c:	429c      	cmp	r4, r3
 8032c0e:	d105      	bne.n	8032c1c <std+0x54>
 8032c10:	f104 0058 	add.w	r0, r4, #88	@ 0x58
 8032c14:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8032c18:	f000 bac2 	b.w	80331a0 <__retarget_lock_init_recursive>
 8032c1c:	bd10      	pop	{r4, pc}
 8032c1e:	bf00      	nop
 8032c20:	08032e51 	.word	0x08032e51
 8032c24:	08032e73 	.word	0x08032e73
 8032c28:	08032eab 	.word	0x08032eab
 8032c2c:	08032ecf 	.word	0x08032ecf
 8032c30:	20012254 	.word	0x20012254

08032c34 <stdio_exit_handler>:
 8032c34:	4a02      	ldr	r2, [pc, #8]	@ (8032c40 <stdio_exit_handler+0xc>)
 8032c36:	4903      	ldr	r1, [pc, #12]	@ (8032c44 <stdio_exit_handler+0x10>)
 8032c38:	4803      	ldr	r0, [pc, #12]	@ (8032c48 <stdio_exit_handler+0x14>)
 8032c3a:	f000 b87b 	b.w	8032d34 <_fwalk_sglue>
 8032c3e:	bf00      	nop
 8032c40:	20000e90 	.word	0x20000e90
 8032c44:	08034985 	.word	0x08034985
 8032c48:	20000ea0 	.word	0x20000ea0

08032c4c <cleanup_stdio>:
 8032c4c:	6841      	ldr	r1, [r0, #4]
 8032c4e:	4b0c      	ldr	r3, [pc, #48]	@ (8032c80 <cleanup_stdio+0x34>)
 8032c50:	4299      	cmp	r1, r3
 8032c52:	b510      	push	{r4, lr}
 8032c54:	4604      	mov	r4, r0
 8032c56:	d001      	beq.n	8032c5c <cleanup_stdio+0x10>
 8032c58:	f001 fe94 	bl	8034984 <_fflush_r>
 8032c5c:	68a1      	ldr	r1, [r4, #8]
 8032c5e:	4b09      	ldr	r3, [pc, #36]	@ (8032c84 <cleanup_stdio+0x38>)
 8032c60:	4299      	cmp	r1, r3
 8032c62:	d002      	beq.n	8032c6a <cleanup_stdio+0x1e>
 8032c64:	4620      	mov	r0, r4
 8032c66:	f001 fe8d 	bl	8034984 <_fflush_r>
 8032c6a:	68e1      	ldr	r1, [r4, #12]
 8032c6c:	4b06      	ldr	r3, [pc, #24]	@ (8032c88 <cleanup_stdio+0x3c>)
 8032c6e:	4299      	cmp	r1, r3
 8032c70:	d004      	beq.n	8032c7c <cleanup_stdio+0x30>
 8032c72:	4620      	mov	r0, r4
 8032c74:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8032c78:	f001 be84 	b.w	8034984 <_fflush_r>
 8032c7c:	bd10      	pop	{r4, pc}
 8032c7e:	bf00      	nop
 8032c80:	20012254 	.word	0x20012254
 8032c84:	200122bc 	.word	0x200122bc
 8032c88:	20012324 	.word	0x20012324

08032c8c <global_stdio_init.part.0>:
 8032c8c:	b510      	push	{r4, lr}
 8032c8e:	4b0b      	ldr	r3, [pc, #44]	@ (8032cbc <global_stdio_init.part.0+0x30>)
 8032c90:	4c0b      	ldr	r4, [pc, #44]	@ (8032cc0 <global_stdio_init.part.0+0x34>)
 8032c92:	4a0c      	ldr	r2, [pc, #48]	@ (8032cc4 <global_stdio_init.part.0+0x38>)
 8032c94:	601a      	str	r2, [r3, #0]
 8032c96:	4620      	mov	r0, r4
 8032c98:	2200      	movs	r2, #0
 8032c9a:	2104      	movs	r1, #4
 8032c9c:	f7ff ff94 	bl	8032bc8 <std>
 8032ca0:	f104 0068 	add.w	r0, r4, #104	@ 0x68
 8032ca4:	2201      	movs	r2, #1
 8032ca6:	2109      	movs	r1, #9
 8032ca8:	f7ff ff8e 	bl	8032bc8 <std>
 8032cac:	f104 00d0 	add.w	r0, r4, #208	@ 0xd0
 8032cb0:	2202      	movs	r2, #2
 8032cb2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8032cb6:	2112      	movs	r1, #18
 8032cb8:	f7ff bf86 	b.w	8032bc8 <std>
 8032cbc:	2001238c 	.word	0x2001238c
 8032cc0:	20012254 	.word	0x20012254
 8032cc4:	08032c35 	.word	0x08032c35

08032cc8 <__sfp_lock_acquire>:
 8032cc8:	4801      	ldr	r0, [pc, #4]	@ (8032cd0 <__sfp_lock_acquire+0x8>)
 8032cca:	f000 ba6a 	b.w	80331a2 <__retarget_lock_acquire_recursive>
 8032cce:	bf00      	nop
 8032cd0:	20012395 	.word	0x20012395

08032cd4 <__sfp_lock_release>:
 8032cd4:	4801      	ldr	r0, [pc, #4]	@ (8032cdc <__sfp_lock_release+0x8>)
 8032cd6:	f000 ba65 	b.w	80331a4 <__retarget_lock_release_recursive>
 8032cda:	bf00      	nop
 8032cdc:	20012395 	.word	0x20012395

08032ce0 <__sinit>:
 8032ce0:	b510      	push	{r4, lr}
 8032ce2:	4604      	mov	r4, r0
 8032ce4:	f7ff fff0 	bl	8032cc8 <__sfp_lock_acquire>
 8032ce8:	6a23      	ldr	r3, [r4, #32]
 8032cea:	b11b      	cbz	r3, 8032cf4 <__sinit+0x14>
 8032cec:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8032cf0:	f7ff bff0 	b.w	8032cd4 <__sfp_lock_release>
 8032cf4:	4b04      	ldr	r3, [pc, #16]	@ (8032d08 <__sinit+0x28>)
 8032cf6:	6223      	str	r3, [r4, #32]
 8032cf8:	4b04      	ldr	r3, [pc, #16]	@ (8032d0c <__sinit+0x2c>)
 8032cfa:	681b      	ldr	r3, [r3, #0]
 8032cfc:	2b00      	cmp	r3, #0
 8032cfe:	d1f5      	bne.n	8032cec <__sinit+0xc>
 8032d00:	f7ff ffc4 	bl	8032c8c <global_stdio_init.part.0>
 8032d04:	e7f2      	b.n	8032cec <__sinit+0xc>
 8032d06:	bf00      	nop
 8032d08:	08032c4d 	.word	0x08032c4d
 8032d0c:	2001238c 	.word	0x2001238c

08032d10 <fiprintf>:
 8032d10:	b40e      	push	{r1, r2, r3}
 8032d12:	b503      	push	{r0, r1, lr}
 8032d14:	4601      	mov	r1, r0
 8032d16:	ab03      	add	r3, sp, #12
 8032d18:	4805      	ldr	r0, [pc, #20]	@ (8032d30 <fiprintf+0x20>)
 8032d1a:	f853 2b04 	ldr.w	r2, [r3], #4
 8032d1e:	6800      	ldr	r0, [r0, #0]
 8032d20:	9301      	str	r3, [sp, #4]
 8032d22:	f001 fc93 	bl	803464c <_vfiprintf_r>
 8032d26:	b002      	add	sp, #8
 8032d28:	f85d eb04 	ldr.w	lr, [sp], #4
 8032d2c:	b003      	add	sp, #12
 8032d2e:	4770      	bx	lr
 8032d30:	20000e9c 	.word	0x20000e9c

08032d34 <_fwalk_sglue>:
 8032d34:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8032d38:	4607      	mov	r7, r0
 8032d3a:	4688      	mov	r8, r1
 8032d3c:	4614      	mov	r4, r2
 8032d3e:	2600      	movs	r6, #0
 8032d40:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 8032d44:	f1b9 0901 	subs.w	r9, r9, #1
 8032d48:	d505      	bpl.n	8032d56 <_fwalk_sglue+0x22>
 8032d4a:	6824      	ldr	r4, [r4, #0]
 8032d4c:	2c00      	cmp	r4, #0
 8032d4e:	d1f7      	bne.n	8032d40 <_fwalk_sglue+0xc>
 8032d50:	4630      	mov	r0, r6
 8032d52:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8032d56:	89ab      	ldrh	r3, [r5, #12]
 8032d58:	2b01      	cmp	r3, #1
 8032d5a:	d907      	bls.n	8032d6c <_fwalk_sglue+0x38>
 8032d5c:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 8032d60:	3301      	adds	r3, #1
 8032d62:	d003      	beq.n	8032d6c <_fwalk_sglue+0x38>
 8032d64:	4629      	mov	r1, r5
 8032d66:	4638      	mov	r0, r7
 8032d68:	47c0      	blx	r8
 8032d6a:	4306      	orrs	r6, r0
 8032d6c:	3568      	adds	r5, #104	@ 0x68
 8032d6e:	e7e9      	b.n	8032d44 <_fwalk_sglue+0x10>

08032d70 <iprintf>:
 8032d70:	b40f      	push	{r0, r1, r2, r3}
 8032d72:	b507      	push	{r0, r1, r2, lr}
 8032d74:	4906      	ldr	r1, [pc, #24]	@ (8032d90 <iprintf+0x20>)
 8032d76:	ab04      	add	r3, sp, #16
 8032d78:	6808      	ldr	r0, [r1, #0]
 8032d7a:	f853 2b04 	ldr.w	r2, [r3], #4
 8032d7e:	6881      	ldr	r1, [r0, #8]
 8032d80:	9301      	str	r3, [sp, #4]
 8032d82:	f001 fc63 	bl	803464c <_vfiprintf_r>
 8032d86:	b003      	add	sp, #12
 8032d88:	f85d eb04 	ldr.w	lr, [sp], #4
 8032d8c:	b004      	add	sp, #16
 8032d8e:	4770      	bx	lr
 8032d90:	20000e9c 	.word	0x20000e9c

08032d94 <_puts_r>:
 8032d94:	6a03      	ldr	r3, [r0, #32]
 8032d96:	b570      	push	{r4, r5, r6, lr}
 8032d98:	6884      	ldr	r4, [r0, #8]
 8032d9a:	4605      	mov	r5, r0
 8032d9c:	460e      	mov	r6, r1
 8032d9e:	b90b      	cbnz	r3, 8032da4 <_puts_r+0x10>
 8032da0:	f7ff ff9e 	bl	8032ce0 <__sinit>
 8032da4:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 8032da6:	07db      	lsls	r3, r3, #31
 8032da8:	d405      	bmi.n	8032db6 <_puts_r+0x22>
 8032daa:	89a3      	ldrh	r3, [r4, #12]
 8032dac:	0598      	lsls	r0, r3, #22
 8032dae:	d402      	bmi.n	8032db6 <_puts_r+0x22>
 8032db0:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 8032db2:	f000 f9f6 	bl	80331a2 <__retarget_lock_acquire_recursive>
 8032db6:	89a3      	ldrh	r3, [r4, #12]
 8032db8:	0719      	lsls	r1, r3, #28
 8032dba:	d502      	bpl.n	8032dc2 <_puts_r+0x2e>
 8032dbc:	6923      	ldr	r3, [r4, #16]
 8032dbe:	2b00      	cmp	r3, #0
 8032dc0:	d135      	bne.n	8032e2e <_puts_r+0x9a>
 8032dc2:	4621      	mov	r1, r4
 8032dc4:	4628      	mov	r0, r5
 8032dc6:	f000 f8c5 	bl	8032f54 <__swsetup_r>
 8032dca:	b380      	cbz	r0, 8032e2e <_puts_r+0x9a>
 8032dcc:	f04f 35ff 	mov.w	r5, #4294967295
 8032dd0:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 8032dd2:	07da      	lsls	r2, r3, #31
 8032dd4:	d405      	bmi.n	8032de2 <_puts_r+0x4e>
 8032dd6:	89a3      	ldrh	r3, [r4, #12]
 8032dd8:	059b      	lsls	r3, r3, #22
 8032dda:	d402      	bmi.n	8032de2 <_puts_r+0x4e>
 8032ddc:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 8032dde:	f000 f9e1 	bl	80331a4 <__retarget_lock_release_recursive>
 8032de2:	4628      	mov	r0, r5
 8032de4:	bd70      	pop	{r4, r5, r6, pc}
 8032de6:	2b00      	cmp	r3, #0
 8032de8:	da04      	bge.n	8032df4 <_puts_r+0x60>
 8032dea:	69a2      	ldr	r2, [r4, #24]
 8032dec:	429a      	cmp	r2, r3
 8032dee:	dc17      	bgt.n	8032e20 <_puts_r+0x8c>
 8032df0:	290a      	cmp	r1, #10
 8032df2:	d015      	beq.n	8032e20 <_puts_r+0x8c>
 8032df4:	6823      	ldr	r3, [r4, #0]
 8032df6:	1c5a      	adds	r2, r3, #1
 8032df8:	6022      	str	r2, [r4, #0]
 8032dfa:	7019      	strb	r1, [r3, #0]
 8032dfc:	68a3      	ldr	r3, [r4, #8]
 8032dfe:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 8032e02:	3b01      	subs	r3, #1
 8032e04:	60a3      	str	r3, [r4, #8]
 8032e06:	2900      	cmp	r1, #0
 8032e08:	d1ed      	bne.n	8032de6 <_puts_r+0x52>
 8032e0a:	2b00      	cmp	r3, #0
 8032e0c:	da11      	bge.n	8032e32 <_puts_r+0x9e>
 8032e0e:	4622      	mov	r2, r4
 8032e10:	210a      	movs	r1, #10
 8032e12:	4628      	mov	r0, r5
 8032e14:	f000 f85f 	bl	8032ed6 <__swbuf_r>
 8032e18:	3001      	adds	r0, #1
 8032e1a:	d0d7      	beq.n	8032dcc <_puts_r+0x38>
 8032e1c:	250a      	movs	r5, #10
 8032e1e:	e7d7      	b.n	8032dd0 <_puts_r+0x3c>
 8032e20:	4622      	mov	r2, r4
 8032e22:	4628      	mov	r0, r5
 8032e24:	f000 f857 	bl	8032ed6 <__swbuf_r>
 8032e28:	3001      	adds	r0, #1
 8032e2a:	d1e7      	bne.n	8032dfc <_puts_r+0x68>
 8032e2c:	e7ce      	b.n	8032dcc <_puts_r+0x38>
 8032e2e:	3e01      	subs	r6, #1
 8032e30:	e7e4      	b.n	8032dfc <_puts_r+0x68>
 8032e32:	6823      	ldr	r3, [r4, #0]
 8032e34:	1c5a      	adds	r2, r3, #1
 8032e36:	6022      	str	r2, [r4, #0]
 8032e38:	220a      	movs	r2, #10
 8032e3a:	701a      	strb	r2, [r3, #0]
 8032e3c:	e7ee      	b.n	8032e1c <_puts_r+0x88>
	...

08032e40 <puts>:
 8032e40:	4b02      	ldr	r3, [pc, #8]	@ (8032e4c <puts+0xc>)
 8032e42:	4601      	mov	r1, r0
 8032e44:	6818      	ldr	r0, [r3, #0]
 8032e46:	f7ff bfa5 	b.w	8032d94 <_puts_r>
 8032e4a:	bf00      	nop
 8032e4c:	20000e9c 	.word	0x20000e9c

08032e50 <__sread>:
 8032e50:	b510      	push	{r4, lr}
 8032e52:	460c      	mov	r4, r1
 8032e54:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8032e58:	f000 f930 	bl	80330bc <_read_r>
 8032e5c:	2800      	cmp	r0, #0
 8032e5e:	bfab      	itete	ge
 8032e60:	6d63      	ldrge	r3, [r4, #84]	@ 0x54
 8032e62:	89a3      	ldrhlt	r3, [r4, #12]
 8032e64:	181b      	addge	r3, r3, r0
 8032e66:	f423 5380 	biclt.w	r3, r3, #4096	@ 0x1000
 8032e6a:	bfac      	ite	ge
 8032e6c:	6563      	strge	r3, [r4, #84]	@ 0x54
 8032e6e:	81a3      	strhlt	r3, [r4, #12]
 8032e70:	bd10      	pop	{r4, pc}

08032e72 <__swrite>:
 8032e72:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8032e76:	461f      	mov	r7, r3
 8032e78:	898b      	ldrh	r3, [r1, #12]
 8032e7a:	05db      	lsls	r3, r3, #23
 8032e7c:	4605      	mov	r5, r0
 8032e7e:	460c      	mov	r4, r1
 8032e80:	4616      	mov	r6, r2
 8032e82:	d505      	bpl.n	8032e90 <__swrite+0x1e>
 8032e84:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8032e88:	2302      	movs	r3, #2
 8032e8a:	2200      	movs	r2, #0
 8032e8c:	f000 f904 	bl	8033098 <_lseek_r>
 8032e90:	89a3      	ldrh	r3, [r4, #12]
 8032e92:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8032e96:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 8032e9a:	81a3      	strh	r3, [r4, #12]
 8032e9c:	4632      	mov	r2, r6
 8032e9e:	463b      	mov	r3, r7
 8032ea0:	4628      	mov	r0, r5
 8032ea2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8032ea6:	f000 b93f 	b.w	8033128 <_write_r>

08032eaa <__sseek>:
 8032eaa:	b510      	push	{r4, lr}
 8032eac:	460c      	mov	r4, r1
 8032eae:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8032eb2:	f000 f8f1 	bl	8033098 <_lseek_r>
 8032eb6:	1c43      	adds	r3, r0, #1
 8032eb8:	89a3      	ldrh	r3, [r4, #12]
 8032eba:	bf15      	itete	ne
 8032ebc:	6560      	strne	r0, [r4, #84]	@ 0x54
 8032ebe:	f423 5380 	biceq.w	r3, r3, #4096	@ 0x1000
 8032ec2:	f443 5380 	orrne.w	r3, r3, #4096	@ 0x1000
 8032ec6:	81a3      	strheq	r3, [r4, #12]
 8032ec8:	bf18      	it	ne
 8032eca:	81a3      	strhne	r3, [r4, #12]
 8032ecc:	bd10      	pop	{r4, pc}

08032ece <__sclose>:
 8032ece:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8032ed2:	f000 b8d1 	b.w	8033078 <_close_r>

08032ed6 <__swbuf_r>:
 8032ed6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8032ed8:	460e      	mov	r6, r1
 8032eda:	4614      	mov	r4, r2
 8032edc:	4605      	mov	r5, r0
 8032ede:	b118      	cbz	r0, 8032ee8 <__swbuf_r+0x12>
 8032ee0:	6a03      	ldr	r3, [r0, #32]
 8032ee2:	b90b      	cbnz	r3, 8032ee8 <__swbuf_r+0x12>
 8032ee4:	f7ff fefc 	bl	8032ce0 <__sinit>
 8032ee8:	69a3      	ldr	r3, [r4, #24]
 8032eea:	60a3      	str	r3, [r4, #8]
 8032eec:	89a3      	ldrh	r3, [r4, #12]
 8032eee:	071a      	lsls	r2, r3, #28
 8032ef0:	d501      	bpl.n	8032ef6 <__swbuf_r+0x20>
 8032ef2:	6923      	ldr	r3, [r4, #16]
 8032ef4:	b943      	cbnz	r3, 8032f08 <__swbuf_r+0x32>
 8032ef6:	4621      	mov	r1, r4
 8032ef8:	4628      	mov	r0, r5
 8032efa:	f000 f82b 	bl	8032f54 <__swsetup_r>
 8032efe:	b118      	cbz	r0, 8032f08 <__swbuf_r+0x32>
 8032f00:	f04f 37ff 	mov.w	r7, #4294967295
 8032f04:	4638      	mov	r0, r7
 8032f06:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8032f08:	6823      	ldr	r3, [r4, #0]
 8032f0a:	6922      	ldr	r2, [r4, #16]
 8032f0c:	1a98      	subs	r0, r3, r2
 8032f0e:	6963      	ldr	r3, [r4, #20]
 8032f10:	b2f6      	uxtb	r6, r6
 8032f12:	4283      	cmp	r3, r0
 8032f14:	4637      	mov	r7, r6
 8032f16:	dc05      	bgt.n	8032f24 <__swbuf_r+0x4e>
 8032f18:	4621      	mov	r1, r4
 8032f1a:	4628      	mov	r0, r5
 8032f1c:	f001 fd32 	bl	8034984 <_fflush_r>
 8032f20:	2800      	cmp	r0, #0
 8032f22:	d1ed      	bne.n	8032f00 <__swbuf_r+0x2a>
 8032f24:	68a3      	ldr	r3, [r4, #8]
 8032f26:	3b01      	subs	r3, #1
 8032f28:	60a3      	str	r3, [r4, #8]
 8032f2a:	6823      	ldr	r3, [r4, #0]
 8032f2c:	1c5a      	adds	r2, r3, #1
 8032f2e:	6022      	str	r2, [r4, #0]
 8032f30:	701e      	strb	r6, [r3, #0]
 8032f32:	6962      	ldr	r2, [r4, #20]
 8032f34:	1c43      	adds	r3, r0, #1
 8032f36:	429a      	cmp	r2, r3
 8032f38:	d004      	beq.n	8032f44 <__swbuf_r+0x6e>
 8032f3a:	89a3      	ldrh	r3, [r4, #12]
 8032f3c:	07db      	lsls	r3, r3, #31
 8032f3e:	d5e1      	bpl.n	8032f04 <__swbuf_r+0x2e>
 8032f40:	2e0a      	cmp	r6, #10
 8032f42:	d1df      	bne.n	8032f04 <__swbuf_r+0x2e>
 8032f44:	4621      	mov	r1, r4
 8032f46:	4628      	mov	r0, r5
 8032f48:	f001 fd1c 	bl	8034984 <_fflush_r>
 8032f4c:	2800      	cmp	r0, #0
 8032f4e:	d0d9      	beq.n	8032f04 <__swbuf_r+0x2e>
 8032f50:	e7d6      	b.n	8032f00 <__swbuf_r+0x2a>
	...

08032f54 <__swsetup_r>:
 8032f54:	b538      	push	{r3, r4, r5, lr}
 8032f56:	4b29      	ldr	r3, [pc, #164]	@ (8032ffc <__swsetup_r+0xa8>)
 8032f58:	4605      	mov	r5, r0
 8032f5a:	6818      	ldr	r0, [r3, #0]
 8032f5c:	460c      	mov	r4, r1
 8032f5e:	b118      	cbz	r0, 8032f68 <__swsetup_r+0x14>
 8032f60:	6a03      	ldr	r3, [r0, #32]
 8032f62:	b90b      	cbnz	r3, 8032f68 <__swsetup_r+0x14>
 8032f64:	f7ff febc 	bl	8032ce0 <__sinit>
 8032f68:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8032f6c:	0719      	lsls	r1, r3, #28
 8032f6e:	d422      	bmi.n	8032fb6 <__swsetup_r+0x62>
 8032f70:	06da      	lsls	r2, r3, #27
 8032f72:	d407      	bmi.n	8032f84 <__swsetup_r+0x30>
 8032f74:	2209      	movs	r2, #9
 8032f76:	602a      	str	r2, [r5, #0]
 8032f78:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8032f7c:	81a3      	strh	r3, [r4, #12]
 8032f7e:	f04f 30ff 	mov.w	r0, #4294967295
 8032f82:	e033      	b.n	8032fec <__swsetup_r+0x98>
 8032f84:	0758      	lsls	r0, r3, #29
 8032f86:	d512      	bpl.n	8032fae <__swsetup_r+0x5a>
 8032f88:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 8032f8a:	b141      	cbz	r1, 8032f9e <__swsetup_r+0x4a>
 8032f8c:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 8032f90:	4299      	cmp	r1, r3
 8032f92:	d002      	beq.n	8032f9a <__swsetup_r+0x46>
 8032f94:	4628      	mov	r0, r5
 8032f96:	f000 ff63 	bl	8033e60 <_free_r>
 8032f9a:	2300      	movs	r3, #0
 8032f9c:	6363      	str	r3, [r4, #52]	@ 0x34
 8032f9e:	89a3      	ldrh	r3, [r4, #12]
 8032fa0:	f023 0324 	bic.w	r3, r3, #36	@ 0x24
 8032fa4:	81a3      	strh	r3, [r4, #12]
 8032fa6:	2300      	movs	r3, #0
 8032fa8:	6063      	str	r3, [r4, #4]
 8032faa:	6923      	ldr	r3, [r4, #16]
 8032fac:	6023      	str	r3, [r4, #0]
 8032fae:	89a3      	ldrh	r3, [r4, #12]
 8032fb0:	f043 0308 	orr.w	r3, r3, #8
 8032fb4:	81a3      	strh	r3, [r4, #12]
 8032fb6:	6923      	ldr	r3, [r4, #16]
 8032fb8:	b94b      	cbnz	r3, 8032fce <__swsetup_r+0x7a>
 8032fba:	89a3      	ldrh	r3, [r4, #12]
 8032fbc:	f403 7320 	and.w	r3, r3, #640	@ 0x280
 8032fc0:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8032fc4:	d003      	beq.n	8032fce <__swsetup_r+0x7a>
 8032fc6:	4621      	mov	r1, r4
 8032fc8:	4628      	mov	r0, r5
 8032fca:	f001 fd29 	bl	8034a20 <__smakebuf_r>
 8032fce:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8032fd2:	f013 0201 	ands.w	r2, r3, #1
 8032fd6:	d00a      	beq.n	8032fee <__swsetup_r+0x9a>
 8032fd8:	2200      	movs	r2, #0
 8032fda:	60a2      	str	r2, [r4, #8]
 8032fdc:	6962      	ldr	r2, [r4, #20]
 8032fde:	4252      	negs	r2, r2
 8032fe0:	61a2      	str	r2, [r4, #24]
 8032fe2:	6922      	ldr	r2, [r4, #16]
 8032fe4:	b942      	cbnz	r2, 8032ff8 <__swsetup_r+0xa4>
 8032fe6:	f013 0080 	ands.w	r0, r3, #128	@ 0x80
 8032fea:	d1c5      	bne.n	8032f78 <__swsetup_r+0x24>
 8032fec:	bd38      	pop	{r3, r4, r5, pc}
 8032fee:	0799      	lsls	r1, r3, #30
 8032ff0:	bf58      	it	pl
 8032ff2:	6962      	ldrpl	r2, [r4, #20]
 8032ff4:	60a2      	str	r2, [r4, #8]
 8032ff6:	e7f4      	b.n	8032fe2 <__swsetup_r+0x8e>
 8032ff8:	2000      	movs	r0, #0
 8032ffa:	e7f7      	b.n	8032fec <__swsetup_r+0x98>
 8032ffc:	20000e9c 	.word	0x20000e9c

08033000 <memset>:
 8033000:	4402      	add	r2, r0
 8033002:	4603      	mov	r3, r0
 8033004:	4293      	cmp	r3, r2
 8033006:	d100      	bne.n	803300a <memset+0xa>
 8033008:	4770      	bx	lr
 803300a:	f803 1b01 	strb.w	r1, [r3], #1
 803300e:	e7f9      	b.n	8033004 <memset+0x4>

08033010 <_raise_r>:
 8033010:	291f      	cmp	r1, #31
 8033012:	b538      	push	{r3, r4, r5, lr}
 8033014:	4605      	mov	r5, r0
 8033016:	460c      	mov	r4, r1
 8033018:	d904      	bls.n	8033024 <_raise_r+0x14>
 803301a:	2316      	movs	r3, #22
 803301c:	6003      	str	r3, [r0, #0]
 803301e:	f04f 30ff 	mov.w	r0, #4294967295
 8033022:	bd38      	pop	{r3, r4, r5, pc}
 8033024:	6bc2      	ldr	r2, [r0, #60]	@ 0x3c
 8033026:	b112      	cbz	r2, 803302e <_raise_r+0x1e>
 8033028:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 803302c:	b94b      	cbnz	r3, 8033042 <_raise_r+0x32>
 803302e:	4628      	mov	r0, r5
 8033030:	f000 f868 	bl	8033104 <_getpid_r>
 8033034:	4622      	mov	r2, r4
 8033036:	4601      	mov	r1, r0
 8033038:	4628      	mov	r0, r5
 803303a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 803303e:	f000 b84f 	b.w	80330e0 <_kill_r>
 8033042:	2b01      	cmp	r3, #1
 8033044:	d00a      	beq.n	803305c <_raise_r+0x4c>
 8033046:	1c59      	adds	r1, r3, #1
 8033048:	d103      	bne.n	8033052 <_raise_r+0x42>
 803304a:	2316      	movs	r3, #22
 803304c:	6003      	str	r3, [r0, #0]
 803304e:	2001      	movs	r0, #1
 8033050:	e7e7      	b.n	8033022 <_raise_r+0x12>
 8033052:	2100      	movs	r1, #0
 8033054:	f842 1024 	str.w	r1, [r2, r4, lsl #2]
 8033058:	4620      	mov	r0, r4
 803305a:	4798      	blx	r3
 803305c:	2000      	movs	r0, #0
 803305e:	e7e0      	b.n	8033022 <_raise_r+0x12>

08033060 <raise>:
 8033060:	4b02      	ldr	r3, [pc, #8]	@ (803306c <raise+0xc>)
 8033062:	4601      	mov	r1, r0
 8033064:	6818      	ldr	r0, [r3, #0]
 8033066:	f7ff bfd3 	b.w	8033010 <_raise_r>
 803306a:	bf00      	nop
 803306c:	20000e9c 	.word	0x20000e9c

08033070 <_localeconv_r>:
 8033070:	4800      	ldr	r0, [pc, #0]	@ (8033074 <_localeconv_r+0x4>)
 8033072:	4770      	bx	lr
 8033074:	20000fdc 	.word	0x20000fdc

08033078 <_close_r>:
 8033078:	b538      	push	{r3, r4, r5, lr}
 803307a:	4d06      	ldr	r5, [pc, #24]	@ (8033094 <_close_r+0x1c>)
 803307c:	2300      	movs	r3, #0
 803307e:	4604      	mov	r4, r0
 8033080:	4608      	mov	r0, r1
 8033082:	602b      	str	r3, [r5, #0]
 8033084:	f001 fd4a 	bl	8034b1c <_close>
 8033088:	1c43      	adds	r3, r0, #1
 803308a:	d102      	bne.n	8033092 <_close_r+0x1a>
 803308c:	682b      	ldr	r3, [r5, #0]
 803308e:	b103      	cbz	r3, 8033092 <_close_r+0x1a>
 8033090:	6023      	str	r3, [r4, #0]
 8033092:	bd38      	pop	{r3, r4, r5, pc}
 8033094:	20012390 	.word	0x20012390

08033098 <_lseek_r>:
 8033098:	b538      	push	{r3, r4, r5, lr}
 803309a:	4d07      	ldr	r5, [pc, #28]	@ (80330b8 <_lseek_r+0x20>)
 803309c:	4604      	mov	r4, r0
 803309e:	4608      	mov	r0, r1
 80330a0:	4611      	mov	r1, r2
 80330a2:	2200      	movs	r2, #0
 80330a4:	602a      	str	r2, [r5, #0]
 80330a6:	461a      	mov	r2, r3
 80330a8:	f001 fd60 	bl	8034b6c <_lseek>
 80330ac:	1c43      	adds	r3, r0, #1
 80330ae:	d102      	bne.n	80330b6 <_lseek_r+0x1e>
 80330b0:	682b      	ldr	r3, [r5, #0]
 80330b2:	b103      	cbz	r3, 80330b6 <_lseek_r+0x1e>
 80330b4:	6023      	str	r3, [r4, #0]
 80330b6:	bd38      	pop	{r3, r4, r5, pc}
 80330b8:	20012390 	.word	0x20012390

080330bc <_read_r>:
 80330bc:	b538      	push	{r3, r4, r5, lr}
 80330be:	4d07      	ldr	r5, [pc, #28]	@ (80330dc <_read_r+0x20>)
 80330c0:	4604      	mov	r4, r0
 80330c2:	4608      	mov	r0, r1
 80330c4:	4611      	mov	r1, r2
 80330c6:	2200      	movs	r2, #0
 80330c8:	602a      	str	r2, [r5, #0]
 80330ca:	461a      	mov	r2, r3
 80330cc:	f001 fd56 	bl	8034b7c <_read>
 80330d0:	1c43      	adds	r3, r0, #1
 80330d2:	d102      	bne.n	80330da <_read_r+0x1e>
 80330d4:	682b      	ldr	r3, [r5, #0]
 80330d6:	b103      	cbz	r3, 80330da <_read_r+0x1e>
 80330d8:	6023      	str	r3, [r4, #0]
 80330da:	bd38      	pop	{r3, r4, r5, pc}
 80330dc:	20012390 	.word	0x20012390

080330e0 <_kill_r>:
 80330e0:	b538      	push	{r3, r4, r5, lr}
 80330e2:	4d07      	ldr	r5, [pc, #28]	@ (8033100 <_kill_r+0x20>)
 80330e4:	2300      	movs	r3, #0
 80330e6:	4604      	mov	r4, r0
 80330e8:	4608      	mov	r0, r1
 80330ea:	4611      	mov	r1, r2
 80330ec:	602b      	str	r3, [r5, #0]
 80330ee:	f001 fd35 	bl	8034b5c <_kill>
 80330f2:	1c43      	adds	r3, r0, #1
 80330f4:	d102      	bne.n	80330fc <_kill_r+0x1c>
 80330f6:	682b      	ldr	r3, [r5, #0]
 80330f8:	b103      	cbz	r3, 80330fc <_kill_r+0x1c>
 80330fa:	6023      	str	r3, [r4, #0]
 80330fc:	bd38      	pop	{r3, r4, r5, pc}
 80330fe:	bf00      	nop
 8033100:	20012390 	.word	0x20012390

08033104 <_getpid_r>:
 8033104:	f001 bd1a 	b.w	8034b3c <_getpid>

08033108 <_sbrk_r>:
 8033108:	b538      	push	{r3, r4, r5, lr}
 803310a:	4d06      	ldr	r5, [pc, #24]	@ (8033124 <_sbrk_r+0x1c>)
 803310c:	2300      	movs	r3, #0
 803310e:	4604      	mov	r4, r0
 8033110:	4608      	mov	r0, r1
 8033112:	602b      	str	r3, [r5, #0]
 8033114:	f7df fe3a 	bl	8012d8c <_sbrk>
 8033118:	1c43      	adds	r3, r0, #1
 803311a:	d102      	bne.n	8033122 <_sbrk_r+0x1a>
 803311c:	682b      	ldr	r3, [r5, #0]
 803311e:	b103      	cbz	r3, 8033122 <_sbrk_r+0x1a>
 8033120:	6023      	str	r3, [r4, #0]
 8033122:	bd38      	pop	{r3, r4, r5, pc}
 8033124:	20012390 	.word	0x20012390

08033128 <_write_r>:
 8033128:	b538      	push	{r3, r4, r5, lr}
 803312a:	4d07      	ldr	r5, [pc, #28]	@ (8033148 <_write_r+0x20>)
 803312c:	4604      	mov	r4, r0
 803312e:	4608      	mov	r0, r1
 8033130:	4611      	mov	r1, r2
 8033132:	2200      	movs	r2, #0
 8033134:	602a      	str	r2, [r5, #0]
 8033136:	461a      	mov	r2, r3
 8033138:	f001 fd28 	bl	8034b8c <_write>
 803313c:	1c43      	adds	r3, r0, #1
 803313e:	d102      	bne.n	8033146 <_write_r+0x1e>
 8033140:	682b      	ldr	r3, [r5, #0]
 8033142:	b103      	cbz	r3, 8033146 <_write_r+0x1e>
 8033144:	6023      	str	r3, [r4, #0]
 8033146:	bd38      	pop	{r3, r4, r5, pc}
 8033148:	20012390 	.word	0x20012390

0803314c <__errno>:
 803314c:	4b01      	ldr	r3, [pc, #4]	@ (8033154 <__errno+0x8>)
 803314e:	6818      	ldr	r0, [r3, #0]
 8033150:	4770      	bx	lr
 8033152:	bf00      	nop
 8033154:	20000e9c 	.word	0x20000e9c

08033158 <__libc_init_array>:
 8033158:	b570      	push	{r4, r5, r6, lr}
 803315a:	4d0d      	ldr	r5, [pc, #52]	@ (8033190 <__libc_init_array+0x38>)
 803315c:	4c0d      	ldr	r4, [pc, #52]	@ (8033194 <__libc_init_array+0x3c>)
 803315e:	1b64      	subs	r4, r4, r5
 8033160:	10a4      	asrs	r4, r4, #2
 8033162:	2600      	movs	r6, #0
 8033164:	42a6      	cmp	r6, r4
 8033166:	d109      	bne.n	803317c <__libc_init_array+0x24>
 8033168:	4d0b      	ldr	r5, [pc, #44]	@ (8033198 <__libc_init_array+0x40>)
 803316a:	4c0c      	ldr	r4, [pc, #48]	@ (803319c <__libc_init_array+0x44>)
 803316c:	f001 fd18 	bl	8034ba0 <_init>
 8033170:	1b64      	subs	r4, r4, r5
 8033172:	10a4      	asrs	r4, r4, #2
 8033174:	2600      	movs	r6, #0
 8033176:	42a6      	cmp	r6, r4
 8033178:	d105      	bne.n	8033186 <__libc_init_array+0x2e>
 803317a:	bd70      	pop	{r4, r5, r6, pc}
 803317c:	f855 3b04 	ldr.w	r3, [r5], #4
 8033180:	4798      	blx	r3
 8033182:	3601      	adds	r6, #1
 8033184:	e7ee      	b.n	8033164 <__libc_init_array+0xc>
 8033186:	f855 3b04 	ldr.w	r3, [r5], #4
 803318a:	4798      	blx	r3
 803318c:	3601      	adds	r6, #1
 803318e:	e7f2      	b.n	8033176 <__libc_init_array+0x1e>
 8033190:	08083cbc 	.word	0x08083cbc
 8033194:	08083cbc 	.word	0x08083cbc
 8033198:	08083cbc 	.word	0x08083cbc
 803319c:	08083cc0 	.word	0x08083cc0

080331a0 <__retarget_lock_init_recursive>:
 80331a0:	4770      	bx	lr

080331a2 <__retarget_lock_acquire_recursive>:
 80331a2:	4770      	bx	lr

080331a4 <__retarget_lock_release_recursive>:
 80331a4:	4770      	bx	lr

080331a6 <memcpy>:
 80331a6:	440a      	add	r2, r1
 80331a8:	4291      	cmp	r1, r2
 80331aa:	f100 33ff 	add.w	r3, r0, #4294967295
 80331ae:	d100      	bne.n	80331b2 <memcpy+0xc>
 80331b0:	4770      	bx	lr
 80331b2:	b510      	push	{r4, lr}
 80331b4:	f811 4b01 	ldrb.w	r4, [r1], #1
 80331b8:	f803 4f01 	strb.w	r4, [r3, #1]!
 80331bc:	4291      	cmp	r1, r2
 80331be:	d1f9      	bne.n	80331b4 <memcpy+0xe>
 80331c0:	bd10      	pop	{r4, pc}

080331c2 <quorem>:
 80331c2:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80331c6:	6903      	ldr	r3, [r0, #16]
 80331c8:	690c      	ldr	r4, [r1, #16]
 80331ca:	42a3      	cmp	r3, r4
 80331cc:	4607      	mov	r7, r0
 80331ce:	db7e      	blt.n	80332ce <quorem+0x10c>
 80331d0:	3c01      	subs	r4, #1
 80331d2:	f101 0814 	add.w	r8, r1, #20
 80331d6:	00a3      	lsls	r3, r4, #2
 80331d8:	f100 0514 	add.w	r5, r0, #20
 80331dc:	9300      	str	r3, [sp, #0]
 80331de:	eb05 0384 	add.w	r3, r5, r4, lsl #2
 80331e2:	9301      	str	r3, [sp, #4]
 80331e4:	f858 3024 	ldr.w	r3, [r8, r4, lsl #2]
 80331e8:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
 80331ec:	3301      	adds	r3, #1
 80331ee:	429a      	cmp	r2, r3
 80331f0:	eb08 0984 	add.w	r9, r8, r4, lsl #2
 80331f4:	fbb2 f6f3 	udiv	r6, r2, r3
 80331f8:	d32e      	bcc.n	8033258 <quorem+0x96>
 80331fa:	f04f 0a00 	mov.w	sl, #0
 80331fe:	46c4      	mov	ip, r8
 8033200:	46ae      	mov	lr, r5
 8033202:	46d3      	mov	fp, sl
 8033204:	f85c 3b04 	ldr.w	r3, [ip], #4
 8033208:	b298      	uxth	r0, r3
 803320a:	fb06 a000 	mla	r0, r6, r0, sl
 803320e:	0c02      	lsrs	r2, r0, #16
 8033210:	0c1b      	lsrs	r3, r3, #16
 8033212:	fb06 2303 	mla	r3, r6, r3, r2
 8033216:	f8de 2000 	ldr.w	r2, [lr]
 803321a:	b280      	uxth	r0, r0
 803321c:	b292      	uxth	r2, r2
 803321e:	1a12      	subs	r2, r2, r0
 8033220:	445a      	add	r2, fp
 8033222:	f8de 0000 	ldr.w	r0, [lr]
 8033226:	ea4f 4a13 	mov.w	sl, r3, lsr #16
 803322a:	b29b      	uxth	r3, r3
 803322c:	ebc3 4322 	rsb	r3, r3, r2, asr #16
 8033230:	eb03 4310 	add.w	r3, r3, r0, lsr #16
 8033234:	b292      	uxth	r2, r2
 8033236:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
 803323a:	45e1      	cmp	r9, ip
 803323c:	f84e 2b04 	str.w	r2, [lr], #4
 8033240:	ea4f 4b23 	mov.w	fp, r3, asr #16
 8033244:	d2de      	bcs.n	8033204 <quorem+0x42>
 8033246:	9b00      	ldr	r3, [sp, #0]
 8033248:	58eb      	ldr	r3, [r5, r3]
 803324a:	b92b      	cbnz	r3, 8033258 <quorem+0x96>
 803324c:	9b01      	ldr	r3, [sp, #4]
 803324e:	3b04      	subs	r3, #4
 8033250:	429d      	cmp	r5, r3
 8033252:	461a      	mov	r2, r3
 8033254:	d32f      	bcc.n	80332b6 <quorem+0xf4>
 8033256:	613c      	str	r4, [r7, #16]
 8033258:	4638      	mov	r0, r7
 803325a:	f001 f8c5 	bl	80343e8 <__mcmp>
 803325e:	2800      	cmp	r0, #0
 8033260:	db25      	blt.n	80332ae <quorem+0xec>
 8033262:	4629      	mov	r1, r5
 8033264:	2000      	movs	r0, #0
 8033266:	f858 2b04 	ldr.w	r2, [r8], #4
 803326a:	f8d1 c000 	ldr.w	ip, [r1]
 803326e:	fa1f fe82 	uxth.w	lr, r2
 8033272:	fa1f f38c 	uxth.w	r3, ip
 8033276:	eba3 030e 	sub.w	r3, r3, lr
 803327a:	4403      	add	r3, r0
 803327c:	0c12      	lsrs	r2, r2, #16
 803327e:	ebc2 4223 	rsb	r2, r2, r3, asr #16
 8033282:	eb02 421c 	add.w	r2, r2, ip, lsr #16
 8033286:	b29b      	uxth	r3, r3
 8033288:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 803328c:	45c1      	cmp	r9, r8
 803328e:	f841 3b04 	str.w	r3, [r1], #4
 8033292:	ea4f 4022 	mov.w	r0, r2, asr #16
 8033296:	d2e6      	bcs.n	8033266 <quorem+0xa4>
 8033298:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
 803329c:	eb05 0384 	add.w	r3, r5, r4, lsl #2
 80332a0:	b922      	cbnz	r2, 80332ac <quorem+0xea>
 80332a2:	3b04      	subs	r3, #4
 80332a4:	429d      	cmp	r5, r3
 80332a6:	461a      	mov	r2, r3
 80332a8:	d30b      	bcc.n	80332c2 <quorem+0x100>
 80332aa:	613c      	str	r4, [r7, #16]
 80332ac:	3601      	adds	r6, #1
 80332ae:	4630      	mov	r0, r6
 80332b0:	b003      	add	sp, #12
 80332b2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80332b6:	6812      	ldr	r2, [r2, #0]
 80332b8:	3b04      	subs	r3, #4
 80332ba:	2a00      	cmp	r2, #0
 80332bc:	d1cb      	bne.n	8033256 <quorem+0x94>
 80332be:	3c01      	subs	r4, #1
 80332c0:	e7c6      	b.n	8033250 <quorem+0x8e>
 80332c2:	6812      	ldr	r2, [r2, #0]
 80332c4:	3b04      	subs	r3, #4
 80332c6:	2a00      	cmp	r2, #0
 80332c8:	d1ef      	bne.n	80332aa <quorem+0xe8>
 80332ca:	3c01      	subs	r4, #1
 80332cc:	e7ea      	b.n	80332a4 <quorem+0xe2>
 80332ce:	2000      	movs	r0, #0
 80332d0:	e7ee      	b.n	80332b0 <quorem+0xee>
 80332d2:	0000      	movs	r0, r0
 80332d4:	0000      	movs	r0, r0
	...

080332d8 <_dtoa_r>:
 80332d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80332dc:	69c7      	ldr	r7, [r0, #28]
 80332de:	b099      	sub	sp, #100	@ 0x64
 80332e0:	ed8d 0b02 	vstr	d0, [sp, #8]
 80332e4:	ec55 4b10 	vmov	r4, r5, d0
 80332e8:	9e22      	ldr	r6, [sp, #136]	@ 0x88
 80332ea:	9109      	str	r1, [sp, #36]	@ 0x24
 80332ec:	4683      	mov	fp, r0
 80332ee:	920e      	str	r2, [sp, #56]	@ 0x38
 80332f0:	9313      	str	r3, [sp, #76]	@ 0x4c
 80332f2:	b97f      	cbnz	r7, 8033314 <_dtoa_r+0x3c>
 80332f4:	2010      	movs	r0, #16
 80332f6:	f7fe ff51 	bl	803219c <malloc>
 80332fa:	4602      	mov	r2, r0
 80332fc:	f8cb 001c 	str.w	r0, [fp, #28]
 8033300:	b920      	cbnz	r0, 803330c <_dtoa_r+0x34>
 8033302:	4ba7      	ldr	r3, [pc, #668]	@ (80335a0 <_dtoa_r+0x2c8>)
 8033304:	21ef      	movs	r1, #239	@ 0xef
 8033306:	48a7      	ldr	r0, [pc, #668]	@ (80335a4 <_dtoa_r+0x2cc>)
 8033308:	f7fe ff0e 	bl	8032128 <__assert_func>
 803330c:	e9c0 7701 	strd	r7, r7, [r0, #4]
 8033310:	6007      	str	r7, [r0, #0]
 8033312:	60c7      	str	r7, [r0, #12]
 8033314:	f8db 301c 	ldr.w	r3, [fp, #28]
 8033318:	6819      	ldr	r1, [r3, #0]
 803331a:	b159      	cbz	r1, 8033334 <_dtoa_r+0x5c>
 803331c:	685a      	ldr	r2, [r3, #4]
 803331e:	604a      	str	r2, [r1, #4]
 8033320:	2301      	movs	r3, #1
 8033322:	4093      	lsls	r3, r2
 8033324:	608b      	str	r3, [r1, #8]
 8033326:	4658      	mov	r0, fp
 8033328:	f000 fe24 	bl	8033f74 <_Bfree>
 803332c:	f8db 301c 	ldr.w	r3, [fp, #28]
 8033330:	2200      	movs	r2, #0
 8033332:	601a      	str	r2, [r3, #0]
 8033334:	1e2b      	subs	r3, r5, #0
 8033336:	bfb9      	ittee	lt
 8033338:	f023 4300 	biclt.w	r3, r3, #2147483648	@ 0x80000000
 803333c:	9303      	strlt	r3, [sp, #12]
 803333e:	2300      	movge	r3, #0
 8033340:	6033      	strge	r3, [r6, #0]
 8033342:	9f03      	ldr	r7, [sp, #12]
 8033344:	4b98      	ldr	r3, [pc, #608]	@ (80335a8 <_dtoa_r+0x2d0>)
 8033346:	bfbc      	itt	lt
 8033348:	2201      	movlt	r2, #1
 803334a:	6032      	strlt	r2, [r6, #0]
 803334c:	43bb      	bics	r3, r7
 803334e:	d112      	bne.n	8033376 <_dtoa_r+0x9e>
 8033350:	9a13      	ldr	r2, [sp, #76]	@ 0x4c
 8033352:	f242 730f 	movw	r3, #9999	@ 0x270f
 8033356:	6013      	str	r3, [r2, #0]
 8033358:	f3c7 0313 	ubfx	r3, r7, #0, #20
 803335c:	4323      	orrs	r3, r4
 803335e:	f000 854d 	beq.w	8033dfc <_dtoa_r+0xb24>
 8033362:	9b23      	ldr	r3, [sp, #140]	@ 0x8c
 8033364:	f8df a254 	ldr.w	sl, [pc, #596]	@ 80335bc <_dtoa_r+0x2e4>
 8033368:	2b00      	cmp	r3, #0
 803336a:	f000 854f 	beq.w	8033e0c <_dtoa_r+0xb34>
 803336e:	f10a 0303 	add.w	r3, sl, #3
 8033372:	f000 bd49 	b.w	8033e08 <_dtoa_r+0xb30>
 8033376:	ed9d 7b02 	vldr	d7, [sp, #8]
 803337a:	2200      	movs	r2, #0
 803337c:	ec51 0b17 	vmov	r0, r1, d7
 8033380:	2300      	movs	r3, #0
 8033382:	ed8d 7b0c 	vstr	d7, [sp, #48]	@ 0x30
 8033386:	f7dd fad7 	bl	8010938 <__aeabi_dcmpeq>
 803338a:	4680      	mov	r8, r0
 803338c:	b158      	cbz	r0, 80333a6 <_dtoa_r+0xce>
 803338e:	9a13      	ldr	r2, [sp, #76]	@ 0x4c
 8033390:	2301      	movs	r3, #1
 8033392:	6013      	str	r3, [r2, #0]
 8033394:	9b23      	ldr	r3, [sp, #140]	@ 0x8c
 8033396:	b113      	cbz	r3, 803339e <_dtoa_r+0xc6>
 8033398:	9a23      	ldr	r2, [sp, #140]	@ 0x8c
 803339a:	4b84      	ldr	r3, [pc, #528]	@ (80335ac <_dtoa_r+0x2d4>)
 803339c:	6013      	str	r3, [r2, #0]
 803339e:	f8df a220 	ldr.w	sl, [pc, #544]	@ 80335c0 <_dtoa_r+0x2e8>
 80333a2:	f000 bd33 	b.w	8033e0c <_dtoa_r+0xb34>
 80333a6:	ed9d 0b0c 	vldr	d0, [sp, #48]	@ 0x30
 80333aa:	aa16      	add	r2, sp, #88	@ 0x58
 80333ac:	a917      	add	r1, sp, #92	@ 0x5c
 80333ae:	4658      	mov	r0, fp
 80333b0:	f001 f8ca 	bl	8034548 <__d2b>
 80333b4:	f3c7 560a 	ubfx	r6, r7, #20, #11
 80333b8:	4681      	mov	r9, r0
 80333ba:	2e00      	cmp	r6, #0
 80333bc:	d077      	beq.n	80334ae <_dtoa_r+0x1d6>
 80333be:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 80333c0:	f8cd 8050 	str.w	r8, [sp, #80]	@ 0x50
 80333c4:	f3c3 0313 	ubfx	r3, r3, #0, #20
 80333c8:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	@ 0x30
 80333cc:	f043 537f 	orr.w	r3, r3, #1069547520	@ 0x3fc00000
 80333d0:	f443 1340 	orr.w	r3, r3, #3145728	@ 0x300000
 80333d4:	f2a6 36ff 	subw	r6, r6, #1023	@ 0x3ff
 80333d8:	4619      	mov	r1, r3
 80333da:	2200      	movs	r2, #0
 80333dc:	4b74      	ldr	r3, [pc, #464]	@ (80335b0 <_dtoa_r+0x2d8>)
 80333de:	f7dc fe8b 	bl	80100f8 <__aeabi_dsub>
 80333e2:	a369      	add	r3, pc, #420	@ (adr r3, 8033588 <_dtoa_r+0x2b0>)
 80333e4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80333e8:	f7dd f83e 	bl	8010468 <__aeabi_dmul>
 80333ec:	a368      	add	r3, pc, #416	@ (adr r3, 8033590 <_dtoa_r+0x2b8>)
 80333ee:	e9d3 2300 	ldrd	r2, r3, [r3]
 80333f2:	f7dc fe83 	bl	80100fc <__adddf3>
 80333f6:	4604      	mov	r4, r0
 80333f8:	4630      	mov	r0, r6
 80333fa:	460d      	mov	r5, r1
 80333fc:	f7dc ffca 	bl	8010394 <__aeabi_i2d>
 8033400:	a365      	add	r3, pc, #404	@ (adr r3, 8033598 <_dtoa_r+0x2c0>)
 8033402:	e9d3 2300 	ldrd	r2, r3, [r3]
 8033406:	f7dd f82f 	bl	8010468 <__aeabi_dmul>
 803340a:	4602      	mov	r2, r0
 803340c:	460b      	mov	r3, r1
 803340e:	4620      	mov	r0, r4
 8033410:	4629      	mov	r1, r5
 8033412:	f7dc fe73 	bl	80100fc <__adddf3>
 8033416:	4604      	mov	r4, r0
 8033418:	460d      	mov	r5, r1
 803341a:	f7dd fad5 	bl	80109c8 <__aeabi_d2iz>
 803341e:	2200      	movs	r2, #0
 8033420:	4607      	mov	r7, r0
 8033422:	2300      	movs	r3, #0
 8033424:	4620      	mov	r0, r4
 8033426:	4629      	mov	r1, r5
 8033428:	f7dd fa90 	bl	801094c <__aeabi_dcmplt>
 803342c:	b140      	cbz	r0, 8033440 <_dtoa_r+0x168>
 803342e:	4638      	mov	r0, r7
 8033430:	f7dc ffb0 	bl	8010394 <__aeabi_i2d>
 8033434:	4622      	mov	r2, r4
 8033436:	462b      	mov	r3, r5
 8033438:	f7dd fa7e 	bl	8010938 <__aeabi_dcmpeq>
 803343c:	b900      	cbnz	r0, 8033440 <_dtoa_r+0x168>
 803343e:	3f01      	subs	r7, #1
 8033440:	2f16      	cmp	r7, #22
 8033442:	d851      	bhi.n	80334e8 <_dtoa_r+0x210>
 8033444:	4b5b      	ldr	r3, [pc, #364]	@ (80335b4 <_dtoa_r+0x2dc>)
 8033446:	eb03 03c7 	add.w	r3, r3, r7, lsl #3
 803344a:	e9d3 2300 	ldrd	r2, r3, [r3]
 803344e:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	@ 0x30
 8033452:	f7dd fa7b 	bl	801094c <__aeabi_dcmplt>
 8033456:	2800      	cmp	r0, #0
 8033458:	d048      	beq.n	80334ec <_dtoa_r+0x214>
 803345a:	3f01      	subs	r7, #1
 803345c:	2300      	movs	r3, #0
 803345e:	9312      	str	r3, [sp, #72]	@ 0x48
 8033460:	9b16      	ldr	r3, [sp, #88]	@ 0x58
 8033462:	1b9b      	subs	r3, r3, r6
 8033464:	1e5a      	subs	r2, r3, #1
 8033466:	bf44      	itt	mi
 8033468:	f1c3 0801 	rsbmi	r8, r3, #1
 803346c:	2300      	movmi	r3, #0
 803346e:	9208      	str	r2, [sp, #32]
 8033470:	bf54      	ite	pl
 8033472:	f04f 0800 	movpl.w	r8, #0
 8033476:	9308      	strmi	r3, [sp, #32]
 8033478:	2f00      	cmp	r7, #0
 803347a:	db39      	blt.n	80334f0 <_dtoa_r+0x218>
 803347c:	9b08      	ldr	r3, [sp, #32]
 803347e:	970f      	str	r7, [sp, #60]	@ 0x3c
 8033480:	443b      	add	r3, r7
 8033482:	9308      	str	r3, [sp, #32]
 8033484:	2300      	movs	r3, #0
 8033486:	930a      	str	r3, [sp, #40]	@ 0x28
 8033488:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 803348a:	2b09      	cmp	r3, #9
 803348c:	d864      	bhi.n	8033558 <_dtoa_r+0x280>
 803348e:	2b05      	cmp	r3, #5
 8033490:	bfc4      	itt	gt
 8033492:	3b04      	subgt	r3, #4
 8033494:	9309      	strgt	r3, [sp, #36]	@ 0x24
 8033496:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8033498:	f1a3 0302 	sub.w	r3, r3, #2
 803349c:	bfcc      	ite	gt
 803349e:	2400      	movgt	r4, #0
 80334a0:	2401      	movle	r4, #1
 80334a2:	2b03      	cmp	r3, #3
 80334a4:	d863      	bhi.n	803356e <_dtoa_r+0x296>
 80334a6:	e8df f003 	tbb	[pc, r3]
 80334aa:	372a      	.short	0x372a
 80334ac:	5535      	.short	0x5535
 80334ae:	e9dd 6316 	ldrd	r6, r3, [sp, #88]	@ 0x58
 80334b2:	441e      	add	r6, r3
 80334b4:	f206 4332 	addw	r3, r6, #1074	@ 0x432
 80334b8:	2b20      	cmp	r3, #32
 80334ba:	bfc1      	itttt	gt
 80334bc:	f1c3 0340 	rsbgt	r3, r3, #64	@ 0x40
 80334c0:	409f      	lslgt	r7, r3
 80334c2:	f206 4312 	addwgt	r3, r6, #1042	@ 0x412
 80334c6:	fa24 f303 	lsrgt.w	r3, r4, r3
 80334ca:	bfd6      	itet	le
 80334cc:	f1c3 0320 	rsble	r3, r3, #32
 80334d0:	ea47 0003 	orrgt.w	r0, r7, r3
 80334d4:	fa04 f003 	lslle.w	r0, r4, r3
 80334d8:	f7dc ff4c 	bl	8010374 <__aeabi_ui2d>
 80334dc:	2201      	movs	r2, #1
 80334de:	f1a1 73f8 	sub.w	r3, r1, #32505856	@ 0x1f00000
 80334e2:	3e01      	subs	r6, #1
 80334e4:	9214      	str	r2, [sp, #80]	@ 0x50
 80334e6:	e777      	b.n	80333d8 <_dtoa_r+0x100>
 80334e8:	2301      	movs	r3, #1
 80334ea:	e7b8      	b.n	803345e <_dtoa_r+0x186>
 80334ec:	9012      	str	r0, [sp, #72]	@ 0x48
 80334ee:	e7b7      	b.n	8033460 <_dtoa_r+0x188>
 80334f0:	427b      	negs	r3, r7
 80334f2:	930a      	str	r3, [sp, #40]	@ 0x28
 80334f4:	2300      	movs	r3, #0
 80334f6:	eba8 0807 	sub.w	r8, r8, r7
 80334fa:	930f      	str	r3, [sp, #60]	@ 0x3c
 80334fc:	e7c4      	b.n	8033488 <_dtoa_r+0x1b0>
 80334fe:	2300      	movs	r3, #0
 8033500:	930b      	str	r3, [sp, #44]	@ 0x2c
 8033502:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 8033504:	2b00      	cmp	r3, #0
 8033506:	dc35      	bgt.n	8033574 <_dtoa_r+0x29c>
 8033508:	2301      	movs	r3, #1
 803350a:	9300      	str	r3, [sp, #0]
 803350c:	9307      	str	r3, [sp, #28]
 803350e:	461a      	mov	r2, r3
 8033510:	920e      	str	r2, [sp, #56]	@ 0x38
 8033512:	e00b      	b.n	803352c <_dtoa_r+0x254>
 8033514:	2301      	movs	r3, #1
 8033516:	e7f3      	b.n	8033500 <_dtoa_r+0x228>
 8033518:	2300      	movs	r3, #0
 803351a:	930b      	str	r3, [sp, #44]	@ 0x2c
 803351c:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 803351e:	18fb      	adds	r3, r7, r3
 8033520:	9300      	str	r3, [sp, #0]
 8033522:	3301      	adds	r3, #1
 8033524:	2b01      	cmp	r3, #1
 8033526:	9307      	str	r3, [sp, #28]
 8033528:	bfb8      	it	lt
 803352a:	2301      	movlt	r3, #1
 803352c:	f8db 001c 	ldr.w	r0, [fp, #28]
 8033530:	2100      	movs	r1, #0
 8033532:	2204      	movs	r2, #4
 8033534:	f102 0514 	add.w	r5, r2, #20
 8033538:	429d      	cmp	r5, r3
 803353a:	d91f      	bls.n	803357c <_dtoa_r+0x2a4>
 803353c:	6041      	str	r1, [r0, #4]
 803353e:	4658      	mov	r0, fp
 8033540:	f000 fcd8 	bl	8033ef4 <_Balloc>
 8033544:	4682      	mov	sl, r0
 8033546:	2800      	cmp	r0, #0
 8033548:	d13c      	bne.n	80335c4 <_dtoa_r+0x2ec>
 803354a:	4b1b      	ldr	r3, [pc, #108]	@ (80335b8 <_dtoa_r+0x2e0>)
 803354c:	4602      	mov	r2, r0
 803354e:	f240 11af 	movw	r1, #431	@ 0x1af
 8033552:	e6d8      	b.n	8033306 <_dtoa_r+0x2e>
 8033554:	2301      	movs	r3, #1
 8033556:	e7e0      	b.n	803351a <_dtoa_r+0x242>
 8033558:	2401      	movs	r4, #1
 803355a:	2300      	movs	r3, #0
 803355c:	9309      	str	r3, [sp, #36]	@ 0x24
 803355e:	940b      	str	r4, [sp, #44]	@ 0x2c
 8033560:	f04f 33ff 	mov.w	r3, #4294967295
 8033564:	9300      	str	r3, [sp, #0]
 8033566:	9307      	str	r3, [sp, #28]
 8033568:	2200      	movs	r2, #0
 803356a:	2312      	movs	r3, #18
 803356c:	e7d0      	b.n	8033510 <_dtoa_r+0x238>
 803356e:	2301      	movs	r3, #1
 8033570:	930b      	str	r3, [sp, #44]	@ 0x2c
 8033572:	e7f5      	b.n	8033560 <_dtoa_r+0x288>
 8033574:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 8033576:	9300      	str	r3, [sp, #0]
 8033578:	9307      	str	r3, [sp, #28]
 803357a:	e7d7      	b.n	803352c <_dtoa_r+0x254>
 803357c:	3101      	adds	r1, #1
 803357e:	0052      	lsls	r2, r2, #1
 8033580:	e7d8      	b.n	8033534 <_dtoa_r+0x25c>
 8033582:	bf00      	nop
 8033584:	f3af 8000 	nop.w
 8033588:	636f4361 	.word	0x636f4361
 803358c:	3fd287a7 	.word	0x3fd287a7
 8033590:	8b60c8b3 	.word	0x8b60c8b3
 8033594:	3fc68a28 	.word	0x3fc68a28
 8033598:	509f79fb 	.word	0x509f79fb
 803359c:	3fd34413 	.word	0x3fd34413
 80335a0:	08083abe 	.word	0x08083abe
 80335a4:	08083ad5 	.word	0x08083ad5
 80335a8:	7ff00000 	.word	0x7ff00000
 80335ac:	08083a8e 	.word	0x08083a8e
 80335b0:	3ff80000 	.word	0x3ff80000
 80335b4:	08083bd0 	.word	0x08083bd0
 80335b8:	08083b2d 	.word	0x08083b2d
 80335bc:	08083aba 	.word	0x08083aba
 80335c0:	08083a8d 	.word	0x08083a8d
 80335c4:	f8db 301c 	ldr.w	r3, [fp, #28]
 80335c8:	6018      	str	r0, [r3, #0]
 80335ca:	9b07      	ldr	r3, [sp, #28]
 80335cc:	2b0e      	cmp	r3, #14
 80335ce:	f200 80a4 	bhi.w	803371a <_dtoa_r+0x442>
 80335d2:	2c00      	cmp	r4, #0
 80335d4:	f000 80a1 	beq.w	803371a <_dtoa_r+0x442>
 80335d8:	2f00      	cmp	r7, #0
 80335da:	dd33      	ble.n	8033644 <_dtoa_r+0x36c>
 80335dc:	4bad      	ldr	r3, [pc, #692]	@ (8033894 <_dtoa_r+0x5bc>)
 80335de:	f007 020f 	and.w	r2, r7, #15
 80335e2:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 80335e6:	ed93 7b00 	vldr	d7, [r3]
 80335ea:	05f8      	lsls	r0, r7, #23
 80335ec:	ed8d 7b04 	vstr	d7, [sp, #16]
 80335f0:	ea4f 1427 	mov.w	r4, r7, asr #4
 80335f4:	d516      	bpl.n	8033624 <_dtoa_r+0x34c>
 80335f6:	4ba8      	ldr	r3, [pc, #672]	@ (8033898 <_dtoa_r+0x5c0>)
 80335f8:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	@ 0x30
 80335fc:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 8033600:	f7dd f85c 	bl	80106bc <__aeabi_ddiv>
 8033604:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8033608:	f004 040f 	and.w	r4, r4, #15
 803360c:	2603      	movs	r6, #3
 803360e:	4da2      	ldr	r5, [pc, #648]	@ (8033898 <_dtoa_r+0x5c0>)
 8033610:	b954      	cbnz	r4, 8033628 <_dtoa_r+0x350>
 8033612:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8033616:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 803361a:	f7dd f84f 	bl	80106bc <__aeabi_ddiv>
 803361e:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8033622:	e028      	b.n	8033676 <_dtoa_r+0x39e>
 8033624:	2602      	movs	r6, #2
 8033626:	e7f2      	b.n	803360e <_dtoa_r+0x336>
 8033628:	07e1      	lsls	r1, r4, #31
 803362a:	d508      	bpl.n	803363e <_dtoa_r+0x366>
 803362c:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8033630:	e9d5 2300 	ldrd	r2, r3, [r5]
 8033634:	f7dc ff18 	bl	8010468 <__aeabi_dmul>
 8033638:	e9cd 0104 	strd	r0, r1, [sp, #16]
 803363c:	3601      	adds	r6, #1
 803363e:	1064      	asrs	r4, r4, #1
 8033640:	3508      	adds	r5, #8
 8033642:	e7e5      	b.n	8033610 <_dtoa_r+0x338>
 8033644:	f000 80d2 	beq.w	80337ec <_dtoa_r+0x514>
 8033648:	427c      	negs	r4, r7
 803364a:	4b92      	ldr	r3, [pc, #584]	@ (8033894 <_dtoa_r+0x5bc>)
 803364c:	4d92      	ldr	r5, [pc, #584]	@ (8033898 <_dtoa_r+0x5c0>)
 803364e:	f004 020f 	and.w	r2, r4, #15
 8033652:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8033656:	e9d3 2300 	ldrd	r2, r3, [r3]
 803365a:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	@ 0x30
 803365e:	f7dc ff03 	bl	8010468 <__aeabi_dmul>
 8033662:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8033666:	1124      	asrs	r4, r4, #4
 8033668:	2300      	movs	r3, #0
 803366a:	2602      	movs	r6, #2
 803366c:	2c00      	cmp	r4, #0
 803366e:	f040 80b2 	bne.w	80337d6 <_dtoa_r+0x4fe>
 8033672:	2b00      	cmp	r3, #0
 8033674:	d1d3      	bne.n	803361e <_dtoa_r+0x346>
 8033676:	9b12      	ldr	r3, [sp, #72]	@ 0x48
 8033678:	e9dd 4502 	ldrd	r4, r5, [sp, #8]
 803367c:	2b00      	cmp	r3, #0
 803367e:	f000 80b7 	beq.w	80337f0 <_dtoa_r+0x518>
 8033682:	4b86      	ldr	r3, [pc, #536]	@ (803389c <_dtoa_r+0x5c4>)
 8033684:	2200      	movs	r2, #0
 8033686:	4620      	mov	r0, r4
 8033688:	4629      	mov	r1, r5
 803368a:	f7dd f95f 	bl	801094c <__aeabi_dcmplt>
 803368e:	2800      	cmp	r0, #0
 8033690:	f000 80ae 	beq.w	80337f0 <_dtoa_r+0x518>
 8033694:	9b07      	ldr	r3, [sp, #28]
 8033696:	2b00      	cmp	r3, #0
 8033698:	f000 80aa 	beq.w	80337f0 <_dtoa_r+0x518>
 803369c:	9b00      	ldr	r3, [sp, #0]
 803369e:	2b00      	cmp	r3, #0
 80336a0:	dd37      	ble.n	8033712 <_dtoa_r+0x43a>
 80336a2:	1e7b      	subs	r3, r7, #1
 80336a4:	9304      	str	r3, [sp, #16]
 80336a6:	4620      	mov	r0, r4
 80336a8:	4b7d      	ldr	r3, [pc, #500]	@ (80338a0 <_dtoa_r+0x5c8>)
 80336aa:	2200      	movs	r2, #0
 80336ac:	4629      	mov	r1, r5
 80336ae:	f7dc fedb 	bl	8010468 <__aeabi_dmul>
 80336b2:	e9cd 0102 	strd	r0, r1, [sp, #8]
 80336b6:	9c00      	ldr	r4, [sp, #0]
 80336b8:	3601      	adds	r6, #1
 80336ba:	4630      	mov	r0, r6
 80336bc:	f7dc fe6a 	bl	8010394 <__aeabi_i2d>
 80336c0:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80336c4:	f7dc fed0 	bl	8010468 <__aeabi_dmul>
 80336c8:	4b76      	ldr	r3, [pc, #472]	@ (80338a4 <_dtoa_r+0x5cc>)
 80336ca:	2200      	movs	r2, #0
 80336cc:	f7dc fd16 	bl	80100fc <__adddf3>
 80336d0:	4605      	mov	r5, r0
 80336d2:	f1a1 7650 	sub.w	r6, r1, #54525952	@ 0x3400000
 80336d6:	2c00      	cmp	r4, #0
 80336d8:	f040 808d 	bne.w	80337f6 <_dtoa_r+0x51e>
 80336dc:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 80336e0:	4b71      	ldr	r3, [pc, #452]	@ (80338a8 <_dtoa_r+0x5d0>)
 80336e2:	2200      	movs	r2, #0
 80336e4:	f7dc fd08 	bl	80100f8 <__aeabi_dsub>
 80336e8:	4602      	mov	r2, r0
 80336ea:	460b      	mov	r3, r1
 80336ec:	e9cd 2302 	strd	r2, r3, [sp, #8]
 80336f0:	462a      	mov	r2, r5
 80336f2:	4633      	mov	r3, r6
 80336f4:	f7dd f948 	bl	8010988 <__aeabi_dcmpgt>
 80336f8:	2800      	cmp	r0, #0
 80336fa:	f040 828b 	bne.w	8033c14 <_dtoa_r+0x93c>
 80336fe:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8033702:	462a      	mov	r2, r5
 8033704:	f106 4300 	add.w	r3, r6, #2147483648	@ 0x80000000
 8033708:	f7dd f920 	bl	801094c <__aeabi_dcmplt>
 803370c:	2800      	cmp	r0, #0
 803370e:	f040 8128 	bne.w	8033962 <_dtoa_r+0x68a>
 8033712:	e9dd 340c 	ldrd	r3, r4, [sp, #48]	@ 0x30
 8033716:	e9cd 3402 	strd	r3, r4, [sp, #8]
 803371a:	9b17      	ldr	r3, [sp, #92]	@ 0x5c
 803371c:	2b00      	cmp	r3, #0
 803371e:	f2c0 815a 	blt.w	80339d6 <_dtoa_r+0x6fe>
 8033722:	2f0e      	cmp	r7, #14
 8033724:	f300 8157 	bgt.w	80339d6 <_dtoa_r+0x6fe>
 8033728:	4b5a      	ldr	r3, [pc, #360]	@ (8033894 <_dtoa_r+0x5bc>)
 803372a:	eb03 03c7 	add.w	r3, r3, r7, lsl #3
 803372e:	ed93 7b00 	vldr	d7, [r3]
 8033732:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 8033734:	2b00      	cmp	r3, #0
 8033736:	ed8d 7b00 	vstr	d7, [sp]
 803373a:	da03      	bge.n	8033744 <_dtoa_r+0x46c>
 803373c:	9b07      	ldr	r3, [sp, #28]
 803373e:	2b00      	cmp	r3, #0
 8033740:	f340 8101 	ble.w	8033946 <_dtoa_r+0x66e>
 8033744:	e9dd 4502 	ldrd	r4, r5, [sp, #8]
 8033748:	4656      	mov	r6, sl
 803374a:	e9dd 2300 	ldrd	r2, r3, [sp]
 803374e:	4620      	mov	r0, r4
 8033750:	4629      	mov	r1, r5
 8033752:	f7dc ffb3 	bl	80106bc <__aeabi_ddiv>
 8033756:	f7dd f937 	bl	80109c8 <__aeabi_d2iz>
 803375a:	4680      	mov	r8, r0
 803375c:	f7dc fe1a 	bl	8010394 <__aeabi_i2d>
 8033760:	e9dd 2300 	ldrd	r2, r3, [sp]
 8033764:	f7dc fe80 	bl	8010468 <__aeabi_dmul>
 8033768:	4602      	mov	r2, r0
 803376a:	460b      	mov	r3, r1
 803376c:	4620      	mov	r0, r4
 803376e:	4629      	mov	r1, r5
 8033770:	f108 0430 	add.w	r4, r8, #48	@ 0x30
 8033774:	f7dc fcc0 	bl	80100f8 <__aeabi_dsub>
 8033778:	f806 4b01 	strb.w	r4, [r6], #1
 803377c:	9d07      	ldr	r5, [sp, #28]
 803377e:	eba6 040a 	sub.w	r4, r6, sl
 8033782:	42a5      	cmp	r5, r4
 8033784:	4602      	mov	r2, r0
 8033786:	460b      	mov	r3, r1
 8033788:	f040 8117 	bne.w	80339ba <_dtoa_r+0x6e2>
 803378c:	f7dc fcb6 	bl	80100fc <__adddf3>
 8033790:	e9dd 2300 	ldrd	r2, r3, [sp]
 8033794:	4604      	mov	r4, r0
 8033796:	460d      	mov	r5, r1
 8033798:	f7dd f8f6 	bl	8010988 <__aeabi_dcmpgt>
 803379c:	2800      	cmp	r0, #0
 803379e:	f040 80f9 	bne.w	8033994 <_dtoa_r+0x6bc>
 80337a2:	e9dd 2300 	ldrd	r2, r3, [sp]
 80337a6:	4620      	mov	r0, r4
 80337a8:	4629      	mov	r1, r5
 80337aa:	f7dd f8c5 	bl	8010938 <__aeabi_dcmpeq>
 80337ae:	b118      	cbz	r0, 80337b8 <_dtoa_r+0x4e0>
 80337b0:	f018 0f01 	tst.w	r8, #1
 80337b4:	f040 80ee 	bne.w	8033994 <_dtoa_r+0x6bc>
 80337b8:	4649      	mov	r1, r9
 80337ba:	4658      	mov	r0, fp
 80337bc:	f000 fbda 	bl	8033f74 <_Bfree>
 80337c0:	2300      	movs	r3, #0
 80337c2:	7033      	strb	r3, [r6, #0]
 80337c4:	9b13      	ldr	r3, [sp, #76]	@ 0x4c
 80337c6:	3701      	adds	r7, #1
 80337c8:	601f      	str	r7, [r3, #0]
 80337ca:	9b23      	ldr	r3, [sp, #140]	@ 0x8c
 80337cc:	2b00      	cmp	r3, #0
 80337ce:	f000 831d 	beq.w	8033e0c <_dtoa_r+0xb34>
 80337d2:	601e      	str	r6, [r3, #0]
 80337d4:	e31a      	b.n	8033e0c <_dtoa_r+0xb34>
 80337d6:	07e2      	lsls	r2, r4, #31
 80337d8:	d505      	bpl.n	80337e6 <_dtoa_r+0x50e>
 80337da:	e9d5 2300 	ldrd	r2, r3, [r5]
 80337de:	f7dc fe43 	bl	8010468 <__aeabi_dmul>
 80337e2:	3601      	adds	r6, #1
 80337e4:	2301      	movs	r3, #1
 80337e6:	1064      	asrs	r4, r4, #1
 80337e8:	3508      	adds	r5, #8
 80337ea:	e73f      	b.n	803366c <_dtoa_r+0x394>
 80337ec:	2602      	movs	r6, #2
 80337ee:	e742      	b.n	8033676 <_dtoa_r+0x39e>
 80337f0:	9c07      	ldr	r4, [sp, #28]
 80337f2:	9704      	str	r7, [sp, #16]
 80337f4:	e761      	b.n	80336ba <_dtoa_r+0x3e2>
 80337f6:	4b27      	ldr	r3, [pc, #156]	@ (8033894 <_dtoa_r+0x5bc>)
 80337f8:	990b      	ldr	r1, [sp, #44]	@ 0x2c
 80337fa:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
 80337fe:	e953 2302 	ldrd	r2, r3, [r3, #-8]
 8033802:	4454      	add	r4, sl
 8033804:	2900      	cmp	r1, #0
 8033806:	d053      	beq.n	80338b0 <_dtoa_r+0x5d8>
 8033808:	4928      	ldr	r1, [pc, #160]	@ (80338ac <_dtoa_r+0x5d4>)
 803380a:	2000      	movs	r0, #0
 803380c:	f7dc ff56 	bl	80106bc <__aeabi_ddiv>
 8033810:	4633      	mov	r3, r6
 8033812:	462a      	mov	r2, r5
 8033814:	f7dc fc70 	bl	80100f8 <__aeabi_dsub>
 8033818:	e9cd 0110 	strd	r0, r1, [sp, #64]	@ 0x40
 803381c:	4656      	mov	r6, sl
 803381e:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8033822:	f7dd f8d1 	bl	80109c8 <__aeabi_d2iz>
 8033826:	4605      	mov	r5, r0
 8033828:	f7dc fdb4 	bl	8010394 <__aeabi_i2d>
 803382c:	4602      	mov	r2, r0
 803382e:	460b      	mov	r3, r1
 8033830:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8033834:	f7dc fc60 	bl	80100f8 <__aeabi_dsub>
 8033838:	3530      	adds	r5, #48	@ 0x30
 803383a:	4602      	mov	r2, r0
 803383c:	460b      	mov	r3, r1
 803383e:	e9cd 2302 	strd	r2, r3, [sp, #8]
 8033842:	f806 5b01 	strb.w	r5, [r6], #1
 8033846:	e9dd 2310 	ldrd	r2, r3, [sp, #64]	@ 0x40
 803384a:	f7dd f87f 	bl	801094c <__aeabi_dcmplt>
 803384e:	2800      	cmp	r0, #0
 8033850:	d171      	bne.n	8033936 <_dtoa_r+0x65e>
 8033852:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8033856:	4911      	ldr	r1, [pc, #68]	@ (803389c <_dtoa_r+0x5c4>)
 8033858:	2000      	movs	r0, #0
 803385a:	f7dc fc4d 	bl	80100f8 <__aeabi_dsub>
 803385e:	e9dd 2310 	ldrd	r2, r3, [sp, #64]	@ 0x40
 8033862:	f7dd f873 	bl	801094c <__aeabi_dcmplt>
 8033866:	2800      	cmp	r0, #0
 8033868:	f040 8095 	bne.w	8033996 <_dtoa_r+0x6be>
 803386c:	42a6      	cmp	r6, r4
 803386e:	f43f af50 	beq.w	8033712 <_dtoa_r+0x43a>
 8033872:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	@ 0x40
 8033876:	4b0a      	ldr	r3, [pc, #40]	@ (80338a0 <_dtoa_r+0x5c8>)
 8033878:	2200      	movs	r2, #0
 803387a:	f7dc fdf5 	bl	8010468 <__aeabi_dmul>
 803387e:	4b08      	ldr	r3, [pc, #32]	@ (80338a0 <_dtoa_r+0x5c8>)
 8033880:	e9cd 0110 	strd	r0, r1, [sp, #64]	@ 0x40
 8033884:	2200      	movs	r2, #0
 8033886:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 803388a:	f7dc fded 	bl	8010468 <__aeabi_dmul>
 803388e:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8033892:	e7c4      	b.n	803381e <_dtoa_r+0x546>
 8033894:	08083bd0 	.word	0x08083bd0
 8033898:	08083ba8 	.word	0x08083ba8
 803389c:	3ff00000 	.word	0x3ff00000
 80338a0:	40240000 	.word	0x40240000
 80338a4:	401c0000 	.word	0x401c0000
 80338a8:	40140000 	.word	0x40140000
 80338ac:	3fe00000 	.word	0x3fe00000
 80338b0:	4631      	mov	r1, r6
 80338b2:	4628      	mov	r0, r5
 80338b4:	f7dc fdd8 	bl	8010468 <__aeabi_dmul>
 80338b8:	e9cd 0110 	strd	r0, r1, [sp, #64]	@ 0x40
 80338bc:	9415      	str	r4, [sp, #84]	@ 0x54
 80338be:	4656      	mov	r6, sl
 80338c0:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 80338c4:	f7dd f880 	bl	80109c8 <__aeabi_d2iz>
 80338c8:	4605      	mov	r5, r0
 80338ca:	f7dc fd63 	bl	8010394 <__aeabi_i2d>
 80338ce:	4602      	mov	r2, r0
 80338d0:	460b      	mov	r3, r1
 80338d2:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 80338d6:	f7dc fc0f 	bl	80100f8 <__aeabi_dsub>
 80338da:	3530      	adds	r5, #48	@ 0x30
 80338dc:	f806 5b01 	strb.w	r5, [r6], #1
 80338e0:	4602      	mov	r2, r0
 80338e2:	460b      	mov	r3, r1
 80338e4:	42a6      	cmp	r6, r4
 80338e6:	e9cd 2302 	strd	r2, r3, [sp, #8]
 80338ea:	f04f 0200 	mov.w	r2, #0
 80338ee:	d124      	bne.n	803393a <_dtoa_r+0x662>
 80338f0:	4bac      	ldr	r3, [pc, #688]	@ (8033ba4 <_dtoa_r+0x8cc>)
 80338f2:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	@ 0x40
 80338f6:	f7dc fc01 	bl	80100fc <__adddf3>
 80338fa:	4602      	mov	r2, r0
 80338fc:	460b      	mov	r3, r1
 80338fe:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8033902:	f7dd f841 	bl	8010988 <__aeabi_dcmpgt>
 8033906:	2800      	cmp	r0, #0
 8033908:	d145      	bne.n	8033996 <_dtoa_r+0x6be>
 803390a:	e9dd 2310 	ldrd	r2, r3, [sp, #64]	@ 0x40
 803390e:	49a5      	ldr	r1, [pc, #660]	@ (8033ba4 <_dtoa_r+0x8cc>)
 8033910:	2000      	movs	r0, #0
 8033912:	f7dc fbf1 	bl	80100f8 <__aeabi_dsub>
 8033916:	4602      	mov	r2, r0
 8033918:	460b      	mov	r3, r1
 803391a:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 803391e:	f7dd f815 	bl	801094c <__aeabi_dcmplt>
 8033922:	2800      	cmp	r0, #0
 8033924:	f43f aef5 	beq.w	8033712 <_dtoa_r+0x43a>
 8033928:	9e15      	ldr	r6, [sp, #84]	@ 0x54
 803392a:	1e73      	subs	r3, r6, #1
 803392c:	9315      	str	r3, [sp, #84]	@ 0x54
 803392e:	f816 3c01 	ldrb.w	r3, [r6, #-1]
 8033932:	2b30      	cmp	r3, #48	@ 0x30
 8033934:	d0f8      	beq.n	8033928 <_dtoa_r+0x650>
 8033936:	9f04      	ldr	r7, [sp, #16]
 8033938:	e73e      	b.n	80337b8 <_dtoa_r+0x4e0>
 803393a:	4b9b      	ldr	r3, [pc, #620]	@ (8033ba8 <_dtoa_r+0x8d0>)
 803393c:	f7dc fd94 	bl	8010468 <__aeabi_dmul>
 8033940:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8033944:	e7bc      	b.n	80338c0 <_dtoa_r+0x5e8>
 8033946:	d10c      	bne.n	8033962 <_dtoa_r+0x68a>
 8033948:	4b98      	ldr	r3, [pc, #608]	@ (8033bac <_dtoa_r+0x8d4>)
 803394a:	2200      	movs	r2, #0
 803394c:	e9dd 0100 	ldrd	r0, r1, [sp]
 8033950:	f7dc fd8a 	bl	8010468 <__aeabi_dmul>
 8033954:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8033958:	f7dd f80c 	bl	8010974 <__aeabi_dcmpge>
 803395c:	2800      	cmp	r0, #0
 803395e:	f000 8157 	beq.w	8033c10 <_dtoa_r+0x938>
 8033962:	2400      	movs	r4, #0
 8033964:	4625      	mov	r5, r4
 8033966:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 8033968:	43db      	mvns	r3, r3
 803396a:	9304      	str	r3, [sp, #16]
 803396c:	4656      	mov	r6, sl
 803396e:	2700      	movs	r7, #0
 8033970:	4621      	mov	r1, r4
 8033972:	4658      	mov	r0, fp
 8033974:	f000 fafe 	bl	8033f74 <_Bfree>
 8033978:	2d00      	cmp	r5, #0
 803397a:	d0dc      	beq.n	8033936 <_dtoa_r+0x65e>
 803397c:	b12f      	cbz	r7, 803398a <_dtoa_r+0x6b2>
 803397e:	42af      	cmp	r7, r5
 8033980:	d003      	beq.n	803398a <_dtoa_r+0x6b2>
 8033982:	4639      	mov	r1, r7
 8033984:	4658      	mov	r0, fp
 8033986:	f000 faf5 	bl	8033f74 <_Bfree>
 803398a:	4629      	mov	r1, r5
 803398c:	4658      	mov	r0, fp
 803398e:	f000 faf1 	bl	8033f74 <_Bfree>
 8033992:	e7d0      	b.n	8033936 <_dtoa_r+0x65e>
 8033994:	9704      	str	r7, [sp, #16]
 8033996:	4633      	mov	r3, r6
 8033998:	461e      	mov	r6, r3
 803399a:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
 803399e:	2a39      	cmp	r2, #57	@ 0x39
 80339a0:	d107      	bne.n	80339b2 <_dtoa_r+0x6da>
 80339a2:	459a      	cmp	sl, r3
 80339a4:	d1f8      	bne.n	8033998 <_dtoa_r+0x6c0>
 80339a6:	9a04      	ldr	r2, [sp, #16]
 80339a8:	3201      	adds	r2, #1
 80339aa:	9204      	str	r2, [sp, #16]
 80339ac:	2230      	movs	r2, #48	@ 0x30
 80339ae:	f88a 2000 	strb.w	r2, [sl]
 80339b2:	781a      	ldrb	r2, [r3, #0]
 80339b4:	3201      	adds	r2, #1
 80339b6:	701a      	strb	r2, [r3, #0]
 80339b8:	e7bd      	b.n	8033936 <_dtoa_r+0x65e>
 80339ba:	4b7b      	ldr	r3, [pc, #492]	@ (8033ba8 <_dtoa_r+0x8d0>)
 80339bc:	2200      	movs	r2, #0
 80339be:	f7dc fd53 	bl	8010468 <__aeabi_dmul>
 80339c2:	2200      	movs	r2, #0
 80339c4:	2300      	movs	r3, #0
 80339c6:	4604      	mov	r4, r0
 80339c8:	460d      	mov	r5, r1
 80339ca:	f7dc ffb5 	bl	8010938 <__aeabi_dcmpeq>
 80339ce:	2800      	cmp	r0, #0
 80339d0:	f43f aebb 	beq.w	803374a <_dtoa_r+0x472>
 80339d4:	e6f0      	b.n	80337b8 <_dtoa_r+0x4e0>
 80339d6:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
 80339d8:	2a00      	cmp	r2, #0
 80339da:	f000 80db 	beq.w	8033b94 <_dtoa_r+0x8bc>
 80339de:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 80339e0:	2a01      	cmp	r2, #1
 80339e2:	f300 80bf 	bgt.w	8033b64 <_dtoa_r+0x88c>
 80339e6:	9a14      	ldr	r2, [sp, #80]	@ 0x50
 80339e8:	2a00      	cmp	r2, #0
 80339ea:	f000 80b7 	beq.w	8033b5c <_dtoa_r+0x884>
 80339ee:	f203 4333 	addw	r3, r3, #1075	@ 0x433
 80339f2:	9c0a      	ldr	r4, [sp, #40]	@ 0x28
 80339f4:	4646      	mov	r6, r8
 80339f6:	9a08      	ldr	r2, [sp, #32]
 80339f8:	2101      	movs	r1, #1
 80339fa:	441a      	add	r2, r3
 80339fc:	4658      	mov	r0, fp
 80339fe:	4498      	add	r8, r3
 8033a00:	9208      	str	r2, [sp, #32]
 8033a02:	f000 fb6b 	bl	80340dc <__i2b>
 8033a06:	4605      	mov	r5, r0
 8033a08:	b15e      	cbz	r6, 8033a22 <_dtoa_r+0x74a>
 8033a0a:	9b08      	ldr	r3, [sp, #32]
 8033a0c:	2b00      	cmp	r3, #0
 8033a0e:	dd08      	ble.n	8033a22 <_dtoa_r+0x74a>
 8033a10:	42b3      	cmp	r3, r6
 8033a12:	9a08      	ldr	r2, [sp, #32]
 8033a14:	bfa8      	it	ge
 8033a16:	4633      	movge	r3, r6
 8033a18:	eba8 0803 	sub.w	r8, r8, r3
 8033a1c:	1af6      	subs	r6, r6, r3
 8033a1e:	1ad3      	subs	r3, r2, r3
 8033a20:	9308      	str	r3, [sp, #32]
 8033a22:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8033a24:	b1f3      	cbz	r3, 8033a64 <_dtoa_r+0x78c>
 8033a26:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 8033a28:	2b00      	cmp	r3, #0
 8033a2a:	f000 80b7 	beq.w	8033b9c <_dtoa_r+0x8c4>
 8033a2e:	b18c      	cbz	r4, 8033a54 <_dtoa_r+0x77c>
 8033a30:	4629      	mov	r1, r5
 8033a32:	4622      	mov	r2, r4
 8033a34:	4658      	mov	r0, fp
 8033a36:	f000 fc11 	bl	803425c <__pow5mult>
 8033a3a:	464a      	mov	r2, r9
 8033a3c:	4601      	mov	r1, r0
 8033a3e:	4605      	mov	r5, r0
 8033a40:	4658      	mov	r0, fp
 8033a42:	f000 fb61 	bl	8034108 <__multiply>
 8033a46:	4649      	mov	r1, r9
 8033a48:	9004      	str	r0, [sp, #16]
 8033a4a:	4658      	mov	r0, fp
 8033a4c:	f000 fa92 	bl	8033f74 <_Bfree>
 8033a50:	9b04      	ldr	r3, [sp, #16]
 8033a52:	4699      	mov	r9, r3
 8033a54:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8033a56:	1b1a      	subs	r2, r3, r4
 8033a58:	d004      	beq.n	8033a64 <_dtoa_r+0x78c>
 8033a5a:	4649      	mov	r1, r9
 8033a5c:	4658      	mov	r0, fp
 8033a5e:	f000 fbfd 	bl	803425c <__pow5mult>
 8033a62:	4681      	mov	r9, r0
 8033a64:	2101      	movs	r1, #1
 8033a66:	4658      	mov	r0, fp
 8033a68:	f000 fb38 	bl	80340dc <__i2b>
 8033a6c:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 8033a6e:	4604      	mov	r4, r0
 8033a70:	2b00      	cmp	r3, #0
 8033a72:	f000 81cf 	beq.w	8033e14 <_dtoa_r+0xb3c>
 8033a76:	461a      	mov	r2, r3
 8033a78:	4601      	mov	r1, r0
 8033a7a:	4658      	mov	r0, fp
 8033a7c:	f000 fbee 	bl	803425c <__pow5mult>
 8033a80:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8033a82:	2b01      	cmp	r3, #1
 8033a84:	4604      	mov	r4, r0
 8033a86:	f300 8095 	bgt.w	8033bb4 <_dtoa_r+0x8dc>
 8033a8a:	9b02      	ldr	r3, [sp, #8]
 8033a8c:	2b00      	cmp	r3, #0
 8033a8e:	f040 8087 	bne.w	8033ba0 <_dtoa_r+0x8c8>
 8033a92:	9b03      	ldr	r3, [sp, #12]
 8033a94:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8033a98:	2b00      	cmp	r3, #0
 8033a9a:	f040 8089 	bne.w	8033bb0 <_dtoa_r+0x8d8>
 8033a9e:	9b03      	ldr	r3, [sp, #12]
 8033aa0:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 8033aa4:	0d1b      	lsrs	r3, r3, #20
 8033aa6:	051b      	lsls	r3, r3, #20
 8033aa8:	b12b      	cbz	r3, 8033ab6 <_dtoa_r+0x7de>
 8033aaa:	9b08      	ldr	r3, [sp, #32]
 8033aac:	3301      	adds	r3, #1
 8033aae:	9308      	str	r3, [sp, #32]
 8033ab0:	f108 0801 	add.w	r8, r8, #1
 8033ab4:	2301      	movs	r3, #1
 8033ab6:	930a      	str	r3, [sp, #40]	@ 0x28
 8033ab8:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 8033aba:	2b00      	cmp	r3, #0
 8033abc:	f000 81b0 	beq.w	8033e20 <_dtoa_r+0xb48>
 8033ac0:	6923      	ldr	r3, [r4, #16]
 8033ac2:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 8033ac6:	6918      	ldr	r0, [r3, #16]
 8033ac8:	f000 fabc 	bl	8034044 <__hi0bits>
 8033acc:	f1c0 0020 	rsb	r0, r0, #32
 8033ad0:	9b08      	ldr	r3, [sp, #32]
 8033ad2:	4418      	add	r0, r3
 8033ad4:	f010 001f 	ands.w	r0, r0, #31
 8033ad8:	d077      	beq.n	8033bca <_dtoa_r+0x8f2>
 8033ada:	f1c0 0320 	rsb	r3, r0, #32
 8033ade:	2b04      	cmp	r3, #4
 8033ae0:	dd6b      	ble.n	8033bba <_dtoa_r+0x8e2>
 8033ae2:	9b08      	ldr	r3, [sp, #32]
 8033ae4:	f1c0 001c 	rsb	r0, r0, #28
 8033ae8:	4403      	add	r3, r0
 8033aea:	4480      	add	r8, r0
 8033aec:	4406      	add	r6, r0
 8033aee:	9308      	str	r3, [sp, #32]
 8033af0:	f1b8 0f00 	cmp.w	r8, #0
 8033af4:	dd05      	ble.n	8033b02 <_dtoa_r+0x82a>
 8033af6:	4649      	mov	r1, r9
 8033af8:	4642      	mov	r2, r8
 8033afa:	4658      	mov	r0, fp
 8033afc:	f000 fc08 	bl	8034310 <__lshift>
 8033b00:	4681      	mov	r9, r0
 8033b02:	9b08      	ldr	r3, [sp, #32]
 8033b04:	2b00      	cmp	r3, #0
 8033b06:	dd05      	ble.n	8033b14 <_dtoa_r+0x83c>
 8033b08:	4621      	mov	r1, r4
 8033b0a:	461a      	mov	r2, r3
 8033b0c:	4658      	mov	r0, fp
 8033b0e:	f000 fbff 	bl	8034310 <__lshift>
 8033b12:	4604      	mov	r4, r0
 8033b14:	9b12      	ldr	r3, [sp, #72]	@ 0x48
 8033b16:	2b00      	cmp	r3, #0
 8033b18:	d059      	beq.n	8033bce <_dtoa_r+0x8f6>
 8033b1a:	4621      	mov	r1, r4
 8033b1c:	4648      	mov	r0, r9
 8033b1e:	f000 fc63 	bl	80343e8 <__mcmp>
 8033b22:	2800      	cmp	r0, #0
 8033b24:	da53      	bge.n	8033bce <_dtoa_r+0x8f6>
 8033b26:	1e7b      	subs	r3, r7, #1
 8033b28:	9304      	str	r3, [sp, #16]
 8033b2a:	4649      	mov	r1, r9
 8033b2c:	2300      	movs	r3, #0
 8033b2e:	220a      	movs	r2, #10
 8033b30:	4658      	mov	r0, fp
 8033b32:	f000 fa41 	bl	8033fb8 <__multadd>
 8033b36:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 8033b38:	4681      	mov	r9, r0
 8033b3a:	2b00      	cmp	r3, #0
 8033b3c:	f000 8172 	beq.w	8033e24 <_dtoa_r+0xb4c>
 8033b40:	2300      	movs	r3, #0
 8033b42:	4629      	mov	r1, r5
 8033b44:	220a      	movs	r2, #10
 8033b46:	4658      	mov	r0, fp
 8033b48:	f000 fa36 	bl	8033fb8 <__multadd>
 8033b4c:	9b00      	ldr	r3, [sp, #0]
 8033b4e:	2b00      	cmp	r3, #0
 8033b50:	4605      	mov	r5, r0
 8033b52:	dc67      	bgt.n	8033c24 <_dtoa_r+0x94c>
 8033b54:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8033b56:	2b02      	cmp	r3, #2
 8033b58:	dc41      	bgt.n	8033bde <_dtoa_r+0x906>
 8033b5a:	e063      	b.n	8033c24 <_dtoa_r+0x94c>
 8033b5c:	9b16      	ldr	r3, [sp, #88]	@ 0x58
 8033b5e:	f1c3 0336 	rsb	r3, r3, #54	@ 0x36
 8033b62:	e746      	b.n	80339f2 <_dtoa_r+0x71a>
 8033b64:	9b07      	ldr	r3, [sp, #28]
 8033b66:	1e5c      	subs	r4, r3, #1
 8033b68:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8033b6a:	42a3      	cmp	r3, r4
 8033b6c:	bfbf      	itttt	lt
 8033b6e:	9b0a      	ldrlt	r3, [sp, #40]	@ 0x28
 8033b70:	9a0f      	ldrlt	r2, [sp, #60]	@ 0x3c
 8033b72:	940a      	strlt	r4, [sp, #40]	@ 0x28
 8033b74:	1ae3      	sublt	r3, r4, r3
 8033b76:	bfb4      	ite	lt
 8033b78:	18d2      	addlt	r2, r2, r3
 8033b7a:	1b1c      	subge	r4, r3, r4
 8033b7c:	9b07      	ldr	r3, [sp, #28]
 8033b7e:	bfbc      	itt	lt
 8033b80:	920f      	strlt	r2, [sp, #60]	@ 0x3c
 8033b82:	2400      	movlt	r4, #0
 8033b84:	2b00      	cmp	r3, #0
 8033b86:	bfb5      	itete	lt
 8033b88:	eba8 0603 	sublt.w	r6, r8, r3
 8033b8c:	9b07      	ldrge	r3, [sp, #28]
 8033b8e:	2300      	movlt	r3, #0
 8033b90:	4646      	movge	r6, r8
 8033b92:	e730      	b.n	80339f6 <_dtoa_r+0x71e>
 8033b94:	9c0a      	ldr	r4, [sp, #40]	@ 0x28
 8033b96:	9d0b      	ldr	r5, [sp, #44]	@ 0x2c
 8033b98:	4646      	mov	r6, r8
 8033b9a:	e735      	b.n	8033a08 <_dtoa_r+0x730>
 8033b9c:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 8033b9e:	e75c      	b.n	8033a5a <_dtoa_r+0x782>
 8033ba0:	2300      	movs	r3, #0
 8033ba2:	e788      	b.n	8033ab6 <_dtoa_r+0x7de>
 8033ba4:	3fe00000 	.word	0x3fe00000
 8033ba8:	40240000 	.word	0x40240000
 8033bac:	40140000 	.word	0x40140000
 8033bb0:	9b02      	ldr	r3, [sp, #8]
 8033bb2:	e780      	b.n	8033ab6 <_dtoa_r+0x7de>
 8033bb4:	2300      	movs	r3, #0
 8033bb6:	930a      	str	r3, [sp, #40]	@ 0x28
 8033bb8:	e782      	b.n	8033ac0 <_dtoa_r+0x7e8>
 8033bba:	d099      	beq.n	8033af0 <_dtoa_r+0x818>
 8033bbc:	9a08      	ldr	r2, [sp, #32]
 8033bbe:	331c      	adds	r3, #28
 8033bc0:	441a      	add	r2, r3
 8033bc2:	4498      	add	r8, r3
 8033bc4:	441e      	add	r6, r3
 8033bc6:	9208      	str	r2, [sp, #32]
 8033bc8:	e792      	b.n	8033af0 <_dtoa_r+0x818>
 8033bca:	4603      	mov	r3, r0
 8033bcc:	e7f6      	b.n	8033bbc <_dtoa_r+0x8e4>
 8033bce:	9b07      	ldr	r3, [sp, #28]
 8033bd0:	9704      	str	r7, [sp, #16]
 8033bd2:	2b00      	cmp	r3, #0
 8033bd4:	dc20      	bgt.n	8033c18 <_dtoa_r+0x940>
 8033bd6:	9300      	str	r3, [sp, #0]
 8033bd8:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8033bda:	2b02      	cmp	r3, #2
 8033bdc:	dd1e      	ble.n	8033c1c <_dtoa_r+0x944>
 8033bde:	9b00      	ldr	r3, [sp, #0]
 8033be0:	2b00      	cmp	r3, #0
 8033be2:	f47f aec0 	bne.w	8033966 <_dtoa_r+0x68e>
 8033be6:	4621      	mov	r1, r4
 8033be8:	2205      	movs	r2, #5
 8033bea:	4658      	mov	r0, fp
 8033bec:	f000 f9e4 	bl	8033fb8 <__multadd>
 8033bf0:	4601      	mov	r1, r0
 8033bf2:	4604      	mov	r4, r0
 8033bf4:	4648      	mov	r0, r9
 8033bf6:	f000 fbf7 	bl	80343e8 <__mcmp>
 8033bfa:	2800      	cmp	r0, #0
 8033bfc:	f77f aeb3 	ble.w	8033966 <_dtoa_r+0x68e>
 8033c00:	4656      	mov	r6, sl
 8033c02:	2331      	movs	r3, #49	@ 0x31
 8033c04:	f806 3b01 	strb.w	r3, [r6], #1
 8033c08:	9b04      	ldr	r3, [sp, #16]
 8033c0a:	3301      	adds	r3, #1
 8033c0c:	9304      	str	r3, [sp, #16]
 8033c0e:	e6ae      	b.n	803396e <_dtoa_r+0x696>
 8033c10:	9c07      	ldr	r4, [sp, #28]
 8033c12:	9704      	str	r7, [sp, #16]
 8033c14:	4625      	mov	r5, r4
 8033c16:	e7f3      	b.n	8033c00 <_dtoa_r+0x928>
 8033c18:	9b07      	ldr	r3, [sp, #28]
 8033c1a:	9300      	str	r3, [sp, #0]
 8033c1c:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 8033c1e:	2b00      	cmp	r3, #0
 8033c20:	f000 8104 	beq.w	8033e2c <_dtoa_r+0xb54>
 8033c24:	2e00      	cmp	r6, #0
 8033c26:	dd05      	ble.n	8033c34 <_dtoa_r+0x95c>
 8033c28:	4629      	mov	r1, r5
 8033c2a:	4632      	mov	r2, r6
 8033c2c:	4658      	mov	r0, fp
 8033c2e:	f000 fb6f 	bl	8034310 <__lshift>
 8033c32:	4605      	mov	r5, r0
 8033c34:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8033c36:	2b00      	cmp	r3, #0
 8033c38:	d05a      	beq.n	8033cf0 <_dtoa_r+0xa18>
 8033c3a:	6869      	ldr	r1, [r5, #4]
 8033c3c:	4658      	mov	r0, fp
 8033c3e:	f000 f959 	bl	8033ef4 <_Balloc>
 8033c42:	4606      	mov	r6, r0
 8033c44:	b928      	cbnz	r0, 8033c52 <_dtoa_r+0x97a>
 8033c46:	4b84      	ldr	r3, [pc, #528]	@ (8033e58 <_dtoa_r+0xb80>)
 8033c48:	4602      	mov	r2, r0
 8033c4a:	f240 21ef 	movw	r1, #751	@ 0x2ef
 8033c4e:	f7ff bb5a 	b.w	8033306 <_dtoa_r+0x2e>
 8033c52:	692a      	ldr	r2, [r5, #16]
 8033c54:	3202      	adds	r2, #2
 8033c56:	0092      	lsls	r2, r2, #2
 8033c58:	f105 010c 	add.w	r1, r5, #12
 8033c5c:	300c      	adds	r0, #12
 8033c5e:	f7ff faa2 	bl	80331a6 <memcpy>
 8033c62:	2201      	movs	r2, #1
 8033c64:	4631      	mov	r1, r6
 8033c66:	4658      	mov	r0, fp
 8033c68:	f000 fb52 	bl	8034310 <__lshift>
 8033c6c:	f10a 0301 	add.w	r3, sl, #1
 8033c70:	9307      	str	r3, [sp, #28]
 8033c72:	9b00      	ldr	r3, [sp, #0]
 8033c74:	4453      	add	r3, sl
 8033c76:	930b      	str	r3, [sp, #44]	@ 0x2c
 8033c78:	9b02      	ldr	r3, [sp, #8]
 8033c7a:	f003 0301 	and.w	r3, r3, #1
 8033c7e:	462f      	mov	r7, r5
 8033c80:	930a      	str	r3, [sp, #40]	@ 0x28
 8033c82:	4605      	mov	r5, r0
 8033c84:	9b07      	ldr	r3, [sp, #28]
 8033c86:	4621      	mov	r1, r4
 8033c88:	3b01      	subs	r3, #1
 8033c8a:	4648      	mov	r0, r9
 8033c8c:	9300      	str	r3, [sp, #0]
 8033c8e:	f7ff fa98 	bl	80331c2 <quorem>
 8033c92:	4639      	mov	r1, r7
 8033c94:	9002      	str	r0, [sp, #8]
 8033c96:	f100 0830 	add.w	r8, r0, #48	@ 0x30
 8033c9a:	4648      	mov	r0, r9
 8033c9c:	f000 fba4 	bl	80343e8 <__mcmp>
 8033ca0:	462a      	mov	r2, r5
 8033ca2:	9008      	str	r0, [sp, #32]
 8033ca4:	4621      	mov	r1, r4
 8033ca6:	4658      	mov	r0, fp
 8033ca8:	f000 fbba 	bl	8034420 <__mdiff>
 8033cac:	68c2      	ldr	r2, [r0, #12]
 8033cae:	4606      	mov	r6, r0
 8033cb0:	bb02      	cbnz	r2, 8033cf4 <_dtoa_r+0xa1c>
 8033cb2:	4601      	mov	r1, r0
 8033cb4:	4648      	mov	r0, r9
 8033cb6:	f000 fb97 	bl	80343e8 <__mcmp>
 8033cba:	4602      	mov	r2, r0
 8033cbc:	4631      	mov	r1, r6
 8033cbe:	4658      	mov	r0, fp
 8033cc0:	920e      	str	r2, [sp, #56]	@ 0x38
 8033cc2:	f000 f957 	bl	8033f74 <_Bfree>
 8033cc6:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8033cc8:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
 8033cca:	9e07      	ldr	r6, [sp, #28]
 8033ccc:	ea43 0102 	orr.w	r1, r3, r2
 8033cd0:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8033cd2:	4319      	orrs	r1, r3
 8033cd4:	d110      	bne.n	8033cf8 <_dtoa_r+0xa20>
 8033cd6:	f1b8 0f39 	cmp.w	r8, #57	@ 0x39
 8033cda:	d029      	beq.n	8033d30 <_dtoa_r+0xa58>
 8033cdc:	9b08      	ldr	r3, [sp, #32]
 8033cde:	2b00      	cmp	r3, #0
 8033ce0:	dd02      	ble.n	8033ce8 <_dtoa_r+0xa10>
 8033ce2:	9b02      	ldr	r3, [sp, #8]
 8033ce4:	f103 0831 	add.w	r8, r3, #49	@ 0x31
 8033ce8:	9b00      	ldr	r3, [sp, #0]
 8033cea:	f883 8000 	strb.w	r8, [r3]
 8033cee:	e63f      	b.n	8033970 <_dtoa_r+0x698>
 8033cf0:	4628      	mov	r0, r5
 8033cf2:	e7bb      	b.n	8033c6c <_dtoa_r+0x994>
 8033cf4:	2201      	movs	r2, #1
 8033cf6:	e7e1      	b.n	8033cbc <_dtoa_r+0x9e4>
 8033cf8:	9b08      	ldr	r3, [sp, #32]
 8033cfa:	2b00      	cmp	r3, #0
 8033cfc:	db04      	blt.n	8033d08 <_dtoa_r+0xa30>
 8033cfe:	9909      	ldr	r1, [sp, #36]	@ 0x24
 8033d00:	430b      	orrs	r3, r1
 8033d02:	990a      	ldr	r1, [sp, #40]	@ 0x28
 8033d04:	430b      	orrs	r3, r1
 8033d06:	d120      	bne.n	8033d4a <_dtoa_r+0xa72>
 8033d08:	2a00      	cmp	r2, #0
 8033d0a:	dded      	ble.n	8033ce8 <_dtoa_r+0xa10>
 8033d0c:	4649      	mov	r1, r9
 8033d0e:	2201      	movs	r2, #1
 8033d10:	4658      	mov	r0, fp
 8033d12:	f000 fafd 	bl	8034310 <__lshift>
 8033d16:	4621      	mov	r1, r4
 8033d18:	4681      	mov	r9, r0
 8033d1a:	f000 fb65 	bl	80343e8 <__mcmp>
 8033d1e:	2800      	cmp	r0, #0
 8033d20:	dc03      	bgt.n	8033d2a <_dtoa_r+0xa52>
 8033d22:	d1e1      	bne.n	8033ce8 <_dtoa_r+0xa10>
 8033d24:	f018 0f01 	tst.w	r8, #1
 8033d28:	d0de      	beq.n	8033ce8 <_dtoa_r+0xa10>
 8033d2a:	f1b8 0f39 	cmp.w	r8, #57	@ 0x39
 8033d2e:	d1d8      	bne.n	8033ce2 <_dtoa_r+0xa0a>
 8033d30:	9a00      	ldr	r2, [sp, #0]
 8033d32:	2339      	movs	r3, #57	@ 0x39
 8033d34:	7013      	strb	r3, [r2, #0]
 8033d36:	4633      	mov	r3, r6
 8033d38:	461e      	mov	r6, r3
 8033d3a:	3b01      	subs	r3, #1
 8033d3c:	f816 2c01 	ldrb.w	r2, [r6, #-1]
 8033d40:	2a39      	cmp	r2, #57	@ 0x39
 8033d42:	d052      	beq.n	8033dea <_dtoa_r+0xb12>
 8033d44:	3201      	adds	r2, #1
 8033d46:	701a      	strb	r2, [r3, #0]
 8033d48:	e612      	b.n	8033970 <_dtoa_r+0x698>
 8033d4a:	2a00      	cmp	r2, #0
 8033d4c:	dd07      	ble.n	8033d5e <_dtoa_r+0xa86>
 8033d4e:	f1b8 0f39 	cmp.w	r8, #57	@ 0x39
 8033d52:	d0ed      	beq.n	8033d30 <_dtoa_r+0xa58>
 8033d54:	9a00      	ldr	r2, [sp, #0]
 8033d56:	f108 0301 	add.w	r3, r8, #1
 8033d5a:	7013      	strb	r3, [r2, #0]
 8033d5c:	e608      	b.n	8033970 <_dtoa_r+0x698>
 8033d5e:	9b07      	ldr	r3, [sp, #28]
 8033d60:	9a07      	ldr	r2, [sp, #28]
 8033d62:	f803 8c01 	strb.w	r8, [r3, #-1]
 8033d66:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 8033d68:	4293      	cmp	r3, r2
 8033d6a:	d028      	beq.n	8033dbe <_dtoa_r+0xae6>
 8033d6c:	4649      	mov	r1, r9
 8033d6e:	2300      	movs	r3, #0
 8033d70:	220a      	movs	r2, #10
 8033d72:	4658      	mov	r0, fp
 8033d74:	f000 f920 	bl	8033fb8 <__multadd>
 8033d78:	42af      	cmp	r7, r5
 8033d7a:	4681      	mov	r9, r0
 8033d7c:	f04f 0300 	mov.w	r3, #0
 8033d80:	f04f 020a 	mov.w	r2, #10
 8033d84:	4639      	mov	r1, r7
 8033d86:	4658      	mov	r0, fp
 8033d88:	d107      	bne.n	8033d9a <_dtoa_r+0xac2>
 8033d8a:	f000 f915 	bl	8033fb8 <__multadd>
 8033d8e:	4607      	mov	r7, r0
 8033d90:	4605      	mov	r5, r0
 8033d92:	9b07      	ldr	r3, [sp, #28]
 8033d94:	3301      	adds	r3, #1
 8033d96:	9307      	str	r3, [sp, #28]
 8033d98:	e774      	b.n	8033c84 <_dtoa_r+0x9ac>
 8033d9a:	f000 f90d 	bl	8033fb8 <__multadd>
 8033d9e:	4629      	mov	r1, r5
 8033da0:	4607      	mov	r7, r0
 8033da2:	2300      	movs	r3, #0
 8033da4:	220a      	movs	r2, #10
 8033da6:	4658      	mov	r0, fp
 8033da8:	f000 f906 	bl	8033fb8 <__multadd>
 8033dac:	4605      	mov	r5, r0
 8033dae:	e7f0      	b.n	8033d92 <_dtoa_r+0xaba>
 8033db0:	9b00      	ldr	r3, [sp, #0]
 8033db2:	2b00      	cmp	r3, #0
 8033db4:	bfcc      	ite	gt
 8033db6:	461e      	movgt	r6, r3
 8033db8:	2601      	movle	r6, #1
 8033dba:	4456      	add	r6, sl
 8033dbc:	2700      	movs	r7, #0
 8033dbe:	4649      	mov	r1, r9
 8033dc0:	2201      	movs	r2, #1
 8033dc2:	4658      	mov	r0, fp
 8033dc4:	f000 faa4 	bl	8034310 <__lshift>
 8033dc8:	4621      	mov	r1, r4
 8033dca:	4681      	mov	r9, r0
 8033dcc:	f000 fb0c 	bl	80343e8 <__mcmp>
 8033dd0:	2800      	cmp	r0, #0
 8033dd2:	dcb0      	bgt.n	8033d36 <_dtoa_r+0xa5e>
 8033dd4:	d102      	bne.n	8033ddc <_dtoa_r+0xb04>
 8033dd6:	f018 0f01 	tst.w	r8, #1
 8033dda:	d1ac      	bne.n	8033d36 <_dtoa_r+0xa5e>
 8033ddc:	4633      	mov	r3, r6
 8033dde:	461e      	mov	r6, r3
 8033de0:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
 8033de4:	2a30      	cmp	r2, #48	@ 0x30
 8033de6:	d0fa      	beq.n	8033dde <_dtoa_r+0xb06>
 8033de8:	e5c2      	b.n	8033970 <_dtoa_r+0x698>
 8033dea:	459a      	cmp	sl, r3
 8033dec:	d1a4      	bne.n	8033d38 <_dtoa_r+0xa60>
 8033dee:	9b04      	ldr	r3, [sp, #16]
 8033df0:	3301      	adds	r3, #1
 8033df2:	9304      	str	r3, [sp, #16]
 8033df4:	2331      	movs	r3, #49	@ 0x31
 8033df6:	f88a 3000 	strb.w	r3, [sl]
 8033dfa:	e5b9      	b.n	8033970 <_dtoa_r+0x698>
 8033dfc:	9b23      	ldr	r3, [sp, #140]	@ 0x8c
 8033dfe:	f8df a05c 	ldr.w	sl, [pc, #92]	@ 8033e5c <_dtoa_r+0xb84>
 8033e02:	b11b      	cbz	r3, 8033e0c <_dtoa_r+0xb34>
 8033e04:	f10a 0308 	add.w	r3, sl, #8
 8033e08:	9a23      	ldr	r2, [sp, #140]	@ 0x8c
 8033e0a:	6013      	str	r3, [r2, #0]
 8033e0c:	4650      	mov	r0, sl
 8033e0e:	b019      	add	sp, #100	@ 0x64
 8033e10:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8033e14:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8033e16:	2b01      	cmp	r3, #1
 8033e18:	f77f ae37 	ble.w	8033a8a <_dtoa_r+0x7b2>
 8033e1c:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 8033e1e:	930a      	str	r3, [sp, #40]	@ 0x28
 8033e20:	2001      	movs	r0, #1
 8033e22:	e655      	b.n	8033ad0 <_dtoa_r+0x7f8>
 8033e24:	9b00      	ldr	r3, [sp, #0]
 8033e26:	2b00      	cmp	r3, #0
 8033e28:	f77f aed6 	ble.w	8033bd8 <_dtoa_r+0x900>
 8033e2c:	4656      	mov	r6, sl
 8033e2e:	4621      	mov	r1, r4
 8033e30:	4648      	mov	r0, r9
 8033e32:	f7ff f9c6 	bl	80331c2 <quorem>
 8033e36:	f100 0830 	add.w	r8, r0, #48	@ 0x30
 8033e3a:	f806 8b01 	strb.w	r8, [r6], #1
 8033e3e:	9b00      	ldr	r3, [sp, #0]
 8033e40:	eba6 020a 	sub.w	r2, r6, sl
 8033e44:	4293      	cmp	r3, r2
 8033e46:	ddb3      	ble.n	8033db0 <_dtoa_r+0xad8>
 8033e48:	4649      	mov	r1, r9
 8033e4a:	2300      	movs	r3, #0
 8033e4c:	220a      	movs	r2, #10
 8033e4e:	4658      	mov	r0, fp
 8033e50:	f000 f8b2 	bl	8033fb8 <__multadd>
 8033e54:	4681      	mov	r9, r0
 8033e56:	e7ea      	b.n	8033e2e <_dtoa_r+0xb56>
 8033e58:	08083b2d 	.word	0x08083b2d
 8033e5c:	08083ab1 	.word	0x08083ab1

08033e60 <_free_r>:
 8033e60:	b538      	push	{r3, r4, r5, lr}
 8033e62:	4605      	mov	r5, r0
 8033e64:	2900      	cmp	r1, #0
 8033e66:	d041      	beq.n	8033eec <_free_r+0x8c>
 8033e68:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8033e6c:	1f0c      	subs	r4, r1, #4
 8033e6e:	2b00      	cmp	r3, #0
 8033e70:	bfb8      	it	lt
 8033e72:	18e4      	addlt	r4, r4, r3
 8033e74:	f7fe fa44 	bl	8032300 <__malloc_lock>
 8033e78:	4a1d      	ldr	r2, [pc, #116]	@ (8033ef0 <_free_r+0x90>)
 8033e7a:	6813      	ldr	r3, [r2, #0]
 8033e7c:	b933      	cbnz	r3, 8033e8c <_free_r+0x2c>
 8033e7e:	6063      	str	r3, [r4, #4]
 8033e80:	6014      	str	r4, [r2, #0]
 8033e82:	4628      	mov	r0, r5
 8033e84:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8033e88:	f7fe ba40 	b.w	803230c <__malloc_unlock>
 8033e8c:	42a3      	cmp	r3, r4
 8033e8e:	d908      	bls.n	8033ea2 <_free_r+0x42>
 8033e90:	6820      	ldr	r0, [r4, #0]
 8033e92:	1821      	adds	r1, r4, r0
 8033e94:	428b      	cmp	r3, r1
 8033e96:	bf01      	itttt	eq
 8033e98:	6819      	ldreq	r1, [r3, #0]
 8033e9a:	685b      	ldreq	r3, [r3, #4]
 8033e9c:	1809      	addeq	r1, r1, r0
 8033e9e:	6021      	streq	r1, [r4, #0]
 8033ea0:	e7ed      	b.n	8033e7e <_free_r+0x1e>
 8033ea2:	461a      	mov	r2, r3
 8033ea4:	685b      	ldr	r3, [r3, #4]
 8033ea6:	b10b      	cbz	r3, 8033eac <_free_r+0x4c>
 8033ea8:	42a3      	cmp	r3, r4
 8033eaa:	d9fa      	bls.n	8033ea2 <_free_r+0x42>
 8033eac:	6811      	ldr	r1, [r2, #0]
 8033eae:	1850      	adds	r0, r2, r1
 8033eb0:	42a0      	cmp	r0, r4
 8033eb2:	d10b      	bne.n	8033ecc <_free_r+0x6c>
 8033eb4:	6820      	ldr	r0, [r4, #0]
 8033eb6:	4401      	add	r1, r0
 8033eb8:	1850      	adds	r0, r2, r1
 8033eba:	4283      	cmp	r3, r0
 8033ebc:	6011      	str	r1, [r2, #0]
 8033ebe:	d1e0      	bne.n	8033e82 <_free_r+0x22>
 8033ec0:	6818      	ldr	r0, [r3, #0]
 8033ec2:	685b      	ldr	r3, [r3, #4]
 8033ec4:	6053      	str	r3, [r2, #4]
 8033ec6:	4408      	add	r0, r1
 8033ec8:	6010      	str	r0, [r2, #0]
 8033eca:	e7da      	b.n	8033e82 <_free_r+0x22>
 8033ecc:	d902      	bls.n	8033ed4 <_free_r+0x74>
 8033ece:	230c      	movs	r3, #12
 8033ed0:	602b      	str	r3, [r5, #0]
 8033ed2:	e7d6      	b.n	8033e82 <_free_r+0x22>
 8033ed4:	6820      	ldr	r0, [r4, #0]
 8033ed6:	1821      	adds	r1, r4, r0
 8033ed8:	428b      	cmp	r3, r1
 8033eda:	bf04      	itt	eq
 8033edc:	6819      	ldreq	r1, [r3, #0]
 8033ede:	685b      	ldreq	r3, [r3, #4]
 8033ee0:	6063      	str	r3, [r4, #4]
 8033ee2:	bf04      	itt	eq
 8033ee4:	1809      	addeq	r1, r1, r0
 8033ee6:	6021      	streq	r1, [r4, #0]
 8033ee8:	6054      	str	r4, [r2, #4]
 8033eea:	e7ca      	b.n	8033e82 <_free_r+0x22>
 8033eec:	bd38      	pop	{r3, r4, r5, pc}
 8033eee:	bf00      	nop
 8033ef0:	20012250 	.word	0x20012250

08033ef4 <_Balloc>:
 8033ef4:	b570      	push	{r4, r5, r6, lr}
 8033ef6:	69c6      	ldr	r6, [r0, #28]
 8033ef8:	4604      	mov	r4, r0
 8033efa:	460d      	mov	r5, r1
 8033efc:	b976      	cbnz	r6, 8033f1c <_Balloc+0x28>
 8033efe:	2010      	movs	r0, #16
 8033f00:	f7fe f94c 	bl	803219c <malloc>
 8033f04:	4602      	mov	r2, r0
 8033f06:	61e0      	str	r0, [r4, #28]
 8033f08:	b920      	cbnz	r0, 8033f14 <_Balloc+0x20>
 8033f0a:	4b18      	ldr	r3, [pc, #96]	@ (8033f6c <_Balloc+0x78>)
 8033f0c:	4818      	ldr	r0, [pc, #96]	@ (8033f70 <_Balloc+0x7c>)
 8033f0e:	216b      	movs	r1, #107	@ 0x6b
 8033f10:	f7fe f90a 	bl	8032128 <__assert_func>
 8033f14:	e9c0 6601 	strd	r6, r6, [r0, #4]
 8033f18:	6006      	str	r6, [r0, #0]
 8033f1a:	60c6      	str	r6, [r0, #12]
 8033f1c:	69e6      	ldr	r6, [r4, #28]
 8033f1e:	68f3      	ldr	r3, [r6, #12]
 8033f20:	b183      	cbz	r3, 8033f44 <_Balloc+0x50>
 8033f22:	69e3      	ldr	r3, [r4, #28]
 8033f24:	68db      	ldr	r3, [r3, #12]
 8033f26:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
 8033f2a:	b9b8      	cbnz	r0, 8033f5c <_Balloc+0x68>
 8033f2c:	2101      	movs	r1, #1
 8033f2e:	fa01 f605 	lsl.w	r6, r1, r5
 8033f32:	1d72      	adds	r2, r6, #5
 8033f34:	0092      	lsls	r2, r2, #2
 8033f36:	4620      	mov	r0, r4
 8033f38:	f7fe f91c 	bl	8032174 <_calloc_r>
 8033f3c:	b160      	cbz	r0, 8033f58 <_Balloc+0x64>
 8033f3e:	e9c0 5601 	strd	r5, r6, [r0, #4]
 8033f42:	e00e      	b.n	8033f62 <_Balloc+0x6e>
 8033f44:	2221      	movs	r2, #33	@ 0x21
 8033f46:	2104      	movs	r1, #4
 8033f48:	4620      	mov	r0, r4
 8033f4a:	f7fe f913 	bl	8032174 <_calloc_r>
 8033f4e:	69e3      	ldr	r3, [r4, #28]
 8033f50:	60f0      	str	r0, [r6, #12]
 8033f52:	68db      	ldr	r3, [r3, #12]
 8033f54:	2b00      	cmp	r3, #0
 8033f56:	d1e4      	bne.n	8033f22 <_Balloc+0x2e>
 8033f58:	2000      	movs	r0, #0
 8033f5a:	bd70      	pop	{r4, r5, r6, pc}
 8033f5c:	6802      	ldr	r2, [r0, #0]
 8033f5e:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
 8033f62:	2300      	movs	r3, #0
 8033f64:	e9c0 3303 	strd	r3, r3, [r0, #12]
 8033f68:	e7f7      	b.n	8033f5a <_Balloc+0x66>
 8033f6a:	bf00      	nop
 8033f6c:	08083abe 	.word	0x08083abe
 8033f70:	08083b3e 	.word	0x08083b3e

08033f74 <_Bfree>:
 8033f74:	b570      	push	{r4, r5, r6, lr}
 8033f76:	69c6      	ldr	r6, [r0, #28]
 8033f78:	4605      	mov	r5, r0
 8033f7a:	460c      	mov	r4, r1
 8033f7c:	b976      	cbnz	r6, 8033f9c <_Bfree+0x28>
 8033f7e:	2010      	movs	r0, #16
 8033f80:	f7fe f90c 	bl	803219c <malloc>
 8033f84:	4602      	mov	r2, r0
 8033f86:	61e8      	str	r0, [r5, #28]
 8033f88:	b920      	cbnz	r0, 8033f94 <_Bfree+0x20>
 8033f8a:	4b09      	ldr	r3, [pc, #36]	@ (8033fb0 <_Bfree+0x3c>)
 8033f8c:	4809      	ldr	r0, [pc, #36]	@ (8033fb4 <_Bfree+0x40>)
 8033f8e:	218f      	movs	r1, #143	@ 0x8f
 8033f90:	f7fe f8ca 	bl	8032128 <__assert_func>
 8033f94:	e9c0 6601 	strd	r6, r6, [r0, #4]
 8033f98:	6006      	str	r6, [r0, #0]
 8033f9a:	60c6      	str	r6, [r0, #12]
 8033f9c:	b13c      	cbz	r4, 8033fae <_Bfree+0x3a>
 8033f9e:	69eb      	ldr	r3, [r5, #28]
 8033fa0:	6862      	ldr	r2, [r4, #4]
 8033fa2:	68db      	ldr	r3, [r3, #12]
 8033fa4:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 8033fa8:	6021      	str	r1, [r4, #0]
 8033faa:	f843 4022 	str.w	r4, [r3, r2, lsl #2]
 8033fae:	bd70      	pop	{r4, r5, r6, pc}
 8033fb0:	08083abe 	.word	0x08083abe
 8033fb4:	08083b3e 	.word	0x08083b3e

08033fb8 <__multadd>:
 8033fb8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8033fbc:	690d      	ldr	r5, [r1, #16]
 8033fbe:	4607      	mov	r7, r0
 8033fc0:	460c      	mov	r4, r1
 8033fc2:	461e      	mov	r6, r3
 8033fc4:	f101 0c14 	add.w	ip, r1, #20
 8033fc8:	2000      	movs	r0, #0
 8033fca:	f8dc 3000 	ldr.w	r3, [ip]
 8033fce:	b299      	uxth	r1, r3
 8033fd0:	fb02 6101 	mla	r1, r2, r1, r6
 8033fd4:	0c1e      	lsrs	r6, r3, #16
 8033fd6:	0c0b      	lsrs	r3, r1, #16
 8033fd8:	fb02 3306 	mla	r3, r2, r6, r3
 8033fdc:	b289      	uxth	r1, r1
 8033fde:	3001      	adds	r0, #1
 8033fe0:	eb01 4103 	add.w	r1, r1, r3, lsl #16
 8033fe4:	4285      	cmp	r5, r0
 8033fe6:	f84c 1b04 	str.w	r1, [ip], #4
 8033fea:	ea4f 4613 	mov.w	r6, r3, lsr #16
 8033fee:	dcec      	bgt.n	8033fca <__multadd+0x12>
 8033ff0:	b30e      	cbz	r6, 8034036 <__multadd+0x7e>
 8033ff2:	68a3      	ldr	r3, [r4, #8]
 8033ff4:	42ab      	cmp	r3, r5
 8033ff6:	dc19      	bgt.n	803402c <__multadd+0x74>
 8033ff8:	6861      	ldr	r1, [r4, #4]
 8033ffa:	4638      	mov	r0, r7
 8033ffc:	3101      	adds	r1, #1
 8033ffe:	f7ff ff79 	bl	8033ef4 <_Balloc>
 8034002:	4680      	mov	r8, r0
 8034004:	b928      	cbnz	r0, 8034012 <__multadd+0x5a>
 8034006:	4602      	mov	r2, r0
 8034008:	4b0c      	ldr	r3, [pc, #48]	@ (803403c <__multadd+0x84>)
 803400a:	480d      	ldr	r0, [pc, #52]	@ (8034040 <__multadd+0x88>)
 803400c:	21ba      	movs	r1, #186	@ 0xba
 803400e:	f7fe f88b 	bl	8032128 <__assert_func>
 8034012:	6922      	ldr	r2, [r4, #16]
 8034014:	3202      	adds	r2, #2
 8034016:	f104 010c 	add.w	r1, r4, #12
 803401a:	0092      	lsls	r2, r2, #2
 803401c:	300c      	adds	r0, #12
 803401e:	f7ff f8c2 	bl	80331a6 <memcpy>
 8034022:	4621      	mov	r1, r4
 8034024:	4638      	mov	r0, r7
 8034026:	f7ff ffa5 	bl	8033f74 <_Bfree>
 803402a:	4644      	mov	r4, r8
 803402c:	eb04 0385 	add.w	r3, r4, r5, lsl #2
 8034030:	3501      	adds	r5, #1
 8034032:	615e      	str	r6, [r3, #20]
 8034034:	6125      	str	r5, [r4, #16]
 8034036:	4620      	mov	r0, r4
 8034038:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 803403c:	08083b2d 	.word	0x08083b2d
 8034040:	08083b3e 	.word	0x08083b3e

08034044 <__hi0bits>:
 8034044:	f5b0 3f80 	cmp.w	r0, #65536	@ 0x10000
 8034048:	4603      	mov	r3, r0
 803404a:	bf36      	itet	cc
 803404c:	0403      	lslcc	r3, r0, #16
 803404e:	2000      	movcs	r0, #0
 8034050:	2010      	movcc	r0, #16
 8034052:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 8034056:	bf3c      	itt	cc
 8034058:	021b      	lslcc	r3, r3, #8
 803405a:	3008      	addcc	r0, #8
 803405c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 8034060:	bf3c      	itt	cc
 8034062:	011b      	lslcc	r3, r3, #4
 8034064:	3004      	addcc	r0, #4
 8034066:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 803406a:	bf3c      	itt	cc
 803406c:	009b      	lslcc	r3, r3, #2
 803406e:	3002      	addcc	r0, #2
 8034070:	2b00      	cmp	r3, #0
 8034072:	db05      	blt.n	8034080 <__hi0bits+0x3c>
 8034074:	f013 4f80 	tst.w	r3, #1073741824	@ 0x40000000
 8034078:	f100 0001 	add.w	r0, r0, #1
 803407c:	bf08      	it	eq
 803407e:	2020      	moveq	r0, #32
 8034080:	4770      	bx	lr

08034082 <__lo0bits>:
 8034082:	6803      	ldr	r3, [r0, #0]
 8034084:	4602      	mov	r2, r0
 8034086:	f013 0007 	ands.w	r0, r3, #7
 803408a:	d00b      	beq.n	80340a4 <__lo0bits+0x22>
 803408c:	07d9      	lsls	r1, r3, #31
 803408e:	d421      	bmi.n	80340d4 <__lo0bits+0x52>
 8034090:	0798      	lsls	r0, r3, #30
 8034092:	bf49      	itett	mi
 8034094:	085b      	lsrmi	r3, r3, #1
 8034096:	089b      	lsrpl	r3, r3, #2
 8034098:	2001      	movmi	r0, #1
 803409a:	6013      	strmi	r3, [r2, #0]
 803409c:	bf5c      	itt	pl
 803409e:	6013      	strpl	r3, [r2, #0]
 80340a0:	2002      	movpl	r0, #2
 80340a2:	4770      	bx	lr
 80340a4:	b299      	uxth	r1, r3
 80340a6:	b909      	cbnz	r1, 80340ac <__lo0bits+0x2a>
 80340a8:	0c1b      	lsrs	r3, r3, #16
 80340aa:	2010      	movs	r0, #16
 80340ac:	b2d9      	uxtb	r1, r3
 80340ae:	b909      	cbnz	r1, 80340b4 <__lo0bits+0x32>
 80340b0:	3008      	adds	r0, #8
 80340b2:	0a1b      	lsrs	r3, r3, #8
 80340b4:	0719      	lsls	r1, r3, #28
 80340b6:	bf04      	itt	eq
 80340b8:	091b      	lsreq	r3, r3, #4
 80340ba:	3004      	addeq	r0, #4
 80340bc:	0799      	lsls	r1, r3, #30
 80340be:	bf04      	itt	eq
 80340c0:	089b      	lsreq	r3, r3, #2
 80340c2:	3002      	addeq	r0, #2
 80340c4:	07d9      	lsls	r1, r3, #31
 80340c6:	d403      	bmi.n	80340d0 <__lo0bits+0x4e>
 80340c8:	085b      	lsrs	r3, r3, #1
 80340ca:	f100 0001 	add.w	r0, r0, #1
 80340ce:	d003      	beq.n	80340d8 <__lo0bits+0x56>
 80340d0:	6013      	str	r3, [r2, #0]
 80340d2:	4770      	bx	lr
 80340d4:	2000      	movs	r0, #0
 80340d6:	4770      	bx	lr
 80340d8:	2020      	movs	r0, #32
 80340da:	4770      	bx	lr

080340dc <__i2b>:
 80340dc:	b510      	push	{r4, lr}
 80340de:	460c      	mov	r4, r1
 80340e0:	2101      	movs	r1, #1
 80340e2:	f7ff ff07 	bl	8033ef4 <_Balloc>
 80340e6:	4602      	mov	r2, r0
 80340e8:	b928      	cbnz	r0, 80340f6 <__i2b+0x1a>
 80340ea:	4b05      	ldr	r3, [pc, #20]	@ (8034100 <__i2b+0x24>)
 80340ec:	4805      	ldr	r0, [pc, #20]	@ (8034104 <__i2b+0x28>)
 80340ee:	f240 1145 	movw	r1, #325	@ 0x145
 80340f2:	f7fe f819 	bl	8032128 <__assert_func>
 80340f6:	2301      	movs	r3, #1
 80340f8:	6144      	str	r4, [r0, #20]
 80340fa:	6103      	str	r3, [r0, #16]
 80340fc:	bd10      	pop	{r4, pc}
 80340fe:	bf00      	nop
 8034100:	08083b2d 	.word	0x08083b2d
 8034104:	08083b3e 	.word	0x08083b3e

08034108 <__multiply>:
 8034108:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 803410c:	4614      	mov	r4, r2
 803410e:	690a      	ldr	r2, [r1, #16]
 8034110:	6923      	ldr	r3, [r4, #16]
 8034112:	429a      	cmp	r2, r3
 8034114:	bfa8      	it	ge
 8034116:	4623      	movge	r3, r4
 8034118:	460f      	mov	r7, r1
 803411a:	bfa4      	itt	ge
 803411c:	460c      	movge	r4, r1
 803411e:	461f      	movge	r7, r3
 8034120:	f8d4 a010 	ldr.w	sl, [r4, #16]
 8034124:	f8d7 9010 	ldr.w	r9, [r7, #16]
 8034128:	68a3      	ldr	r3, [r4, #8]
 803412a:	6861      	ldr	r1, [r4, #4]
 803412c:	eb0a 0609 	add.w	r6, sl, r9
 8034130:	42b3      	cmp	r3, r6
 8034132:	b085      	sub	sp, #20
 8034134:	bfb8      	it	lt
 8034136:	3101      	addlt	r1, #1
 8034138:	f7ff fedc 	bl	8033ef4 <_Balloc>
 803413c:	b930      	cbnz	r0, 803414c <__multiply+0x44>
 803413e:	4602      	mov	r2, r0
 8034140:	4b44      	ldr	r3, [pc, #272]	@ (8034254 <__multiply+0x14c>)
 8034142:	4845      	ldr	r0, [pc, #276]	@ (8034258 <__multiply+0x150>)
 8034144:	f44f 71b1 	mov.w	r1, #354	@ 0x162
 8034148:	f7fd ffee 	bl	8032128 <__assert_func>
 803414c:	f100 0514 	add.w	r5, r0, #20
 8034150:	eb05 0886 	add.w	r8, r5, r6, lsl #2
 8034154:	462b      	mov	r3, r5
 8034156:	2200      	movs	r2, #0
 8034158:	4543      	cmp	r3, r8
 803415a:	d321      	bcc.n	80341a0 <__multiply+0x98>
 803415c:	f107 0114 	add.w	r1, r7, #20
 8034160:	f104 0214 	add.w	r2, r4, #20
 8034164:	eb02 028a 	add.w	r2, r2, sl, lsl #2
 8034168:	eb01 0389 	add.w	r3, r1, r9, lsl #2
 803416c:	9302      	str	r3, [sp, #8]
 803416e:	1b13      	subs	r3, r2, r4
 8034170:	3b15      	subs	r3, #21
 8034172:	f023 0303 	bic.w	r3, r3, #3
 8034176:	3304      	adds	r3, #4
 8034178:	f104 0715 	add.w	r7, r4, #21
 803417c:	42ba      	cmp	r2, r7
 803417e:	bf38      	it	cc
 8034180:	2304      	movcc	r3, #4
 8034182:	9301      	str	r3, [sp, #4]
 8034184:	9b02      	ldr	r3, [sp, #8]
 8034186:	9103      	str	r1, [sp, #12]
 8034188:	428b      	cmp	r3, r1
 803418a:	d80c      	bhi.n	80341a6 <__multiply+0x9e>
 803418c:	2e00      	cmp	r6, #0
 803418e:	dd03      	ble.n	8034198 <__multiply+0x90>
 8034190:	f858 3d04 	ldr.w	r3, [r8, #-4]!
 8034194:	2b00      	cmp	r3, #0
 8034196:	d05b      	beq.n	8034250 <__multiply+0x148>
 8034198:	6106      	str	r6, [r0, #16]
 803419a:	b005      	add	sp, #20
 803419c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80341a0:	f843 2b04 	str.w	r2, [r3], #4
 80341a4:	e7d8      	b.n	8034158 <__multiply+0x50>
 80341a6:	f8b1 a000 	ldrh.w	sl, [r1]
 80341aa:	f1ba 0f00 	cmp.w	sl, #0
 80341ae:	d024      	beq.n	80341fa <__multiply+0xf2>
 80341b0:	f104 0e14 	add.w	lr, r4, #20
 80341b4:	46a9      	mov	r9, r5
 80341b6:	f04f 0c00 	mov.w	ip, #0
 80341ba:	f85e 7b04 	ldr.w	r7, [lr], #4
 80341be:	f8d9 3000 	ldr.w	r3, [r9]
 80341c2:	fa1f fb87 	uxth.w	fp, r7
 80341c6:	b29b      	uxth	r3, r3
 80341c8:	fb0a 330b 	mla	r3, sl, fp, r3
 80341cc:	ea4f 4b17 	mov.w	fp, r7, lsr #16
 80341d0:	f8d9 7000 	ldr.w	r7, [r9]
 80341d4:	4463      	add	r3, ip
 80341d6:	ea4f 4c17 	mov.w	ip, r7, lsr #16
 80341da:	fb0a c70b 	mla	r7, sl, fp, ip
 80341de:	eb07 4713 	add.w	r7, r7, r3, lsr #16
 80341e2:	b29b      	uxth	r3, r3
 80341e4:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
 80341e8:	4572      	cmp	r2, lr
 80341ea:	f849 3b04 	str.w	r3, [r9], #4
 80341ee:	ea4f 4c17 	mov.w	ip, r7, lsr #16
 80341f2:	d8e2      	bhi.n	80341ba <__multiply+0xb2>
 80341f4:	9b01      	ldr	r3, [sp, #4]
 80341f6:	f845 c003 	str.w	ip, [r5, r3]
 80341fa:	9b03      	ldr	r3, [sp, #12]
 80341fc:	f8b3 9002 	ldrh.w	r9, [r3, #2]
 8034200:	3104      	adds	r1, #4
 8034202:	f1b9 0f00 	cmp.w	r9, #0
 8034206:	d021      	beq.n	803424c <__multiply+0x144>
 8034208:	682b      	ldr	r3, [r5, #0]
 803420a:	f104 0c14 	add.w	ip, r4, #20
 803420e:	46ae      	mov	lr, r5
 8034210:	f04f 0a00 	mov.w	sl, #0
 8034214:	f8bc b000 	ldrh.w	fp, [ip]
 8034218:	f8be 7002 	ldrh.w	r7, [lr, #2]
 803421c:	fb09 770b 	mla	r7, r9, fp, r7
 8034220:	4457      	add	r7, sl
 8034222:	b29b      	uxth	r3, r3
 8034224:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
 8034228:	f84e 3b04 	str.w	r3, [lr], #4
 803422c:	f85c 3b04 	ldr.w	r3, [ip], #4
 8034230:	ea4f 4a13 	mov.w	sl, r3, lsr #16
 8034234:	f8be 3000 	ldrh.w	r3, [lr]
 8034238:	fb09 330a 	mla	r3, r9, sl, r3
 803423c:	eb03 4317 	add.w	r3, r3, r7, lsr #16
 8034240:	4562      	cmp	r2, ip
 8034242:	ea4f 4a13 	mov.w	sl, r3, lsr #16
 8034246:	d8e5      	bhi.n	8034214 <__multiply+0x10c>
 8034248:	9f01      	ldr	r7, [sp, #4]
 803424a:	51eb      	str	r3, [r5, r7]
 803424c:	3504      	adds	r5, #4
 803424e:	e799      	b.n	8034184 <__multiply+0x7c>
 8034250:	3e01      	subs	r6, #1
 8034252:	e79b      	b.n	803418c <__multiply+0x84>
 8034254:	08083b2d 	.word	0x08083b2d
 8034258:	08083b3e 	.word	0x08083b3e

0803425c <__pow5mult>:
 803425c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8034260:	4615      	mov	r5, r2
 8034262:	f012 0203 	ands.w	r2, r2, #3
 8034266:	4607      	mov	r7, r0
 8034268:	460e      	mov	r6, r1
 803426a:	d007      	beq.n	803427c <__pow5mult+0x20>
 803426c:	4c25      	ldr	r4, [pc, #148]	@ (8034304 <__pow5mult+0xa8>)
 803426e:	3a01      	subs	r2, #1
 8034270:	2300      	movs	r3, #0
 8034272:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
 8034276:	f7ff fe9f 	bl	8033fb8 <__multadd>
 803427a:	4606      	mov	r6, r0
 803427c:	10ad      	asrs	r5, r5, #2
 803427e:	d03d      	beq.n	80342fc <__pow5mult+0xa0>
 8034280:	69fc      	ldr	r4, [r7, #28]
 8034282:	b97c      	cbnz	r4, 80342a4 <__pow5mult+0x48>
 8034284:	2010      	movs	r0, #16
 8034286:	f7fd ff89 	bl	803219c <malloc>
 803428a:	4602      	mov	r2, r0
 803428c:	61f8      	str	r0, [r7, #28]
 803428e:	b928      	cbnz	r0, 803429c <__pow5mult+0x40>
 8034290:	4b1d      	ldr	r3, [pc, #116]	@ (8034308 <__pow5mult+0xac>)
 8034292:	481e      	ldr	r0, [pc, #120]	@ (803430c <__pow5mult+0xb0>)
 8034294:	f240 11b3 	movw	r1, #435	@ 0x1b3
 8034298:	f7fd ff46 	bl	8032128 <__assert_func>
 803429c:	e9c0 4401 	strd	r4, r4, [r0, #4]
 80342a0:	6004      	str	r4, [r0, #0]
 80342a2:	60c4      	str	r4, [r0, #12]
 80342a4:	f8d7 801c 	ldr.w	r8, [r7, #28]
 80342a8:	f8d8 4008 	ldr.w	r4, [r8, #8]
 80342ac:	b94c      	cbnz	r4, 80342c2 <__pow5mult+0x66>
 80342ae:	f240 2171 	movw	r1, #625	@ 0x271
 80342b2:	4638      	mov	r0, r7
 80342b4:	f7ff ff12 	bl	80340dc <__i2b>
 80342b8:	2300      	movs	r3, #0
 80342ba:	f8c8 0008 	str.w	r0, [r8, #8]
 80342be:	4604      	mov	r4, r0
 80342c0:	6003      	str	r3, [r0, #0]
 80342c2:	f04f 0900 	mov.w	r9, #0
 80342c6:	07eb      	lsls	r3, r5, #31
 80342c8:	d50a      	bpl.n	80342e0 <__pow5mult+0x84>
 80342ca:	4631      	mov	r1, r6
 80342cc:	4622      	mov	r2, r4
 80342ce:	4638      	mov	r0, r7
 80342d0:	f7ff ff1a 	bl	8034108 <__multiply>
 80342d4:	4631      	mov	r1, r6
 80342d6:	4680      	mov	r8, r0
 80342d8:	4638      	mov	r0, r7
 80342da:	f7ff fe4b 	bl	8033f74 <_Bfree>
 80342de:	4646      	mov	r6, r8
 80342e0:	106d      	asrs	r5, r5, #1
 80342e2:	d00b      	beq.n	80342fc <__pow5mult+0xa0>
 80342e4:	6820      	ldr	r0, [r4, #0]
 80342e6:	b938      	cbnz	r0, 80342f8 <__pow5mult+0x9c>
 80342e8:	4622      	mov	r2, r4
 80342ea:	4621      	mov	r1, r4
 80342ec:	4638      	mov	r0, r7
 80342ee:	f7ff ff0b 	bl	8034108 <__multiply>
 80342f2:	6020      	str	r0, [r4, #0]
 80342f4:	f8c0 9000 	str.w	r9, [r0]
 80342f8:	4604      	mov	r4, r0
 80342fa:	e7e4      	b.n	80342c6 <__pow5mult+0x6a>
 80342fc:	4630      	mov	r0, r6
 80342fe:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8034302:	bf00      	nop
 8034304:	08083b98 	.word	0x08083b98
 8034308:	08083abe 	.word	0x08083abe
 803430c:	08083b3e 	.word	0x08083b3e

08034310 <__lshift>:
 8034310:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8034314:	460c      	mov	r4, r1
 8034316:	6849      	ldr	r1, [r1, #4]
 8034318:	6923      	ldr	r3, [r4, #16]
 803431a:	eb03 1862 	add.w	r8, r3, r2, asr #5
 803431e:	68a3      	ldr	r3, [r4, #8]
 8034320:	4607      	mov	r7, r0
 8034322:	4691      	mov	r9, r2
 8034324:	ea4f 1a62 	mov.w	sl, r2, asr #5
 8034328:	f108 0601 	add.w	r6, r8, #1
 803432c:	42b3      	cmp	r3, r6
 803432e:	db0b      	blt.n	8034348 <__lshift+0x38>
 8034330:	4638      	mov	r0, r7
 8034332:	f7ff fddf 	bl	8033ef4 <_Balloc>
 8034336:	4605      	mov	r5, r0
 8034338:	b948      	cbnz	r0, 803434e <__lshift+0x3e>
 803433a:	4602      	mov	r2, r0
 803433c:	4b28      	ldr	r3, [pc, #160]	@ (80343e0 <__lshift+0xd0>)
 803433e:	4829      	ldr	r0, [pc, #164]	@ (80343e4 <__lshift+0xd4>)
 8034340:	f44f 71ef 	mov.w	r1, #478	@ 0x1de
 8034344:	f7fd fef0 	bl	8032128 <__assert_func>
 8034348:	3101      	adds	r1, #1
 803434a:	005b      	lsls	r3, r3, #1
 803434c:	e7ee      	b.n	803432c <__lshift+0x1c>
 803434e:	2300      	movs	r3, #0
 8034350:	f100 0114 	add.w	r1, r0, #20
 8034354:	f100 0210 	add.w	r2, r0, #16
 8034358:	4618      	mov	r0, r3
 803435a:	4553      	cmp	r3, sl
 803435c:	db33      	blt.n	80343c6 <__lshift+0xb6>
 803435e:	6920      	ldr	r0, [r4, #16]
 8034360:	ea2a 7aea 	bic.w	sl, sl, sl, asr #31
 8034364:	f104 0314 	add.w	r3, r4, #20
 8034368:	f019 091f 	ands.w	r9, r9, #31
 803436c:	eb01 018a 	add.w	r1, r1, sl, lsl #2
 8034370:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
 8034374:	d02b      	beq.n	80343ce <__lshift+0xbe>
 8034376:	f1c9 0e20 	rsb	lr, r9, #32
 803437a:	468a      	mov	sl, r1
 803437c:	2200      	movs	r2, #0
 803437e:	6818      	ldr	r0, [r3, #0]
 8034380:	fa00 f009 	lsl.w	r0, r0, r9
 8034384:	4310      	orrs	r0, r2
 8034386:	f84a 0b04 	str.w	r0, [sl], #4
 803438a:	f853 2b04 	ldr.w	r2, [r3], #4
 803438e:	459c      	cmp	ip, r3
 8034390:	fa22 f20e 	lsr.w	r2, r2, lr
 8034394:	d8f3      	bhi.n	803437e <__lshift+0x6e>
 8034396:	ebac 0304 	sub.w	r3, ip, r4
 803439a:	3b15      	subs	r3, #21
 803439c:	f023 0303 	bic.w	r3, r3, #3
 80343a0:	3304      	adds	r3, #4
 80343a2:	f104 0015 	add.w	r0, r4, #21
 80343a6:	4584      	cmp	ip, r0
 80343a8:	bf38      	it	cc
 80343aa:	2304      	movcc	r3, #4
 80343ac:	50ca      	str	r2, [r1, r3]
 80343ae:	b10a      	cbz	r2, 80343b4 <__lshift+0xa4>
 80343b0:	f108 0602 	add.w	r6, r8, #2
 80343b4:	3e01      	subs	r6, #1
 80343b6:	4638      	mov	r0, r7
 80343b8:	612e      	str	r6, [r5, #16]
 80343ba:	4621      	mov	r1, r4
 80343bc:	f7ff fdda 	bl	8033f74 <_Bfree>
 80343c0:	4628      	mov	r0, r5
 80343c2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80343c6:	f842 0f04 	str.w	r0, [r2, #4]!
 80343ca:	3301      	adds	r3, #1
 80343cc:	e7c5      	b.n	803435a <__lshift+0x4a>
 80343ce:	3904      	subs	r1, #4
 80343d0:	f853 2b04 	ldr.w	r2, [r3], #4
 80343d4:	f841 2f04 	str.w	r2, [r1, #4]!
 80343d8:	459c      	cmp	ip, r3
 80343da:	d8f9      	bhi.n	80343d0 <__lshift+0xc0>
 80343dc:	e7ea      	b.n	80343b4 <__lshift+0xa4>
 80343de:	bf00      	nop
 80343e0:	08083b2d 	.word	0x08083b2d
 80343e4:	08083b3e 	.word	0x08083b3e

080343e8 <__mcmp>:
 80343e8:	690a      	ldr	r2, [r1, #16]
 80343ea:	4603      	mov	r3, r0
 80343ec:	6900      	ldr	r0, [r0, #16]
 80343ee:	1a80      	subs	r0, r0, r2
 80343f0:	b530      	push	{r4, r5, lr}
 80343f2:	d10e      	bne.n	8034412 <__mcmp+0x2a>
 80343f4:	3314      	adds	r3, #20
 80343f6:	3114      	adds	r1, #20
 80343f8:	eb03 0482 	add.w	r4, r3, r2, lsl #2
 80343fc:	eb01 0182 	add.w	r1, r1, r2, lsl #2
 8034400:	f854 5d04 	ldr.w	r5, [r4, #-4]!
 8034404:	f851 2d04 	ldr.w	r2, [r1, #-4]!
 8034408:	4295      	cmp	r5, r2
 803440a:	d003      	beq.n	8034414 <__mcmp+0x2c>
 803440c:	d205      	bcs.n	803441a <__mcmp+0x32>
 803440e:	f04f 30ff 	mov.w	r0, #4294967295
 8034412:	bd30      	pop	{r4, r5, pc}
 8034414:	42a3      	cmp	r3, r4
 8034416:	d3f3      	bcc.n	8034400 <__mcmp+0x18>
 8034418:	e7fb      	b.n	8034412 <__mcmp+0x2a>
 803441a:	2001      	movs	r0, #1
 803441c:	e7f9      	b.n	8034412 <__mcmp+0x2a>
	...

08034420 <__mdiff>:
 8034420:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8034424:	4689      	mov	r9, r1
 8034426:	4606      	mov	r6, r0
 8034428:	4611      	mov	r1, r2
 803442a:	4648      	mov	r0, r9
 803442c:	4614      	mov	r4, r2
 803442e:	f7ff ffdb 	bl	80343e8 <__mcmp>
 8034432:	1e05      	subs	r5, r0, #0
 8034434:	d112      	bne.n	803445c <__mdiff+0x3c>
 8034436:	4629      	mov	r1, r5
 8034438:	4630      	mov	r0, r6
 803443a:	f7ff fd5b 	bl	8033ef4 <_Balloc>
 803443e:	4602      	mov	r2, r0
 8034440:	b928      	cbnz	r0, 803444e <__mdiff+0x2e>
 8034442:	4b3f      	ldr	r3, [pc, #252]	@ (8034540 <__mdiff+0x120>)
 8034444:	f240 2137 	movw	r1, #567	@ 0x237
 8034448:	483e      	ldr	r0, [pc, #248]	@ (8034544 <__mdiff+0x124>)
 803444a:	f7fd fe6d 	bl	8032128 <__assert_func>
 803444e:	2301      	movs	r3, #1
 8034450:	e9c0 3504 	strd	r3, r5, [r0, #16]
 8034454:	4610      	mov	r0, r2
 8034456:	b003      	add	sp, #12
 8034458:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 803445c:	bfbc      	itt	lt
 803445e:	464b      	movlt	r3, r9
 8034460:	46a1      	movlt	r9, r4
 8034462:	4630      	mov	r0, r6
 8034464:	f8d9 1004 	ldr.w	r1, [r9, #4]
 8034468:	bfba      	itte	lt
 803446a:	461c      	movlt	r4, r3
 803446c:	2501      	movlt	r5, #1
 803446e:	2500      	movge	r5, #0
 8034470:	f7ff fd40 	bl	8033ef4 <_Balloc>
 8034474:	4602      	mov	r2, r0
 8034476:	b918      	cbnz	r0, 8034480 <__mdiff+0x60>
 8034478:	4b31      	ldr	r3, [pc, #196]	@ (8034540 <__mdiff+0x120>)
 803447a:	f240 2145 	movw	r1, #581	@ 0x245
 803447e:	e7e3      	b.n	8034448 <__mdiff+0x28>
 8034480:	f8d9 7010 	ldr.w	r7, [r9, #16]
 8034484:	6926      	ldr	r6, [r4, #16]
 8034486:	60c5      	str	r5, [r0, #12]
 8034488:	f109 0310 	add.w	r3, r9, #16
 803448c:	f109 0514 	add.w	r5, r9, #20
 8034490:	f104 0e14 	add.w	lr, r4, #20
 8034494:	f100 0b14 	add.w	fp, r0, #20
 8034498:	eb05 0887 	add.w	r8, r5, r7, lsl #2
 803449c:	eb0e 0686 	add.w	r6, lr, r6, lsl #2
 80344a0:	9301      	str	r3, [sp, #4]
 80344a2:	46d9      	mov	r9, fp
 80344a4:	f04f 0c00 	mov.w	ip, #0
 80344a8:	9b01      	ldr	r3, [sp, #4]
 80344aa:	f85e 0b04 	ldr.w	r0, [lr], #4
 80344ae:	f853 af04 	ldr.w	sl, [r3, #4]!
 80344b2:	9301      	str	r3, [sp, #4]
 80344b4:	fa1f f38a 	uxth.w	r3, sl
 80344b8:	4619      	mov	r1, r3
 80344ba:	b283      	uxth	r3, r0
 80344bc:	1acb      	subs	r3, r1, r3
 80344be:	0c00      	lsrs	r0, r0, #16
 80344c0:	4463      	add	r3, ip
 80344c2:	ebc0 401a 	rsb	r0, r0, sl, lsr #16
 80344c6:	eb00 4023 	add.w	r0, r0, r3, asr #16
 80344ca:	b29b      	uxth	r3, r3
 80344cc:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
 80344d0:	4576      	cmp	r6, lr
 80344d2:	f849 3b04 	str.w	r3, [r9], #4
 80344d6:	ea4f 4c20 	mov.w	ip, r0, asr #16
 80344da:	d8e5      	bhi.n	80344a8 <__mdiff+0x88>
 80344dc:	1b33      	subs	r3, r6, r4
 80344de:	3b15      	subs	r3, #21
 80344e0:	f023 0303 	bic.w	r3, r3, #3
 80344e4:	3415      	adds	r4, #21
 80344e6:	3304      	adds	r3, #4
 80344e8:	42a6      	cmp	r6, r4
 80344ea:	bf38      	it	cc
 80344ec:	2304      	movcc	r3, #4
 80344ee:	441d      	add	r5, r3
 80344f0:	445b      	add	r3, fp
 80344f2:	461e      	mov	r6, r3
 80344f4:	462c      	mov	r4, r5
 80344f6:	4544      	cmp	r4, r8
 80344f8:	d30e      	bcc.n	8034518 <__mdiff+0xf8>
 80344fa:	f108 0103 	add.w	r1, r8, #3
 80344fe:	1b49      	subs	r1, r1, r5
 8034500:	f021 0103 	bic.w	r1, r1, #3
 8034504:	3d03      	subs	r5, #3
 8034506:	45a8      	cmp	r8, r5
 8034508:	bf38      	it	cc
 803450a:	2100      	movcc	r1, #0
 803450c:	440b      	add	r3, r1
 803450e:	f853 1d04 	ldr.w	r1, [r3, #-4]!
 8034512:	b191      	cbz	r1, 803453a <__mdiff+0x11a>
 8034514:	6117      	str	r7, [r2, #16]
 8034516:	e79d      	b.n	8034454 <__mdiff+0x34>
 8034518:	f854 1b04 	ldr.w	r1, [r4], #4
 803451c:	46e6      	mov	lr, ip
 803451e:	0c08      	lsrs	r0, r1, #16
 8034520:	fa1c fc81 	uxtah	ip, ip, r1
 8034524:	4471      	add	r1, lr
 8034526:	eb00 402c 	add.w	r0, r0, ip, asr #16
 803452a:	b289      	uxth	r1, r1
 803452c:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
 8034530:	f846 1b04 	str.w	r1, [r6], #4
 8034534:	ea4f 4c20 	mov.w	ip, r0, asr #16
 8034538:	e7dd      	b.n	80344f6 <__mdiff+0xd6>
 803453a:	3f01      	subs	r7, #1
 803453c:	e7e7      	b.n	803450e <__mdiff+0xee>
 803453e:	bf00      	nop
 8034540:	08083b2d 	.word	0x08083b2d
 8034544:	08083b3e 	.word	0x08083b3e

08034548 <__d2b>:
 8034548:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 803454c:	460f      	mov	r7, r1
 803454e:	2101      	movs	r1, #1
 8034550:	ec59 8b10 	vmov	r8, r9, d0
 8034554:	4616      	mov	r6, r2
 8034556:	f7ff fccd 	bl	8033ef4 <_Balloc>
 803455a:	4604      	mov	r4, r0
 803455c:	b930      	cbnz	r0, 803456c <__d2b+0x24>
 803455e:	4602      	mov	r2, r0
 8034560:	4b23      	ldr	r3, [pc, #140]	@ (80345f0 <__d2b+0xa8>)
 8034562:	4824      	ldr	r0, [pc, #144]	@ (80345f4 <__d2b+0xac>)
 8034564:	f240 310f 	movw	r1, #783	@ 0x30f
 8034568:	f7fd fdde 	bl	8032128 <__assert_func>
 803456c:	f3c9 550a 	ubfx	r5, r9, #20, #11
 8034570:	f3c9 0313 	ubfx	r3, r9, #0, #20
 8034574:	b10d      	cbz	r5, 803457a <__d2b+0x32>
 8034576:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
 803457a:	9301      	str	r3, [sp, #4]
 803457c:	f1b8 0300 	subs.w	r3, r8, #0
 8034580:	d023      	beq.n	80345ca <__d2b+0x82>
 8034582:	4668      	mov	r0, sp
 8034584:	9300      	str	r3, [sp, #0]
 8034586:	f7ff fd7c 	bl	8034082 <__lo0bits>
 803458a:	e9dd 1200 	ldrd	r1, r2, [sp]
 803458e:	b1d0      	cbz	r0, 80345c6 <__d2b+0x7e>
 8034590:	f1c0 0320 	rsb	r3, r0, #32
 8034594:	fa02 f303 	lsl.w	r3, r2, r3
 8034598:	430b      	orrs	r3, r1
 803459a:	40c2      	lsrs	r2, r0
 803459c:	6163      	str	r3, [r4, #20]
 803459e:	9201      	str	r2, [sp, #4]
 80345a0:	9b01      	ldr	r3, [sp, #4]
 80345a2:	61a3      	str	r3, [r4, #24]
 80345a4:	2b00      	cmp	r3, #0
 80345a6:	bf0c      	ite	eq
 80345a8:	2201      	moveq	r2, #1
 80345aa:	2202      	movne	r2, #2
 80345ac:	6122      	str	r2, [r4, #16]
 80345ae:	b1a5      	cbz	r5, 80345da <__d2b+0x92>
 80345b0:	f2a5 4533 	subw	r5, r5, #1075	@ 0x433
 80345b4:	4405      	add	r5, r0
 80345b6:	603d      	str	r5, [r7, #0]
 80345b8:	f1c0 0035 	rsb	r0, r0, #53	@ 0x35
 80345bc:	6030      	str	r0, [r6, #0]
 80345be:	4620      	mov	r0, r4
 80345c0:	b003      	add	sp, #12
 80345c2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80345c6:	6161      	str	r1, [r4, #20]
 80345c8:	e7ea      	b.n	80345a0 <__d2b+0x58>
 80345ca:	a801      	add	r0, sp, #4
 80345cc:	f7ff fd59 	bl	8034082 <__lo0bits>
 80345d0:	9b01      	ldr	r3, [sp, #4]
 80345d2:	6163      	str	r3, [r4, #20]
 80345d4:	3020      	adds	r0, #32
 80345d6:	2201      	movs	r2, #1
 80345d8:	e7e8      	b.n	80345ac <__d2b+0x64>
 80345da:	eb04 0382 	add.w	r3, r4, r2, lsl #2
 80345de:	f2a0 4032 	subw	r0, r0, #1074	@ 0x432
 80345e2:	6038      	str	r0, [r7, #0]
 80345e4:	6918      	ldr	r0, [r3, #16]
 80345e6:	f7ff fd2d 	bl	8034044 <__hi0bits>
 80345ea:	ebc0 1042 	rsb	r0, r0, r2, lsl #5
 80345ee:	e7e5      	b.n	80345bc <__d2b+0x74>
 80345f0:	08083b2d 	.word	0x08083b2d
 80345f4:	08083b3e 	.word	0x08083b3e

080345f8 <__sfputc_r>:
 80345f8:	6893      	ldr	r3, [r2, #8]
 80345fa:	3b01      	subs	r3, #1
 80345fc:	2b00      	cmp	r3, #0
 80345fe:	b410      	push	{r4}
 8034600:	6093      	str	r3, [r2, #8]
 8034602:	da08      	bge.n	8034616 <__sfputc_r+0x1e>
 8034604:	6994      	ldr	r4, [r2, #24]
 8034606:	42a3      	cmp	r3, r4
 8034608:	db01      	blt.n	803460e <__sfputc_r+0x16>
 803460a:	290a      	cmp	r1, #10
 803460c:	d103      	bne.n	8034616 <__sfputc_r+0x1e>
 803460e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8034612:	f7fe bc60 	b.w	8032ed6 <__swbuf_r>
 8034616:	6813      	ldr	r3, [r2, #0]
 8034618:	1c58      	adds	r0, r3, #1
 803461a:	6010      	str	r0, [r2, #0]
 803461c:	7019      	strb	r1, [r3, #0]
 803461e:	4608      	mov	r0, r1
 8034620:	f85d 4b04 	ldr.w	r4, [sp], #4
 8034624:	4770      	bx	lr

08034626 <__sfputs_r>:
 8034626:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8034628:	4606      	mov	r6, r0
 803462a:	460f      	mov	r7, r1
 803462c:	4614      	mov	r4, r2
 803462e:	18d5      	adds	r5, r2, r3
 8034630:	42ac      	cmp	r4, r5
 8034632:	d101      	bne.n	8034638 <__sfputs_r+0x12>
 8034634:	2000      	movs	r0, #0
 8034636:	e007      	b.n	8034648 <__sfputs_r+0x22>
 8034638:	f814 1b01 	ldrb.w	r1, [r4], #1
 803463c:	463a      	mov	r2, r7
 803463e:	4630      	mov	r0, r6
 8034640:	f7ff ffda 	bl	80345f8 <__sfputc_r>
 8034644:	1c43      	adds	r3, r0, #1
 8034646:	d1f3      	bne.n	8034630 <__sfputs_r+0xa>
 8034648:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

0803464c <_vfiprintf_r>:
 803464c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8034650:	460d      	mov	r5, r1
 8034652:	b09d      	sub	sp, #116	@ 0x74
 8034654:	4614      	mov	r4, r2
 8034656:	4698      	mov	r8, r3
 8034658:	4606      	mov	r6, r0
 803465a:	b118      	cbz	r0, 8034664 <_vfiprintf_r+0x18>
 803465c:	6a03      	ldr	r3, [r0, #32]
 803465e:	b90b      	cbnz	r3, 8034664 <_vfiprintf_r+0x18>
 8034660:	f7fe fb3e 	bl	8032ce0 <__sinit>
 8034664:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 8034666:	07d9      	lsls	r1, r3, #31
 8034668:	d405      	bmi.n	8034676 <_vfiprintf_r+0x2a>
 803466a:	89ab      	ldrh	r3, [r5, #12]
 803466c:	059a      	lsls	r2, r3, #22
 803466e:	d402      	bmi.n	8034676 <_vfiprintf_r+0x2a>
 8034670:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 8034672:	f7fe fd96 	bl	80331a2 <__retarget_lock_acquire_recursive>
 8034676:	89ab      	ldrh	r3, [r5, #12]
 8034678:	071b      	lsls	r3, r3, #28
 803467a:	d501      	bpl.n	8034680 <_vfiprintf_r+0x34>
 803467c:	692b      	ldr	r3, [r5, #16]
 803467e:	b99b      	cbnz	r3, 80346a8 <_vfiprintf_r+0x5c>
 8034680:	4629      	mov	r1, r5
 8034682:	4630      	mov	r0, r6
 8034684:	f7fe fc66 	bl	8032f54 <__swsetup_r>
 8034688:	b170      	cbz	r0, 80346a8 <_vfiprintf_r+0x5c>
 803468a:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 803468c:	07dc      	lsls	r4, r3, #31
 803468e:	d504      	bpl.n	803469a <_vfiprintf_r+0x4e>
 8034690:	f04f 30ff 	mov.w	r0, #4294967295
 8034694:	b01d      	add	sp, #116	@ 0x74
 8034696:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 803469a:	89ab      	ldrh	r3, [r5, #12]
 803469c:	0598      	lsls	r0, r3, #22
 803469e:	d4f7      	bmi.n	8034690 <_vfiprintf_r+0x44>
 80346a0:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 80346a2:	f7fe fd7f 	bl	80331a4 <__retarget_lock_release_recursive>
 80346a6:	e7f3      	b.n	8034690 <_vfiprintf_r+0x44>
 80346a8:	2300      	movs	r3, #0
 80346aa:	9309      	str	r3, [sp, #36]	@ 0x24
 80346ac:	2320      	movs	r3, #32
 80346ae:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
 80346b2:	f8cd 800c 	str.w	r8, [sp, #12]
 80346b6:	2330      	movs	r3, #48	@ 0x30
 80346b8:	f8df 81ac 	ldr.w	r8, [pc, #428]	@ 8034868 <_vfiprintf_r+0x21c>
 80346bc:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
 80346c0:	f04f 0901 	mov.w	r9, #1
 80346c4:	4623      	mov	r3, r4
 80346c6:	469a      	mov	sl, r3
 80346c8:	f813 2b01 	ldrb.w	r2, [r3], #1
 80346cc:	b10a      	cbz	r2, 80346d2 <_vfiprintf_r+0x86>
 80346ce:	2a25      	cmp	r2, #37	@ 0x25
 80346d0:	d1f9      	bne.n	80346c6 <_vfiprintf_r+0x7a>
 80346d2:	ebba 0b04 	subs.w	fp, sl, r4
 80346d6:	d00b      	beq.n	80346f0 <_vfiprintf_r+0xa4>
 80346d8:	465b      	mov	r3, fp
 80346da:	4622      	mov	r2, r4
 80346dc:	4629      	mov	r1, r5
 80346de:	4630      	mov	r0, r6
 80346e0:	f7ff ffa1 	bl	8034626 <__sfputs_r>
 80346e4:	3001      	adds	r0, #1
 80346e6:	f000 80a7 	beq.w	8034838 <_vfiprintf_r+0x1ec>
 80346ea:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 80346ec:	445a      	add	r2, fp
 80346ee:	9209      	str	r2, [sp, #36]	@ 0x24
 80346f0:	f89a 3000 	ldrb.w	r3, [sl]
 80346f4:	2b00      	cmp	r3, #0
 80346f6:	f000 809f 	beq.w	8034838 <_vfiprintf_r+0x1ec>
 80346fa:	2300      	movs	r3, #0
 80346fc:	f04f 32ff 	mov.w	r2, #4294967295
 8034700:	e9cd 2305 	strd	r2, r3, [sp, #20]
 8034704:	f10a 0a01 	add.w	sl, sl, #1
 8034708:	9304      	str	r3, [sp, #16]
 803470a:	9307      	str	r3, [sp, #28]
 803470c:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
 8034710:	931a      	str	r3, [sp, #104]	@ 0x68
 8034712:	4654      	mov	r4, sl
 8034714:	2205      	movs	r2, #5
 8034716:	f814 1b01 	ldrb.w	r1, [r4], #1
 803471a:	4853      	ldr	r0, [pc, #332]	@ (8034868 <_vfiprintf_r+0x21c>)
 803471c:	f7db fc90 	bl	8010040 <memchr>
 8034720:	9a04      	ldr	r2, [sp, #16]
 8034722:	b9d8      	cbnz	r0, 803475c <_vfiprintf_r+0x110>
 8034724:	06d1      	lsls	r1, r2, #27
 8034726:	bf44      	itt	mi
 8034728:	2320      	movmi	r3, #32
 803472a:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 803472e:	0713      	lsls	r3, r2, #28
 8034730:	bf44      	itt	mi
 8034732:	232b      	movmi	r3, #43	@ 0x2b
 8034734:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 8034738:	f89a 3000 	ldrb.w	r3, [sl]
 803473c:	2b2a      	cmp	r3, #42	@ 0x2a
 803473e:	d015      	beq.n	803476c <_vfiprintf_r+0x120>
 8034740:	9a07      	ldr	r2, [sp, #28]
 8034742:	4654      	mov	r4, sl
 8034744:	2000      	movs	r0, #0
 8034746:	f04f 0c0a 	mov.w	ip, #10
 803474a:	4621      	mov	r1, r4
 803474c:	f811 3b01 	ldrb.w	r3, [r1], #1
 8034750:	3b30      	subs	r3, #48	@ 0x30
 8034752:	2b09      	cmp	r3, #9
 8034754:	d94b      	bls.n	80347ee <_vfiprintf_r+0x1a2>
 8034756:	b1b0      	cbz	r0, 8034786 <_vfiprintf_r+0x13a>
 8034758:	9207      	str	r2, [sp, #28]
 803475a:	e014      	b.n	8034786 <_vfiprintf_r+0x13a>
 803475c:	eba0 0308 	sub.w	r3, r0, r8
 8034760:	fa09 f303 	lsl.w	r3, r9, r3
 8034764:	4313      	orrs	r3, r2
 8034766:	9304      	str	r3, [sp, #16]
 8034768:	46a2      	mov	sl, r4
 803476a:	e7d2      	b.n	8034712 <_vfiprintf_r+0xc6>
 803476c:	9b03      	ldr	r3, [sp, #12]
 803476e:	1d19      	adds	r1, r3, #4
 8034770:	681b      	ldr	r3, [r3, #0]
 8034772:	9103      	str	r1, [sp, #12]
 8034774:	2b00      	cmp	r3, #0
 8034776:	bfbb      	ittet	lt
 8034778:	425b      	neglt	r3, r3
 803477a:	f042 0202 	orrlt.w	r2, r2, #2
 803477e:	9307      	strge	r3, [sp, #28]
 8034780:	9307      	strlt	r3, [sp, #28]
 8034782:	bfb8      	it	lt
 8034784:	9204      	strlt	r2, [sp, #16]
 8034786:	7823      	ldrb	r3, [r4, #0]
 8034788:	2b2e      	cmp	r3, #46	@ 0x2e
 803478a:	d10a      	bne.n	80347a2 <_vfiprintf_r+0x156>
 803478c:	7863      	ldrb	r3, [r4, #1]
 803478e:	2b2a      	cmp	r3, #42	@ 0x2a
 8034790:	d132      	bne.n	80347f8 <_vfiprintf_r+0x1ac>
 8034792:	9b03      	ldr	r3, [sp, #12]
 8034794:	1d1a      	adds	r2, r3, #4
 8034796:	681b      	ldr	r3, [r3, #0]
 8034798:	9203      	str	r2, [sp, #12]
 803479a:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
 803479e:	3402      	adds	r4, #2
 80347a0:	9305      	str	r3, [sp, #20]
 80347a2:	f8df a0d4 	ldr.w	sl, [pc, #212]	@ 8034878 <_vfiprintf_r+0x22c>
 80347a6:	7821      	ldrb	r1, [r4, #0]
 80347a8:	2203      	movs	r2, #3
 80347aa:	4650      	mov	r0, sl
 80347ac:	f7db fc48 	bl	8010040 <memchr>
 80347b0:	b138      	cbz	r0, 80347c2 <_vfiprintf_r+0x176>
 80347b2:	9b04      	ldr	r3, [sp, #16]
 80347b4:	eba0 000a 	sub.w	r0, r0, sl
 80347b8:	2240      	movs	r2, #64	@ 0x40
 80347ba:	4082      	lsls	r2, r0
 80347bc:	4313      	orrs	r3, r2
 80347be:	3401      	adds	r4, #1
 80347c0:	9304      	str	r3, [sp, #16]
 80347c2:	f814 1b01 	ldrb.w	r1, [r4], #1
 80347c6:	4829      	ldr	r0, [pc, #164]	@ (803486c <_vfiprintf_r+0x220>)
 80347c8:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
 80347cc:	2206      	movs	r2, #6
 80347ce:	f7db fc37 	bl	8010040 <memchr>
 80347d2:	2800      	cmp	r0, #0
 80347d4:	d03f      	beq.n	8034856 <_vfiprintf_r+0x20a>
 80347d6:	4b26      	ldr	r3, [pc, #152]	@ (8034870 <_vfiprintf_r+0x224>)
 80347d8:	bb1b      	cbnz	r3, 8034822 <_vfiprintf_r+0x1d6>
 80347da:	9b03      	ldr	r3, [sp, #12]
 80347dc:	3307      	adds	r3, #7
 80347de:	f023 0307 	bic.w	r3, r3, #7
 80347e2:	3308      	adds	r3, #8
 80347e4:	9303      	str	r3, [sp, #12]
 80347e6:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80347e8:	443b      	add	r3, r7
 80347ea:	9309      	str	r3, [sp, #36]	@ 0x24
 80347ec:	e76a      	b.n	80346c4 <_vfiprintf_r+0x78>
 80347ee:	fb0c 3202 	mla	r2, ip, r2, r3
 80347f2:	460c      	mov	r4, r1
 80347f4:	2001      	movs	r0, #1
 80347f6:	e7a8      	b.n	803474a <_vfiprintf_r+0xfe>
 80347f8:	2300      	movs	r3, #0
 80347fa:	3401      	adds	r4, #1
 80347fc:	9305      	str	r3, [sp, #20]
 80347fe:	4619      	mov	r1, r3
 8034800:	f04f 0c0a 	mov.w	ip, #10
 8034804:	4620      	mov	r0, r4
 8034806:	f810 2b01 	ldrb.w	r2, [r0], #1
 803480a:	3a30      	subs	r2, #48	@ 0x30
 803480c:	2a09      	cmp	r2, #9
 803480e:	d903      	bls.n	8034818 <_vfiprintf_r+0x1cc>
 8034810:	2b00      	cmp	r3, #0
 8034812:	d0c6      	beq.n	80347a2 <_vfiprintf_r+0x156>
 8034814:	9105      	str	r1, [sp, #20]
 8034816:	e7c4      	b.n	80347a2 <_vfiprintf_r+0x156>
 8034818:	fb0c 2101 	mla	r1, ip, r1, r2
 803481c:	4604      	mov	r4, r0
 803481e:	2301      	movs	r3, #1
 8034820:	e7f0      	b.n	8034804 <_vfiprintf_r+0x1b8>
 8034822:	ab03      	add	r3, sp, #12
 8034824:	9300      	str	r3, [sp, #0]
 8034826:	462a      	mov	r2, r5
 8034828:	4b12      	ldr	r3, [pc, #72]	@ (8034874 <_vfiprintf_r+0x228>)
 803482a:	a904      	add	r1, sp, #16
 803482c:	4630      	mov	r0, r6
 803482e:	f7fd fe13 	bl	8032458 <_printf_float>
 8034832:	4607      	mov	r7, r0
 8034834:	1c78      	adds	r0, r7, #1
 8034836:	d1d6      	bne.n	80347e6 <_vfiprintf_r+0x19a>
 8034838:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 803483a:	07d9      	lsls	r1, r3, #31
 803483c:	d405      	bmi.n	803484a <_vfiprintf_r+0x1fe>
 803483e:	89ab      	ldrh	r3, [r5, #12]
 8034840:	059a      	lsls	r2, r3, #22
 8034842:	d402      	bmi.n	803484a <_vfiprintf_r+0x1fe>
 8034844:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 8034846:	f7fe fcad 	bl	80331a4 <__retarget_lock_release_recursive>
 803484a:	89ab      	ldrh	r3, [r5, #12]
 803484c:	065b      	lsls	r3, r3, #25
 803484e:	f53f af1f 	bmi.w	8034690 <_vfiprintf_r+0x44>
 8034852:	9809      	ldr	r0, [sp, #36]	@ 0x24
 8034854:	e71e      	b.n	8034694 <_vfiprintf_r+0x48>
 8034856:	ab03      	add	r3, sp, #12
 8034858:	9300      	str	r3, [sp, #0]
 803485a:	462a      	mov	r2, r5
 803485c:	4b05      	ldr	r3, [pc, #20]	@ (8034874 <_vfiprintf_r+0x228>)
 803485e:	a904      	add	r1, sp, #16
 8034860:	4630      	mov	r0, r6
 8034862:	f7fe f891 	bl	8032988 <_printf_i>
 8034866:	e7e4      	b.n	8034832 <_vfiprintf_r+0x1e6>
 8034868:	08083c98 	.word	0x08083c98
 803486c:	08083ca2 	.word	0x08083ca2
 8034870:	08032459 	.word	0x08032459
 8034874:	08034627 	.word	0x08034627
 8034878:	08083c9e 	.word	0x08083c9e

0803487c <__sflush_r>:
 803487c:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 8034880:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8034884:	0716      	lsls	r6, r2, #28
 8034886:	4605      	mov	r5, r0
 8034888:	460c      	mov	r4, r1
 803488a:	d454      	bmi.n	8034936 <__sflush_r+0xba>
 803488c:	684b      	ldr	r3, [r1, #4]
 803488e:	2b00      	cmp	r3, #0
 8034890:	dc02      	bgt.n	8034898 <__sflush_r+0x1c>
 8034892:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
 8034894:	2b00      	cmp	r3, #0
 8034896:	dd48      	ble.n	803492a <__sflush_r+0xae>
 8034898:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 803489a:	2e00      	cmp	r6, #0
 803489c:	d045      	beq.n	803492a <__sflush_r+0xae>
 803489e:	2300      	movs	r3, #0
 80348a0:	f412 5280 	ands.w	r2, r2, #4096	@ 0x1000
 80348a4:	682f      	ldr	r7, [r5, #0]
 80348a6:	6a21      	ldr	r1, [r4, #32]
 80348a8:	602b      	str	r3, [r5, #0]
 80348aa:	d030      	beq.n	803490e <__sflush_r+0x92>
 80348ac:	6d62      	ldr	r2, [r4, #84]	@ 0x54
 80348ae:	89a3      	ldrh	r3, [r4, #12]
 80348b0:	0759      	lsls	r1, r3, #29
 80348b2:	d505      	bpl.n	80348c0 <__sflush_r+0x44>
 80348b4:	6863      	ldr	r3, [r4, #4]
 80348b6:	1ad2      	subs	r2, r2, r3
 80348b8:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 80348ba:	b10b      	cbz	r3, 80348c0 <__sflush_r+0x44>
 80348bc:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 80348be:	1ad2      	subs	r2, r2, r3
 80348c0:	2300      	movs	r3, #0
 80348c2:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 80348c4:	6a21      	ldr	r1, [r4, #32]
 80348c6:	4628      	mov	r0, r5
 80348c8:	47b0      	blx	r6
 80348ca:	1c43      	adds	r3, r0, #1
 80348cc:	89a3      	ldrh	r3, [r4, #12]
 80348ce:	d106      	bne.n	80348de <__sflush_r+0x62>
 80348d0:	6829      	ldr	r1, [r5, #0]
 80348d2:	291d      	cmp	r1, #29
 80348d4:	d82b      	bhi.n	803492e <__sflush_r+0xb2>
 80348d6:	4a2a      	ldr	r2, [pc, #168]	@ (8034980 <__sflush_r+0x104>)
 80348d8:	410a      	asrs	r2, r1
 80348da:	07d6      	lsls	r6, r2, #31
 80348dc:	d427      	bmi.n	803492e <__sflush_r+0xb2>
 80348de:	2200      	movs	r2, #0
 80348e0:	6062      	str	r2, [r4, #4]
 80348e2:	04d9      	lsls	r1, r3, #19
 80348e4:	6922      	ldr	r2, [r4, #16]
 80348e6:	6022      	str	r2, [r4, #0]
 80348e8:	d504      	bpl.n	80348f4 <__sflush_r+0x78>
 80348ea:	1c42      	adds	r2, r0, #1
 80348ec:	d101      	bne.n	80348f2 <__sflush_r+0x76>
 80348ee:	682b      	ldr	r3, [r5, #0]
 80348f0:	b903      	cbnz	r3, 80348f4 <__sflush_r+0x78>
 80348f2:	6560      	str	r0, [r4, #84]	@ 0x54
 80348f4:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 80348f6:	602f      	str	r7, [r5, #0]
 80348f8:	b1b9      	cbz	r1, 803492a <__sflush_r+0xae>
 80348fa:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 80348fe:	4299      	cmp	r1, r3
 8034900:	d002      	beq.n	8034908 <__sflush_r+0x8c>
 8034902:	4628      	mov	r0, r5
 8034904:	f7ff faac 	bl	8033e60 <_free_r>
 8034908:	2300      	movs	r3, #0
 803490a:	6363      	str	r3, [r4, #52]	@ 0x34
 803490c:	e00d      	b.n	803492a <__sflush_r+0xae>
 803490e:	2301      	movs	r3, #1
 8034910:	4628      	mov	r0, r5
 8034912:	47b0      	blx	r6
 8034914:	4602      	mov	r2, r0
 8034916:	1c50      	adds	r0, r2, #1
 8034918:	d1c9      	bne.n	80348ae <__sflush_r+0x32>
 803491a:	682b      	ldr	r3, [r5, #0]
 803491c:	2b00      	cmp	r3, #0
 803491e:	d0c6      	beq.n	80348ae <__sflush_r+0x32>
 8034920:	2b1d      	cmp	r3, #29
 8034922:	d001      	beq.n	8034928 <__sflush_r+0xac>
 8034924:	2b16      	cmp	r3, #22
 8034926:	d11e      	bne.n	8034966 <__sflush_r+0xea>
 8034928:	602f      	str	r7, [r5, #0]
 803492a:	2000      	movs	r0, #0
 803492c:	e022      	b.n	8034974 <__sflush_r+0xf8>
 803492e:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8034932:	b21b      	sxth	r3, r3
 8034934:	e01b      	b.n	803496e <__sflush_r+0xf2>
 8034936:	690f      	ldr	r7, [r1, #16]
 8034938:	2f00      	cmp	r7, #0
 803493a:	d0f6      	beq.n	803492a <__sflush_r+0xae>
 803493c:	0793      	lsls	r3, r2, #30
 803493e:	680e      	ldr	r6, [r1, #0]
 8034940:	bf08      	it	eq
 8034942:	694b      	ldreq	r3, [r1, #20]
 8034944:	600f      	str	r7, [r1, #0]
 8034946:	bf18      	it	ne
 8034948:	2300      	movne	r3, #0
 803494a:	eba6 0807 	sub.w	r8, r6, r7
 803494e:	608b      	str	r3, [r1, #8]
 8034950:	f1b8 0f00 	cmp.w	r8, #0
 8034954:	dde9      	ble.n	803492a <__sflush_r+0xae>
 8034956:	6a21      	ldr	r1, [r4, #32]
 8034958:	6aa6      	ldr	r6, [r4, #40]	@ 0x28
 803495a:	4643      	mov	r3, r8
 803495c:	463a      	mov	r2, r7
 803495e:	4628      	mov	r0, r5
 8034960:	47b0      	blx	r6
 8034962:	2800      	cmp	r0, #0
 8034964:	dc08      	bgt.n	8034978 <__sflush_r+0xfc>
 8034966:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 803496a:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 803496e:	81a3      	strh	r3, [r4, #12]
 8034970:	f04f 30ff 	mov.w	r0, #4294967295
 8034974:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8034978:	4407      	add	r7, r0
 803497a:	eba8 0800 	sub.w	r8, r8, r0
 803497e:	e7e7      	b.n	8034950 <__sflush_r+0xd4>
 8034980:	dfbffffe 	.word	0xdfbffffe

08034984 <_fflush_r>:
 8034984:	b538      	push	{r3, r4, r5, lr}
 8034986:	690b      	ldr	r3, [r1, #16]
 8034988:	4605      	mov	r5, r0
 803498a:	460c      	mov	r4, r1
 803498c:	b913      	cbnz	r3, 8034994 <_fflush_r+0x10>
 803498e:	2500      	movs	r5, #0
 8034990:	4628      	mov	r0, r5
 8034992:	bd38      	pop	{r3, r4, r5, pc}
 8034994:	b118      	cbz	r0, 803499e <_fflush_r+0x1a>
 8034996:	6a03      	ldr	r3, [r0, #32]
 8034998:	b90b      	cbnz	r3, 803499e <_fflush_r+0x1a>
 803499a:	f7fe f9a1 	bl	8032ce0 <__sinit>
 803499e:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 80349a2:	2b00      	cmp	r3, #0
 80349a4:	d0f3      	beq.n	803498e <_fflush_r+0xa>
 80349a6:	6e62      	ldr	r2, [r4, #100]	@ 0x64
 80349a8:	07d0      	lsls	r0, r2, #31
 80349aa:	d404      	bmi.n	80349b6 <_fflush_r+0x32>
 80349ac:	0599      	lsls	r1, r3, #22
 80349ae:	d402      	bmi.n	80349b6 <_fflush_r+0x32>
 80349b0:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 80349b2:	f7fe fbf6 	bl	80331a2 <__retarget_lock_acquire_recursive>
 80349b6:	4628      	mov	r0, r5
 80349b8:	4621      	mov	r1, r4
 80349ba:	f7ff ff5f 	bl	803487c <__sflush_r>
 80349be:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 80349c0:	07da      	lsls	r2, r3, #31
 80349c2:	4605      	mov	r5, r0
 80349c4:	d4e4      	bmi.n	8034990 <_fflush_r+0xc>
 80349c6:	89a3      	ldrh	r3, [r4, #12]
 80349c8:	059b      	lsls	r3, r3, #22
 80349ca:	d4e1      	bmi.n	8034990 <_fflush_r+0xc>
 80349cc:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 80349ce:	f7fe fbe9 	bl	80331a4 <__retarget_lock_release_recursive>
 80349d2:	e7dd      	b.n	8034990 <_fflush_r+0xc>

080349d4 <__swhatbuf_r>:
 80349d4:	b570      	push	{r4, r5, r6, lr}
 80349d6:	460c      	mov	r4, r1
 80349d8:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80349dc:	2900      	cmp	r1, #0
 80349de:	b096      	sub	sp, #88	@ 0x58
 80349e0:	4615      	mov	r5, r2
 80349e2:	461e      	mov	r6, r3
 80349e4:	da0d      	bge.n	8034a02 <__swhatbuf_r+0x2e>
 80349e6:	89a3      	ldrh	r3, [r4, #12]
 80349e8:	f013 0f80 	tst.w	r3, #128	@ 0x80
 80349ec:	f04f 0100 	mov.w	r1, #0
 80349f0:	bf14      	ite	ne
 80349f2:	2340      	movne	r3, #64	@ 0x40
 80349f4:	f44f 6380 	moveq.w	r3, #1024	@ 0x400
 80349f8:	2000      	movs	r0, #0
 80349fa:	6031      	str	r1, [r6, #0]
 80349fc:	602b      	str	r3, [r5, #0]
 80349fe:	b016      	add	sp, #88	@ 0x58
 8034a00:	bd70      	pop	{r4, r5, r6, pc}
 8034a02:	466a      	mov	r2, sp
 8034a04:	f000 f848 	bl	8034a98 <_fstat_r>
 8034a08:	2800      	cmp	r0, #0
 8034a0a:	dbec      	blt.n	80349e6 <__swhatbuf_r+0x12>
 8034a0c:	9901      	ldr	r1, [sp, #4]
 8034a0e:	f401 4170 	and.w	r1, r1, #61440	@ 0xf000
 8034a12:	f5a1 5300 	sub.w	r3, r1, #8192	@ 0x2000
 8034a16:	4259      	negs	r1, r3
 8034a18:	4159      	adcs	r1, r3
 8034a1a:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 8034a1e:	e7eb      	b.n	80349f8 <__swhatbuf_r+0x24>

08034a20 <__smakebuf_r>:
 8034a20:	898b      	ldrh	r3, [r1, #12]
 8034a22:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8034a24:	079d      	lsls	r5, r3, #30
 8034a26:	4606      	mov	r6, r0
 8034a28:	460c      	mov	r4, r1
 8034a2a:	d507      	bpl.n	8034a3c <__smakebuf_r+0x1c>
 8034a2c:	f104 0347 	add.w	r3, r4, #71	@ 0x47
 8034a30:	6023      	str	r3, [r4, #0]
 8034a32:	6123      	str	r3, [r4, #16]
 8034a34:	2301      	movs	r3, #1
 8034a36:	6163      	str	r3, [r4, #20]
 8034a38:	b003      	add	sp, #12
 8034a3a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8034a3c:	ab01      	add	r3, sp, #4
 8034a3e:	466a      	mov	r2, sp
 8034a40:	f7ff ffc8 	bl	80349d4 <__swhatbuf_r>
 8034a44:	9f00      	ldr	r7, [sp, #0]
 8034a46:	4605      	mov	r5, r0
 8034a48:	4639      	mov	r1, r7
 8034a4a:	4630      	mov	r0, r6
 8034a4c:	f7fd fbd8 	bl	8032200 <_malloc_r>
 8034a50:	b948      	cbnz	r0, 8034a66 <__smakebuf_r+0x46>
 8034a52:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8034a56:	059a      	lsls	r2, r3, #22
 8034a58:	d4ee      	bmi.n	8034a38 <__smakebuf_r+0x18>
 8034a5a:	f023 0303 	bic.w	r3, r3, #3
 8034a5e:	f043 0302 	orr.w	r3, r3, #2
 8034a62:	81a3      	strh	r3, [r4, #12]
 8034a64:	e7e2      	b.n	8034a2c <__smakebuf_r+0xc>
 8034a66:	89a3      	ldrh	r3, [r4, #12]
 8034a68:	6020      	str	r0, [r4, #0]
 8034a6a:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8034a6e:	81a3      	strh	r3, [r4, #12]
 8034a70:	9b01      	ldr	r3, [sp, #4]
 8034a72:	e9c4 0704 	strd	r0, r7, [r4, #16]
 8034a76:	b15b      	cbz	r3, 8034a90 <__smakebuf_r+0x70>
 8034a78:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8034a7c:	4630      	mov	r0, r6
 8034a7e:	f000 f81d 	bl	8034abc <_isatty_r>
 8034a82:	b128      	cbz	r0, 8034a90 <__smakebuf_r+0x70>
 8034a84:	89a3      	ldrh	r3, [r4, #12]
 8034a86:	f023 0303 	bic.w	r3, r3, #3
 8034a8a:	f043 0301 	orr.w	r3, r3, #1
 8034a8e:	81a3      	strh	r3, [r4, #12]
 8034a90:	89a3      	ldrh	r3, [r4, #12]
 8034a92:	431d      	orrs	r5, r3
 8034a94:	81a5      	strh	r5, [r4, #12]
 8034a96:	e7cf      	b.n	8034a38 <__smakebuf_r+0x18>

08034a98 <_fstat_r>:
 8034a98:	b538      	push	{r3, r4, r5, lr}
 8034a9a:	4d07      	ldr	r5, [pc, #28]	@ (8034ab8 <_fstat_r+0x20>)
 8034a9c:	2300      	movs	r3, #0
 8034a9e:	4604      	mov	r4, r0
 8034aa0:	4608      	mov	r0, r1
 8034aa2:	4611      	mov	r1, r2
 8034aa4:	602b      	str	r3, [r5, #0]
 8034aa6:	f000 f841 	bl	8034b2c <_fstat>
 8034aaa:	1c43      	adds	r3, r0, #1
 8034aac:	d102      	bne.n	8034ab4 <_fstat_r+0x1c>
 8034aae:	682b      	ldr	r3, [r5, #0]
 8034ab0:	b103      	cbz	r3, 8034ab4 <_fstat_r+0x1c>
 8034ab2:	6023      	str	r3, [r4, #0]
 8034ab4:	bd38      	pop	{r3, r4, r5, pc}
 8034ab6:	bf00      	nop
 8034ab8:	20012390 	.word	0x20012390

08034abc <_isatty_r>:
 8034abc:	b538      	push	{r3, r4, r5, lr}
 8034abe:	4d06      	ldr	r5, [pc, #24]	@ (8034ad8 <_isatty_r+0x1c>)
 8034ac0:	2300      	movs	r3, #0
 8034ac2:	4604      	mov	r4, r0
 8034ac4:	4608      	mov	r0, r1
 8034ac6:	602b      	str	r3, [r5, #0]
 8034ac8:	f000 f840 	bl	8034b4c <_isatty>
 8034acc:	1c43      	adds	r3, r0, #1
 8034ace:	d102      	bne.n	8034ad6 <_isatty_r+0x1a>
 8034ad0:	682b      	ldr	r3, [r5, #0]
 8034ad2:	b103      	cbz	r3, 8034ad6 <_isatty_r+0x1a>
 8034ad4:	6023      	str	r3, [r4, #0]
 8034ad6:	bd38      	pop	{r3, r4, r5, pc}
 8034ad8:	20012390 	.word	0x20012390

08034adc <__ascii_mbtowc>:
 8034adc:	b082      	sub	sp, #8
 8034ade:	b901      	cbnz	r1, 8034ae2 <__ascii_mbtowc+0x6>
 8034ae0:	a901      	add	r1, sp, #4
 8034ae2:	b142      	cbz	r2, 8034af6 <__ascii_mbtowc+0x1a>
 8034ae4:	b14b      	cbz	r3, 8034afa <__ascii_mbtowc+0x1e>
 8034ae6:	7813      	ldrb	r3, [r2, #0]
 8034ae8:	600b      	str	r3, [r1, #0]
 8034aea:	7812      	ldrb	r2, [r2, #0]
 8034aec:	1e10      	subs	r0, r2, #0
 8034aee:	bf18      	it	ne
 8034af0:	2001      	movne	r0, #1
 8034af2:	b002      	add	sp, #8
 8034af4:	4770      	bx	lr
 8034af6:	4610      	mov	r0, r2
 8034af8:	e7fb      	b.n	8034af2 <__ascii_mbtowc+0x16>
 8034afa:	f06f 0001 	mvn.w	r0, #1
 8034afe:	e7f8      	b.n	8034af2 <__ascii_mbtowc+0x16>

08034b00 <__ascii_wctomb>:
 8034b00:	4603      	mov	r3, r0
 8034b02:	4608      	mov	r0, r1
 8034b04:	b141      	cbz	r1, 8034b18 <__ascii_wctomb+0x18>
 8034b06:	2aff      	cmp	r2, #255	@ 0xff
 8034b08:	d904      	bls.n	8034b14 <__ascii_wctomb+0x14>
 8034b0a:	228a      	movs	r2, #138	@ 0x8a
 8034b0c:	601a      	str	r2, [r3, #0]
 8034b0e:	f04f 30ff 	mov.w	r0, #4294967295
 8034b12:	4770      	bx	lr
 8034b14:	700a      	strb	r2, [r1, #0]
 8034b16:	2001      	movs	r0, #1
 8034b18:	4770      	bx	lr
	...

08034b1c <_close>:
 8034b1c:	4b02      	ldr	r3, [pc, #8]	@ (8034b28 <_close+0xc>)
 8034b1e:	2258      	movs	r2, #88	@ 0x58
 8034b20:	601a      	str	r2, [r3, #0]
 8034b22:	f04f 30ff 	mov.w	r0, #4294967295
 8034b26:	4770      	bx	lr
 8034b28:	20012390 	.word	0x20012390

08034b2c <_fstat>:
 8034b2c:	4b02      	ldr	r3, [pc, #8]	@ (8034b38 <_fstat+0xc>)
 8034b2e:	2258      	movs	r2, #88	@ 0x58
 8034b30:	601a      	str	r2, [r3, #0]
 8034b32:	f04f 30ff 	mov.w	r0, #4294967295
 8034b36:	4770      	bx	lr
 8034b38:	20012390 	.word	0x20012390

08034b3c <_getpid>:
 8034b3c:	4b02      	ldr	r3, [pc, #8]	@ (8034b48 <_getpid+0xc>)
 8034b3e:	2258      	movs	r2, #88	@ 0x58
 8034b40:	601a      	str	r2, [r3, #0]
 8034b42:	f04f 30ff 	mov.w	r0, #4294967295
 8034b46:	4770      	bx	lr
 8034b48:	20012390 	.word	0x20012390

08034b4c <_isatty>:
 8034b4c:	4b02      	ldr	r3, [pc, #8]	@ (8034b58 <_isatty+0xc>)
 8034b4e:	2258      	movs	r2, #88	@ 0x58
 8034b50:	601a      	str	r2, [r3, #0]
 8034b52:	2000      	movs	r0, #0
 8034b54:	4770      	bx	lr
 8034b56:	bf00      	nop
 8034b58:	20012390 	.word	0x20012390

08034b5c <_kill>:
 8034b5c:	4b02      	ldr	r3, [pc, #8]	@ (8034b68 <_kill+0xc>)
 8034b5e:	2258      	movs	r2, #88	@ 0x58
 8034b60:	601a      	str	r2, [r3, #0]
 8034b62:	f04f 30ff 	mov.w	r0, #4294967295
 8034b66:	4770      	bx	lr
 8034b68:	20012390 	.word	0x20012390

08034b6c <_lseek>:
 8034b6c:	4b02      	ldr	r3, [pc, #8]	@ (8034b78 <_lseek+0xc>)
 8034b6e:	2258      	movs	r2, #88	@ 0x58
 8034b70:	601a      	str	r2, [r3, #0]
 8034b72:	f04f 30ff 	mov.w	r0, #4294967295
 8034b76:	4770      	bx	lr
 8034b78:	20012390 	.word	0x20012390

08034b7c <_read>:
 8034b7c:	4b02      	ldr	r3, [pc, #8]	@ (8034b88 <_read+0xc>)
 8034b7e:	2258      	movs	r2, #88	@ 0x58
 8034b80:	601a      	str	r2, [r3, #0]
 8034b82:	f04f 30ff 	mov.w	r0, #4294967295
 8034b86:	4770      	bx	lr
 8034b88:	20012390 	.word	0x20012390

08034b8c <_write>:
 8034b8c:	4b02      	ldr	r3, [pc, #8]	@ (8034b98 <_write+0xc>)
 8034b8e:	2258      	movs	r2, #88	@ 0x58
 8034b90:	601a      	str	r2, [r3, #0]
 8034b92:	f04f 30ff 	mov.w	r0, #4294967295
 8034b96:	4770      	bx	lr
 8034b98:	20012390 	.word	0x20012390

08034b9c <_exit>:
 8034b9c:	e7fe      	b.n	8034b9c <_exit>
	...

08034ba0 <_init>:
 8034ba0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8034ba2:	bf00      	nop
 8034ba4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8034ba6:	bc08      	pop	{r3}
 8034ba8:	469e      	mov	lr, r3
 8034baa:	4770      	bx	lr

08034bac <_fini>:
 8034bac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8034bae:	bf00      	nop
 8034bb0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8034bb2:	bc08      	pop	{r3}
 8034bb4:	469e      	mov	lr, r3
 8034bb6:	4770      	bx	lr
